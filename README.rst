This is a collection of libraries implementing assemblers and disassemblers for
several architectures based on LLVM TableGen data.

Setup
=====

This package is supported on Ubuntu Xenial (16.04 LTS) and depends on
the following packages:

 * binutils-multiarch

To configure your system to build this package, run `setup.sh`.

Library Concept
===============

The high level idea of this library is to generate assemblers and disassemblers
from the data provided by LLVM TableGen.  Among other things, this data includes
lists of all of the instructions for the Instruction Set Architectures (ISA)
that we care about.  Moreover, it includes the encodings of those instructions,
as well as their operands and types of operands.

The ``dismantle-tablegen`` library provides tools for parsing the LLVM TableGen
data, as well as top-level helpers to generate assemblers and disassemblers in
Template Haskell.

Stability Notes
===============

Please note that the various architecture-specific ISA packages (such as
``dismantle-arm``) may be incomplete or incorrect for some instructions,
operands, or pretty-printed representations. This is because the
degree to which any of these backend packages has been completed is
a function of the particular binaries we used to test them (i.e.
the binaries found in ``tests/bin`` in each package). As a result
it's possible that when using ``dismantle`` with new binaries, some
instructions may not be supported by the disassembler, may reassemble
to incorrect bit sequences, or may have erroneous pretty-printing
representations when compared to the output of ``objdump``. As new
binaries are used with this software, code coverage of the ISA in
question may increase, revealing as-yet-unimplemented or incorrect
operand type implementations.

If any of the above cases are encountered, the operand type(s) and
instruction(s) in question will need to be supported. Fixing this
involves:

* Determining which Tablegen descriptor entry is associated with the
  offending input byte sequence. If an instruction fails any checks,
  its bit pattern will be printed by the test suite; the bit pattern
  can then be checked against both the Tablegen descriptors and
  architecture reference manual to identify the instruction and its
  operand semantics.

* If the byte sequence fails to disassemble, ensure that the descriptor
  is not blacklisted by the ISA (e.g. due to metadata or other
  filtering). For this, check the ``isaInstructionFilter`` behavior.

* Ensure that all operand types required by the descriptor have been
  added to the ISA operand type list. For this, check the
  ``isaOperandPayloadTypes`` list. Note that the entries in mapping must
  match the operand type names used in the Tablegen descriptors except
  that their first letters must be capitalized (since they get used to
  construct Haskell types).

* Ensure that the operand types decode the proper bit fields as
  indicated by the descriptor's bit pattern.

* Ensure that the operand types provide pretty printers that
  recover the original instruction operands and match the ``objdump``
  representation.

Generating TableGen Files
=========================

The file we take as inputs to this suite of tools are not actually in the
TableGen format (extension ``.td``); instead, we consume the output of the
``llvm-tblgen`` tool, which reads the real TableGen files and pre-processes
them. We use data files generated from sources of LLVM 3.9.

The real TableGen files are included in the LLVM source distribution.

.. code-block:: shell

   # Assuming that the LLVM source has been unpacked to ${LLVM_ROOT}
   cd ${LLVM_ROOT}/lib/Target

   # Choose the architecture you want to process, assume PowerPC
   cd PowerPC

   # Run tablegen
   llvm-tblgen -I${LLVM_ROOT}/include PPC.td > PPC.tgen


The ``.tgen`` extension is made up for this project, and not something
from LLVM.  The default output of the ``llvm-tblgen`` tool is a fully-expanded
version of the input TableGen files.  It is reasonably easy to parse, and the
format we consume in the ``dismantle-tablegen`` library to produce assemblers
and disassemblers.

Developing in Template Haskell
==============================

Development of Template Haskell code can be frustrating, especially when things
do not type check as expected.  Some tips:

* Dumping Splices

  It is often helpful to see what code is actually being generated by
  TH. The ``-ddump-splices`` flag tells ghc to dump the code it
  generates (before type checking) to disk. The file will have the
  extension ``.dump-splices``. It can be hard to read, but it is much
  better than guessing.

  For example, if using Stack you can generate the splices for PPC
  using::

      stack clean dismantle-ppc
      stack build dismantle-ppc --ghc-options=-ddump-splices

  and then find them with::

      find .stack-work -name '*.dump-splices'

* Minimize TH

  TH is really horrible in many ways, so try to implement as much as
  possible in normal functions and just glue it together using TH.

<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><link href="insn.css" rel="stylesheet" type="text/css"/><meta content="iform.xsl" name="generator"/><title>AArch32 Instruction Summary -- Shared Pseudocode</title></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table align="center"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="a32_encindex.html">A32 Instructions by Encoding</a></div></td><td><div class="topbar"><a href="t32_encindex.html">T32 Instructions by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h2 class="instruction-section">Shared Pseudocode Functions</h2><p id="desc">This page displays common pseudocode functions shared by many pages.
          <p></p><p></p></p><h2 class="pseudocode">Pseudocodes</h2><div class="ps" psname="aarch32.debug.VCRMatch.AArch32.VCRMatch"><a id="aarch32.debug.VCRMatch.AArch32.VCRMatch" name="aarch32.debug.VCRMatch.AArch32.VCRMatch"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/VCRMatch/AArch32.VCRMatch</h3><p class="pseudocode">// AArch32.VCRMatch()
// ==================

boolean <a id="AArch32.VCRMatch.1" name="AArch32.VCRMatch.1"></a>AArch32.VCRMatch(bits(32) vaddress)

    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(vaddress&lt;1:0>) &amp;&amp; PSTATE.EL != <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        // Each bit position in this string corresponds to a bit in DBGVCR and an exception vector.
        match_word = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(32);

        if vaddress&lt;31:5> == <a href="shared_pseudocode.html#impl-aarch32.ExcVectorBase.0" title="function: bits(32) ExcVectorBase()">ExcVectorBase</a>()&lt;31:5> then
            if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then
                match_word&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(vaddress&lt;4:2>) + 24> = '1';     // Non-secure vectors
            else
                match_word&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(vaddress&lt;4:2>) + 0> = '1';      // Secure vectors (or no EL3)

        if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() &amp;&amp; vaddress&lt;31:5> == MVBAR&lt;31:5> then
            match_word&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(vaddress&lt;4:2>) + 8> = '1';          // Monitor vectors

        // Mask out bits not corresponding to vectors.
        if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
            mask = '00000000':'00000000':'00000000':'11011110'; // DBGVCR[31:8] are RES0
        elsif !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
            mask = '11011110':'00000000':'00000000':'11011110'; // DBGVCR[15:8] are RES0
        else
            mask = '11011110':'00000000':'11011100':'11011110';

        match_word = match_word AND DBGVCR AND mask;
        match = !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(match_word);

        // Check for UNPREDICTABLE case - match on Prefetch Abort and Data Abort vectors
        if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(match_word&lt;28:27,12:11,4:3>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.DebugTarget.0" title="function: bits(2) DebugTarget()">DebugTarget</a>() == PSTATE.EL then
            match = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_VCMATCHDAPA" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}">Unpredictable_VCMATCHDAPA</a>);
    else
        match = FALSE;

    return match;</p></div><div class="ps" psname="aarch32.debug.authentication.AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled"><a id="aarch32.debug.authentication.AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled" name="aarch32.debug.authentication.AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/authentication/AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled</h3><p class="pseudocode">// AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled()
// ========================================================

boolean <a id="AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled.0" name="AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled.0"></a>AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled()
    // The definition of this function is IMPLEMENTATION DEFINED.
    // In the recommended interface, AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled returns
    // the state of the (DBGEN AND SPIDEN) signal.
    if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then return FALSE;
    return DBGEN == HIGH &amp;&amp; SPIDEN == HIGH;</p></div><div class="ps" psname="aarch32.debug.breakpoint.AArch32.BreakpointMatch"><a id="aarch32.debug.breakpoint.AArch32.BreakpointMatch" name="aarch32.debug.breakpoint.AArch32.BreakpointMatch"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/breakpoint/AArch32.BreakpointMatch</h3><p class="pseudocode">// AArch32.BreakpointMatch()
// =========================
// Breakpoint matching in an AArch32 translation regime.

(boolean,boolean) <a id="AArch32.BreakpointMatch.3" name="AArch32.BreakpointMatch.3"></a>AArch32.BreakpointMatch(integer n, bits(32) vaddress,  integer size)
    assert <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>());
    assert n &lt;= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(DBGDIDR.BRPs);

    enabled = DBGBCR[n].E == '1';
    ispriv = PSTATE.EL != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
    linked = DBGBCR[n].BT == '0x01';
    isbreakpnt = TRUE;
    linked_to = FALSE;

    state_match = <a href="shared_pseudocode.html#AArch32.StateMatch.7" title="function: boolean AArch32.StateMatch(bits(2) SSC, bit HMC, bits(2) PxC, boolean linked, bits(4) LBN, boolean isbreakpnt,  boolean ispriv)">AArch32.StateMatch</a>(DBGBCR[n].SSC, DBGBCR[n].HMC, DBGBCR[n].PMC,
                                     linked, DBGBCR[n].LBN, isbreakpnt, ispriv);
    (value_match, value_mismatch) = <a href="shared_pseudocode.html#AArch32.BreakpointValueMatch.3" title="function: (boolean,boolean) AArch32.BreakpointValueMatch(integer n, bits(32) vaddress, boolean linked_to)">AArch32.BreakpointValueMatch</a>(n, vaddress, linked_to);

    if size == 4 then                 // Check second halfword
        // If the breakpoint address and BAS of an Address breakpoint match the address of the
        // second halfword of an instruction, but not the address of the first halfword, it is
        // CONSTRAINED UNPREDICTABLE whether or not this breakpoint generates a Breakpoint debug
        // event.
        (match_i, mismatch_i) = <a href="shared_pseudocode.html#AArch32.BreakpointValueMatch.3" title="function: (boolean,boolean) AArch32.BreakpointValueMatch(integer n, bits(32) vaddress, boolean linked_to)">AArch32.BreakpointValueMatch</a>(n, vaddress + 2, linked_to);
        if !value_match &amp;&amp; match_i then
            value_match = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_BPMATCHHALF" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}">Unpredictable_BPMATCHHALF</a>);
        if value_mismatch &amp;&amp; !mismatch_i then
            value_mismatch = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_BPMISMATCHHALF" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}">Unpredictable_BPMISMATCHHALF</a>);

    if vaddress&lt;1> == '1' &amp;&amp; DBGBCR[n].BAS == '1111' then
        // The above notwithstanding, if DBGBCR[n].BAS == '1111', then it is CONSTRAINED
        // UNPREDICTABLE whether or not a Breakpoint debug event is generated for an instruction
        // at the address DBGBVR[n]+2.
        if value_match then value_match = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_BPMATCHHALF" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}">Unpredictable_BPMATCHHALF</a>);
        if !value_mismatch then value_mismatch = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_BPMISMATCHHALF" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}">Unpredictable_BPMISMATCHHALF</a>);

    match = value_match &amp;&amp; state_match &amp;&amp; enabled;
    mismatch = value_mismatch &amp;&amp; state_match &amp;&amp; enabled;

    return (match, mismatch);</p></div><div class="ps" psname="aarch32.debug.breakpoint.AArch32.BreakpointValueMatch"><a id="aarch32.debug.breakpoint.AArch32.BreakpointValueMatch" name="aarch32.debug.breakpoint.AArch32.BreakpointValueMatch"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/breakpoint/AArch32.BreakpointValueMatch</h3><p class="pseudocode">// AArch32.BreakpointValueMatch()
// ==============================
// The first result is whether an Address Match or Context breakpoint is programmed on the
// instruction at "address". The second result is whether an Address Mismatch breakpoint is
// programmed on the instruction, that is, whether the instruction should be stepped.

(boolean,boolean) <a id="AArch32.BreakpointValueMatch.3" name="AArch32.BreakpointValueMatch.3"></a>AArch32.BreakpointValueMatch(integer n, bits(32) vaddress, boolean linked_to)

    // "n" is the identity of the breakpoint unit to match against.
    // "vaddress" is the current instruction address, ignored if linked_to is TRUE and for Context
    //   matching breakpoints.
    // "linked_to" is TRUE if this is a call from StateMatch for linking.

    // If a non-existent breakpoint then it is CONSTRAINED UNPREDICTABLE whether this gives
    // no match or the breakpoint is mapped to another UNKNOWN implemented breakpoint.
    if n > <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(DBGDIDR.BRPs) then
        (c, n) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableInteger.3" title="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high, Unpredictable which)">ConstrainUnpredictableInteger</a>(0, <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(DBGDIDR.BRPs), <a href="shared_pseudocode.html#Unpredictable_BPNOTIMPL" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}">Unpredictable_BPNOTIMPL</a>);
        assert c IN {<a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}">Constraint_UNKNOWN</a>};
        if c == <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}">Constraint_DISABLED</a> then return (FALSE,FALSE);

    // If this breakpoint is not enabled, it cannot generate a match. (This could also happen on a
    // call from StateMatch for linking).
    if DBGBCR[n].E == '0' then return (FALSE,FALSE);

    context_aware = (n >= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(DBGDIDR.BRPs) - <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(DBGDIDR.CTX_CMPs));

    // If BT is set to a reserved type, behaves either as disabled or as a not-reserved type.
    type = DBGBCR[n].BT;

    if ((type IN {'011x','11xx'} &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>()) ||              // Context matching
          (type == '010x' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaltOnBreakpointOrWatchpoint.0" title="function: boolean HaltOnBreakpointOrWatchpoint()">HaltOnBreakpointOrWatchpoint</a>()) ||         // Address mismatch
          (type != '0x0x' &amp;&amp; !context_aware) ||                         // Context matching
          (type == '1xxx' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>))) then                        // EL2 extension
        (c, type) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_RESBPTYPE" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}">Unpredictable_RESBPTYPE</a>);
        assert c IN {<a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}">Constraint_UNKNOWN</a>};
        if c == <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}">Constraint_DISABLED</a> then return (FALSE,FALSE);
        // Otherwise the value returned by ConstrainUnpredictableBits must be a not-reserved value

    // Determine what to compare against.
    match_addr = (type == '0x0x');
    mismatch   = (type == '010x');
    match_vmid = (type == '10xx');
    match_cid1 = (type == 'xx1x');
    match_cid2 = (type == '11xx');
    linked     = (type == 'xxx1');

    // If this is a call from StateMatch, return FALSE if the breakpoint is not programmed for a
    // VMID and/or context ID match, of if not context-aware. The above assertions mean that the
    // code can just test for match_addr == TRUE to confirm all these things.
    if linked_to &amp;&amp; (!linked || match_addr) then return (FALSE,FALSE);

    // If called from BreakpointMatch return FALSE for Linked context ID and/or VMID matches.
    if !linked_to &amp;&amp; linked &amp;&amp; !match_addr then return (FALSE,FALSE);

    // Do the comparison.
    if match_addr then
        byte = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(vaddress&lt;1:0>);
        assert byte IN {0,2};                     // "vaddress" is halfword aligned
        byte_select_match = (DBGBCR[n].BAS&lt;byte> == '1');
        BVR_match = vaddress&lt;31:2> == DBGBVR[n]&lt;31:2> &amp;&amp; byte_select_match;
    elsif match_cid1 then
        BVR_match = (PSTATE.EL != <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; CONTEXTIDR == DBGBVR[n]&lt;31:0>);
    if match_vmid then
        if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
            vmid = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(VTTBR.VMID, 16);
            bvr_vmid = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(DBGBXVR[n]&lt;7:0>, 16);
        elsif !<a href="shared_pseudocode.html#impl-shared.Have16bitVMID.0" title="function: boolean Have16bitVMID()">Have16bitVMID</a>() || VTCR_EL2.VS == '0' then
            vmid = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(VTTBR_EL2.VMID&lt;7:0>, 16);
            bvr_vmid = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(DBGBXVR[n]&lt;7:0>, 16);
        else
            vmid = VTTBR_EL2.VMID;
            bvr_vmid = DBGBXVR[n]&lt;15:0>;
        BXVR_match = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>,<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp;
                      vmid == bvr_vmid);
    elsif match_cid2 then
        BXVR_match = (!<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp;
                      !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp;
                      DBGBXVR[n]&lt;31:0> == CONTEXTIDR_EL2);

    bvr_match_valid = (match_addr || match_cid1);
    bxvr_match_valid = (match_vmid || match_cid2);

    match = (!bxvr_match_valid || BXVR_match) &amp;&amp; (!bvr_match_valid || BVR_match);

    return (match &amp;&amp; !mismatch, !match &amp;&amp; mismatch);</p></div><div class="ps" psname="aarch32.debug.breakpoint.AArch32.StateMatch"><a id="aarch32.debug.breakpoint.AArch32.StateMatch" name="aarch32.debug.breakpoint.AArch32.StateMatch"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/breakpoint/AArch32.StateMatch</h3><p class="pseudocode">// AArch32.StateMatch()
// ====================
// Determine whether a breakpoint or watchpoint is enabled in the current mode and state.

boolean <a id="AArch32.StateMatch.7" name="AArch32.StateMatch.7"></a>AArch32.StateMatch(bits(2) SSC, bit HMC, bits(2) PxC, boolean linked, bits(4) LBN,
                           boolean isbreakpnt,  boolean ispriv)
    // "SSC", "HMC", "PxC" are the control fields from the DBGBCR[n] or DBGWCR[n] register.
    // "linked" is TRUE if this is a linked breakpoint/watchpoint type.
    // "LBN" is the linked breakpoint number from the DBGBCR[n] or DBGWCR[n] register.
    // "isbreakpnt" is TRUE for breakpoints, FALSE for watchpoints.
    // "ispriv" is valid for watchpoints, and selects between privileged and unprivileged accesses.

    // If parameters are set to a reserved type, behaves as either disabled or a defined type
    if ((HMC:SSC:PxC) IN {'011xx','100x0','101x0','11010','11101','1111x'} ||       // Reserved
          (HMC == '0' &amp;&amp; PxC == '00' &amp;&amp; !isbreakpnt) ||                             // Usr/Svc/Sys
          (SSC IN {'01','10'} &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>)) ||                                   // No EL3
          (HMC:SSC:PxC == '11000' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>)) ||                        // AArch64 only
          (HMC:SSC != '000' &amp;&amp; HMC:SSC != '111' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>)) || // No EL3/EL2
          (HMC:SSC:PxC == '11100' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>))) then                            // No EL2
        (c, &lt;HMC,SSC,PxC>) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_RESBPWPCTRL" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}">Unpredictable_RESBPWPCTRL</a>);
        assert c IN {<a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}">Constraint_UNKNOWN</a>};
        if c == <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}">Constraint_DISABLED</a> then return FALSE;
        // Otherwise the value returned by ConstrainUnpredictableBits must be a not-reserved value

    PL2_match = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; HMC == '1';
    PL1_match = PxC&lt;0> == '1';
    PL0_match = PxC&lt;1> == '1';
    SSU_match = isbreakpnt &amp;&amp; HMC == '0' &amp;&amp; PxC == '00' &amp;&amp; SSC != '11';

    el = PSTATE.EL;

    if !ispriv &amp;&amp; !isbreakpnt then
        priv_match = PL0_match;
    elsif SSU_match then
        priv_match = PSTATE.M IN {<a href="shared_pseudocode.html#M32_User" title="constant bits(5) M32_User = '10000'">M32_User</a>,<a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'">M32_Svc</a>,<a href="shared_pseudocode.html#M32_System" title="constant bits(5) M32_System = '11111'">M32_System</a>};
    else
        case el of
            when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  priv_match = PL1_match;           // EL3 and EL1 are both PL1
            when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  priv_match = PL2_match;
            when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  priv_match = PL1_match;
            when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>  priv_match = PL0_match;

    case SSC of
        when '00'  security_state_match = TRUE;         // Both
        when '01'  security_state_match = !<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>();  // Non-secure only
        when '10'  security_state_match = <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>();   // Secure only
        when '11'  security_state_match = TRUE;         // Both

    if linked then
        // "LBN" must be an enabled context-aware breakpoint unit. If it is not context-aware then
        // it is CONSTRAINED UNPREDICTABLE whether this gives no match, or LBN is mapped to some
        // UNKNOWN breakpoint that is context-aware.
        lbn = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(LBN);
        first_ctx_cmp = (<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(DBGDIDR.BRPs) - <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(DBGDIDR.CTX_CMPs));
        last_ctx_cmp = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(DBGDIDR.BRPs);
        if (lbn &lt; first_ctx_cmp || lbn > last_ctx_cmp) then
            (c, lbn) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableInteger.3" title="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high, Unpredictable which)">ConstrainUnpredictableInteger</a>(first_ctx_cmp, last_ctx_cmp, <a href="shared_pseudocode.html#Unpredictable_BPNOTCTXCMP" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}">Unpredictable_BPNOTCTXCMP</a>);
            assert c IN {<a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}">Constraint_NONE</a>, <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}">Constraint_UNKNOWN</a>};
            case c of
                when <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}">Constraint_DISABLED</a>  return FALSE;      // Disabled
                when <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}">Constraint_NONE</a>      linked = FALSE;    // No linking
                // Otherwise ConstrainUnpredictableInteger returned a context-aware breakpoint

    if linked then
        vaddress = bits(32) UNKNOWN;
        linked_to = TRUE;
        (linked_match,-) = <a href="shared_pseudocode.html#AArch32.BreakpointValueMatch.3" title="function: (boolean,boolean) AArch32.BreakpointValueMatch(integer n, bits(32) vaddress, boolean linked_to)">AArch32.BreakpointValueMatch</a>(lbn, vaddress, linked_to);

    return priv_match &amp;&amp; security_state_match &amp;&amp; (!linked || linked_match);</p></div><div class="ps" psname="aarch32.debug.enables.AArch32.GenerateDebugExceptions"><a id="aarch32.debug.enables.AArch32.GenerateDebugExceptions" name="aarch32.debug.enables.AArch32.GenerateDebugExceptions"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/enables/AArch32.GenerateDebugExceptions</h3><p class="pseudocode">// AArch32.GenerateDebugExceptions()
// =================================

boolean <a id="AArch32.GenerateDebugExceptions.0" name="AArch32.GenerateDebugExceptions.0"></a>AArch32.GenerateDebugExceptions()
    return <a href="shared_pseudocode.html#AArch32.GenerateDebugExceptionsFrom.2" title="function: boolean AArch32.GenerateDebugExceptionsFrom(bits(2) from, boolean secure)">AArch32.GenerateDebugExceptionsFrom</a>(PSTATE.EL, <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>());</p></div><div class="ps" psname="aarch32.debug.enables.AArch32.GenerateDebugExceptionsFrom"><a id="aarch32.debug.enables.AArch32.GenerateDebugExceptionsFrom" name="aarch32.debug.enables.AArch32.GenerateDebugExceptionsFrom"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/enables/AArch32.GenerateDebugExceptionsFrom</h3><p class="pseudocode">// AArch32.GenerateDebugExceptionsFrom()
// =====================================

boolean <a id="AArch32.GenerateDebugExceptionsFrom.2" name="AArch32.GenerateDebugExceptionsFrom.2"></a>AArch32.GenerateDebugExceptionsFrom(bits(2) from, boolean secure)

    if from == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELStateUsingAArch32.2" title="function: boolean ELStateUsingAArch32(bits(2) el, boolean secure)">ELStateUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, secure) then
        mask = bit UNKNOWN;                          // PSTATE.D mask, unused for EL0 case
        return <a href="shared_pseudocode.html#AArch64.GenerateDebugExceptionsFrom.3" title="function: boolean AArch64.GenerateDebugExceptionsFrom(bits(2) from, boolean secure, bit mask)">AArch64.GenerateDebugExceptionsFrom</a>(from, secure, mask);

    if DBGOSLSR.OSLK == '1' || <a href="shared_pseudocode.html#impl-shared.DoubleLockStatus.0" title="function: boolean DoubleLockStatus()">DoubleLockStatus</a>() || <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() then
        return FALSE;

    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; secure then
        spd = if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then SDCR.SPD else MDCR_EL3.SPD32;
        if spd&lt;1> == '1' then
            enabled = spd&lt;0> == '1';
        else
            // SPD == 0b01 is reserved, but behaves the same as 0b00.
            enabled = <a href="shared_pseudocode.html#AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled.0" title="function: boolean AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled()">AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled</a>();
        if from == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then enabled = enabled || SDER.SUIDEN == '1';
    else
        enabled = from != <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;

    return enabled;</p></div><div class="ps" psname="aarch32.debug.pmu.AArch32.CheckForPMUOverflow"><a id="aarch32.debug.pmu.AArch32.CheckForPMUOverflow" name="aarch32.debug.pmu.AArch32.CheckForPMUOverflow"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/pmu/AArch32.CheckForPMUOverflow</h3><p class="pseudocode">// AArch32.CheckForPMUOverflow()
// =============================
// Signal Performance Monitors overflow IRQ and CTI overflow events

boolean <a id="AArch32.CheckForPMUOverflow.0" name="AArch32.CheckForPMUOverflow.0"></a>AArch32.CheckForPMUOverflow()

    if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then return <a href="shared_pseudocode.html#AArch64.CheckForPMUOverflow.0" title="function: boolean AArch64.CheckForPMUOverflow()">AArch64.CheckForPMUOverflow</a>();
    pmuirq = PMCR.E == '1' &amp;&amp; PMINTENSET&lt;31> == '1' &amp;&amp; PMOVSSET&lt;31> == '1';
    for n = 0 to <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PMCR.N) - 1
        if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
            hpmn = if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then MDCR_EL2.HPMN else HDCR.HPMN;
            hpme = if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then MDCR_EL2.HPME else HDCR.HPME;
            E = (if n &lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(hpmn) then PMCR.E else hpme);
        else
            E = PMCR.E;
        if E == '1' &amp;&amp; PMINTENSET&lt;n> == '1' &amp;&amp; PMOVSSET&lt;n> == '1' then pmuirq = TRUE;

    SetInterruptRequestLevel(<a href="shared_pseudocode.html#InterruptID_PMUIRQ" title="enumeration InterruptID {InterruptID_PMUIRQ, InterruptID_COMMIRQ, InterruptID_CTIIRQ, InterruptID_COMMRX, InterruptID_COMMTX}">InterruptID_PMUIRQ</a>, if pmuirq then HIGH else LOW);

    CTI_SetEventLevel(<a href="shared_pseudocode.html#CrossTriggerIn_PMUOverflow" title="enumeration CrossTriggerIn  {CrossTriggerIn_CrossHalt,     CrossTriggerIn_PMUOverflow, CrossTriggerIn_RSVD2,         CrossTriggerIn_RSVD3, CrossTriggerIn_TraceExtOut0,  CrossTriggerIn_TraceExtOut1, CrossTriggerIn_TraceExtOut2,  CrossTriggerIn_TraceExtOut3}">CrossTriggerIn_PMUOverflow</a>, if pmuirq then HIGH else LOW);

    // The request remains set until the condition is cleared. (For example, an interrupt handler
    // or cross-triggered event handler clears the overflow status flag by writing to PMOVSCLR_EL0.)

    return pmuirq;</p></div><div class="ps" psname="aarch32.debug.pmu.AArch32.CountEvents"><a id="aarch32.debug.pmu.AArch32.CountEvents" name="aarch32.debug.pmu.AArch32.CountEvents"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/pmu/AArch32.CountEvents</h3><p class="pseudocode">// AArch32.CountEvents()
// =====================
// Return TRUE if counter "n" should count its event. For the cycle counter, n == 31.

boolean <a id="AArch32.CountEvents.1" name="AArch32.CountEvents.1"></a>AArch32.CountEvents(integer n)
    assert n == 31 || n &lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PMCR.N);

    if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then return <a href="shared_pseudocode.html#AArch64.CountEvents.1" title="function: boolean AArch64.CountEvents(integer n)">AArch64.CountEvents</a>(n);
    // Event counting is disabled in Debug state
    debug = <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>();

    // In Non-secure state, some counters are reserved for EL2
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        hpmn = if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then MDCR_EL2.HPMN else HDCR.HPMN;
        hpme = if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then MDCR_EL2.HPME else HDCR.HPME;
        E = if n &lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(hpmn) || n == 31 then PMCR.E else hpme;
    else
        E = PMCR.E;
    enabled = E == '1' &amp;&amp; PMCNTENSET&lt;n> == '1';

    if !<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then
        // Event counting in Non-secure state is allowed unless all of:
        // * EL2 and the HPMD Extension are implemented
        // * Executing at EL2
        // * PMNx is not reserved for EL2
        // * HDCR.HPMD == 1
        if <a href="shared_pseudocode.html#impl-shared.HaveHPMDExt.0" title="function: boolean HaveHPMDExt()">HaveHPMDExt</a>() &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; (n &lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(hpmn) || n == 31) then
            hpmd = if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then MDCR_EL2.HPMD else HDCR.HPMD;
            prohibited = (hpmd == '1');
        else
            prohibited = FALSE;
    else
        // Event counting in Secure state is prohibited unless any one of:
        // * EL3 is not implemented
        // * EL3 is using AArch64 and MDCR_EL3.SPME == 1
        // * EL3 is using AArch32 and SDCR.SPME == 1
        // * Executing at EL0, and SDER.SUNIDEN == 1.
        spme = (if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then SDCR.SPME else MDCR_EL3.SPME);
        prohibited = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; spme == '0' &amp;&amp; (PSTATE.EL != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> || SDER.SUNIDEN == '0');

    // The IMPLEMENTATION DEFINED authentication interface might override software controls
    if prohibited &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveNoSecurePMUDisableOverride.0" title="function: boolean HaveNoSecurePMUDisableOverride()">HaveNoSecurePMUDisableOverride</a>() then
        prohibited = !<a href="shared_pseudocode.html#impl-shared.ExternalSecureNoninvasiveDebugEnabled.0" title="function: boolean ExternalSecureNoninvasiveDebugEnabled()">ExternalSecureNoninvasiveDebugEnabled</a>();

    // For the cycle counter, PMCR.DP enables counting when otherwise prohibited
    if prohibited &amp;&amp; n == 31 then prohibited = (PMCR.DP == '1');

    // Event counting can be filtered by the {P, U, NSK, NSU, NSH} bits
    filter = if n == 31 then PMCCFILTR else PMEVTYPER[n];

    P = filter&lt;31>;
    U = filter&lt;30>;
    NSK = if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then filter&lt;29> else '0';
    NSU = if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then filter&lt;28> else '0';
    NSH = if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then filter&lt;27> else '0';

    case PSTATE.EL of
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>  filtered = if <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then U == '1' else U != NSU;
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  filtered = if <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then P == '1' else P != NSK;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  filtered = (NSH == '0');
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  filtered = (P == '1');

    return !debug &amp;&amp; enabled &amp;&amp; !prohibited &amp;&amp; !filtered;</p></div><div class="ps" psname="aarch32.debug.takeexceptiondbg.AArch32.EnterHypModeInDebugState"><a id="aarch32.debug.takeexceptiondbg.AArch32.EnterHypModeInDebugState" name="aarch32.debug.takeexceptiondbg.AArch32.EnterHypModeInDebugState"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/takeexceptiondbg/AArch32.EnterHypModeInDebugState</h3><p class="pseudocode">// AArch32.EnterHypModeInDebugState()
// ==================================
// Take an exception in Debug state to Hyp mode.

<a id="AArch32.EnterHypModeInDebugState.1" name="AArch32.EnterHypModeInDebugState.1"></a>AArch32.EnterHypModeInDebugState(<a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is (Exception type, bits(25) syndrome, bits(64) vaddress, boolean ipavalid, bits(1) NS, bits(52) ipaddress)">ExceptionRecord</a> exception)
    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()">SynchronizeContext</a>();
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);

    <a href="shared_pseudocode.html#AArch32.ReportHypEntry.1" title="function: AArch32.ReportHypEntry(ExceptionRecord exception)">AArch32.ReportHypEntry</a>(exception);
    <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>);
    <a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(32) value">SPSR</a>[] = bits(32) UNKNOWN;
<ins>    PSTATE.SSBS = bits(1) UNKNOWN;
    ELR_hyp = bits(32) UNKNOWN;
    // In Debug state, the PE always execute T32 instructions when in AArch32 state, and
    // PSTATE.{SS,A,I,F} are not observable so behave as UNKNOWN.
    PSTATE.T = '1';                             // PSTATE.J is RES0
    PSTATE.&lt;SS,A,I,F> = bits(4) UNKNOWN;
    DLR = bits(32) UNKNOWN;
    DSPSR = bits(32) UNKNOWN;
    PSTATE.E = HSCTLR.EE;
    PSTATE.IL = '0';
    PSTATE.IT = '00000000';
    EDSCR.ERR = '1';</ins><del>    if</del>
    <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()"><del>HaveSSBSExt</del></a><del>() then PSTATE.SSBS = bits(1) UNKNOWN;
    ELR_hyp = bits(32) UNKNOWN;
    // In Debug state, the PE always execute T32 instructions when in AArch32 state, and
    // PSTATE.{SS,A,I,F} are not observable so behave as UNKNOWN.
    PSTATE.T = '1';                             // PSTATE.J is RES0
    PSTATE.&lt;SS,A,I,F> = bits(4) UNKNOWN;
    DLR = bits(32) UNKNOWN;
    DSPSR = bits(32) UNKNOWN;
    PSTATE.E = HSCTLR.EE;
    PSTATE.IL = '0';
    PSTATE.IT = '00000000';
    EDSCR.ERR = '1';
    </del><a href="shared_pseudocode.html#impl-shared.UpdateEDSCRFields.0" title="function: UpdateEDSCRFields()">UpdateEDSCRFields</a>();

    <a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()">EndOfInstruction</a>();</p></div><div class="ps" psname="aarch32.debug.takeexceptiondbg.AArch32.EnterModeInDebugState"><a id="aarch32.debug.takeexceptiondbg.AArch32.EnterModeInDebugState" name="aarch32.debug.takeexceptiondbg.AArch32.EnterModeInDebugState"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/takeexceptiondbg/AArch32.EnterModeInDebugState</h3><p class="pseudocode">// AArch32.EnterModeInDebugState()
// ===============================
// Take an exception in Debug state to a mode other than Monitor and Hyp mode.

<a id="AArch32.EnterModeInDebugState.1" name="AArch32.EnterModeInDebugState.1"></a>AArch32.EnterModeInDebugState(bits(5) target_mode)
    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()">SynchronizeContext</a>();
    assert <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; PSTATE.EL != <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;

    if PSTATE.M == <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then SCR.NS = '0';
    <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(target_mode);
    <a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(32) value">SPSR</a>[] = bits(32) UNKNOWN;
<ins>    PSTATE.SSBS = bits(1) UNKNOWN;</ins><del>    if</del>
    <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()"><del>HaveSSBSExt</del></a><del>() then PSTATE.SSBS = bits(1) UNKNOWN;
    </del><a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value">R</a>[14] = bits(32) UNKNOWN;
    // In Debug state, the PE always execute T32 instructions when in AArch32 state, and
    // PSTATE.{SS,A,I,F} are not observable so behave as UNKNOWN.
    PSTATE.T = '1';                             // PSTATE.J is RES0
    PSTATE.&lt;SS,A,I,F> = bits(4) UNKNOWN;
    DLR = bits(32) UNKNOWN;
    DSPSR = bits(32) UNKNOWN;
    PSTATE.E = SCTLR.EE;
    PSTATE.IL = '0';
    PSTATE.IT = '00000000';
    if <a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()">HavePANExt</a>() &amp;&amp; SCTLR.SPAN == '0' then
        PSTATE.PAN = '1';
    EDSCR.ERR = '1';
    <a href="shared_pseudocode.html#impl-shared.UpdateEDSCRFields.0" title="function: UpdateEDSCRFields()">UpdateEDSCRFields</a>();                        // Update EDSCR processor state flags.

    <a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()">EndOfInstruction</a>();</p></div><div class="ps" psname="aarch32.debug.takeexceptiondbg.AArch32.EnterMonitorModeInDebugState"><a id="aarch32.debug.takeexceptiondbg.AArch32.EnterMonitorModeInDebugState" name="aarch32.debug.takeexceptiondbg.AArch32.EnterMonitorModeInDebugState"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/takeexceptiondbg/AArch32.EnterMonitorModeInDebugState</h3><p class="pseudocode">// AArch32.EnterMonitorModeInDebugState()
// ======================================
// Take an exception in Debug state to Monitor mode.

<a id="AArch32.EnterMonitorModeInDebugState.0" name="AArch32.EnterMonitorModeInDebugState.0"></a>AArch32.EnterMonitorModeInDebugState()
    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()">SynchronizeContext</a>();
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    from_secure = <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>();
    if PSTATE.M == <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then SCR.NS = '0';
    <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>);
    <a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(32) value">SPSR</a>[] = bits(32) UNKNOWN;
<ins>    PSTATE.SSBS = bits(1) UNKNOWN;</ins><del>    if</del>
    <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()"><del>HaveSSBSExt</del></a><del>() then PSTATE.SSBS = bits(1) UNKNOWN;
    </del><a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value">R</a>[14] = bits(32) UNKNOWN;
    // In Debug state, the PE always execute T32 instructions when in AArch32 state, and
    // PSTATE.{SS,A,I,F} are not observable so behave as UNKNOWN.
    PSTATE.T = '1';                             // PSTATE.J is RES0
    PSTATE.&lt;SS,A,I,F> = bits(4) UNKNOWN;
    DLR = bits(32) UNKNOWN;
    DSPSR = bits(32) UNKNOWN;
    PSTATE.E = SCTLR.EE;
    PSTATE.IL = '0';
    PSTATE.IT = '00000000';
    if <a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()">HavePANExt</a>() then
        if !from_secure then
            PSTATE.PAN = '0';
        elsif SCTLR.SPAN == '0' then
            PSTATE.PAN = '1';
    EDSCR.ERR = '1';
    <a href="shared_pseudocode.html#impl-shared.UpdateEDSCRFields.0" title="function: UpdateEDSCRFields()">UpdateEDSCRFields</a>();                        // Update EDSCR processor state flags.

    <a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()">EndOfInstruction</a>();</p></div><div class="ps" psname="aarch32.debug.watchpoint.AArch32.WatchpointByteMatch"><a id="aarch32.debug.watchpoint.AArch32.WatchpointByteMatch" name="aarch32.debug.watchpoint.AArch32.WatchpointByteMatch"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/watchpoint/AArch32.WatchpointByteMatch</h3><p class="pseudocode">// AArch32.WatchpointByteMatch()
// =============================

boolean <a id="AArch32.WatchpointByteMatch.2" name="AArch32.WatchpointByteMatch.2"></a>AArch32.WatchpointByteMatch(integer n,  bits(32) vaddress)

    bottom = if DBGWVR[n]&lt;2> == '1' then 2 else 3;            // Word or doubleword
    byte_select_match = (DBGWCR[n].BAS&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(vaddress&lt;bottom-1:0>)> != '0');
    mask = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(DBGWCR[n].MASK);

    // If DBGWCR[n].MASK is non-zero value and DBGWCR[n].BAS is not set to '11111111', or
    // DBGWCR[n].BAS specifies a non-contiguous set of bytes behavior is CONSTRAINED
    // UNPREDICTABLE.
    if mask > 0 &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(DBGWCR[n].BAS) then
        byte_select_match = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_WPMASKANDBAS" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}">Unpredictable_WPMASKANDBAS</a>);
    else
        LSB = (DBGWCR[n].BAS AND NOT(DBGWCR[n].BAS - 1));  MSB = (DBGWCR[n].BAS + LSB);
        if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(MSB AND (MSB - 1)) then                     // Not contiguous
            byte_select_match = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_WPBASCONTIGUOUS" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}">Unpredictable_WPBASCONTIGUOUS</a>);
            bottom = 3;                                        // For the whole doubleword

    // If the address mask is set to a reserved value, the behavior is CONSTRAINED UNPREDICTABLE.
    if mask > 0 &amp;&amp; mask &lt;= 2 then
        (c, mask) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableInteger.3" title="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high, Unpredictable which)">ConstrainUnpredictableInteger</a>(3, 31, <a href="shared_pseudocode.html#Unpredictable_RESWPMASK" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}">Unpredictable_RESWPMASK</a>);
        assert c IN {<a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}">Constraint_NONE</a>, <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}">Constraint_UNKNOWN</a>};
        case c of
            when <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}">Constraint_DISABLED</a>  return FALSE;            // Disabled
            when <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}">Constraint_NONE</a>      mask = 0;                // No masking
            // Otherwise the value returned by ConstrainUnpredictableInteger is a not-reserved value

    if mask > bottom then
        WVR_match = (vaddress&lt;31:mask> == DBGWVR[n]&lt;31:mask>);
        // If masked bits of DBGWVR_EL1[n] are not zero, the behavior is CONSTRAINED UNPREDICTABLE.
        if WVR_match &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(DBGWVR[n]&lt;mask-1:bottom>) then
            WVR_match = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_WPMASKEDBITS" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}">Unpredictable_WPMASKEDBITS</a>);
    else
        WVR_match = vaddress&lt;31:bottom> == DBGWVR[n]&lt;31:bottom>;

    return WVR_match &amp;&amp; byte_select_match;</p></div><div class="ps" psname="aarch32.debug.watchpoint.AArch32.WatchpointMatch"><a id="aarch32.debug.watchpoint.AArch32.WatchpointMatch" name="aarch32.debug.watchpoint.AArch32.WatchpointMatch"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/watchpoint/AArch32.WatchpointMatch</h3><p class="pseudocode">// AArch32.WatchpointMatch()
// =========================
// Watchpoint matching in an AArch32 translation regime.

boolean <a id="AArch32.WatchpointMatch.5" name="AArch32.WatchpointMatch.5"></a>AArch32.WatchpointMatch(integer n, bits(32) vaddress, integer size, boolean ispriv,
                                 boolean iswrite)
    assert <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>());
    assert n &lt;= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(DBGDIDR.WRPs);

    // "ispriv" is FALSE for LDRT/STRT instructions executed at EL1 and all
    // load/stores at EL0, TRUE for all other load/stores. "iswrite" is TRUE for stores, FALSE for
    // loads.
    enabled = DBGWCR[n].E == '1';
    linked = DBGWCR[n].WT == '1';
    isbreakpnt = FALSE;

    state_match = <a href="shared_pseudocode.html#AArch32.StateMatch.7" title="function: boolean AArch32.StateMatch(bits(2) SSC, bit HMC, bits(2) PxC, boolean linked, bits(4) LBN, boolean isbreakpnt,  boolean ispriv)">AArch32.StateMatch</a>(DBGWCR[n].SSC, DBGWCR[n].HMC, DBGWCR[n].PAC,
                                     linked, DBGWCR[n].LBN, isbreakpnt, ispriv);

    ls_match = (DBGWCR[n].LSC&lt;(if iswrite then 1 else 0)> == '1');

    value_match = FALSE;
    for byte = 0 to size - 1
        value_match = value_match || <a href="shared_pseudocode.html#AArch32.WatchpointByteMatch.2" title="function: boolean AArch32.WatchpointByteMatch(integer n,  bits(32) vaddress)">AArch32.WatchpointByteMatch</a>(n, vaddress + byte);

    return value_match &amp;&amp; state_match &amp;&amp; ls_match &amp;&amp; enabled;</p></div><div class="ps" psname="aarch32.exceptions.aborts.AArch32.Abort"><a id="aarch32.exceptions.aborts.AArch32.Abort" name="aarch32.exceptions.aborts.AArch32.Abort"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/AArch32.Abort</h3><p class="pseudocode">// AArch32.Abort()
// ===============
// Abort and Debug exception handling in an AArch32 translation regime.

<a id="AArch32.Abort.2" name="AArch32.Abort.2"></a>AArch32.Abort(bits(32) vaddress, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)

    // Check if routed to AArch64 state
    route_to_aarch64 = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);

    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        route_to_aarch64 = (HCR_EL2.TGE == '1' || <a href="shared_pseudocode.html#impl-shared.IsSecondStage.1" title="function: boolean IsSecondStage(FaultRecord fault)">IsSecondStage</a>(fault) ||
                            (<a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; HCR2.TEA == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault type)">IsExternalAbort</a>(fault)) ||
                            (<a href="shared_pseudocode.html#impl-shared.IsDebugException.1" title="function: boolean IsDebugException(FaultRecord fault)">IsDebugException</a>(fault) &amp;&amp; MDCR_EL2.TDE == '1'));

    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        route_to_aarch64 = SCR_EL3.EA == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault type)">IsExternalAbort</a>(fault);

    if route_to_aarch64 then
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(<a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(vaddress), fault);
    elsif fault.acctype == <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType_IFETCH</a> then
        <a href="shared_pseudocode.html#AArch32.TakePrefetchAbortException.2" title="function: AArch32.TakePrefetchAbortException(bits(32) vaddress, FaultRecord fault)">AArch32.TakePrefetchAbortException</a>(vaddress, fault);
    else
        <a href="shared_pseudocode.html#AArch32.TakeDataAbortException.2" title="function: AArch32.TakeDataAbortException(bits(32) vaddress, FaultRecord fault)">AArch32.TakeDataAbortException</a>(vaddress, fault);</p></div><div class="ps" psname="aarch32.exceptions.aborts.AArch32.AbortSyndrome"><a id="aarch32.exceptions.aborts.AArch32.AbortSyndrome" name="aarch32.exceptions.aborts.AArch32.AbortSyndrome"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/AArch32.AbortSyndrome</h3><p class="pseudocode">// AArch32.AbortSyndrome()
// =======================
// Creates an exception syndrome record for Abort  exceptions taken to Hyp mode
// from an AArch32 translation regime.

ExceptionRecord <a id="AArch32.AbortSyndrome.3" name="AArch32.AbortSyndrome.3"></a>AArch32.AbortSyndrome(<a href="shared_pseudocode.html#Exception" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception</a> type, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault, bits(32) vaddress)

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)">ExceptionSyndrome</a>(type);

    d_side = type == <a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_DataAbort</a>;

    exception.syndrome = <a href="shared_pseudocode.html#AArch32.FaultSyndrome.2" title="function: bits(25) AArch32.FaultSyndrome(boolean d_side, FaultRecord fault)">AArch32.FaultSyndrome</a>(d_side, fault);
    exception.vaddress = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(vaddress);
    if <a href="shared_pseudocode.html#impl-shared.IPAValid.1" title="function: boolean IPAValid(FaultRecord fault)">IPAValid</a>(fault) then
        exception.ipavalid = TRUE;
        exception.NS = fault.ipaddress.NS;
        exception.ipaddress = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(fault.ipaddress.address);
    else
        exception.ipavalid = FALSE;

    return exception;</p></div><div class="ps" psname="aarch32.exceptions.aborts.AArch32.CheckPCAlignment"><a id="aarch32.exceptions.aborts.AArch32.CheckPCAlignment" name="aarch32.exceptions.aborts.AArch32.CheckPCAlignment"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/AArch32.CheckPCAlignment</h3><p class="pseudocode">// AArch32.CheckPCAlignment()
// ==========================

<a id="AArch32.CheckPCAlignment.0" name="AArch32.CheckPCAlignment.0"></a>AArch32.CheckPCAlignment()

    bits(32) pc = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    if (<a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>() == <a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a> &amp;&amp; pc&lt;1> == '1') || pc&lt;0> == '1' then
        if <a href="shared_pseudocode.html#AArch32.GeneralExceptionsToAArch64.0" title="function: boolean AArch32.GeneralExceptionsToAArch64()">AArch32.GeneralExceptionsToAArch64</a>() then <a href="shared_pseudocode.html#AArch64.PCAlignmentFault.0" title="function: AArch64.PCAlignmentFault()">AArch64.PCAlignmentFault</a>();

        // Generate an Alignment fault Prefetch Abort exception
        vaddress = pc;
        acctype = <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType_IFETCH</a>;
        iswrite = FALSE;
        secondstage = FALSE;
        <a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(vaddress, <a href="shared_pseudocode.html#AArch32.AlignmentFault.3" title="function: FaultRecord AArch32.AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)">AArch32.AlignmentFault</a>(acctype, iswrite, secondstage));</p></div><div class="ps" psname="aarch32.exceptions.aborts.AArch32.ReportDataAbort"><a id="aarch32.exceptions.aborts.AArch32.ReportDataAbort" name="aarch32.exceptions.aborts.AArch32.ReportDataAbort"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/AArch32.ReportDataAbort</h3><p class="pseudocode">// AArch32.ReportDataAbort()
// =========================
// Report syndrome information for aborts taken to modes other than Hyp mode.

<a id="AArch32.ReportDataAbort.3" name="AArch32.ReportDataAbort.3"></a>AArch32.ReportDataAbort(boolean route_to_monitor, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault, bits(32) vaddress)

    // The encoding used in the IFSR or DFSR can be Long-descriptor format or Short-descriptor
    // format.  Normally, the current translation table format determines the format. For an abort
    // from Non-secure state to Monitor mode, the IFSR or DFSR uses the Long-descriptor format if
    // any of the following applies:
    // * The Secure TTBCR.EAE is set to 1.
    // * The abort is synchronous and either:
    //   - It is taken from Hyp mode.
    //   - It is taken from EL1 or EL0, and the Non-secure TTBCR.EAE is set to 1.
    long_format = FALSE;
    if route_to_monitor &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then
        long_format = TTBCR_S.EAE == '1';
        if !<a href="shared_pseudocode.html#impl-shared.IsSErrorInterrupt.1" title="function: boolean IsSErrorInterrupt(Fault type)">IsSErrorInterrupt</a>(fault) &amp;&amp; !long_format then
            long_format = PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || TTBCR.EAE == '1';
    else
        long_format = TTBCR.EAE == '1';
    d_side = TRUE;
    if long_format then
        syndrome = <a href="shared_pseudocode.html#AArch32.FaultStatusLD.2" title="function: bits(32) AArch32.FaultStatusLD(boolean d_side, FaultRecord fault)">AArch32.FaultStatusLD</a>(d_side, fault);
    else
        syndrome = <a href="shared_pseudocode.html#AArch32.FaultStatusSD.2" title="function: bits(32) AArch32.FaultStatusSD(boolean d_side, FaultRecord fault)">AArch32.FaultStatusSD</a>(d_side, fault);

    if fault.acctype == <a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType_IC</a> then
        if (!long_format &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Report I-cache maintenance fault in IFSR") then
            i_syndrome = syndrome;
            syndrome&lt;10,3:0> = <a href="shared_pseudocode.html#impl-aarch32.EncodeSDFSC.2" title="function: bits(5) EncodeSDFSC(Fault type, integer level)">EncodeSDFSC</a>(<a href="shared_pseudocode.html#Fault_ICacheMaint" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}">Fault_ICacheMaint</a>, 1);
        else
            i_syndrome = bits(32) UNKNOWN;
        if route_to_monitor then
            IFSR_S = i_syndrome;
        else
            IFSR = i_syndrome;

    if route_to_monitor then
        DFSR_S = syndrome;
        DFAR_S = vaddress;
    else
        DFSR = syndrome;
        DFAR = vaddress;

    return;</p></div><div class="ps" psname="aarch32.exceptions.aborts.AArch32.ReportPrefetchAbort"><a id="aarch32.exceptions.aborts.AArch32.ReportPrefetchAbort" name="aarch32.exceptions.aborts.AArch32.ReportPrefetchAbort"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/AArch32.ReportPrefetchAbort</h3><p class="pseudocode">// AArch32.ReportPrefetchAbort()
// =============================
// Report syndrome information for aborts taken to modes other than Hyp mode.

<a id="AArch32.ReportPrefetchAbort.3" name="AArch32.ReportPrefetchAbort.3"></a>AArch32.ReportPrefetchAbort(boolean route_to_monitor, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault, bits(32) vaddress)
    // The encoding used in the IFSR can be Long-descriptor format or Short-descriptor format.
    // Normally, the current translation table format determines the format. For an abort from
    // Non-secure state to Monitor mode, the IFSR uses the Long-descriptor format if any of the
    // following applies:
    // * The Secure TTBCR.EAE is set to 1.
    // * It is taken from Hyp mode.
    // * It is taken from EL1 or EL0, and the Non-secure TTBCR.EAE is set to 1.
    long_format = FALSE;
    if route_to_monitor &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then
        long_format = TTBCR_S.EAE == '1' || PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || TTBCR.EAE == '1';
    else
        long_format = TTBCR.EAE == '1';

    d_side = FALSE;
    if long_format then
        fsr = <a href="shared_pseudocode.html#AArch32.FaultStatusLD.2" title="function: bits(32) AArch32.FaultStatusLD(boolean d_side, FaultRecord fault)">AArch32.FaultStatusLD</a>(d_side, fault);
    else
        fsr = <a href="shared_pseudocode.html#AArch32.FaultStatusSD.2" title="function: bits(32) AArch32.FaultStatusSD(boolean d_side, FaultRecord fault)">AArch32.FaultStatusSD</a>(d_side, fault);

    if route_to_monitor then
        IFSR_S = fsr;
        IFAR_S = vaddress;
    else
        IFSR = fsr;
        IFAR = vaddress;

    return;</p></div><div class="ps" psname="aarch32.exceptions.aborts.AArch32.TakeDataAbortException"><a id="aarch32.exceptions.aborts.AArch32.TakeDataAbortException" name="aarch32.exceptions.aborts.AArch32.TakeDataAbortException"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/AArch32.TakeDataAbortException</h3><p class="pseudocode">// AArch32.TakeDataAbortException()
// ================================

<a id="AArch32.TakeDataAbortException.2" name="AArch32.TakeDataAbortException.2"></a>AArch32.TakeDataAbortException(bits(32) vaddress, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    route_to_monitor = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR.EA == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault type)">IsExternalAbort</a>(fault);
    route_to_hyp = (<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>,<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp;
                    (HCR.TGE == '1' || <a href="shared_pseudocode.html#impl-shared.IsSecondStage.1" title="function: boolean IsSecondStage(FaultRecord fault)">IsSecondStage</a>(fault) ||
                    (<a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; HCR2.TEA == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault type)">IsExternalAbort</a>(fault)) ||
                    (<a href="shared_pseudocode.html#impl-shared.IsDebugException.1" title="function: boolean IsDebugException(FaultRecord fault)">IsDebugException</a>(fault) &amp;&amp; HDCR.TDE == '1')));
    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x10;
    lr_offset = 8;

    if <a href="shared_pseudocode.html#impl-shared.IsDebugException.1" title="function: boolean IsDebugException(FaultRecord fault)">IsDebugException</a>(fault) then DBGDSCRext.MOE = fault.debugmoe;
    if route_to_monitor then
        <a href="shared_pseudocode.html#AArch32.ReportDataAbort.3" title="function: AArch32.ReportDataAbort(boolean route_to_monitor, FaultRecord fault, bits(32) vaddress)">AArch32.ReportDataAbort</a>(route_to_monitor, fault, vaddress);
        <a href="shared_pseudocode.html#AArch32.EnterMonitorMode.3" title="function: AArch32.EnterMonitorMode(bits(32) preferred_exception_return, integer lr_offset, integer vect_offset)">AArch32.EnterMonitorMode</a>(preferred_exception_return, lr_offset, vect_offset);
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_hyp then
        exception = <a href="shared_pseudocode.html#AArch32.AbortSyndrome.3" title="function: ExceptionRecord AArch32.AbortSyndrome(Exception type, FaultRecord fault, bits(32) vaddress)">AArch32.AbortSyndrome</a>(<a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_DataAbort</a>, fault, vaddress);
        if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
            <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return, integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
        else
            <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return, integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, 0x14);
    else
        <a href="shared_pseudocode.html#AArch32.ReportDataAbort.3" title="function: AArch32.ReportDataAbort(boolean route_to_monitor, FaultRecord fault, bits(32) vaddress)">AArch32.ReportDataAbort</a>(route_to_monitor, fault, vaddress);
        <a href="shared_pseudocode.html#AArch32.EnterMode.4" title="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset, integer vect_offset)">AArch32.EnterMode</a>(<a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a>, preferred_exception_return, lr_offset, vect_offset);</p></div><div class="ps" psname="aarch32.exceptions.aborts.AArch32.TakePrefetchAbortException"><a id="aarch32.exceptions.aborts.AArch32.TakePrefetchAbortException" name="aarch32.exceptions.aborts.AArch32.TakePrefetchAbortException"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/AArch32.TakePrefetchAbortException</h3><p class="pseudocode">// AArch32.TakePrefetchAbortException()
// ====================================

<a id="AArch32.TakePrefetchAbortException.2" name="AArch32.TakePrefetchAbortException.2"></a>AArch32.TakePrefetchAbortException(bits(32) vaddress, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    route_to_monitor = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR.EA == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault type)">IsExternalAbort</a>(fault);
    route_to_hyp = (<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>,<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp;
                    (HCR.TGE == '1' || <a href="shared_pseudocode.html#impl-shared.IsSecondStage.1" title="function: boolean IsSecondStage(FaultRecord fault)">IsSecondStage</a>(fault) ||
                    (<a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; HCR2.TEA == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault type)">IsExternalAbort</a>(fault)) ||
                    (<a href="shared_pseudocode.html#impl-shared.IsDebugException.1" title="function: boolean IsDebugException(FaultRecord fault)">IsDebugException</a>(fault) &amp;&amp; HDCR.TDE == '1')));

    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0C;
    lr_offset = 4;

    if <a href="shared_pseudocode.html#impl-shared.IsDebugException.1" title="function: boolean IsDebugException(FaultRecord fault)">IsDebugException</a>(fault) then DBGDSCRext.MOE = fault.debugmoe;
    if route_to_monitor then
        <a href="shared_pseudocode.html#AArch32.ReportPrefetchAbort.3" title="function: AArch32.ReportPrefetchAbort(boolean route_to_monitor, FaultRecord fault, bits(32) vaddress)">AArch32.ReportPrefetchAbort</a>(route_to_monitor, fault, vaddress);
        <a href="shared_pseudocode.html#AArch32.EnterMonitorMode.3" title="function: AArch32.EnterMonitorMode(bits(32) preferred_exception_return, integer lr_offset, integer vect_offset)">AArch32.EnterMonitorMode</a>(preferred_exception_return, lr_offset, vect_offset);
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_hyp then
        if fault.type == <a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}">Fault_Alignment</a> then             // PC Alignment fault
            exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_PCAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_PCAlignment</a>);
            exception.vaddress = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
        else
            exception = <a href="shared_pseudocode.html#AArch32.AbortSyndrome.3" title="function: ExceptionRecord AArch32.AbortSyndrome(Exception type, FaultRecord fault, bits(32) vaddress)">AArch32.AbortSyndrome</a>(<a href="shared_pseudocode.html#Exception_InstructionAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_InstructionAbort</a>, fault, vaddress);
        if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
            <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return, integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
        else
            <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return, integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, 0x14);
    else
        <a href="shared_pseudocode.html#AArch32.ReportPrefetchAbort.3" title="function: AArch32.ReportPrefetchAbort(boolean route_to_monitor, FaultRecord fault, bits(32) vaddress)">AArch32.ReportPrefetchAbort</a>(route_to_monitor, fault, vaddress);
        <a href="shared_pseudocode.html#AArch32.EnterMode.4" title="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset, integer vect_offset)">AArch32.EnterMode</a>(<a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a>, preferred_exception_return, lr_offset, vect_offset);</p></div><div class="ps" psname="aarch32.exceptions.aborts.BranchTargetException"><a id="aarch32.exceptions.aborts.BranchTargetException" name="aarch32.exceptions.aborts.BranchTargetException"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/BranchTargetException</h3><p class="pseudocode">// BranchTargetException
// =====================
// Raise branch target exception.

<a id="AArch64.BranchTargetException.1" name="AArch64.BranchTargetException.1"></a>AArch64.BranchTargetException(bits(52) vaddress)

    route_to_el2 = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; HCR_EL2.TGE == '1';
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_BranchTarget" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_BranchTarget</a>);
    exception.syndrome&lt;1:0>   = PSTATE.BTYPE;
    exception.syndrome&lt;24:2>  = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();         // RES0

    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) > <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
    elsif route_to_el2 then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p></div><div class="ps" psname="aarch32.exceptions.aborts.EffectiveTCF"><a id="aarch32.exceptions.aborts.EffectiveTCF" name="aarch32.exceptions.aborts.EffectiveTCF"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/EffectiveTCF</h3><p class="pseudocode">// EffectiveTCF()
// ==============
// Returns the TCF field applied to Tag Check Fails in the given Exception Level

bits(2) <a id="impl-aarch64.EffectiveTCF.1" name="impl-aarch64.EffectiveTCF.1"></a>EffectiveTCF(bits(2) el)
    if el == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
        tcf = SCTLR_EL3.TCF;
    elsif el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        tcf = SCTLR_EL2.TCF;
    elsif el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> then
        tcf = SCTLR_EL1.TCF;
    elsif el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; HCR_EL2.&lt;E2H,TGE> == '11' then
        tcf = SCTLR_EL2.TCF0;
    elsif el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; HCR_EL2.&lt;E2H,TGE> != '11' then
        tcf = SCTLR_EL1.TCF0;

    return tcf;</p></div><div class="ps" psname="aarch32.exceptions.aborts.RecordTagCheckFail"><a id="aarch32.exceptions.aborts.RecordTagCheckFail" name="aarch32.exceptions.aborts.RecordTagCheckFail"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/RecordTagCheckFail</h3><p class="pseudocode">// RecordTagCheckFail()
// ====================
// Records a tag fail exception into the appropriate TCFR_ELx

<a id="impl-aarch64.ReportTagCheckFail.2" name="impl-aarch64.ReportTagCheckFail.2"></a>ReportTagCheckFail(bits(2) el, bit ttbr)
    if el == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
        assert ttbr == '0';
        TFSR_EL3.TF0 = '1';
    elsif el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        if ttbr == '0' then
            TFSR_EL2.TF0 = '1';
        else
            TFSR_EL2.TF1 = '1';
    elsif el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> then
        if ttbr == '0' then
            TFSR_EL1.TF0 = '1';
        else
            TFSR_EL1.TF1 = '1';
    elsif el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        if ttbr == '0' then
            TFSRE0_EL1.TF0 = '1';
        else
            TFSRE0_EL1.TF1 = '1';</p></div><div class="ps" psname="aarch32.exceptions.aborts.TagCheckFail"><a id="aarch32.exceptions.aborts.TagCheckFail" name="aarch32.exceptions.aborts.TagCheckFail"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/TagCheckFail</h3><p class="pseudocode">// TagCheckFail()
// ==============
// Handle a tag check fail condition

<a id="impl-aarch64.TagCheckFail.2" name="impl-aarch64.TagCheckFail.2"></a>TagCheckFail(bits(64) vaddress, boolean iswrite)
    bits(2) tcf = <a href="shared_pseudocode.html#impl-aarch32.EffectiveTCF.1" title="function: bits(2) EffectiveTCF(bits(2) el)">EffectiveTCF</a>(PSTATE.EL);
    if tcf == '01' then
        <a href="shared_pseudocode.html#impl-aarch32.TagCheckFault.2" title="function: TagCheckFault(bits(64) va, boolean write)">TagCheckFault</a>(vaddress, iswrite);
    elsif tcf == '10' then
        <a href="shared_pseudocode.html#impl-aarch32.ReportTagCheckFail.2" title="function: ReportTagCheckFail(bits(2) el, bit ttbr)">ReportTagCheckFail</a>(PSTATE.EL, vaddress&lt;55>);</p></div><div class="ps" psname="aarch32.exceptions.aborts.TagCheckFault"><a id="aarch32.exceptions.aborts.TagCheckFault" name="aarch32.exceptions.aborts.TagCheckFault"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/TagCheckFault</h3><p class="pseudocode">// TagCheckFault()
// ===============
// Raise a tag check fail exception.

<a id="impl-aarch64.TagCheckFault.2" name="impl-aarch64.TagCheckFault.2"></a>TagCheckFault(bits(64) va, boolean write)
    bits(2) target_el;
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    integer vect_offset = 0x0;

    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        target_el = if HCR_EL2.TGE == 0 then <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> else <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    else
        target_el = PSTATE.EL;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_DataAbort</a>);
    exception.syndrome&lt;5:0> = '010001';
    if write then
        exception.syndrome&lt;6> = '1';
    exception.vaddress = va;

    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</p></div><div class="ps" psname="aarch32.exceptions.asynch.AArch32.TakePhysicalFIQException"><a id="aarch32.exceptions.asynch.AArch32.TakePhysicalFIQException" name="aarch32.exceptions.asynch.AArch32.TakePhysicalFIQException"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/asynch/AArch32.TakePhysicalFIQException</h3><p class="pseudocode">// AArch32.TakePhysicalFIQException()
// ==================================

<a id="AArch32.TakePhysicalFIQException.0" name="AArch32.TakePhysicalFIQException.0"></a>AArch32.TakePhysicalFIQException()

    // Check if routed to AArch64 state
    route_to_aarch64 = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);
    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        route_to_aarch64 = HCR_EL2.TGE == '1' || (HCR_EL2.FMO == '1' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>());

    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        route_to_aarch64 = SCR_EL3.FIQ == '1';

    if route_to_aarch64 then <a href="shared_pseudocode.html#AArch64.TakePhysicalFIQException.0" title="function: AArch64.TakePhysicalFIQException()">AArch64.TakePhysicalFIQException</a>();
    route_to_monitor = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR.FIQ == '1';
    route_to_hyp = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>,<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp;
                    (HCR.TGE == '1' || HCR.FMO == '1'));
    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x1C;
    lr_offset = 4;
    if route_to_monitor then
        <a href="shared_pseudocode.html#AArch32.EnterMonitorMode.3" title="function: AArch32.EnterMonitorMode(bits(32) preferred_exception_return, integer lr_offset, integer vect_offset)">AArch32.EnterMonitorMode</a>(preferred_exception_return, lr_offset, vect_offset);
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_hyp then
        exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_FIQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_FIQ</a>);
        <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return, integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch32.EnterMode.4" title="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset, integer vect_offset)">AArch32.EnterMode</a>(<a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a>, preferred_exception_return, lr_offset, vect_offset);</p></div><div class="ps" psname="aarch32.exceptions.asynch.AArch32.TakePhysicalIRQException"><a id="aarch32.exceptions.asynch.AArch32.TakePhysicalIRQException" name="aarch32.exceptions.asynch.AArch32.TakePhysicalIRQException"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/asynch/AArch32.TakePhysicalIRQException</h3><p class="pseudocode">// AArch32.TakePhysicalIRQException()
// ==================================
// Take an enabled physical IRQ exception.

<a id="AArch32.TakePhysicalIRQException.0" name="AArch32.TakePhysicalIRQException.0"></a>AArch32.TakePhysicalIRQException()

    // Check if routed to AArch64 state
    route_to_aarch64 = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);
    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        route_to_aarch64 = HCR_EL2.TGE == '1' || (HCR_EL2.IMO == '1' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>());
    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        route_to_aarch64 = SCR_EL3.IRQ == '1';

    if route_to_aarch64 then <a href="shared_pseudocode.html#AArch64.TakePhysicalIRQException.0" title="function: AArch64.TakePhysicalIRQException()">AArch64.TakePhysicalIRQException</a>();

    route_to_monitor = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR.IRQ == '1';
    route_to_hyp = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>,<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp;
                    (HCR.TGE == '1' || HCR.IMO == '1'));
    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x18;
    lr_offset = 4;
    if route_to_monitor then
        <a href="shared_pseudocode.html#AArch32.EnterMonitorMode.3" title="function: AArch32.EnterMonitorMode(bits(32) preferred_exception_return, integer lr_offset, integer vect_offset)">AArch32.EnterMonitorMode</a>(preferred_exception_return, lr_offset, vect_offset);
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_hyp then
        exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_IRQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_IRQ</a>);
        <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return, integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch32.EnterMode.4" title="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset, integer vect_offset)">AArch32.EnterMode</a>(<a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a>, preferred_exception_return, lr_offset, vect_offset);</p></div><div class="ps" psname="aarch32.exceptions.asynch.AArch32.TakePhysicalSErrorException"><a id="aarch32.exceptions.asynch.AArch32.TakePhysicalSErrorException" name="aarch32.exceptions.asynch.AArch32.TakePhysicalSErrorException"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/asynch/AArch32.TakePhysicalSErrorException</h3><p class="pseudocode">// AArch32.TakePhysicalSErrorException()
// =====================================

<a id="AArch32.TakePhysicalSErrorException.5" name="AArch32.TakePhysicalSErrorException.5"></a>AArch32.TakePhysicalSErrorException(boolean parity, bit extflag, bits(2) errortype,
                                         boolean impdef_syndrome, bits(24) full_syndrome)

    <a href="shared_pseudocode.html#impl-shared.ClearPendingPhysicalSError.0" title="function: ClearPendingPhysicalSError()">ClearPendingPhysicalSError</a>();
    // Check if routed to AArch64 state
    route_to_aarch64 = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);

    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        route_to_aarch64 = (HCR_EL2.TGE == '1' || (!<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() &amp;&amp; HCR_EL2.AMO == '1'));
    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        route_to_aarch64 = SCR_EL3.EA == '1';

    if route_to_aarch64 then
        <a href="shared_pseudocode.html#AArch64.TakePhysicalSErrorException.2" title="function: AArch64.TakePhysicalSErrorException(boolean impdef_syndrome, bits(24) syndrome)">AArch64.TakePhysicalSErrorException</a>(impdef_syndrome, full_syndrome);

    route_to_monitor = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR.EA == '1';
    route_to_hyp = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>,<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp;
                    (HCR.TGE == '1' || HCR.AMO == '1'));
    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x10;
    lr_offset = 8;

    fault = <a href="shared_pseudocode.html#AArch32.AsynchExternalAbort.3" title="function: FaultRecord AArch32.AsynchExternalAbort(boolean parity, bits(2) errortype, bit extflag)">AArch32.AsynchExternalAbort</a>(parity, errortype, extflag);
    vaddress = bits(32) UNKNOWN;
    if route_to_monitor then
        <a href="shared_pseudocode.html#AArch32.ReportDataAbort.3" title="function: AArch32.ReportDataAbort(boolean route_to_monitor, FaultRecord fault, bits(32) vaddress)">AArch32.ReportDataAbort</a>(route_to_monitor, fault, vaddress);
        <a href="shared_pseudocode.html#AArch32.EnterMonitorMode.3" title="function: AArch32.EnterMonitorMode(bits(32) preferred_exception_return, integer lr_offset, integer vect_offset)">AArch32.EnterMonitorMode</a>(preferred_exception_return, lr_offset, vect_offset);
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_hyp then
        exception = <a href="shared_pseudocode.html#AArch32.AbortSyndrome.3" title="function: ExceptionRecord AArch32.AbortSyndrome(Exception type, FaultRecord fault, bits(32) vaddress)">AArch32.AbortSyndrome</a>(<a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_DataAbort</a>, fault, vaddress);
        if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
            <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return, integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
        else
            <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return, integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, 0x14);
    else
        <a href="shared_pseudocode.html#AArch32.ReportDataAbort.3" title="function: AArch32.ReportDataAbort(boolean route_to_monitor, FaultRecord fault, bits(32) vaddress)">AArch32.ReportDataAbort</a>(route_to_monitor, fault, vaddress);
        <a href="shared_pseudocode.html#AArch32.EnterMode.4" title="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset, integer vect_offset)">AArch32.EnterMode</a>(<a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a>, preferred_exception_return, lr_offset, vect_offset);</p></div><div class="ps" psname="aarch32.exceptions.asynch.AArch32.TakeVirtualFIQException"><a id="aarch32.exceptions.asynch.AArch32.TakeVirtualFIQException" name="aarch32.exceptions.asynch.AArch32.TakeVirtualFIQException"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/asynch/AArch32.TakeVirtualFIQException</h3><p class="pseudocode">// AArch32.TakeVirtualFIQException()
// =================================

<a id="AArch32.TakeVirtualFIQException.0" name="AArch32.TakeVirtualFIQException.0"></a>AArch32.TakeVirtualFIQException()
    assert <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>,<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};
    if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then  // Virtual IRQ enabled if TGE==0 and FMO==1
        assert HCR.TGE == '0' &amp;&amp; HCR.FMO == '1';
    else
        assert HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.FMO == '1';
    // Check if routed to AArch64 state
    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then <a href="shared_pseudocode.html#AArch64.TakeVirtualFIQException.0" title="function: AArch64.TakeVirtualFIQException()">AArch64.TakeVirtualFIQException</a>();

    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x1C;
    lr_offset = 4;

    <a href="shared_pseudocode.html#AArch32.EnterMode.4" title="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset, integer vect_offset)">AArch32.EnterMode</a>(<a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a>, preferred_exception_return, lr_offset, vect_offset);</p></div><div class="ps" psname="aarch32.exceptions.asynch.AArch32.TakeVirtualIRQException"><a id="aarch32.exceptions.asynch.AArch32.TakeVirtualIRQException" name="aarch32.exceptions.asynch.AArch32.TakeVirtualIRQException"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/asynch/AArch32.TakeVirtualIRQException</h3><p class="pseudocode">// AArch32.TakeVirtualIRQException()
// =================================

<a id="AArch32.TakeVirtualIRQException.0" name="AArch32.TakeVirtualIRQException.0"></a>AArch32.TakeVirtualIRQException()
    assert <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>,<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then   // Virtual IRQs enabled if TGE==0 and IMO==1
        assert HCR.TGE == '0' &amp;&amp; HCR.IMO == '1';
    else
        assert HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.IMO == '1';

    // Check if routed to AArch64 state
    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then <a href="shared_pseudocode.html#AArch64.TakeVirtualIRQException.0" title="function: AArch64.TakeVirtualIRQException()">AArch64.TakeVirtualIRQException</a>();

    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x18;
    lr_offset = 4;

    <a href="shared_pseudocode.html#AArch32.EnterMode.4" title="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset, integer vect_offset)">AArch32.EnterMode</a>(<a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a>, preferred_exception_return, lr_offset, vect_offset);</p></div><div class="ps" psname="aarch32.exceptions.asynch.AArch32.TakeVirtualSErrorException"><a id="aarch32.exceptions.asynch.AArch32.TakeVirtualSErrorException" name="aarch32.exceptions.asynch.AArch32.TakeVirtualSErrorException"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/asynch/AArch32.TakeVirtualSErrorException</h3><p class="pseudocode">// AArch32.TakeVirtualSErrorException()
// ====================================

<a id="AArch32.TakeVirtualSErrorException.4" name="AArch32.TakeVirtualSErrorException.4"></a>AArch32.TakeVirtualSErrorException(bit extflag, bits(2) errortype, boolean impdef_syndrome, bits(24) full_syndrome)

    assert <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>,<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};
    if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then   // Virtual SError enabled if TGE==0 and AMO==1
        assert HCR.TGE == '0' &amp;&amp; HCR.AMO == '1';
    else
        assert HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.AMO == '1';
    // Check if routed to AArch64 state
    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then <a href="shared_pseudocode.html#AArch64.TakeVirtualSErrorException.2" title="function: AArch64.TakeVirtualSErrorException(boolean impdef_syndrome, bits(24) syndrome)">AArch64.TakeVirtualSErrorException</a>(impdef_syndrome, full_syndrome);

    route_to_monitor = FALSE;

    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x10;
    lr_offset = 8;

    vaddress = bits(32) UNKNOWN;
    parity = FALSE;
    if <a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() then
        if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
            fault = <a href="shared_pseudocode.html#AArch32.AsynchExternalAbort.3" title="function: FaultRecord AArch32.AsynchExternalAbort(boolean parity, bits(2) errortype, bit extflag)">AArch32.AsynchExternalAbort</a>(FALSE, VDFSR.AET, VDFSR.ExT);
        else
            fault = <a href="shared_pseudocode.html#AArch32.AsynchExternalAbort.3" title="function: FaultRecord AArch32.AsynchExternalAbort(boolean parity, bits(2) errortype, bit extflag)">AArch32.AsynchExternalAbort</a>(FALSE, VSESR_EL2.AET, VSESR_EL2.ExT);
    else
        fault = <a href="shared_pseudocode.html#AArch32.AsynchExternalAbort.3" title="function: FaultRecord AArch32.AsynchExternalAbort(boolean parity, bits(2) errortype, bit extflag)">AArch32.AsynchExternalAbort</a>(parity, errortype, extflag);

    <a href="shared_pseudocode.html#impl-shared.ClearPendingVirtualSError.0" title="function: ClearPendingVirtualSError()">ClearPendingVirtualSError</a>();
    <a href="shared_pseudocode.html#AArch32.ReportDataAbort.3" title="function: AArch32.ReportDataAbort(boolean route_to_monitor, FaultRecord fault, bits(32) vaddress)">AArch32.ReportDataAbort</a>(route_to_monitor, fault, vaddress);
    <a href="shared_pseudocode.html#AArch32.EnterMode.4" title="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset, integer vect_offset)">AArch32.EnterMode</a>(<a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a>, preferred_exception_return, lr_offset, vect_offset);</p></div><div class="ps" psname="aarch32.exceptions.debug.AArch32.SoftwareBreakpoint"><a id="aarch32.exceptions.debug.AArch32.SoftwareBreakpoint" name="aarch32.exceptions.debug.AArch32.SoftwareBreakpoint"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/debug/AArch32.SoftwareBreakpoint</h3><p class="pseudocode">// AArch32.SoftwareBreakpoint()
// ============================

<a id="AArch32.SoftwareBreakpoint.1" name="AArch32.SoftwareBreakpoint.1"></a>AArch32.SoftwareBreakpoint(bits(16) immediate)

    if (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp;
        (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1')) || !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        <a href="shared_pseudocode.html#AArch64.SoftwareBreakpoint.1" title="function: AArch64.SoftwareBreakpoint(bits(16) immediate)">AArch64.SoftwareBreakpoint</a>(immediate);
    vaddress = bits(32) UNKNOWN;
    acctype = <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType_IFETCH</a>;           // Take as a Prefetch Abort
    iswrite = FALSE;
    entry = <a href="shared_pseudocode.html#DebugException_BKPT" title="constant bits(4) DebugException_BKPT = '0011'">DebugException_BKPT</a>;

    fault = <a href="shared_pseudocode.html#AArch32.DebugFault.3" title="function: FaultRecord AArch32.DebugFault(AccType acctype, boolean iswrite, bits(4) debugmoe)">AArch32.DebugFault</a>(acctype, iswrite, entry);
    <a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(vaddress, fault);</p></div><div class="ps" psname="aarch32.exceptions.debug.DebugException"><a id="aarch32.exceptions.debug.DebugException" name="aarch32.exceptions.debug.DebugException"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/debug/DebugException</h3><p class="pseudocode">constant bits(4) <a id="DebugException_Breakpoint" name="DebugException_Breakpoint"></a>DebugException_Breakpoint  = '0001';
constant bits(4) <a id="DebugException_BKPT" name="DebugException_BKPT"></a>DebugException_BKPT        = '0011';
constant bits(4) <a id="DebugException_VectorCatch" name="DebugException_VectorCatch"></a>DebugException_VectorCatch = '0101';
constant bits(4) <a id="DebugException_Watchpoint" name="DebugException_Watchpoint"></a>DebugException_Watchpoint  = '1010';</p></div><div class="ps" psname="aarch32.exceptions.exceptions.AArch32.CheckAdvSIMDOrFPRegisterTraps"><a id="aarch32.exceptions.exceptions.AArch32.CheckAdvSIMDOrFPRegisterTraps" name="aarch32.exceptions.exceptions.AArch32.CheckAdvSIMDOrFPRegisterTraps"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/exceptions/AArch32.CheckAdvSIMDOrFPRegisterTraps</h3><p class="pseudocode">// AArch32.CheckAdvSIMDOrFPRegisterTraps()
// =======================================
// Check if an instruction that accesses an Advanced SIMD and
// floating-point System register is trapped by an appropriate HCR.TIDx
// ID group trap control.

<a id="AArch32.CheckAdvSIMDOrFPRegisterTraps.1" name="AArch32.CheckAdvSIMDOrFPRegisterTraps.1"></a>AArch32.CheckAdvSIMDOrFPRegisterTraps(bits(4) reg)

    if PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        tid0 = if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then HCR.TID0 else HCR_EL2.TID0;
        tid3 = if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then HCR.TID3 else HCR_EL2.TID3;

        if (tid0 == '1' &amp;&amp; reg == '0000')                             // FPSID
          || (tid3 == '1' &amp;&amp; reg IN {'0101', '0110', '0111'}) then    // MVFRx
            if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
                <a href="shared_pseudocode.html#AArch32.SystemAccessTrap.2" title="function: AArch32.SystemAccessTrap(bits(5) mode, integer ec)"><ins>AArch32.SystemAccessTrap</ins></a><a href="shared_pseudocode.html#AArch32.AArch32SystemAccessTrap.2" title="function: AArch32.AArch32SystemAccessTrap(bits(2) target_el, bits(32) instr)"><del>AArch32.AArch32SystemAccessTrap</del></a>(<a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'"><ins>M32_Hyp</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>, 0x8);               // Exception_AdvSIMDFPAccessTrap
            else</ins><del>,</del>
                <a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()"><del>ThisInstr</del></a><del>());
            else
                </del><a href="shared_pseudocode.html#AArch64.AArch32SystemAccessTrap.2" title="function: AArch64.AArch32SystemAccessTrap(bits(2) target_el, integer ec)">AArch64.AArch32SystemAccessTrap</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a><del>, </del><a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()"><del>ThisInstr</del></a><ins>, 0x8);            // Exception_AdvSIMDFPAccessTrap</ins><del>());</del></p></div><div class="ps" psname="aarch32.exceptions.exceptions.AArch32.ExceptionClass"><a id="aarch32.exceptions.exceptions.AArch32.ExceptionClass" name="aarch32.exceptions.exceptions.AArch32.ExceptionClass"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/exceptions/AArch32.ExceptionClass</h3><p class="pseudocode">// AArch32.ExceptionClass()
// ========================
<ins>// Returns the Exception Class and Instruction Length fields to be reported in HSR
</ins><del>// Return the Exception Class and Instruction Length fields for reported in HSR
</del>
(integer,bit) <a id="AArch32.ExceptionClass.1" name="AArch32.ExceptionClass.1"></a>AArch32.ExceptionClass(<a href="shared_pseudocode.html#Exception" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception</a> type)

    il = if <a href="shared_pseudocode.html#impl-shared.ThisInstrLength.0" title="function: integer ThisInstrLength()">ThisInstrLength</a>() == 32 then '1' else '0';

    case type of
        when <a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_Uncategorized</a>        ec = 0x00; il = '1';
        when <a href="shared_pseudocode.html#Exception_WFxTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_WFxTrap</a>              ec = 0x01;
        when <a href="shared_pseudocode.html#Exception_CP15RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_CP15RTTrap</a>           ec = 0x03;
        when <a href="shared_pseudocode.html#Exception_CP15RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_CP15RRTTrap</a>          ec = 0x04;
        when <a href="shared_pseudocode.html#Exception_CP14RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_CP14RTTrap</a>           ec = 0x05;
        when <a href="shared_pseudocode.html#Exception_CP14DTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_CP14DTTrap</a>           ec = 0x06;
        when <a href="shared_pseudocode.html#Exception_AdvSIMDFPAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_AdvSIMDFPAccessTrap</a>  ec = 0x07;
        when <a href="shared_pseudocode.html#Exception_FPIDTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_FPIDTrap</a>             ec = 0x08;
        when <a href="shared_pseudocode.html#Exception_PACTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_PACTrap</a>              ec = 0x09;
        when <a href="shared_pseudocode.html#Exception_CP14RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_CP14RRTTrap</a>          ec = 0x0C;
        when <a href="shared_pseudocode.html#Exception_BranchTarget" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_BranchTarget</a>         ec = 0x0D;
        when <a href="shared_pseudocode.html#Exception_IllegalState" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_IllegalState</a>         ec = 0x0E; il = '1';
        when <a href="shared_pseudocode.html#Exception_SupervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_SupervisorCall</a>       ec = 0x11;
        when <a href="shared_pseudocode.html#Exception_HypervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_HypervisorCall</a>       ec = 0x12;
        when <a href="shared_pseudocode.html#Exception_MonitorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_MonitorCall</a>          ec = 0x13;
        when <a href="shared_pseudocode.html#Exception_ERetTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_ERetTrap</a>             ec = 0x1A;
        when <a href="shared_pseudocode.html#Exception_InstructionAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_InstructionAbort</a>     ec = 0x20; il = '1';
        when <a href="shared_pseudocode.html#Exception_PCAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_PCAlignment</a>          ec = 0x22; il = '1';
        when <a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_DataAbort</a>            ec = 0x24;
        when <a href="shared_pseudocode.html#Exception_NV2DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_NV2DataAbort</a>         ec = 0x25;
        when <a href="shared_pseudocode.html#Exception_FPTrappedException" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_FPTrappedException</a>   ec = 0x28;
        otherwise                           <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    if ec IN {0x20,0x24} &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        ec = ec + 1;

    return (ec,il);</p></div><div class="ps" psname="aarch32.exceptions.exceptions.AArch32.GeneralExceptionsToAArch64"><a id="aarch32.exceptions.exceptions.AArch32.GeneralExceptionsToAArch64" name="aarch32.exceptions.exceptions.AArch32.GeneralExceptionsToAArch64"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/exceptions/AArch32.GeneralExceptionsToAArch64</h3><p class="pseudocode">// AArch32.GeneralExceptionsToAArch64()
// ====================================
// Returns TRUE if exceptions normally routed to EL1 are being handled at an Exception
// level using AArch64, because either EL1 is using AArch64 or TGE is in force and EL2
// is using AArch64.

boolean <a id="AArch32.GeneralExceptionsToAArch64.0" name="AArch32.GeneralExceptionsToAArch64.0"></a>AArch32.GeneralExceptionsToAArch64()
    return ((PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>)) ||
            (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; HCR_EL2.TGE == '1'));</p></div><div class="ps" psname="aarch32.exceptions.exceptions.AArch32.ReportHypEntry"><a id="aarch32.exceptions.exceptions.AArch32.ReportHypEntry" name="aarch32.exceptions.exceptions.AArch32.ReportHypEntry"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/exceptions/AArch32.ReportHypEntry</h3><p class="pseudocode">// AArch32.ReportHypEntry()
// ========================
// Report syndrome information to Hyp mode registers.

<a id="AArch32.ReportHypEntry.1" name="AArch32.ReportHypEntry.1"></a>AArch32.ReportHypEntry(<a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is (Exception type, bits(25) syndrome, bits(64) vaddress, boolean ipavalid, bits(1) NS, bits(52) ipaddress)">ExceptionRecord</a> exception)

    <a href="shared_pseudocode.html#Exception" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception</a> type = exception.type;

    (ec,il) = <a href="shared_pseudocode.html#AArch32.ExceptionClass.1" title="function: (integer,bit) AArch32.ExceptionClass(Exception type)">AArch32.ExceptionClass</a>(type);
    iss = exception.syndrome;

    // IL is not valid for Data Abort exceptions without valid instruction syndrome information
    if ec IN {0x24,0x25} &amp;&amp; iss&lt;24> == '0' then
        il = '1';

    HSR = ec&lt;5:0>:il:iss;

    if type IN {<a href="shared_pseudocode.html#Exception_InstructionAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_InstructionAbort</a>, <a href="shared_pseudocode.html#Exception_PCAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_PCAlignment</a>} then
        HIFAR = exception.vaddress&lt;31:0>;
        HDFAR = bits(32) UNKNOWN;
    elsif type == <a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_DataAbort</a> then
        HIFAR = bits(32) UNKNOWN;
        HDFAR = exception.vaddress&lt;31:0>;

    if exception.ipavalid then
        HPFAR&lt;31:4> = exception.ipaddress&lt;39:12>;
    else
        HPFAR&lt;31:4> = bits(28) UNKNOWN;

    return;</p></div><div class="ps" psname="aarch32.exceptions.exceptions.AArch32.ResetControlRegisters"><a id="aarch32.exceptions.exceptions.AArch32.ResetControlRegisters" name="aarch32.exceptions.exceptions.AArch32.ResetControlRegisters"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/exceptions/AArch32.ResetControlRegisters</h3><p class="pseudocode">// Resets System registers and memory-mapped control registers that have architecturally-defined
// reset values to those values.
<a id="AArch32.ResetControlRegisters.1" name="AArch32.ResetControlRegisters.1"></a>AArch32.ResetControlRegisters(boolean cold_reset);</p></div><div class="ps" psname="aarch32.exceptions.exceptions.AArch32.TakeReset"><a id="aarch32.exceptions.exceptions.AArch32.TakeReset" name="aarch32.exceptions.exceptions.AArch32.TakeReset"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/exceptions/AArch32.TakeReset</h3><p class="pseudocode">// AArch32.TakeReset()
// ===================
// Reset into AArch32 state

<a id="AArch32.TakeReset.1" name="AArch32.TakeReset.1"></a>AArch32.TakeReset(boolean cold_reset)
    assert <a href="shared_pseudocode.html#impl-shared.HighestELUsingAArch32.0" title="function: boolean HighestELUsingAArch32()">HighestELUsingAArch32</a>();

    // Enter the highest implemented Exception level in AArch32 state
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'">M32_Svc</a>);
        SCR.NS = '0';                     // Secure state
    elsif <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>);
    else
        <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'">M32_Svc</a>);

    // Reset the CP14 and CP15 registers and other system components
    <a href="shared_pseudocode.html#AArch32.ResetControlRegisters.1" title="function: AArch32.ResetControlRegisters(boolean cold_reset)">AArch32.ResetControlRegisters</a>(cold_reset);
    FPEXC.EN = '0';

    // Reset all other PSTATE fields, including instruction set and endianness according to the
    // SCTLR values produced by the above call to ResetControlRegisters()
    PSTATE.&lt;A,I,F> = '111';       // All asynchronous exceptions masked
    PSTATE.IT = '00000000';       // IT block state reset
    PSTATE.T = SCTLR.TE;          // Instruction set: TE=0: A32, TE=1: T32. PSTATE.J is RES0.
    PSTATE.E = SCTLR.EE;          // Endianness: EE=0: little-endian, EE=1: big-endian
    PSTATE.IL = '0';              // Clear Illegal Execution state bit

    // All registers, bits and fields not reset by the above pseudocode or by the BranchTo() call
    // below are UNKNOWN bitstrings after reset. In particular, the return information registers
    // R14 or ELR_hyp and SPSR have UNKNOWN values, so that it
    // is impossible to return from a reset in an architecturally defined way.
    <a href="shared_pseudocode.html#AArch32.ResetGeneralRegisters.0" title="function: AArch32.ResetGeneralRegisters()">AArch32.ResetGeneralRegisters</a>();
    <a href="shared_pseudocode.html#AArch32.ResetSIMDFPRegisters.0" title="function: AArch32.ResetSIMDFPRegisters()">AArch32.ResetSIMDFPRegisters</a>();
    <a href="shared_pseudocode.html#AArch32.ResetSpecialRegisters.0" title="function: AArch32.ResetSpecialRegisters()">AArch32.ResetSpecialRegisters</a>();
    <a href="shared_pseudocode.html#impl-shared.ResetExternalDebugRegisters.1" title="function: ResetExternalDebugRegisters(boolean cold_reset)">ResetExternalDebugRegisters</a>(cold_reset);

    bits(32) rv;                      // IMPLEMENTATION DEFINED reset vector

    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        if MVBAR&lt;0> == '1' then           // Reset vector in MVBAR
            rv = MVBAR&lt;31:1>:'0';
        else
            rv = bits(32) IMPLEMENTATION_DEFINED "reset vector address";
    else
        rv = RVBAR&lt;31:1>:'0';

    // The reset vector must be correctly aligned
    assert rv&lt;0> == '0' &amp;&amp; (PSTATE.T == '1' || rv&lt;1> == '0');

    <a href="shared_pseudocode.html#impl-shared.BranchTo.2" title="function: BranchTo(bits(N) target, BranchType branch_type)">BranchTo</a>(rv, <a href="shared_pseudocode.html#BranchType_RESET" title="enumeration BranchType { BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType_RESET</a>);</p></div><div class="ps" psname="aarch32.exceptions.exceptions.ExcVectorBase"><a id="aarch32.exceptions.exceptions.ExcVectorBase" name="aarch32.exceptions.exceptions.ExcVectorBase"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/exceptions/ExcVectorBase</h3><p class="pseudocode">// ExcVectorBase()
// ===============

bits(32) <a id="impl-aarch32.ExcVectorBase.0" name="impl-aarch32.ExcVectorBase.0"></a>ExcVectorBase()
    if SCTLR.V == '1' then  // Hivecs selected, base = 0xFFFF0000
        return <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(16):<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16);
    else
        return VBAR&lt;31:5>:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(5);</p></div><div class="ps" psname="aarch32.exceptions.ieeefp.AArch32.FPTrappedException"><a id="aarch32.exceptions.ieeefp.AArch32.FPTrappedException" name="aarch32.exceptions.ieeefp.AArch32.FPTrappedException"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/ieeefp/AArch32.FPTrappedException</h3><p class="pseudocode">// AArch32.FPTrappedException()
// ============================

<a id="AArch32.FPTrappedException.1" name="AArch32.FPTrappedException.1"></a>AArch32.FPTrappedException(bits(8) accumulated_exceptions)
    if <a href="shared_pseudocode.html#AArch32.GeneralExceptionsToAArch64.0" title="function: boolean AArch32.GeneralExceptionsToAArch64()">AArch32.GeneralExceptionsToAArch64</a>() then
        is_ase = FALSE;
        element = 0;
        <a href="shared_pseudocode.html#AArch64.FPTrappedException.3" title="function: AArch64.FPTrappedException(boolean is_ase, integer element, bits(8) accumulated_exceptions)">AArch64.FPTrappedException</a>(is_ase, element, accumulated_exceptions);
    FPEXC.DEX    = '1';
    FPEXC.TFV    = '1';
    FPEXC&lt;7,4:0> = accumulated_exceptions&lt;7,4:0>;                  // IDF,IXF,UFF,OFF,DZF,IOF
    FPEXC&lt;10:8>  = '111';                                          // VECITR is RES1

    <a href="shared_pseudocode.html#AArch32.TakeUndefInstrException.0" title="function: AArch32.TakeUndefInstrException()">AArch32.TakeUndefInstrException</a>();</p></div><div class="ps" psname="aarch32.exceptions.syscalls.AArch32.CallHypervisor"><a id="aarch32.exceptions.syscalls.AArch32.CallHypervisor" name="aarch32.exceptions.syscalls.AArch32.CallHypervisor"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/syscalls/AArch32.CallHypervisor</h3><p class="pseudocode">// AArch32.CallHypervisor()
// ========================
// Performs a HVC call

<a id="AArch32.CallHypervisor.1" name="AArch32.CallHypervisor.1"></a>AArch32.CallHypervisor(bits(16) immediate)
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);

    if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        <a href="shared_pseudocode.html#AArch64.CallHypervisor.1" title="function: AArch64.CallHypervisor(bits(16) immediate)">AArch64.CallHypervisor</a>(immediate);
    else
        <a href="shared_pseudocode.html#AArch32.TakeHVCException.1" title="function: AArch32.TakeHVCException(bits(16) immediate)">AArch32.TakeHVCException</a>(immediate);</p></div><div class="ps" psname="aarch32.exceptions.syscalls.AArch32.CallSupervisor"><a id="aarch32.exceptions.syscalls.AArch32.CallSupervisor" name="aarch32.exceptions.syscalls.AArch32.CallSupervisor"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/syscalls/AArch32.CallSupervisor</h3><p class="pseudocode">// AArch32.CallSupervisor()
// ========================
// Calls the Supervisor

<a id="AArch32.CallSupervisor.1" name="AArch32.CallSupervisor.1"></a>AArch32.CallSupervisor(bits(16) immediate)

    if <a href="shared_pseudocode.html#AArch32.CurrentCond.0" title="function: bits(4) AArch32.CurrentCond()">AArch32.CurrentCond</a>() != '1110' then
        immediate = bits(16) UNKNOWN;
    if <a href="shared_pseudocode.html#AArch32.GeneralExceptionsToAArch64.0" title="function: boolean AArch32.GeneralExceptionsToAArch64()">AArch32.GeneralExceptionsToAArch64</a>() then
        <a href="shared_pseudocode.html#AArch64.CallSupervisor.1" title="function: AArch64.CallSupervisor(bits(16) immediate)">AArch64.CallSupervisor</a>(immediate);
    else
        <a href="shared_pseudocode.html#AArch32.TakeSVCException.1" title="function: AArch32.TakeSVCException(bits(16) immediate)">AArch32.TakeSVCException</a>(immediate);</p></div><div class="ps" psname="aarch32.exceptions.syscalls.AArch32.TakeHVCException"><a id="aarch32.exceptions.syscalls.AArch32.TakeHVCException" name="aarch32.exceptions.syscalls.AArch32.TakeHVCException"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/syscalls/AArch32.TakeHVCException</h3><p class="pseudocode">// AArch32.TakeHVCException()
// ==========================

<a id="AArch32.TakeHVCException.1" name="AArch32.TakeHVCException.1"></a>AArch32.TakeHVCException(bits(16) immediate)
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);

    <a href="shared_pseudocode.html#AArch32.ITAdvance.0" title="function: AArch32.ITAdvance()">AArch32.ITAdvance</a>();
    <a href="shared_pseudocode.html#impl-shared.SSAdvance.0" title="function: SSAdvance()">SSAdvance</a>();
    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.NextInstrAddr.0" title="function: bits(N) NextInstrAddr()">NextInstrAddr</a>();
    vect_offset = 0x08;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_HypervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_HypervisorCall</a>);
    exception.syndrome&lt;15:0> = immediate;

    if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return, integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return, integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, 0x14);</p></div><div class="ps" psname="aarch32.exceptions.syscalls.AArch32.TakeSMCException"><a id="aarch32.exceptions.syscalls.AArch32.TakeSMCException" name="aarch32.exceptions.syscalls.AArch32.TakeSMCException"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/syscalls/AArch32.TakeSMCException</h3><p class="pseudocode">// AArch32.TakeSMCException()
// ==========================

<a id="AArch32.TakeSMCException.0" name="AArch32.TakeSMCException.0"></a>AArch32.TakeSMCException()
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    <a href="shared_pseudocode.html#AArch32.ITAdvance.0" title="function: AArch32.ITAdvance()">AArch32.ITAdvance</a>();
    <a href="shared_pseudocode.html#impl-shared.SSAdvance.0" title="function: SSAdvance()">SSAdvance</a>();
    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.NextInstrAddr.0" title="function: bits(N) NextInstrAddr()">NextInstrAddr</a>();
    vect_offset = 0x08;
    lr_offset = 0;

    <a href="shared_pseudocode.html#AArch32.EnterMonitorMode.3" title="function: AArch32.EnterMonitorMode(bits(32) preferred_exception_return, integer lr_offset, integer vect_offset)">AArch32.EnterMonitorMode</a>(preferred_exception_return, lr_offset, vect_offset);</p></div><div class="ps" psname="aarch32.exceptions.syscalls.AArch32.TakeSVCException"><a id="aarch32.exceptions.syscalls.AArch32.TakeSVCException" name="aarch32.exceptions.syscalls.AArch32.TakeSVCException"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/syscalls/AArch32.TakeSVCException</h3><p class="pseudocode">// AArch32.TakeSVCException()
// ==========================

<a id="AArch32.TakeSVCException.1" name="AArch32.TakeSVCException.1"></a>AArch32.TakeSVCException(bits(16) immediate)

    <a href="shared_pseudocode.html#AArch32.ITAdvance.0" title="function: AArch32.ITAdvance()">AArch32.ITAdvance</a>();
    <a href="shared_pseudocode.html#impl-shared.SSAdvance.0" title="function: SSAdvance()">SSAdvance</a>();
    route_to_hyp = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; HCR.TGE == '1';

    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.NextInstrAddr.0" title="function: bits(N) NextInstrAddr()">NextInstrAddr</a>();
    vect_offset = 0x08;
    lr_offset = 0;

    if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_hyp then
        exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_SupervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_SupervisorCall</a>);
        exception.syndrome&lt;15:0> = immediate;
        if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
            <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return, integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
        else
            <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return, integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, 0x14);
    else
        <a href="shared_pseudocode.html#AArch32.EnterMode.4" title="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset, integer vect_offset)">AArch32.EnterMode</a>(<a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'">M32_Svc</a>, preferred_exception_return, lr_offset, vect_offset);</p></div><div class="ps" psname="aarch32.exceptions.takeexception.AArch32.EnterHypMode"><a id="aarch32.exceptions.takeexception.AArch32.EnterHypMode" name="aarch32.exceptions.takeexception.AArch32.EnterHypMode"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/takeexception/AArch32.EnterHypMode</h3><p class="pseudocode">// AArch32.EnterHypMode()
// ======================
// Take an exception to Hyp mode.

<a id="AArch32.EnterHypMode.3" name="AArch32.EnterHypMode.3"></a>AArch32.EnterHypMode(<a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is (Exception type, bits(25) syndrome, bits(64) vaddress, boolean ipavalid, bits(1) NS, bits(52) ipaddress)">ExceptionRecord</a> exception, bits(32) preferred_exception_return,
                     integer vect_offset)
    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()">SynchronizeContext</a>();
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);

    spsr = <a href="shared_pseudocode.html#impl-shared.GetPSRFromPSTATE.0" title="function: bits(32) GetPSRFromPSTATE()">GetPSRFromPSTATE</a>();
    if !(exception.type IN {<a href="shared_pseudocode.html#Exception_IRQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_IRQ</a>, <a href="shared_pseudocode.html#Exception_FIQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_FIQ</a>}) then
        <a href="shared_pseudocode.html#AArch32.ReportHypEntry.1" title="function: AArch32.ReportHypEntry(ExceptionRecord exception)">AArch32.ReportHypEntry</a>(exception);
    <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>);
    <a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(32) value">SPSR</a>[] = spsr;
    if <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = HSCTLR.DSSBS;
    ELR_hyp = preferred_exception_return;
    PSTATE.T = HSCTLR.TE;                       // PSTATE.J is RES0
    PSTATE.SS = '0';
    if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || <a href="shared_pseudocode.html#impl-shared.SCR_GEN.read.0" title="accessor: SCRType SCR_GEN[]">SCR_GEN</a>[].EA == '0' then PSTATE.A = '1';
    if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || <a href="shared_pseudocode.html#impl-shared.SCR_GEN.read.0" title="accessor: SCRType SCR_GEN[]">SCR_GEN</a>[].IRQ == '0' then PSTATE.I = '1';
    if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || <a href="shared_pseudocode.html#impl-shared.SCR_GEN.read.0" title="accessor: SCRType SCR_GEN[]">SCR_GEN</a>[].FIQ == '0' then PSTATE.F = '1';
    PSTATE.E = HSCTLR.EE;
    PSTATE.IL = '0';
    PSTATE.IT = '00000000';
    <a href="shared_pseudocode.html#impl-shared.BranchTo.2" title="function: BranchTo(bits(N) target, BranchType branch_type)">BranchTo</a>(HVBAR&lt;31:5>:vect_offset&lt;4:0>, <a href="shared_pseudocode.html#BranchType_EXCEPTION" title="enumeration BranchType { BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType_EXCEPTION</a>);

    <a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()">EndOfInstruction</a>();</p></div><div class="ps" psname="aarch32.exceptions.takeexception.AArch32.EnterMode"><a id="aarch32.exceptions.takeexception.AArch32.EnterMode" name="aarch32.exceptions.takeexception.AArch32.EnterMode"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/takeexception/AArch32.EnterMode</h3><p class="pseudocode">// AArch32.EnterMode()
// ===================
// Take an exception to a mode other than Monitor and Hyp mode.

<a id="AArch32.EnterMode.4" name="AArch32.EnterMode.4"></a>AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,
                  integer vect_offset)
    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()">SynchronizeContext</a>();
    assert <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; PSTATE.EL != <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;

    spsr = <a href="shared_pseudocode.html#impl-shared.GetPSRFromPSTATE.0" title="function: bits(32) GetPSRFromPSTATE()">GetPSRFromPSTATE</a>();
    if PSTATE.M == <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then SCR.NS = '0';
    <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(target_mode);
    <a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(32) value">SPSR</a>[] = spsr;
    if <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = SCTLR.DSSBS;
    <a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value">R</a>[14] = preferred_exception_return + lr_offset;
    PSTATE.T = SCTLR.TE;                        // PSTATE.J is RES0
    PSTATE.SS = '0';
    if target_mode == <a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a> then
        PSTATE.&lt;A,I,F> = '111';
    elsif target_mode IN {<a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a>, <a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a>} then
        PSTATE.&lt;A,I> = '11';
    else
        PSTATE.I = '1';
    PSTATE.E = SCTLR.EE;
    PSTATE.IL = '0';
    PSTATE.IT = '00000000';
    if <a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()">HavePANExt</a>() &amp;&amp; SCTLR.SPAN == '0' then
        PSTATE.PAN = '1';
    <a href="shared_pseudocode.html#impl-shared.BranchTo.2" title="function: BranchTo(bits(N) target, BranchType branch_type)">BranchTo</a>(<a href="shared_pseudocode.html#impl-aarch32.ExcVectorBase.0" title="function: bits(32) ExcVectorBase()">ExcVectorBase</a>()&lt;31:5>:vect_offset&lt;4:0>, <a href="shared_pseudocode.html#BranchType_EXCEPTION" title="enumeration BranchType { BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType_EXCEPTION</a>);

    <a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()">EndOfInstruction</a>();</p></div><div class="ps" psname="aarch32.exceptions.takeexception.AArch32.EnterMonitorMode"><a id="aarch32.exceptions.takeexception.AArch32.EnterMonitorMode" name="aarch32.exceptions.takeexception.AArch32.EnterMonitorMode"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/takeexception/AArch32.EnterMonitorMode</h3><p class="pseudocode">// AArch32.EnterMonitorMode()
// ==========================
// Take an exception to Monitor mode.

<a id="AArch32.EnterMonitorMode.3" name="AArch32.EnterMonitorMode.3"></a>AArch32.EnterMonitorMode(bits(32) preferred_exception_return, integer lr_offset,
                         integer vect_offset)
    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()">SynchronizeContext</a>();
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    from_secure = <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>();
    spsr = <a href="shared_pseudocode.html#impl-shared.GetPSRFromPSTATE.0" title="function: bits(32) GetPSRFromPSTATE()">GetPSRFromPSTATE</a>();
    if PSTATE.M == <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then SCR.NS = '0';
    <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>);
    <a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(32) value">SPSR</a>[] = spsr;
    if <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = SCTLR.DSSBS;
    <a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value">R</a>[14] = preferred_exception_return + lr_offset;
    PSTATE.T = SCTLR.TE;                        // PSTATE.J is RES0
    PSTATE.SS = '0';
    PSTATE.&lt;A,I,F> = '111';
    PSTATE.E = SCTLR.EE;
    PSTATE.IL = '0';
    PSTATE.IT = '00000000';
    if <a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()">HavePANExt</a>() then
        if !from_secure then
            PSTATE.PAN = '0';
        elsif SCTLR.SPAN == '0' then
            PSTATE.PAN = '1';
    <a href="shared_pseudocode.html#impl-shared.BranchTo.2" title="function: BranchTo(bits(N) target, BranchType branch_type)">BranchTo</a>(MVBAR&lt;31:5>:vect_offset&lt;4:0>, <a href="shared_pseudocode.html#BranchType_EXCEPTION" title="enumeration BranchType { BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}">BranchType_EXCEPTION</a>);

    <a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()">EndOfInstruction</a>();</p></div><div class="ps" psname="aarch32.exceptions.traps.AArch32.CheckAdvSIMDOrFPEnabled"><a id="aarch32.exceptions.traps.AArch32.CheckAdvSIMDOrFPEnabled" name="aarch32.exceptions.traps.AArch32.CheckAdvSIMDOrFPEnabled"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/<ins>AArch32.CheckAdvSIMDOrFPEnabled</ins><del>AArch32.AArch32SystemAccessTrap</del></h3><p class="pseudocode"><ins>// AArch32.CheckAdvSIMDOrFPEnabled()
</ins><del>// AArch32.AArch32SystemAccessTrap()
</del>// =================================
<ins>// Check against CPACR, FPEXC, HCPTR, NSACR, and CPTR_EL3.</ins><del>// Trapped AArch32 System register access other than due to CPTR_EL2 or CPACR_EL1.</del>

<a id="AArch32.CheckAdvSIMDOrFPEnabled.2" name="AArch32.CheckAdvSIMDOrFPEnabled.2"></a><ins>AArch32.CheckAdvSIMDOrFPEnabled(boolean fpexc_check, boolean advsimd)
    if PSTATE.EL ==</ins><del>AArch32.AArch32SystemAccessTrap(bits(2) target_el, bits(32) instr)
    assert</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins> &amp;&amp; (!</ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a><ins>(</ins><del>(target_el) &amp;&amp; target_el !=</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) || (!</ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) &amp;&amp; HCR_EL2.TGE == '0')) &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>) then
        // The PE behaves as if FPEXC.EN is 1
        </ins><a href="shared_pseudocode.html#AArch64.CheckFPAdvSIMDEnabled.0" title="function: AArch64.CheckFPAdvSIMDEnabled()"><ins>AArch64.CheckFPAdvSIMDEnabled</ins></a><ins>();
    elsif PSTATE.EL == </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>(</ins><del>(target_el) >=</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>) &amp;&amp; !</ins><del>(PSTATE.EL);

    if !</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a><ins>(</ins><del>(target_el) ||</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#AArch32.GeneralExceptionsToAArch64.0" title="function: boolean AArch32.GeneralExceptionsToAArch64()"><del>AArch32.GeneralExceptionsToAArch64</del></a><ins>) &amp;&amp; HCR_EL2.TGE == '1' &amp;&amp; !</ins><del>() then</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><a href="shared_pseudocode.html#AArch64.AArch32SystemAccessTrap.2" title="function: AArch64.AArch32SystemAccessTrap(bits(2) target_el, bits(32) aarch32_instr)"><del>AArch64.AArch32SystemAccessTrap</del></a><ins>(</ins><del>(target_el, instr);

    assert target_el IN {</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a><ins>) then
        if fpexc_check &amp;&amp; HCR_EL2.RW == '0' then
            fpexc_en = bits(1) IMPLEMENTATION_DEFINED "FPEXC.EN value when TGE==1 and RW==0";
            if fpexc_en == '0' then UNDEFINED;</ins><del>,</del>
        <a href="shared_pseudocode.html#AArch64.CheckFPAdvSIMDEnabled.0" title="function: AArch64.CheckFPAdvSIMDEnabled()"><ins>AArch64.CheckFPAdvSIMDEnabled</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>();
    else
        cpacr_asedis = CPACR.ASEDIS;
        cpacr_cp10 = CPACR.cp10;
</ins><del>};
</del>
<ins>        if</ins><del>    if target_el ==</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>() then
            // Check if access disabled in NSACR
            if NSACR.NSASEDIS == '1' then cpacr_asedis = '1';
            if NSACR.cp10 == '0' then cpacr_cp10 = '00';

        if PSTATE.EL != </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
<ins>            // Check if Advanced SIMD disabled in CPACR
            if advsimd &amp;&amp; cpacr_asedis == '1' then UNDEFINED;

            if cpacr_cp10 == '10' then
                (c, cpacr_cp10) =</ins><del>        exception =</del> <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)"><ins>ConstrainUnpredictableBits</ins></a><a href="shared_pseudocode.html#AArch32.AArch32SystemAccessTrapSyndrome.1" title="function: ExceptionRecord AArch32.AArch32SystemAccessTrapSyndrome(bits(32) instr)"><del>AArch32.AArch32SystemAccessTrapSyndrome</del></a><ins>(</ins><del>(instr);</del><a href="shared_pseudocode.html#Unpredictable_RESCPACR" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESCPACR</ins></a><a href="shared_pseudocode.html#AArch32.TakeHypTrapException.1" title="function: AArch32.TakeHypTrapException(ExceptionRecord exception)"><del>AArch32.TakeHypTrapException</del></a><ins>);

            // Check if access disabled in CPACR
            case cpacr_cp10 of
                when '00'  disabled = TRUE;
                when '01'  disabled = PSTATE.EL ==</ins><del>(exception);
    else</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#AArch32.TakeUndefInstrException.0" title="function: AArch32.TakeUndefInstrException()"><del>AArch32.TakeUndefInstrException</del></a><ins>;
                when '11'  disabled = FALSE;
            if disabled then UNDEFINED;

        // If required, check FPEXC enabled bit.
        if fpexc_check &amp;&amp; FPEXC.EN == '0' then UNDEFINED;

        </ins><a href="shared_pseudocode.html#AArch32.CheckFPAdvSIMDTrap.1" title="function: AArch32.CheckFPAdvSIMDTrap(boolean advsimd)"><ins>AArch32.CheckFPAdvSIMDTrap</ins></a><ins>(advsimd);    // Also check against HCPTR and CPTR_EL3</ins><del>();</del></p></div><div class="ps" psname="aarch32.exceptions.traps.AArch32.CheckFPAdvSIMDTrap"><a id="aarch32.exceptions.traps.AArch32.CheckFPAdvSIMDTrap" name="aarch32.exceptions.traps.AArch32.CheckFPAdvSIMDTrap"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/<ins>AArch32.CheckFPAdvSIMDTrap</ins><del>AArch32.AArch32SystemAccessTrapSyndrome</del></h3><p class="pseudocode"><ins>// AArch32.CheckFPAdvSIMDTrap()
// ============================
// Check against CPTR_EL2 and CPTR_EL3.</ins><del>// AArch32.AArch32SystemAccessTrapSyndrome()
// =========================================
// Return the syndrome information for traps on AArch32 MCR, MCRR, MRC, MRRC, and VMRS instructions,
// other than traps that are due to HCPTR or CPACR.

ExceptionRecord</del>

<a id="AArch32.CheckFPAdvSIMDTrap.1" name="AArch32.CheckFPAdvSIMDTrap.1"></a><ins>AArch32.CheckFPAdvSIMDTrap(boolean advsimd)
    if</ins><del>AArch32.AArch32SystemAccessTrapSyndrome(bits(32) instr)</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is (Exception type, bits(25) syndrome, bits(64) vaddress, boolean ipavalid, bits(1) NS, bits(52) ipaddress)"><del>ExceptionRecord</del></a><ins>() &amp;&amp; !</ins><del>exception;
    cpnum =</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>(</ins><del>(instr&lt;11:8>);

    bits(20) iss =</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><del>Zeros</del></a><ins>) then</ins><del>();
    if instr&lt;27:24> == '1110' &amp;&amp; instr&lt;4> == '1' &amp;&amp; instr&lt;31:28> != '1111' then
        // MRC/MCR
        case cpnum of
            when 10    exception =</del>
        <a href="shared_pseudocode.html#AArch64.CheckFPAdvSIMDTrap.0" title="function: AArch64.CheckFPAdvSIMDTrap()"><ins>AArch64.CheckFPAdvSIMDTrap</ins></a><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a><ins>();
    else
        if</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#Exception_FPIDTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_FPIDTrap</del></a><ins>(</ins><del>);
            when 14    exception =</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a><ins>) &amp;&amp; !</ins><del>(</del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><a href="shared_pseudocode.html#Exception_CP14RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_CP14RTTrap</del></a><ins>() then
            hcptr_tase = HCPTR.TASE;
            hcptr_cp10 = HCPTR.TCP10;

            if</ins><del>);
            when 15    exception =</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#Exception_CP15RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_CP15RTTrap</del></a><ins>) &amp;&amp;</ins><del>);
            otherwise</del> <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><del>Unreachable</del></a><ins>(</ins><del>();
        iss&lt;19:17> = instr&lt;7:5>;      // opc2
        iss&lt;16:14> = instr&lt;23:21>;    // opc1
        iss&lt;13:10> = instr&lt;19:16>;    // CRn
        iss&lt;8:5>   = instr&lt;15:12>;    // Rt
        iss&lt;4:1>   = instr&lt;3:0>;      // CRm
    elsif instr&lt;27:21> == '1100010' &amp;&amp; instr&lt;31:28> != '1111' then
        // MRRC/MCRR
        case cpnum of
            when 14    exception =</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a><ins>) &amp;&amp; !</ins><del>(</del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><a href="shared_pseudocode.html#Exception_CP14RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_CP14RRTTrap</del></a><ins>() then
                // Check if access disabled in NSACR
                if NSACR.NSASEDIS == '1' then hcptr_tase = '1';
                if NSACR.cp10 == '0' then hcptr_cp10 = '1';

            // Check if access disabled in HCPTR
            if (advsimd &amp;&amp; hcptr_tase == '1') || hcptr_cp10 == '1' then
                exception =</ins><del>);
            when 15    exception =</del> <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_AdvSIMDFPAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_AdvSIMDFPAccessTrap</ins></a><a href="shared_pseudocode.html#Exception_CP15RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_CP15RRTTrap</del></a>);
<ins>                exception.syndrome&lt;24:20> =</ins><del>            otherwise</del> <a href="shared_pseudocode.html#impl-shared.ConditionSyndrome.0" title="function: bits(5) ConditionSyndrome()"><ins>ConditionSyndrome</ins></a><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><del>Unreachable</del></a>();
<ins>
                if advsimd then
                    exception.syndrome&lt;5> = '1';
                else
                    exception.syndrome&lt;5> = '0';
                    exception.syndrome&lt;3:0> = '1010';         // coproc field, always 0xA

                if PSTATE.EL ==</ins><del>        iss&lt;19:16> = instr&lt;7:4>;      // opc1
        iss&lt;13:10> = instr&lt;19:16>;    // Rt2
        iss&lt;8:5>   = instr&lt;15:12>;    // Rt
        iss&lt;4:1>   = instr&lt;3:0>;      // CRm
    elsif instr&lt;27:25> == '110' &amp;&amp; instr&lt;31:28> != '1111' then
        // LDC/STC
        assert cpnum == 14;
        exception =</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a> <ins>then</ins><del>(</del>
                    <a href="shared_pseudocode.html#AArch32.TakeUndefInstrException.1" title="function: AArch32.TakeUndefInstrException(ExceptionRecord exception)"><ins>AArch32.TakeUndefInstrException</ins></a><a href="shared_pseudocode.html#Exception_CP14DTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_CP14DTTrap</del></a><ins>(exception);
                else</ins><del>);
        iss&lt;19:12> = instr&lt;7:0>;      // imm8
        iss&lt;4>     = instr&lt;23>;       // U
        iss&lt;2:1>   = instr&lt;24,21>;    // P,W
        if instr&lt;19:16> == '1111' then    // Rn==15, LDC(Literal addressing)/STC
            iss&lt;8:5> = bits(4) UNKNOWN;
            iss&lt;3>   = '1';
        else
            iss&lt;8:5> = instr&lt;19:16>;  // Rn
            iss&lt;3>   = '0';
    else</del>
                    <a href="shared_pseudocode.html#AArch32.TakeHypTrapException.1" title="function: AArch32.TakeHypTrapException(integer ec)"><ins>AArch32.TakeHypTrapException</ins></a><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><del>Unreachable</del></a><ins>(exception);
</ins><del>();
    iss&lt;0> = instr&lt;20>;               // Direction
</del>
<ins>        if</ins><del>    exception.syndrome&lt;24:20> =</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-shared.ConditionSyndrome.0" title="function: bits(5) ConditionSyndrome()"><del>ConditionSyndrome</del></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) then
            // Check if access disabled in CPTR_EL3
            if CPTR_EL3.TFP == '1' then </ins><a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)"><ins>AArch64.AdvSIMDFPAccessTrap</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>);
    return;</ins><del>();
    exception.syndrome&lt;19:0>  = iss;

    return exception;</del></p></div><div class="ps" psname="aarch32.exceptions.traps.AArch32.CheckForSMCUndefOrTrap"><a id="aarch32.exceptions.traps.AArch32.CheckForSMCUndefOrTrap" name="aarch32.exceptions.traps.AArch32.CheckForSMCUndefOrTrap"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/<ins>AArch32.CheckForSMCUndefOrTrap</ins><del>AArch32.CheckAdvSIMDOrFPEnabled</del></h3><p class="pseudocode"><ins>// AArch32.CheckForSMCUndefOrTrap()
// ================================
// Check for UNDEFINED or trap on SMC instruction</ins><del>// AArch32.CheckAdvSIMDOrFPEnabled()
// =================================
// Check against CPACR, FPEXC, HCPTR, NSACR, and CPTR_EL3.</del>

<a id="AArch32.CheckForSMCUndefOrTrap.0" name="AArch32.CheckForSMCUndefOrTrap.0"></a><ins>AArch32.CheckForSMCUndefOrTrap()
    if !</ins><del>AArch32.CheckAdvSIMDOrFPEnabled(boolean fpexc_check, boolean advsimd)
    if PSTATE.EL ==</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del> &amp;&amp; (!</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>) || PSTATE.EL ==</ins><del>) || (!</del> <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) &amp;&amp; HCR_EL2.TGE == '0')) &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>) then
        // The PE behaves as if FPEXC.EN is 1
        </del><a href="shared_pseudocode.html#AArch64.CheckFPAdvSIMDEnabled.0" title="function: AArch64.CheckFPAdvSIMDEnabled()"><del>AArch64.CheckFPAdvSIMDEnabled</del></a><del>();
    elsif PSTATE.EL == </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> <ins>then
        UNDEFINED;

    if</ins><del>&amp;&amp;</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>() &amp;&amp; !</ins><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a><ins>) then</ins><del>) &amp;&amp; HCR_EL2.TGE == '1' &amp;&amp; !</del>
        <a href="shared_pseudocode.html#AArch64.CheckForSMCUndefOrTrap.1" title="function: AArch64.CheckForSMCUndefOrTrap(bits(16) imm)"><ins>AArch64.CheckForSMCUndefOrTrap</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>(16));
    else
        route_to_hyp =</ins><del>) then
        if fpexc_check &amp;&amp; HCR_EL2.RW == '0' then
            fpexc_en = bits(1) IMPLEMENTATION_DEFINED "FPEXC.EN value when TGE==1 and RW==0";
            if fpexc_en == '0' then UNDEFINED;</del> <a href="shared_pseudocode.html#AArch64.CheckFPAdvSIMDEnabled.0" title="function: AArch64.CheckFPAdvSIMDEnabled()"><del>AArch64.CheckFPAdvSIMDEnabled</del></a><del>();
    else
        cpacr_asedis = CPACR.ASEDIS;
        cpacr_cp10 = CPACR.cp10;

        if </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><ins>) &amp;&amp; !</ins><del>) &amp;&amp;</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a><ins>() &amp;&amp; PSTATE.EL ==</ins><del>() then
            // Check if access disabled in NSACR
            if NSACR.NSASEDIS == '1' then cpacr_asedis = '1';
            if NSACR.cp10 == '0' then cpacr_cp10 = '00';

        if PSTATE.EL !=</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a> <ins>&amp;&amp; HCR.TSC == '1';
        if route_to_hyp then
            exception =</ins><del>then
            // Check if Advanced SIMD disabled in CPACR
            if advsimd &amp;&amp; cpacr_asedis == '1' then UNDEFINED;

            if cpacr_cp10 == '10' then
                (c, cpacr_cp10) =</del> <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)"><del>ConstrainUnpredictableBits</del></a>(<a href="shared_pseudocode.html#Exception_MonitorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_MonitorCall</ins></a><a href="shared_pseudocode.html#Unpredictable_RESCPACR" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESCPACR</del></a><ins>);</ins><del>);

            // Check if access disabled in CPACR
            case cpacr_cp10 of
                when '00'  disabled = TRUE;
                when '01'  disabled = PSTATE.EL ==</del>
            <del>;
                when '11'  disabled = FALSE;
            if disabled then UNDEFINED;

        // If required, check FPEXC enabled bit.
        if fpexc_check &amp;&amp; FPEXC.EN == '0' then UNDEFINED;

        </del><a href="shared_pseudocode.html#AArch32.CheckFPAdvSIMDTrap.1" title="function: AArch32.CheckFPAdvSIMDTrap(boolean advsimd)"><del>AArch32.CheckFPAdvSIMDTrap</del></a><a href="shared_pseudocode.html#AArch32.TakeHypTrapException.1" title="function: AArch32.TakeHypTrapException(integer ec)"><ins>AArch32.TakeHypTrapException</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>(exception);</ins><del>(advsimd);    // Also check against HCPTR and CPTR_EL3</del></p></div><div class="ps" psname="aarch32.exceptions.traps.AArch32.CheckForWFxTrap"><a id="aarch32.exceptions.traps.AArch32.CheckForWFxTrap" name="aarch32.exceptions.traps.AArch32.CheckForWFxTrap"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/<ins>AArch32.CheckForWFxTrap</ins><del>AArch32.CheckFPAdvSIMDTrap</del></h3><p class="pseudocode"><ins>// AArch32.CheckForWFxTrap()
// =========================
// Check for trap on WFE or WFI instruction</ins><del>// AArch32.CheckFPAdvSIMDTrap()
// ============================
// Check against CPTR_EL2 and CPTR_EL3.</del>

<a id="AArch32.CheckForWFxTrap.2" name="AArch32.CheckForWFxTrap.2"></a><ins>AArch32.CheckForWFxTrap(bits(2) target_el, boolean is_wfe)
    assert</ins><del>AArch32.CheckFPAdvSIMDTrap(boolean advsimd)
    if</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><ins>(target_el);

    // Check for routing to AArch64
    if !</ins><del>() &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a><ins>(target_el) then</ins><del>(</del>
        <a href="shared_pseudocode.html#AArch64.CheckForWFxTrap.2" title="function: AArch64.CheckForWFxTrap(bits(2) target_el, boolean is_wfe)"><ins>AArch64.CheckForWFxTrap</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>(target_el, is_wfe);
        return;
    case target_el of
        when</ins><del>) then</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#AArch64.CheckFPAdvSIMDTrap.0" title="function: AArch64.CheckFPAdvSIMDTrap()"><del>AArch64.CheckFPAdvSIMDTrap</del></a> <ins>trap = (if is_wfe then SCTLR.nTWE else SCTLR.nTWI) == '0';
        when</ins><del>();
    else
        if</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> <ins>trap = (if is_wfe then HCR.TWE else HCR.TWI) == '1';
        when</ins><del>) &amp;&amp; !</del> <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a> <ins>trap = (if is_wfe then SCR.TWE else SCR.TWI) == '1';
    if trap then
        if target_el ==</ins><del>() then
            hcptr_tase = HCPTR.TASE;
            hcptr_cp10 = HCPTR.TCP10;

            if</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a> <ins>&amp;&amp;</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><ins>() &amp;&amp; !</ins><del>) &amp;&amp;</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) &amp;&amp; HCR_EL2.TGE == '1' then
            </ins><a href="shared_pseudocode.html#AArch64.WFxTrap.2" title="function: AArch64.WFxTrap(bits(2) target_el, boolean is_wfe)"><ins>AArch64.WFxTrap</ins></a><ins>(target_el, is_wfe);
        if target_el == </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> <ins>then</ins><del>) &amp;&amp; !</del>
            <a href="shared_pseudocode.html#AArch32.TakeMonitorTrapException.0" title="function: AArch32.TakeMonitorTrapException()"><ins>AArch32.TakeMonitorTrapException</ins></a><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><ins>();
        elsif target_el ==</ins><del>() then
                // Check if access disabled in NSACR
                if NSACR.NSASEDIS == '1' then hcptr_tase = '1';
                if NSACR.cp10 == '0' then hcptr_cp10 = '1';

            // Check if access disabled in HCPTR
            if (advsimd &amp;&amp; hcptr_tase == '1') || hcptr_cp10 == '1' then
                exception =</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins> then
            exception = </ins><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_WFxTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_WFxTrap</ins></a><a href="shared_pseudocode.html#Exception_AdvSIMDFPAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_AdvSIMDFPAccessTrap</del></a>);
            exception.syndrome&lt;24:20> = <a href="shared_pseudocode.html#impl-shared.ConditionSyndrome.0" title="function: bits(5) ConditionSyndrome()">ConditionSyndrome</a>();
<ins>            exception.syndrome&lt;0> = if is_wfe then '1' else '0';</ins><del>
                if advsimd then
                    exception.syndrome&lt;5> = '1';
                else
                    exception.syndrome&lt;5> = '0';
                    exception.syndrome&lt;3:0> = '1010';         // coproc field, always 0xA

                if PSTATE.EL ==</del>
            <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del> then
                    </del><a href="shared_pseudocode.html#AArch32.TakeUndefInstrException.1" title="function: AArch32.TakeUndefInstrException(ExceptionRecord exception)"><del>AArch32.TakeUndefInstrException</del></a><del>(exception);
                else
                    </del><a href="shared_pseudocode.html#AArch32.TakeHypTrapException.1" title="function: AArch32.TakeHypTrapException(integer ec)">AArch32.TakeHypTrapException</a>(exception);
<ins>        else</ins><del>
        if</del>
            <del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) then
            // Check if access disabled in CPTR_EL3
            if CPTR_EL3.TFP == '1' then </del><a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)"><del>AArch64.AdvSIMDFPAccessTrap</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><a href="shared_pseudocode.html#AArch32.TakeUndefInstrException.0" title="function: AArch32.TakeUndefInstrException()"><ins>AArch32.TakeUndefInstrException</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>();</ins><del>);
    return;</del></p></div><div class="ps" psname="aarch32.exceptions.traps.AArch32.CheckITEnabled"><a id="aarch32.exceptions.traps.AArch32.CheckITEnabled" name="aarch32.exceptions.traps.AArch32.CheckITEnabled"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/<ins>AArch32.CheckITEnabled</ins><del>AArch32.CheckForSMCUndefOrTrap</del></h3><p class="pseudocode"><ins>// AArch32.CheckITEnabled()
// ========================
// Check whether the T32 IT instruction is disabled.</ins><del>// AArch32.CheckForSMCUndefOrTrap()
// ================================
// Check for UNDEFINED or trap on SMC instruction</del>

<a id="AArch32.CheckITEnabled.1" name="AArch32.CheckITEnabled.1"></a><ins>AArch32.CheckITEnabled(bits(4) mask)
    if PSTATE.EL ==</ins><del>AArch32.CheckForSMCUndefOrTrap()
    if !</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a> <ins>then
        it_disabled = HSCTLR.ITD;
    else
        it_disabled = (if</ins><del>(</del> <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) || PSTATE.EL == </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del> then
        UNDEFINED;

    if </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) then
        </del><a href="shared_pseudocode.html#AArch64.CheckForSMCUndefOrTrap.1" title="function: AArch64.CheckForSMCUndefOrTrap(bits(16) imm)"><del>AArch64.CheckForSMCUndefOrTrap</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(16));
    else
        route_to_hyp = </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>() &amp;&amp; PSTATE.EL == </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a><ins>) then SCTLR.ITD else SCTLR[].ITD);
    if it_disabled == '1' then
        if mask != '1000' then UNDEFINED;

        // Otherwise whether the IT block is allowed depends on hw1 of the next instruction.
        next_instr =</ins><del>&amp;&amp; HCR.TSC == '1';
        if route_to_hyp then
            exception =</del> <a href="shared_pseudocode.html#AArch32.MemSingle.read.4" title="accessor: bits(size*8) AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean wasaligned]"><ins>AArch32.MemSingle</ins></a><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a><ins>[</ins><del>(</del><a href="shared_pseudocode.html#impl-shared.NextInstrAddr.0" title="function: bits(N) NextInstrAddr()"><ins>NextInstrAddr</ins></a><a href="shared_pseudocode.html#Exception_MonitorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_MonitorCall</del></a><ins>(), 2,</ins><del>);</del> <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><a href="shared_pseudocode.html#AArch32.TakeHypTrapException.1" title="function: AArch32.TakeHypTrapException(ExceptionRecord exception)"><del>AArch32.TakeHypTrapException</del></a><ins>, TRUE];

        if next_instr IN {'11xxxxxxxxxxxxxx', '1011xxxxxxxxxxxx', '10100xxxxxxxxxxx',
                          '01001xxxxxxxxxxx', '010001xxx1111xxx', '010001xx1xxxx111'} then
            // It is IMPLEMENTATION DEFINED whether the Undefined Instruction exception is
            // taken on the IT instruction or the next instruction. This is not reflected in
            // the pseudocode, which always takes the exception on the IT instruction. This
            // also does not take into account cases where the next instruction is UNPREDICTABLE.
            UNDEFINED;

    return;</ins><del>(exception);</del></p></div><div class="ps" psname="aarch32.exceptions.traps.AArch32.CheckIllegalState"><a id="aarch32.exceptions.traps.AArch32.CheckIllegalState" name="aarch32.exceptions.traps.AArch32.CheckIllegalState"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/<ins>AArch32.CheckIllegalState</ins><del>AArch32.CheckForWFxTrap</del></h3><p class="pseudocode"><ins>// AArch32.CheckIllegalState()
// ===========================
// Check PSTATE.IL bit and generate Illegal Execution state exception if set.</ins><del>// AArch32.CheckForWFxTrap()
// =========================
// Check for trap on WFE or WFI instruction</del>

<a id="AArch32.CheckIllegalState.0" name="AArch32.CheckIllegalState.0"></a><ins>AArch32.CheckIllegalState()
    if</ins><del>AArch32.CheckForWFxTrap(bits(2) target_el, boolean is_wfe)
    assert</del> <a href="shared_pseudocode.html#AArch32.GeneralExceptionsToAArch64.0" title="function: boolean AArch32.GeneralExceptionsToAArch64()"><ins>AArch32.GeneralExceptionsToAArch64</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>() then</ins><del>(target_el);

    // Check for routing to AArch64
    if !</del>
        <a href="shared_pseudocode.html#AArch64.CheckIllegalState.0" title="function: AArch64.CheckIllegalState()"><ins>AArch64.CheckIllegalState</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><ins>();
    elsif PSTATE.IL == '1' then
        route_to_hyp =</ins><del>(target_el) then</del> <a href="shared_pseudocode.html#AArch64.CheckForWFxTrap.2" title="function: AArch64.CheckForWFxTrap(bits(2) target_el, boolean is_wfe)"><del>AArch64.CheckForWFxTrap</del></a><del>(target_el, is_wfe);
        return;
    case target_el of
        when </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del> trap = (if is_wfe then SCTLR.nTWE else SCTLR.nTWI) == '0';
        when </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del> trap = (if is_wfe then HCR.TWE else HCR.TWI) == '1';
        when </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del> trap = (if is_wfe then SCR.TWE else SCR.TWI) == '1';
    if trap then
        if target_el == </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del> &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a><ins>() &amp;&amp; PSTATE.EL ==</ins><del>() &amp;&amp; !</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a> <ins>&amp;&amp; HCR.TGE == '1';

        bits(32) preferred_exception_return =</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><ins>ThisInstrAddr</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>();
        vect_offset = 0x04;

        if PSTATE.EL ==</ins><del>) &amp;&amp; HCR_EL2.TGE == '1' then</del> <a href="shared_pseudocode.html#AArch64.WFxTrap.2" title="function: AArch64.WFxTrap(bits(2) target_el, boolean is_wfe)"><del>AArch64.WFxTrap</del></a><del>(target_el, is_wfe);
        if target_el == </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del> then
            </del><a href="shared_pseudocode.html#AArch32.TakeMonitorTrapException.0" title="function: AArch32.TakeMonitorTrapException()"><del>AArch32.TakeMonitorTrapException</del></a><del>();
        elsif target_el == </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> <ins>|| route_to_hyp then
</ins><del>then
</del>            exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_IllegalState" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_IllegalState</ins></a><a href="shared_pseudocode.html#Exception_WFxTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_WFxTrap</del></a>);
<ins>            if PSTATE.EL ==</ins><del>            exception.syndrome&lt;24:20> =</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-shared.ConditionSyndrome.0" title="function: bits(5) ConditionSyndrome()"><del>ConditionSyndrome</del></a> <ins>then</ins><del>();
            exception.syndrome&lt;0> = if is_wfe then '1' else '0';</del>
                <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return, integer vect_offset)"><ins>AArch32.EnterHypMode</ins></a><a href="shared_pseudocode.html#AArch32.TakeHypTrapException.1" title="function: AArch32.TakeHypTrapException(ExceptionRecord exception)"><del>AArch32.TakeHypTrapException</del></a><ins>(exception, preferred_exception_return, vect_offset);
            else
                </ins><a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return, integer vect_offset)"><ins>AArch32.EnterHypMode</ins></a><ins>(exception, preferred_exception_return, 0x14);
</ins><del>(exception);
</del>        else
            <a href="shared_pseudocode.html#AArch32.TakeUndefInstrException.0" title="function: AArch32.TakeUndefInstrException()">AArch32.TakeUndefInstrException</a>();</p></div><div class="ps" psname="aarch32.exceptions.traps.AArch32.CheckSETENDEnabled"><a id="aarch32.exceptions.traps.AArch32.CheckSETENDEnabled" name="aarch32.exceptions.traps.AArch32.CheckSETENDEnabled"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/<ins>AArch32.CheckSETENDEnabled</ins><del>AArch32.CheckITEnabled</del></h3><p class="pseudocode"><ins>// AArch32.CheckSETENDEnabled()
// ============================
// Check whether the AArch32 SETEND instruction is disabled.</ins><del>// AArch32.CheckITEnabled()
// ========================
// Check whether the T32 IT instruction is disabled.</del>

<a id="AArch32.CheckSETENDEnabled.0" name="AArch32.CheckSETENDEnabled.0"></a><ins>AArch32.CheckSETENDEnabled()
</ins><del>AArch32.CheckITEnabled(bits(4) mask)
</del>    if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
<ins>        setend_disabled = HSCTLR.SED;
</ins><del>        it_disabled = HSCTLR.ITD;
</del>    else
<ins>        setend_disabled = (if</ins><del>        it_disabled = (if</del> <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a><ins>) then SCTLR.SED else SCTLR[].SED);
    if setend_disabled == '1' then
        UNDEFINED;
</ins><del>) then SCTLR.ITD else SCTLR[].ITD);
    if it_disabled == '1' then
        if mask != '1000' then UNDEFINED;
</del>
<ins>    return;</ins><del>        // Otherwise whether the IT block is allowed depends on hw1 of the next instruction.
        next_instr =</del><a href="shared_pseudocode.html#AArch32.MemSingle.read.4" title="accessor: bits(size*8) AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean wasaligned]"><del>AArch32.MemSingle</del></a><del>[</del><a href="shared_pseudocode.html#impl-shared.NextInstrAddr.0" title="function: bits(N) NextInstrAddr()"><del>NextInstrAddr</del></a><del>(), 2, </del><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IFETCH</del></a><del>, TRUE];

        if next_instr IN {'11xxxxxxxxxxxxxx', '1011xxxxxxxxxxxx', '10100xxxxxxxxxxx',
                          '01001xxxxxxxxxxx', '010001xxx1111xxx', '010001xx1xxxx111'} then
            // It is IMPLEMENTATION DEFINED whether the Undefined Instruction exception is
            // taken on the IT instruction or the next instruction. This is not reflected in
            // the pseudocode, which always takes the exception on the IT instruction. This
            // also does not take into account cases where the next instruction is UNPREDICTABLE.
            UNDEFINED;

    return;</del></p></div><div class="ps" psname="aarch32.exceptions.traps.AArch32.SystemAccessTrap"><a id="aarch32.exceptions.traps.AArch32.SystemAccessTrap" name="aarch32.exceptions.traps.AArch32.SystemAccessTrap"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/<ins>AArch32.SystemAccessTrap</ins><del>AArch32.CheckIllegalState</del></h3><p class="pseudocode"><ins>// AArch32.SystemAccessTrap()
// ==========================
// Trapped  system register access.</ins><del>// AArch32.CheckIllegalState()
// ===========================
// Check PSTATE.IL bit and generate Illegal Execution state exception if set.</del>

<a id="AArch32.SystemAccessTrap.2" name="AArch32.SystemAccessTrap.2"></a><ins>AArch32.SystemAccessTrap(bits(5) mode, integer ec)
    (valid, target_el) =</ins><del>AArch32.CheckIllegalState()
    if</del> <a href="shared_pseudocode.html#impl-shared.ELFromM32.1" title="function: (boolean,bits(2)) ELFromM32(bits(5) mode)"><ins>ELFromM32</ins></a><a href="shared_pseudocode.html#AArch32.GeneralExceptionsToAArch64.0" title="function: boolean AArch32.GeneralExceptionsToAArch64()"><del>AArch32.GeneralExceptionsToAArch64</del></a><ins>(mode);
    assert valid &amp;&amp;</ins><del>() then</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#AArch64.CheckIllegalState.0" title="function: AArch64.CheckIllegalState()"><del>AArch64.CheckIllegalState</del></a><ins>(target_el) &amp;&amp; target_el !=</ins><del>();
    elsif PSTATE.IL == '1' then
        route_to_hyp =</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; PSTATE.EL == </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> <ins>&amp;&amp;</ins><del>&amp;&amp; HCR.TGE == '1';

        bits(32) preferred_exception_return =</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><del>ThisInstrAddr</del></a><ins>(target_el) >=</ins><del>();
        vect_offset = 0x04;

        if PSTATE.EL ==</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>(PSTATE.EL);

    if target_el ==</ins><del>|| route_to_hyp then
            exception =</del> <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a><del>(</del><a href="shared_pseudocode.html#Exception_IllegalState" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_IllegalState</del></a><del>);
            if PSTATE.EL == </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> <ins>then
        exception =</ins><del>then</del> <a href="shared_pseudocode.html#AArch32.SystemAccessTrapSyndrome.2" title="function: ExceptionRecord AArch32.SystemAccessTrapSyndrome(bits(32) instr, integer ec)"><ins>AArch32.SystemAccessTrapSyndrome</ins></a><a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return, integer vect_offset)"><del>AArch32.EnterHypMode</del></a><ins>(</ins><del>(exception, preferred_exception_return, vect_offset);
            else</del><a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()"><ins>ThisInstr</ins></a><a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return, integer vect_offset)"><del>AArch32.EnterHypMode</del></a><ins>(), ec);
        </ins><a href="shared_pseudocode.html#AArch32.TakeHypTrapException.1" title="function: AArch32.TakeHypTrapException(integer ec)"><ins>AArch32.TakeHypTrapException</ins></a><ins>(exception);
    else</ins><del>(exception, preferred_exception_return, 0x14);
        else</del>
        <a href="shared_pseudocode.html#AArch32.TakeUndefInstrException.0" title="function: AArch32.TakeUndefInstrException()">AArch32.TakeUndefInstrException</a>();</p></div><div class="ps" psname="aarch32.exceptions.traps.AArch32.SystemAccessTrapSyndrome"><a id="aarch32.exceptions.traps.AArch32.SystemAccessTrapSyndrome" name="aarch32.exceptions.traps.AArch32.SystemAccessTrapSyndrome"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/<ins>AArch32.SystemAccessTrapSyndrome</ins><del>AArch32.CheckSETENDEnabled</del></h3><p class="pseudocode"><ins>// AArch32.SystemAccessTrapSyndrome()
// ==================================
// Returns the syndrome information for traps on AArch32 MCR, MCRR, MRC, MRRC, and VMRS, VMSR instructions,
// other than traps that are due to HCPTR or CPACR.

ExceptionRecord</ins><del>// AArch32.CheckSETENDEnabled()
// ============================
// Check whether the AArch32 SETEND instruction is disabled.</del> <a id="AArch32.SystemAccessTrapSyndrome.2" name="AArch32.SystemAccessTrapSyndrome.2"></a><ins>AArch32.SystemAccessTrapSyndrome(bits(32) instr, integer ec)</ins><del>AArch32.CheckSETENDEnabled()
    if PSTATE.EL ==</del>
    <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is (Exception type, bits(25) syndrome, bits(64) vaddress, boolean ipavalid, bits(1) NS, bits(52) ipaddress)"><ins>ExceptionRecord</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a> <ins>exception;

    case ec of
        when 0x0    exception =</ins><del>then
        setend_disabled = HSCTLR.SED;
    else
        setend_disabled = (if</del> <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a>(<a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_Uncategorized</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>);
        when 0x3    exception = </ins><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><ins>(</ins><a href="shared_pseudocode.html#Exception_CP15RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_CP15RTTrap</ins></a><ins>);
        when 0x4    exception = </ins><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><ins>(</ins><a href="shared_pseudocode.html#Exception_CP15RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_CP15RRTTrap</ins></a><ins>);
        when 0x5    exception = </ins><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><ins>(</ins><a href="shared_pseudocode.html#Exception_CP14RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_CP14RTTrap</ins></a><ins>);
        when 0x6    exception = </ins><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><ins>(</ins><a href="shared_pseudocode.html#Exception_CP14DTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_CP14DTTrap</ins></a><ins>);
        when 0x7    exception = </ins><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><ins>(</ins><a href="shared_pseudocode.html#Exception_AdvSIMDFPAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_AdvSIMDFPAccessTrap</ins></a><ins>);
        when 0x8    exception = </ins><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><ins>(</ins><a href="shared_pseudocode.html#Exception_FPIDTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_FPIDTrap</ins></a><ins>);
        when 0xC    exception = </ins><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><ins>(</ins><a href="shared_pseudocode.html#Exception_CP14RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_CP14RRTTrap</ins></a><ins>);
        otherwise   </ins><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><ins>Unreachable</ins></a><ins>();

    bits(20) iss = </ins><a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><ins>Zeros</ins></a><ins>();

    if exception.type IN {</ins><a href="shared_pseudocode.html#Exception_FPIDTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_FPIDTrap</ins></a><ins>, </ins><a href="shared_pseudocode.html#Exception_CP14RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_CP14RTTrap</ins></a><ins>, </ins><a href="shared_pseudocode.html#Exception_CP15RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_CP15RTTrap</ins></a><ins>} then
        // Trapped MRC/MCR, VMRS on FPSID
        iss&lt;19:17> = instr&lt;7:5>;           // opc2
        iss&lt;16:14> = instr&lt;23:21>;         // opc1
        iss&lt;13:10> = instr&lt;19:16>;         // CRn
        iss&lt;8:5>   = instr&lt;15:12>;         // Rt
    elsif exception.type IN {</ins><a href="shared_pseudocode.html#Exception_CP14RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_CP14RRTTrap</ins></a><ins>, </ins><a href="shared_pseudocode.html#Exception_AdvSIMDFPAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_AdvSIMDFPAccessTrap</ins></a><ins>, </ins><a href="shared_pseudocode.html#Exception_CP15RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_CP15RRTTrap</ins></a><ins>} then
        // Trapped MRRC/MCRR, VMRS/VMSR
        iss&lt;19:16> = instr&lt;7:4>;          // opc1
        iss&lt;13:10> = instr&lt;19:16>;        // Rt2
        iss&lt;8:5> = instr&lt;15:12>;          // Rt
        iss&lt;4:1>   = instr&lt;3:0>;         // CRm
    elsif exception.type == </ins><a href="shared_pseudocode.html#Exception_CP14DTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_CP14DTTrap</ins></a><ins> then
        // Trapped LDC/STC
        iss&lt;19:12> = instr&lt;7:0>;         // imm8
        iss&lt;4>     = instr&lt;23>;          // U
        iss&lt;2:1>   = instr&lt;24,21>;       // P,W
        if instr&lt;19:16> == '1111' then   // Rn==15, LDC(Literal addressing)/STC
            iss&lt;8:5> = bits(4) UNKNOWN;
            iss&lt;3>   = '1';
    elsif exception.type == </ins><a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_Uncategorized</ins></a><ins> then
        // Trapped for unknown reason
        iss&lt;8:5> = instr&lt;19:16>;         // Rn
        iss&lt;3>   = '0';

    iss&lt;0> = instr&lt;20>;                  // Direction

    exception.syndrome&lt;24:20> = </ins><a href="shared_pseudocode.html#impl-shared.ConditionSyndrome.0" title="function: bits(5) ConditionSyndrome()"><ins>ConditionSyndrome</ins></a><ins>();
    exception.syndrome&lt;19:0>  = iss;
</ins><del>) then SCTLR.SED else SCTLR[].SED);
    if setend_disabled == '1' then
        UNDEFINED;
</del>
<ins>    return exception;</ins><del>    return;</del></p></div><div class="ps" psname="aarch32.exceptions.traps.AArch32.TakeHypTrapException"><a id="aarch32.exceptions.traps.AArch32.TakeHypTrapException" name="aarch32.exceptions.traps.AArch32.TakeHypTrapException"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32.TakeHypTrapException</h3><p class="pseudocode">// AArch32.TakeHypTrapException()
// ==============================
// Exceptions routed to Hyp mode as a Hyp Trap exception.

<a id="AArch32.TakeHypTrapException.1" name="AArch32.TakeHypTrapException.1"></a><ins>AArch32.TakeHypTrapException(integer ec)
    exception =</ins><del>AArch32.TakeHypTrapException(</del> <a href="shared_pseudocode.html#AArch32.SystemAccessTrapSyndrome.2" title="function: ExceptionRecord AArch32.SystemAccessTrapSyndrome(bits(32) instr, integer ec)"><ins>AArch32.SystemAccessTrapSyndrome</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()"><ins>ThisInstr</ins></a><ins>(), ec);
    </ins><a href="shared_pseudocode.html#AArch32.TakeHypTrapException.1" title="function: AArch32.TakeHypTrapException(integer ec)"><ins>AArch32.TakeHypTrapException</ins></a><ins>(exception);

// AArch32.TakeHypTrapException()
// ==============================
// Exceptions routed to Hyp mode as a Hyp Trap exception.

</ins><a href="shared_pseudocode.html#AArch32.TakeHypTrapException.1" title="function: AArch32.TakeHypTrapException(integer ec)"><ins>AArch32.TakeHypTrapException</ins></a><ins>(</ins><a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is (Exception type, bits(25) syndrome, bits(64) vaddress, boolean ipavalid, bits(1) NS, bits(52) ipaddress)">ExceptionRecord</a> exception)
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);

    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x14;

    <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return, integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);</p></div><div class="ps" psname="aarch32.exceptions.traps.AArch32.TakeMonitorTrapException"><a id="aarch32.exceptions.traps.AArch32.TakeMonitorTrapException" name="aarch32.exceptions.traps.AArch32.TakeMonitorTrapException"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32.TakeMonitorTrapException</h3><p class="pseudocode">// AArch32.TakeMonitorTrapException()
// ==================================
// Exceptions routed to Monitor mode as a Monitor Trap exception.

<a id="AArch32.TakeMonitorTrapException.0" name="AArch32.TakeMonitorTrapException.0"></a>AArch32.TakeMonitorTrapException()
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);

    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x04;
    lr_offset = if <a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>() == <a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a> then 4 else 2;

    <a href="shared_pseudocode.html#AArch32.EnterMonitorMode.3" title="function: AArch32.EnterMonitorMode(bits(32) preferred_exception_return, integer lr_offset, integer vect_offset)">AArch32.EnterMonitorMode</a>(preferred_exception_return, lr_offset, vect_offset);</p></div><div class="ps" psname="aarch32.exceptions.traps.AArch32.TakeUndefInstrException"><a id="aarch32.exceptions.traps.AArch32.TakeUndefInstrException" name="aarch32.exceptions.traps.AArch32.TakeUndefInstrException"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32.TakeUndefInstrException</h3><p class="pseudocode">// AArch32.TakeUndefInstrException()
// =================================

<a id="AArch32.TakeUndefInstrException.0" name="AArch32.TakeUndefInstrException.0"></a>AArch32.TakeUndefInstrException()
    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}">Exception_Uncategorized</a>);
    <a href="shared_pseudocode.html#AArch32.TakeUndefInstrException.1" title="function: AArch32.TakeUndefInstrException(ExceptionRecord exception)">AArch32.TakeUndefInstrException</a>(exception);

// AArch32.TakeUndefInstrException()
// =================================

<a id="AArch32.TakeUndefInstrException.1" name="AArch32.TakeUndefInstrException.1"></a>AArch32.TakeUndefInstrException(<a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is (Exception type, bits(25) syndrome, bits(64) vaddress, boolean ipavalid, bits(1) NS, bits(52) ipaddress)">ExceptionRecord</a> exception)

    route_to_hyp = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; HCR.TGE == '1';
    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x04;
    lr_offset = if <a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>() == <a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a> then 4 else 2;

    if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return, integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
    elsif route_to_hyp then
        <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return, integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, 0x14);
    else
        <a href="shared_pseudocode.html#AArch32.EnterMode.4" title="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset, integer vect_offset)">AArch32.EnterMode</a>(<a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'">M32_Undef</a>, preferred_exception_return, lr_offset, vect_offset);</p></div><div class="ps" psname="aarch32.exceptions.traps.AArch32.UndefinedFault"><a id="aarch32.exceptions.traps.AArch32.UndefinedFault" name="aarch32.exceptions.traps.AArch32.UndefinedFault"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32.UndefinedFault</h3><p class="pseudocode">// AArch32.UndefinedFault()
// ========================

<a id="AArch32.UndefinedFault.0" name="AArch32.UndefinedFault.0"></a>AArch32.UndefinedFault()

    if <a href="shared_pseudocode.html#AArch32.GeneralExceptionsToAArch64.0" title="function: boolean AArch32.GeneralExceptionsToAArch64()">AArch32.GeneralExceptionsToAArch64</a>() then <a href="shared_pseudocode.html#AArch64.UndefinedFault.0" title="function: AArch64.UndefinedFault()">AArch64.UndefinedFault</a>();
    <a href="shared_pseudocode.html#AArch32.TakeUndefInstrException.0" title="function: AArch32.TakeUndefInstrException()">AArch32.TakeUndefInstrException</a>();</p></div><div class="ps" psname="aarch32.functions.aborts.AArch32.CreateFaultRecord"><a id="aarch32.functions.aborts.AArch32.CreateFaultRecord" name="aarch32.functions.aborts.AArch32.CreateFaultRecord"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/aborts/AArch32.CreateFaultRecord</h3><p class="pseudocode">// AArch32.CreateFaultRecord()
// ===========================

FaultRecord <a id="AArch32.CreateFaultRecord.11" name="AArch32.CreateFaultRecord.11"></a>AArch32.CreateFaultRecord(<a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}">Fault</a> type, bits(40) ipaddress,   bits(4) domain,
                                      integer level, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType</a> acctype, boolean write, bit extflag,
                                      bits(4) debugmoe, bits(2) errortype, boolean secondstage, boolean s2fs1walk)

    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault;
    fault.type = type;
    if (type != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}">Fault_None</a> &amp;&amp; PSTATE.EL != <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; TTBCR.EAE == '0' &amp;&amp; !secondstage &amp;&amp; !s2fs1walk &amp;&amp;
        <a href="shared_pseudocode.html#AArch32.DomainValid.2" title="function: boolean AArch32.DomainValid(Fault type, integer level)">AArch32.DomainValid</a>(type, level)) then
        fault.domain = domain;
    else
        fault.domain = bits(4) UNKNOWN;
    fault.debugmoe = debugmoe;
    fault.errortype = errortype;
    fault.ipaddress.NS = bit UNKNOWN;
    fault.ipaddress.address = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(ipaddress);
    fault.level = level;
    fault.acctype = acctype;
    fault.write = write;
    fault.extflag = extflag;
    fault.secondstage = secondstage;
    fault.s2fs1walk = s2fs1walk;

    return fault;</p></div><div class="ps" psname="aarch32.functions.aborts.AArch32.DomainValid"><a id="aarch32.functions.aborts.AArch32.DomainValid" name="aarch32.functions.aborts.AArch32.DomainValid"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/aborts/AArch32.DomainValid</h3><p class="pseudocode">// AArch32.DomainValid()
// =====================
// Returns TRUE if the Domain is valid for a Short-descriptor translation scheme.

boolean <a id="AArch32.DomainValid.2" name="AArch32.DomainValid.2"></a>AArch32.DomainValid(<a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}">Fault</a> type, integer level)
    assert type != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}">Fault_None</a>;

    case type of
        when <a href="shared_pseudocode.html#Fault_Domain" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}">Fault_Domain</a>
            return TRUE;
        when <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}">Fault_Translation</a>, <a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}">Fault_AccessFlag</a>, <a href="shared_pseudocode.html#Fault_SyncExternalOnWalk" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}">Fault_SyncExternalOnWalk</a>, <a href="shared_pseudocode.html#Fault_SyncParityOnWalk" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}">Fault_SyncParityOnWalk</a>
            return level == 2;
        otherwise
            return FALSE;</p></div><div class="ps" psname="aarch32.functions.aborts.AArch32.FaultStatusLD"><a id="aarch32.functions.aborts.AArch32.FaultStatusLD" name="aarch32.functions.aborts.AArch32.FaultStatusLD"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/aborts/AArch32.FaultStatusLD</h3><p class="pseudocode">// AArch32.FaultStatusLD()
// =======================
// Creates an exception fault status value for Abort and Watchpoint exceptions taken
// to Abort mode using AArch32 and Long-descriptor format.

bits(32) <a id="AArch32.FaultStatusLD.2" name="AArch32.FaultStatusLD.2"></a>AArch32.FaultStatusLD(boolean d_side, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    assert fault.type != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}">Fault_None</a>;

    bits(32) fsr = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();
    if <a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsAsyncAbort.1" title="function: boolean IsAsyncAbort(Fault type)">IsAsyncAbort</a>(fault) then fsr&lt;15:14> = fault.errortype;
    if d_side then
        if fault.acctype IN {<a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType_DC</a>, <a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType_IC</a>, <a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType_AT</a>} then
            fsr&lt;13> = '1'; fsr&lt;11> = '1';
        else
            fsr&lt;11> = if fault.write then '1' else '0';
    if <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault type)">IsExternalAbort</a>(fault) then fsr&lt;12> = fault.extflag;
    fsr&lt;9> = '1';
    fsr&lt;5:0> = <a href="shared_pseudocode.html#impl-shared.EncodeLDFSC.2" title="function: bits(6) EncodeLDFSC(Fault type, integer level)">EncodeLDFSC</a>(fault.type, fault.level);

    return fsr;</p></div><div class="ps" psname="aarch32.functions.aborts.AArch32.FaultStatusSD"><a id="aarch32.functions.aborts.AArch32.FaultStatusSD" name="aarch32.functions.aborts.AArch32.FaultStatusSD"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/aborts/AArch32.FaultStatusSD</h3><p class="pseudocode">// AArch32.FaultStatusSD()
// =======================
// Creates an exception fault status value for Abort and Watchpoint exceptions taken
// to Abort mode using AArch32 and Short-descriptor format.

bits(32) <a id="AArch32.FaultStatusSD.2" name="AArch32.FaultStatusSD.2"></a>AArch32.FaultStatusSD(boolean d_side, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    assert fault.type != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}">Fault_None</a>;

    bits(32) fsr = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();
    if <a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsAsyncAbort.1" title="function: boolean IsAsyncAbort(Fault type)">IsAsyncAbort</a>(fault) then fsr&lt;15:14> = fault.errortype;
    if d_side then
        if fault.acctype IN {<a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType_DC</a>, <a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType_IC</a>, <a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType_AT</a>} then
            fsr&lt;13> = '1'; fsr&lt;11> = '1';
        else
            fsr&lt;11> = if fault.write then '1' else '0';
    if <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault type)">IsExternalAbort</a>(fault) then fsr&lt;12> = fault.extflag;
    fsr&lt;9> = '0';
    fsr&lt;10,3:0> = <a href="shared_pseudocode.html#impl-aarch32.EncodeSDFSC.2" title="function: bits(5) EncodeSDFSC(Fault type, integer level)">EncodeSDFSC</a>(fault.type, fault.level);
    if d_side then
        fsr&lt;7:4> = fault.domain;               // Domain field (data fault only)

    return fsr;</p></div><div class="ps" psname="aarch32.functions.aborts.AArch32.FaultSyndrome"><a id="aarch32.functions.aborts.AArch32.FaultSyndrome" name="aarch32.functions.aborts.AArch32.FaultSyndrome"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/aborts/AArch32.FaultSyndrome</h3><p class="pseudocode">// AArch32.FaultSyndrome()
// =======================
// Creates an exception syndrome value for Abort and Watchpoint exceptions taken to
// AArch32 Hyp mode.

bits(25) <a id="AArch32.FaultSyndrome.2" name="AArch32.FaultSyndrome.2"></a>AArch32.FaultSyndrome(boolean d_side, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    assert fault.type != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}">Fault_None</a>;

    bits(25) iss = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();
    if <a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsAsyncAbort.1" title="function: boolean IsAsyncAbort(Fault type)">IsAsyncAbort</a>(fault) then iss&lt;11:10> = fault.errortype; // AET
    if d_side then
        if <a href="shared_pseudocode.html#impl-shared.IsSecondStage.1" title="function: boolean IsSecondStage(FaultRecord fault)">IsSecondStage</a>(fault) &amp;&amp; !fault.s2fs1walk then iss&lt;24:14> = <a href="shared_pseudocode.html#impl-shared.LSInstructionSyndrome.0" title="function: bits(11) LSInstructionSyndrome()">LSInstructionSyndrome</a>();
        if fault.acctype IN {<a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType_DC</a>, <a href="shared_pseudocode.html#AccType_DC_UNPRIV" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType_DC_UNPRIV</a>, <a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType_IC</a>, <a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType_AT</a>} then
            iss&lt;8> = '1';  iss&lt;6> = '1';
        else
            iss&lt;6> = if fault.write then '1' else '0';
    if <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault type)">IsExternalAbort</a>(fault) then iss&lt;9> = fault.extflag;
    iss&lt;7> = if fault.s2fs1walk then '1' else '0';
    iss&lt;5:0> = <a href="shared_pseudocode.html#impl-shared.EncodeLDFSC.2" title="function: bits(6) EncodeLDFSC(Fault type, integer level)">EncodeLDFSC</a>(fault.type, fault.level);

    return iss;</p></div><div class="ps" psname="aarch32.functions.aborts.EncodeSDFSC"><a id="aarch32.functions.aborts.EncodeSDFSC" name="aarch32.functions.aborts.EncodeSDFSC"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/aborts/EncodeSDFSC</h3><p class="pseudocode">// EncodeSDFSC()
// =============
// Function that gives the Short-descriptor FSR code for different types of Fault

bits(5) <a id="impl-aarch32.EncodeSDFSC.2" name="impl-aarch32.EncodeSDFSC.2"></a>EncodeSDFSC(<a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}">Fault</a> type, integer level)

    bits(5) result;
    case type of
        when <a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}">Fault_AccessFlag</a>
            assert level IN {1,2};
            result = if level == 1 then '00011' else '00110';
        when <a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}">Fault_Alignment</a>
            result = '00001';
        when <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}">Fault_Permission</a>
            assert level IN {1,2};
            result = if level == 1 then '01101' else '01111';
        when <a href="shared_pseudocode.html#Fault_Domain" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}">Fault_Domain</a>
            assert level IN {1,2};
            result = if level == 1 then '01001' else '01011';
        when <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}">Fault_Translation</a>
            assert level IN {1,2};
            result = if level == 1 then '00101' else '00111';
        when <a href="shared_pseudocode.html#Fault_SyncExternal" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}">Fault_SyncExternal</a>
            result = '01000';
        when <a href="shared_pseudocode.html#Fault_SyncExternalOnWalk" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}">Fault_SyncExternalOnWalk</a>
            assert level IN {1,2};
            result = if level == 1 then '01100' else '01110';
        when <a href="shared_pseudocode.html#Fault_SyncParity" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}">Fault_SyncParity</a>
            result = '11001';
        when <a href="shared_pseudocode.html#Fault_SyncParityOnWalk" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}">Fault_SyncParityOnWalk</a>
            assert level IN {1,2};
            result = if level == 1 then '11100' else '11110';
        when <a href="shared_pseudocode.html#Fault_AsyncParity" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}">Fault_AsyncParity</a>
            result = '11000';
        when <a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}">Fault_AsyncExternal</a>
            result = '10110';
        when <a href="shared_pseudocode.html#Fault_Debug" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}">Fault_Debug</a>
            result = '00010';
        when <a href="shared_pseudocode.html#Fault_TLBConflict" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}">Fault_TLBConflict</a>
            result = '10000';
        when <a href="shared_pseudocode.html#Fault_Lockdown" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}">Fault_Lockdown</a>
            result = '10100';   // IMPLEMENTATION DEFINED
        when <a href="shared_pseudocode.html#Fault_Exclusive" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}">Fault_Exclusive</a>
            result = '10101';   // IMPLEMENTATION DEFINED
        when <a href="shared_pseudocode.html#Fault_ICacheMaint" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}">Fault_ICacheMaint</a>
            result = '00100';
        otherwise
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    return result;</p></div><div class="ps" psname="aarch32.functions.common.A32ExpandImm"><a id="aarch32.functions.common.A32ExpandImm" name="aarch32.functions.common.A32ExpandImm"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/A32ExpandImm</h3><p class="pseudocode">// A32ExpandImm()
// ==============

bits(32) <a id="impl-aarch32.A32ExpandImm.1" name="impl-aarch32.A32ExpandImm.1"></a>A32ExpandImm(bits(12) imm12)

    // PSTATE.C argument to following function call does not affect the imm32 result.
    (imm32, -) = <a href="shared_pseudocode.html#impl-aarch32.A32ExpandImm_C.2" title="function: (bits(32), bit) A32ExpandImm_C(bits(12) imm12, bit carry_in)">A32ExpandImm_C</a>(imm12, PSTATE.C);

    return imm32;</p></div><div class="ps" psname="aarch32.functions.common.A32ExpandImm_C"><a id="aarch32.functions.common.A32ExpandImm_C" name="aarch32.functions.common.A32ExpandImm_C"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/A32ExpandImm_C</h3><p class="pseudocode">// A32ExpandImm_C()
// ================

(bits(32), bit) <a id="impl-aarch32.A32ExpandImm_C.2" name="impl-aarch32.A32ExpandImm_C.2"></a>A32ExpandImm_C(bits(12) imm12, bit carry_in)

    unrotated_value = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(imm12&lt;7:0>, 32);
    (imm32, carry_out) = <a href="shared_pseudocode.html#impl-aarch32.Shift_C.4" title="function: (bits(N), bit) Shift_C(bits(N) value, SRType type, integer amount, bit carry_in)">Shift_C</a>(unrotated_value, <a href="shared_pseudocode.html#SRType_ROR" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_ROR</a>, 2*<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(imm12&lt;11:8>), carry_in);

    return (imm32, carry_out);</p></div><div class="ps" psname="aarch32.functions.common.DecodeImmShift"><a id="aarch32.functions.common.DecodeImmShift" name="aarch32.functions.common.DecodeImmShift"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/DecodeImmShift</h3><p class="pseudocode">// DecodeImmShift()
// ================

(SRType, integer) <a id="impl-aarch32.DecodeImmShift.2" name="impl-aarch32.DecodeImmShift.2"></a>DecodeImmShift(bits(2) type, bits(5) imm5)

    case type of
        when '00'
            shift_t = <a href="shared_pseudocode.html#SRType_LSL" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_LSL</a>;  shift_n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(imm5);
        when '01'
            shift_t = <a href="shared_pseudocode.html#SRType_LSR" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_LSR</a>;  shift_n = if imm5 == '00000' then 32 else <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(imm5);
        when '10'
            shift_t = <a href="shared_pseudocode.html#SRType_ASR" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_ASR</a>;  shift_n = if imm5 == '00000' then 32 else <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(imm5);
        when '11'
            if imm5 == '00000' then
                shift_t = <a href="shared_pseudocode.html#SRType_RRX" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_RRX</a>;  shift_n = 1;
            else
                shift_t = <a href="shared_pseudocode.html#SRType_ROR" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_ROR</a>;  shift_n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(imm5);

    return (shift_t, shift_n);</p></div><div class="ps" psname="aarch32.functions.common.DecodeRegShift"><a id="aarch32.functions.common.DecodeRegShift" name="aarch32.functions.common.DecodeRegShift"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/DecodeRegShift</h3><p class="pseudocode">// DecodeRegShift()
// ================

SRType <a id="impl-aarch32.DecodeRegShift.1" name="impl-aarch32.DecodeRegShift.1"></a>DecodeRegShift(bits(2) type)
    case type of
        when '00'  shift_t = <a href="shared_pseudocode.html#SRType_LSL" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_LSL</a>;
        when '01'  shift_t = <a href="shared_pseudocode.html#SRType_LSR" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_LSR</a>;
        when '10'  shift_t = <a href="shared_pseudocode.html#SRType_ASR" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_ASR</a>;
        when '11'  shift_t = <a href="shared_pseudocode.html#SRType_ROR" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_ROR</a>;
    return shift_t;</p></div><div class="ps" psname="aarch32.functions.common.RRX"><a id="aarch32.functions.common.RRX" name="aarch32.functions.common.RRX"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/RRX</h3><p class="pseudocode">// RRX()
// =====

bits(N) <a id="impl-aarch32.RRX.2" name="impl-aarch32.RRX.2"></a>RRX(bits(N) x, bit carry_in)
    (result, -) = <a href="shared_pseudocode.html#impl-aarch32.RRX_C.2" title="function: (bits(N), bit) RRX_C(bits(N) x, bit carry_in)">RRX_C</a>(x, carry_in);
    return result;</p></div><div class="ps" psname="aarch32.functions.common.RRX_C"><a id="aarch32.functions.common.RRX_C" name="aarch32.functions.common.RRX_C"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/RRX_C</h3><p class="pseudocode">// RRX_C()
// =======

(bits(N), bit) <a id="impl-aarch32.RRX_C.2" name="impl-aarch32.RRX_C.2"></a>RRX_C(bits(N) x, bit carry_in)
    result = carry_in : x&lt;N-1:1>;
    carry_out = x&lt;0>;
    return (result, carry_out);</p></div><div class="ps" psname="aarch32.functions.common.SRType"><a id="aarch32.functions.common.SRType" name="aarch32.functions.common.SRType"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/SRType</h3><p class="pseudocode">enumeration <a id="SRType" name="SRType"></a>SRType {<a id="SRType_LSL" name="SRType_LSL"></a>SRType_LSL, <a id="SRType_LSR" name="SRType_LSR"></a>SRType_LSR, <a id="SRType_ASR" name="SRType_ASR"></a>SRType_ASR, <a id="SRType_ROR" name="SRType_ROR"></a>SRType_ROR, <a id="SRType_RRX" name="SRType_RRX"></a>SRType_RRX};</p></div><div class="ps" psname="aarch32.functions.common.Shift"><a id="aarch32.functions.common.Shift" name="aarch32.functions.common.Shift"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/Shift</h3><p class="pseudocode">// Shift()
// =======

bits(N) <a id="impl-aarch32.Shift.4" name="impl-aarch32.Shift.4"></a>Shift(bits(N) value, <a href="shared_pseudocode.html#SRType" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType</a> type, integer amount, bit carry_in)
    (result, -) = <a href="shared_pseudocode.html#impl-aarch32.Shift_C.4" title="function: (bits(N), bit) Shift_C(bits(N) value, SRType type, integer amount, bit carry_in)">Shift_C</a>(value, type, amount, carry_in);
    return result;</p></div><div class="ps" psname="aarch32.functions.common.Shift_C"><a id="aarch32.functions.common.Shift_C" name="aarch32.functions.common.Shift_C"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/Shift_C</h3><p class="pseudocode">// Shift_C()
// =========

(bits(N), bit) <a id="impl-aarch32.Shift_C.4" name="impl-aarch32.Shift_C.4"></a>Shift_C(bits(N) value, <a href="shared_pseudocode.html#SRType" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType</a> type, integer amount, bit carry_in)
    assert !(type == <a href="shared_pseudocode.html#SRType_RRX" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_RRX</a> &amp;&amp; amount != 1);

    if amount == 0 then
        (result, carry_out) = (value, carry_in);
    else
        case type of
            when <a href="shared_pseudocode.html#SRType_LSL" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_LSL</a>
                (result, carry_out) = <a href="shared_pseudocode.html#impl-shared.LSL_C.2" title="function: (bits(N), bit) LSL_C(bits(N) x, integer shift)">LSL_C</a>(value, amount);
            when <a href="shared_pseudocode.html#SRType_LSR" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_LSR</a>
                (result, carry_out) = <a href="shared_pseudocode.html#impl-shared.LSR_C.2" title="function: (bits(N), bit) LSR_C(bits(N) x, integer shift)">LSR_C</a>(value, amount);
            when <a href="shared_pseudocode.html#SRType_ASR" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_ASR</a>
                (result, carry_out) = <a href="shared_pseudocode.html#impl-shared.ASR_C.2" title="function: (bits(N), bit) ASR_C(bits(N) x, integer shift)">ASR_C</a>(value, amount);
            when <a href="shared_pseudocode.html#SRType_ROR" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_ROR</a>
                (result, carry_out) = <a href="shared_pseudocode.html#impl-shared.ROR_C.2" title="function: (bits(N), bit) ROR_C(bits(N) x, integer shift)">ROR_C</a>(value, amount);
            when <a href="shared_pseudocode.html#SRType_RRX" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_RRX</a>
                (result, carry_out) = <a href="shared_pseudocode.html#impl-aarch32.RRX_C.2" title="function: (bits(N), bit) RRX_C(bits(N) x, bit carry_in)">RRX_C</a>(value, carry_in);

    return (result, carry_out);</p></div><div class="ps" psname="aarch32.functions.common.T32ExpandImm"><a id="aarch32.functions.common.T32ExpandImm" name="aarch32.functions.common.T32ExpandImm"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/T32ExpandImm</h3><p class="pseudocode">// T32ExpandImm()
// ==============

bits(32) <a id="impl-aarch32.T32ExpandImm.1" name="impl-aarch32.T32ExpandImm.1"></a>T32ExpandImm(bits(12) imm12)

    // PSTATE.C argument to following function call does not affect the imm32 result.
    (imm32, -) = <a href="shared_pseudocode.html#impl-aarch32.T32ExpandImm_C.2" title="function: (bits(32), bit) T32ExpandImm_C(bits(12) imm12, bit carry_in)">T32ExpandImm_C</a>(imm12, PSTATE.C);

    return imm32;</p></div><div class="ps" psname="aarch32.functions.common.T32ExpandImm_C"><a id="aarch32.functions.common.T32ExpandImm_C" name="aarch32.functions.common.T32ExpandImm_C"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/T32ExpandImm_C</h3><p class="pseudocode">// T32ExpandImm_C()
// ================

(bits(32), bit) <a id="impl-aarch32.T32ExpandImm_C.2" name="impl-aarch32.T32ExpandImm_C.2"></a>T32ExpandImm_C(bits(12) imm12, bit carry_in)

    if imm12&lt;11:10> == '00' then
        case imm12&lt;9:8> of
            when '00'
                imm32 = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(imm12&lt;7:0>, 32);
            when '01'
                imm32 = '00000000' : imm12&lt;7:0> : '00000000' : imm12&lt;7:0>;
            when '10'
                imm32 = imm12&lt;7:0> : '00000000' : imm12&lt;7:0> : '00000000';
            when '11'
                imm32 = imm12&lt;7:0> : imm12&lt;7:0> : imm12&lt;7:0> : imm12&lt;7:0>;
        carry_out = carry_in;
    else
        unrotated_value = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>('1':imm12&lt;6:0>, 32);
        (imm32, carry_out) = <a href="shared_pseudocode.html#impl-shared.ROR_C.2" title="function: (bits(N), bit) ROR_C(bits(N) x, integer shift)">ROR_C</a>(unrotated_value, <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(imm12&lt;11:7>));

    return (imm32, carry_out);</p></div><div class="ps" psname="aarch32.functions.coproc.AArch32.CheckCP15InstrCoarseTraps"><a id="aarch32.functions.coproc.AArch32.CheckCP15InstrCoarseTraps" name="aarch32.functions.coproc.AArch32.CheckCP15InstrCoarseTraps"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/coproc/AArch32.CheckCP15InstrCoarseTraps</h3><p class="pseudocode">// AArch32.CheckCP15InstrCoarseTraps()
// ===================================
// Check for coarse-grained CP15 traps in HSTR and HCR.

boolean <a id="AArch32.CheckCP15InstrCoarseTraps.3" name="AArch32.CheckCP15InstrCoarseTraps.3"></a>AArch32.CheckCP15InstrCoarseTraps(integer CRn, integer nreg, integer CRm)

    // Check for coarse-grained Hyp traps
    if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>,<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} then
        if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
            return <a href="shared_pseudocode.html#AArch64.CheckCP15InstrCoarseTraps.3" title="function: boolean AArch64.CheckCP15InstrCoarseTraps(integer CRn, integer nreg, integer CRm)">AArch64.CheckCP15InstrCoarseTraps</a>(CRn, nreg, CRm);
        // Check for MCR, MRC, MCRR and MRRC disabled by HSTR&lt;CRn/CRm>
        major = if nreg == 1 then CRn else CRm;
        if !(major IN {4,14}) &amp;&amp; HSTR&lt;major> == '1' then
            return TRUE;

        // Check for MRC and MCR disabled by HCR.TIDCP
        if (HCR.TIDCP == '1' &amp;&amp; nreg == 1 &amp;&amp;
            ((CRn == 9  &amp;&amp; CRm IN {0,1,2,    5,6,7,8   }) ||
             (CRn == 10 &amp;&amp; CRm IN {0,1,    4,      8   }) ||
             (CRn == 11 &amp;&amp; CRm IN {0,1,2,3,4,5,6,7,8,15}))) then
            return TRUE;

    return FALSE;</p></div><div class="ps" psname="aarch32.functions.exclusive.AArch32.ExclusiveMonitorsPass"><a id="aarch32.functions.exclusive.AArch32.ExclusiveMonitorsPass" name="aarch32.functions.exclusive.AArch32.ExclusiveMonitorsPass"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>exclusive</ins><del>coproc</del>/<ins>AArch32.ExclusiveMonitorsPass</ins><del>AArch32.CheckSystemAccess</del></h3><p class="pseudocode"><ins>// AArch32.ExclusiveMonitorsPass()
// ===============================

// Return TRUE if the Exclusives monitors for the current PE include all of the addresses
// associated with the virtual address region of size bytes starting at address.
// The immediately following memory write must be to the same addresses.

boolean</ins><del>// AArch32.CheckSystemAccess()
// ===========================
// Check System register access instruction for enables and disables</del> <a id="AArch32.ExclusiveMonitorsPass.2" name="AArch32.ExclusiveMonitorsPass.2"></a><ins>AArch32.ExclusiveMonitorsPass(bits(32) address, integer size)

    // It is IMPLEMENTATION DEFINED whether the detection of memory aborts happens
    // before or after the check on the local Exclusives monitor. As a result a failure
    // of the local monitor can occur on some implementations even if the memory
    // access would give an memory abort.

    acctype =</ins><del>AArch32.CheckSystemAccess(integer cp_num, bits(32) instr)
    assert cp_num ==</del> <a href="shared_pseudocode.html#AccType_ATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ATOMIC</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>;
    iswrite = TRUE;
    aligned = (address ==</ins><del>(instr&lt;11:8>) &amp;&amp; (cp_num IN {14,15});
    if PSTATE.EL ==</del> <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)"><ins>Align</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>(address, size));

    if !aligned then
        secondstage = FALSE;</ins><del>&amp;&amp; !</del>
        <a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)"><ins>AArch32.Abort</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><ins>(address,</ins><del>(</del> <a href="shared_pseudocode.html#AArch32.AlignmentFault.3" title="function: FaultRecord AArch32.AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)"><ins>AArch32.AlignmentFault</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>(acctype, iswrite, secondstage));

    passed =</ins><del>) then</del> <a href="shared_pseudocode.html#AArch32.IsExclusiveVA.3" title="function: boolean AArch32.IsExclusiveVA(bits(32) address, integer processorid, integer size)"><ins>AArch32.IsExclusiveVA</ins></a><a href="shared_pseudocode.html#AArch64.CheckAArch32SystemAccess.1" title="function: AArch64.CheckAArch32SystemAccess(bits(32) instr)"><del>AArch64.CheckAArch32SystemAccess</del></a><ins>(address,</ins><del>(instr);
        return;
    // Decode the AArch32 System register access instruction
    if instr&lt;31:28> != '1111' &amp;&amp; instr&lt;27:24> == '1110' &amp;&amp; instr&lt;4> == '1' then      // MRC/MCR
        cprt = TRUE;  cpdt = FALSE;  nreg = 1;
        opc1 =</del> <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><ins>ProcessorID</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>(), size);
    if !passed then
        return FALSE;
    memaddrdesc =</ins><del>(instr&lt;23:21>);
        opc2 =</del> <a href="shared_pseudocode.html#AArch32.TranslateAddress.5" title="function: AddressDescriptor AArch32.TranslateAddress(bits(32) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><ins>AArch32.TranslateAddress</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>(address, acctype, iswrite, aligned, size);

    // Check for aborts or debug exceptions
    if</ins><del>(instr&lt;7:5>);
        CRn  =</del> <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>(memaddrdesc) then</ins><del>(instr&lt;19:16>);
        CRm  =</del>
        <a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)"><ins>AArch32.Abort</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>(address, memaddrdesc.fault);

    passed =</ins><del>(instr&lt;3:0>);
    elsif instr&lt;31:28> != '1111' &amp;&amp; instr&lt;27:21> == '1100010' then                   // MRRC/MCRR
        cprt = TRUE;  cpdt = FALSE;  nreg = 2;
        opc1 =</del> <a href="shared_pseudocode.html#impl-shared.IsExclusiveLocal.3" title="function: boolean IsExclusiveLocal(FullAddress paddress, integer processorid, integer size)"><ins>IsExclusiveLocal</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>(memaddrdesc.paddress,</ins><del>(instr&lt;7:4>);
        CRm  =</del> <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><ins>ProcessorID</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>(), size);

    if passed then</ins><del>(instr&lt;3:0>);
    elsif instr&lt;31:28> != '1111' &amp;&amp; instr&lt;27:25> == '110' &amp;&amp; instr&lt;22> == '0' then   // LDC/STC
        cprt = FALSE;  cpdt = TRUE;  nreg = 0;
        opc1 = 0;
        CRn  =</del>
        <a href="shared_pseudocode.html#impl-shared.ClearExclusiveLocal.1" title="function: ClearExclusiveLocal(integer processorid)"><ins>ClearExclusiveLocal</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>(</ins><del>(instr&lt;15:12>);
    else
        allocated = FALSE;

    //
    // Coarse-grain decode into CP14 or CP15 encoding space. Each of the CPxxxInstrDecode functions
    // returns TRUE if the instruction is allocated at the current Exception level, FALSE otherwise.
    if cp_num == 14 then
        // LDC and STC only supported for c5 in CP14 encoding space
        if cpdt &amp;&amp; CRn != 5 then
            allocated = FALSE;
        else
            // Coarse-grained decode of CP14 based on opc1 field
            case opc1 of
                when 0     allocated =</del><a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><ins>ProcessorID</ins></a><a href="shared_pseudocode.html#impl-aarch32.CP14DebugInstrDecode.1" title="function: boolean CP14DebugInstrDecode(bits(32) instr)"><del>CP14DebugInstrDecode</del></a><ins>());
        if memaddrdesc.memattrs.shareable then
            passed =</ins><del>(instr);
                when 1     allocated =</del> <a href="shared_pseudocode.html#impl-shared.IsExclusiveGlobal.3" title="function: boolean IsExclusiveGlobal(FullAddress paddress, integer processorid, integer size)"><ins>IsExclusiveGlobal</ins></a><a href="shared_pseudocode.html#impl-aarch32.CP14TraceInstrDecode.1" title="function: boolean CP14TraceInstrDecode(bits(32) instr)"><del>CP14TraceInstrDecode</del></a><ins>(memaddrdesc.paddress,</ins><del>(instr);
                when 7     allocated =</del> <del>(instr);    // JIDR only
                otherwise  allocated = FALSE;          // All other values are unallocated

    elsif cp_num == 15 then
        // LDC and STC not supported in CP15 encoding space
        if !cprt then
            allocated = FALSE;
        else
            allocated = </del><a href="shared_pseudocode.html#impl-aarch32.CP15InstrDecode.1" title="function: boolean CP15InstrDecode(bits(32) instr)"><del>CP15InstrDecode</del></a><del>(instr);

            // Coarse-grain traps to EL2 have a higher priority than exceptions generated because
            // the access instruction is UNDEFINED
            if </del><a href="shared_pseudocode.html#AArch32.CheckCP15InstrCoarseTraps.3" title="function: boolean AArch32.CheckCP15InstrCoarseTraps(integer CRn, integer nreg, integer CRm)"><del>AArch32.CheckCP15InstrCoarseTraps</del></a><del>(CRn, nreg, CRm) then
                // For a coarse-grain trap, if it is IMPLEMENTATION DEFINED whether an access from
                // User mode is UNDEFINED when the trap is disabled, then it is
                // IMPLEMENTATION DEFINED whether the same access is UNDEFINED or generates a trap
                // when the trap is enabled.
                if PSTATE.EL == </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del> &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; !allocated then
                    if boolean IMPLEMENTATION_DEFINED "UNDEF unallocated CP15 access at </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>" then
                        UNDEFINED;
                </del><a href="shared_pseudocode.html#AArch32.AArch32SystemAccessTrap.2" title="function: AArch32.AArch32SystemAccessTrap(bits(2) target_el, bits(32) instr)"><del>AArch32.AArch32SystemAccessTrap</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>, instr);

    else
        allocated = FALSE;

    if !allocated then
        UNDEFINED;

    // If the instruction is not UNDEFINED, it might be disabled or trapped to a higher EL.
    </del><a href="shared_pseudocode.html#AArch32.CheckSystemAccessTraps.1" title="function: AArch32.CheckSystemAccessTraps(bits(32) instr)"><del>AArch32.CheckSystemAccessTraps</del></a><a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><ins>ProcessorID</ins></a><a href="shared_pseudocode.html#impl-aarch32.CP14JazelleInstrDecode.1" title="function: boolean CP14JazelleInstrDecode(bits(32) instr)"><del>CP14JazelleInstrDecode</del></a><ins>(), size);
</ins><del>(instr);
</del>
<ins>    return passed;</ins><del>    return;</del></p></div><div class="ps" psname="aarch32.functions.exclusive.AArch32.IsExclusiveVA"><a id="aarch32.functions.exclusive.AArch32.IsExclusiveVA" name="aarch32.functions.exclusive.AArch32.IsExclusiveVA"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>exclusive</ins><del>coproc</del>/<ins>AArch32.IsExclusiveVA</ins><del>AArch32.CheckSystemAccessEL1Traps</del></h3><p class="pseudocode"><ins>// An optional IMPLEMENTATION DEFINED test for an exclusive access to a virtual
// address region of size bytes starting at address.
//
// It is permitted (but not required) for this function to return FALSE and
// cause a store exclusive to fail if the virtual address region is not
// totally included within the region recorded by MarkExclusiveVA().
//
// It is always safe to return TRUE which will check the physical address only.
boolean</ins><del>// AArch32.CheckSystemAccessEL1Traps()
// ===================================
// Check for configurable disables or traps to EL1 or EL2 of a System register
// access instruction.</del> <a id="AArch32.IsExclusiveVA.3" name="AArch32.IsExclusiveVA.3"></a><ins>AArch32.IsExclusiveVA(bits(32) address, integer processorid, integer size);</ins><del>AArch32.CheckSystemAccessEL1Traps(bits(32) instr)
    assert PSTATE.EL ==</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>;

    if ((</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>) &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>() &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>)) || </del><a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><del>IsInHost</del></a><del>()) then
        </del><a href="shared_pseudocode.html#AArch64.CheckAArch32SystemAccessEL1Traps.1" title="function: AArch64.CheckAArch32SystemAccessEL1Traps(bits(32) instr)"><del>AArch64.CheckAArch32SystemAccessEL1Traps</del></a><del>(instr);
        return;
    trap = FALSE;

    // Decode the AArch32 System register access instruction
    (op, cp_num, opc1, CRn, CRm, opc2, write) = </del><a href="shared_pseudocode.html#AArch32.DecodeSysRegAccess.1" title="function: (SystemAccessType, integer, integer, integer, integer, integer, boolean) AArch32.DecodeSysRegAccess(bits(32) instr)"><del>AArch32.DecodeSysRegAccess</del></a><del>(instr);

    if cp_num == 14 then
        if ((op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 0 &amp;&amp; CRm == 5 &amp;&amp; opc2 == 0) || // DBGDTRRXint/DBGDTRTXint
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_DT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_DT</del></a><del> &amp;&amp; CRn == 5 &amp;&amp; opc2 == 0)) then                       // DBGDTRRXint/DBGDTRTXint (STC/LDC)
            trap = !</del><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><del>Halted</del></a><del>() &amp;&amp; DBGDSCRext.UDCCdis == '1';

        elsif opc1 == 0 then
            trap = DBGDSCRext.UDCCdis == '1';

        elsif opc1 == 1 then
            trap = CPACR.TRCDIS == '1';
            if </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; NSACR.NSTRCDIS == '1' then
                trap = TRUE;

    elsif cp_num == 15 then
        if ((op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 9 &amp;&amp; CRm == 12 &amp;&amp; opc2 == 0) || // PMCR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 9 &amp;&amp; CRm == 12 &amp;&amp; opc2 == 1) || // PMCNTENSET
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 9 &amp;&amp; CRm == 12 &amp;&amp; opc2 == 2) || // PMCNTENCLR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 9 &amp;&amp; CRm == 12 &amp;&amp; opc2 == 3) || // PMOVSR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 9 &amp;&amp; CRm == 12 &amp;&amp; opc2 == 6) || // PMCEID0
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 9 &amp;&amp; CRm == 12 &amp;&amp; opc2 == 7) || // PMCEID1
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 9 &amp;&amp; CRm == 13 &amp;&amp; opc2 == 1) || // PMXEVTYPER
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 9 &amp;&amp; CRm == 14 &amp;&amp; opc2 == 3) || // PMOVSSET
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 14 &amp;&amp; CRm >= 12)) then          // PMEVTYPER&lt;n>
            trap = PMUSERENR.EN == '0';

        elsif op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 9 &amp;&amp; CRm == 14 &amp;&amp; opc2 == 4 then // PMSWINC
            trap = PMUSERENR.EN == '0' &amp;&amp; PMUSERENR.SW == '0';

        elsif ((op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 9 &amp;&amp; CRm == 13 &amp;&amp; opc2 == 0) || // PMCCNTR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RRT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RRT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRm == 9)) then                          // PMCCNTR (MRRC/MCRR)
            trap = PMUSERENR.EN == '0' &amp;&amp; (write || PMUSERENR.CR == '0');

        elsif ((op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 9 &amp;&amp; CRm == 13 &amp;&amp; opc2 == 2) || // PMXEVCNTR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 14 &amp;&amp; CRm >= 8 &amp;&amp; CRm &lt;= 11)) then  // PMEVCNTR&lt;n>
            trap = PMUSERENR.EN == '0' &amp;&amp; (write || PMUSERENR.ER == '0');

        elsif op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 9 &amp;&amp; CRm == 12 &amp;&amp; opc2 == 5 then    // PMSELR
            trap = PMUSERENR.EN == '0' &amp;&amp; PMUSERENR.ER == '0';

        elsif op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 14 &amp;&amp; CRm == 2 &amp;&amp; opc2 IN {0,1,2} then // CNTP_TVAL CNTP_CTL CNTP_CVAL
            trap = CNTKCTL.PL0PTEN == '0';

        elsif op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 14 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 0 then       // CNTFRQ
            trap = CNTKCTL.PL0PCTEN == '0' &amp;&amp; CNTKCTL.PL0VCTEN == '0';

        elsif op == </del><a href="shared_pseudocode.html#SystemAccessType_RRT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RRT</del></a><del> &amp;&amp; opc1 == 1 &amp;&amp; CRm == 14 then                               // CNTVCT
            trap = CNTKCTL.PL0VCTEN == '0';

    if trap then
        </del><a href="shared_pseudocode.html#AArch32.AArch32SystemAccessTrap.2" title="function: AArch32.AArch32SystemAccessTrap(bits(2) target_el, bits(32) instr)"><del>AArch32.AArch32SystemAccessTrap</del></a><del>(</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>, instr);</del></p></div><div class="ps" psname="aarch32.functions.exclusive.AArch32.MarkExclusiveVA"><a id="aarch32.functions.exclusive.AArch32.MarkExclusiveVA" name="aarch32.functions.exclusive.AArch32.MarkExclusiveVA"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>exclusive</ins><del>coproc</del>/<ins>AArch32.MarkExclusiveVA</ins><del>AArch32.CheckSystemAccessEL2Traps</del></h3><p class="pseudocode"><ins>// Optionally record an exclusive access to the virtual address region of size bytes
// starting at address for processorid.</ins><del>// AArch32.CheckSystemAccessEL2Traps()
// ===================================
// Check for configurable traps to EL2 of a System register access instruction.</del>
<a id="AArch32.MarkExclusiveVA.3" name="AArch32.MarkExclusiveVA.3"></a><ins>AArch32.MarkExclusiveVA(bits(32) address, integer processorid, integer size);</ins><del>AArch32.CheckSystemAccessEL2Traps(bits(32) instr)
    assert</del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; PSTATE.EL IN {</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>, </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>, </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>};

    if </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) then
        </del><a href="shared_pseudocode.html#AArch64.CheckAArch32SystemAccessEL2Traps.1" title="function: AArch64.CheckAArch32SystemAccessEL2Traps(bits(32) instr)"><del>AArch64.CheckAArch32SystemAccessEL2Traps</del></a><del>(instr);
        return;
    trap = FALSE;

    // Decode the AArch32 System register access instruction
    (op, cp_num, opc1, CRn, CRm, opc2, write) = </del><a href="shared_pseudocode.html#AArch32.DecodeSysRegAccess.1" title="function: (SystemAccessType, integer, integer, integer, integer, integer, boolean) AArch32.DecodeSysRegAccess(bits(32) instr)"><del>AArch32.DecodeSysRegAccess</del></a><del>(instr);

    if cp_num == 14 &amp;&amp; PSTATE.EL IN {</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>, </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>} then
        if ((op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 1 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 0) || // DBGDRAR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RRT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RRT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRm == 1) ||                         // DBGDRAR (MRRC)
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 2 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 0) || // DBGDSAR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RRT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RRT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRm == 2)) then                      // DBGDSAR (MRRC)
            trap = HDCR.TDRA == '1' || HDCR.TDE == '1' || HCR.TGE == '1';

        elsif ((op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 1 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 4) || // DBGOSLAR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 1 &amp;&amp; CRm == 1 &amp;&amp; opc2 == 4) ||    // DBGOSLSR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 1 &amp;&amp; CRm == 3 &amp;&amp; opc2 == 4) ||    // DBGOSDLR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 1 &amp;&amp; CRm == 4 &amp;&amp; opc2 == 4)) then // DBGPRCR
            trap = HDCR.TDOSA == '1' || HDCR.TDE == '1' || HCR.TGE == '1';

        elsif opc1 == 0 &amp;&amp; (!</del><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><del>Halted</del></a><del>() || !(op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; CRn == 0 &amp;&amp; CRm == 5 &amp;&amp; opc2 == 0)) then
            trap = HDCR.TDA == '1' || HDCR.TDE == '1' || HCR.TGE == '1';

        elsif opc1 == 1 then
            trap = HCPTR.TTA == '1';
            if </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; NSACR.NSTRCDIS == '1' then
                trap = TRUE;

        elsif op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 7 &amp;&amp; CRn == 0 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 0 then  // JIDR
            trap = HCR.TID0 == '1';

    elsif cp_num == 14 &amp;&amp; PSTATE.EL == </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del> then
        if opc1 == 1 then
            trap = HCPTR.TTA == '1';

    elsif cp_num == 15 &amp;&amp; PSTATE.EL IN {</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>, </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>} then
        if ((op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 1 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 0) ||  // SCTLR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 2 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 0) ||  // TTBR0
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RRT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RRT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRm == 2) ||                          // TTBR0 (MRRC/MCCR)
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 2 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 1) ||  // TTBR1
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RRT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RRT</del></a><del> &amp;&amp; opc1 == 1 &amp;&amp; CRm == 2) ||                          // TTBR1 (MRRC/MCCR)
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 2 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 2) ||  // TTBCR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 2 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 3) ||  // TTBCR2
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 3 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 0) ||  // DACR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 5 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 0) ||  // DFSR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 5 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 1) ||  // IFSR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 6 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 0) ||  // DFAR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 6 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 2) ||  // IFAR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 5 &amp;&amp; CRm == 1 &amp;&amp; opc2 == 0) ||  // ADFSR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 5 &amp;&amp; CRm == 1 &amp;&amp; opc2 == 1) ||  // AIFSR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 10 &amp;&amp; CRm == 2 &amp;&amp; opc2 == 0) || // PRRR/MAIR0
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 10 &amp;&amp; CRm == 2 &amp;&amp; opc2 == 1) || // NMRR/MAIR1
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 10 &amp;&amp; CRm == 3 &amp;&amp; opc2 == 0) || // AMAIR0
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 10 &amp;&amp; CRm == 3 &amp;&amp; opc2 == 1) || // AMAIR1
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 13 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 1)) then // CONTEXTIDR
            trap = if write then HCR.TVM == '1' else HCR.TRVM == '1';
        elsif op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 8 then                         // TLBI
            trap = write &amp;&amp; HCR.TTLB == '1';
        elsif ((op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 7 &amp;&amp; CRm == 6 &amp;&amp; opc2 == 2) ||  // DCISW
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 7 &amp;&amp; CRm == 10 &amp;&amp; opc2 == 2) ||    // DCCSW
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 7 &amp;&amp; CRm == 14 &amp;&amp; opc2 == 2)) then // DCCISW
            trap = write &amp;&amp; HCR.TSW == '1';

        elsif ((op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 7 &amp;&amp; CRm == 6 &amp;&amp; opc2 == 1) ||  // DCIMVAC
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 7 &amp;&amp; CRm == 10 &amp;&amp; opc2 == 1) ||    // DCCMVAC
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 7 &amp;&amp; CRm == 14 &amp;&amp; opc2 == 1)) then // DCCIMVAC
            trap = write &amp;&amp; HCR.TPC == '1';

        elsif ((op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 7 &amp;&amp; CRm == 5 &amp;&amp; opc2 == 1) ||  // ICIMVAU
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 7 &amp;&amp; CRm == 5 &amp;&amp; opc2 == 0) ||     // ICIALLU
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 7 &amp;&amp; CRm == 1 &amp;&amp; opc2 == 0) ||     // ICIALLUIS
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 7 &amp;&amp; CRm == 11 &amp;&amp; opc2 == 1)) then // DCCMVAU
            trap = write &amp;&amp; HCR.TPU == '1';

        elsif ((op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 1 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 1) ||   // ACTLR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 1 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 3)) then   // ACTLR2
            trap = HCR.TAC == '1';

        elsif ((op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 0 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 2) ||  // TCMTR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 0 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 3) ||     // TLBTR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 0 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 6) ||     // REVIDR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 1 &amp;&amp; CRn == 0 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 7)) then  // AIDR
            trap = HCR.TID1 == '1';

        elsif ((op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 0 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 1) ||  // CTR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 1 &amp;&amp; CRn == 0 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 0) ||     // CCSIDR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 1 &amp;&amp; CRn == 0 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 2) ||     // CCSIDR2
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 1 &amp;&amp; CRn == 0 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 1) ||     // CLIDR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 2 &amp;&amp; CRn == 0 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 0)) then  // CSSELR
            trap = HCR.TID2 == '1';

        elsif ((op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 0 &amp;&amp; CRm == 1) ||               // ID_*
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 0 &amp;&amp; CRm == 2 &amp;&amp; opc2 &lt;= 7) ||     // ID_*
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 0 &amp;&amp; CRm >= 3 &amp;&amp; opc2 &lt;= 1) ||     // Reserved
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 0 &amp;&amp; CRm == 3 &amp;&amp; opc2 == 2) ||     // Reserved
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 0 &amp;&amp; CRm == 5 &amp;&amp; opc2 IN {4,5})) then  // Reserved
            trap = HCR.TID3 == '1';

        elsif op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 1 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 2 then   // CPACR
            trap = HCPTR.TCPAC == '1';

        elsif op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 9 &amp;&amp; CRm == 12 &amp;&amp; opc2 == 0 then  // PMCR
            trap = HDCR.TPMCR == '1' || HDCR.TPM == '1';

        elsif ((op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 14 &amp;&amp; CRm >= 8) ||      // PMEVCNTR&lt;n>/PMEVTYPER&lt;n>
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 9 &amp;&amp; CRm IN {12,13,14}) || // PM*
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RRT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RRT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRm == 9)) then                  // PMCCNTR (MRRC/MCCR)
            trap = HDCR.TPM == '1';

        elsif op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 14 &amp;&amp; CRm == 2 &amp;&amp; opc2 IN {0,1,2} then      // CNTP_TVAL CNTP_CTL CNTP_CVAL
            trap = CNTHCTL.PL1PCEN == '0';
        elsif op == </del><a href="shared_pseudocode.html#SystemAccessType_RRT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RRT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRm == 14 then                                    // CNTPCT
            trap = CNTHCTL.PL1PCTEN == '0';

        elsif ((op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 1 &amp;&amp; CRm == 1 &amp;&amp; opc2 == 0) ||    // SCR
               (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 1 &amp;&amp; CRm == 1 &amp;&amp; opc2 == 2) ||    // NSACR
               (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 12 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 1) ||   // MVBAR
               (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 1 &amp;&amp; CRm == 3 &amp;&amp; opc2 == 1) ||    // SDCR
               (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 7 &amp;&amp; CRm == 8 &amp;&amp; opc2 >= 4)) then // ATS12NSOxx
            trap = </del><a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()"><del>IsSecureEL2Enabled</del></a><del>() &amp;&amp; PSTATE.EL == </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del> &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>() &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>);

    if trap then
        </del><a href="shared_pseudocode.html#AArch32.AArch32SystemAccessTrap.2" title="function: AArch32.AArch32SystemAccessTrap(bits(2) target_el, bits(32) instr)"><del>AArch32.AArch32SystemAccessTrap</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>, instr);</del></p></div><div class="ps" psname="aarch32.functions.exclusive.AArch32.SetExclusiveMonitors"><a id="aarch32.functions.exclusive.AArch32.SetExclusiveMonitors" name="aarch32.functions.exclusive.AArch32.SetExclusiveMonitors"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>exclusive</ins><del>coproc</del>/<ins>AArch32.SetExclusiveMonitors</ins><del>AArch32.CheckSystemAccessTraps</del></h3><p class="pseudocode"><ins>// AArch32.SetExclusiveMonitors()
// ==============================

// Sets the Exclusives monitors for the current PE to record the addresses associated
// with the virtual address region of size bytes starting at address.</ins><del>// AArch32.CheckSystemAccessTraps()
// ================================
// Check for configurable disables or traps to a higher EL of an System register access.</del>

<a id="AArch32.SetExclusiveMonitors.2" name="AArch32.SetExclusiveMonitors.2"></a><ins>AArch32.SetExclusiveMonitors(bits(32) address, integer size)
</ins><del>AArch32.CheckSystemAccessTraps(bits(32) instr)
</del>
<ins>    acctype =</ins><del>    if PSTATE.EL ==</del> <a href="shared_pseudocode.html#AccType_ATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ATOMIC</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>;
    iswrite = FALSE;
    aligned = (address ==</ins><del>then</del> <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)"><ins>Align</ins></a><a href="shared_pseudocode.html#AArch32.CheckSystemAccessEL1Traps.1" title="function: AArch32.CheckSystemAccessEL1Traps(bits(32) instr)"><del>AArch32.CheckSystemAccessEL1Traps</del></a><ins>(address, size));
    memaddrdesc =</ins><del>(instr);
    if</del> <a href="shared_pseudocode.html#AArch32.TranslateAddress.5" title="function: AddressDescriptor AArch32.TranslateAddress(bits(32) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><ins>AArch32.TranslateAddress</ins></a><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><ins>(address, acctype, iswrite, aligned, size);

    // Check for aborts or debug exceptions
    if</ins><del>() &amp;&amp; PSTATE.EL IN {</del> <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>(memaddrdesc) then
        return;

    if memaddrdesc.memattrs.shareable then</ins><del>,</del>
        <a href="shared_pseudocode.html#impl-shared.MarkExclusiveGlobal.3" title="function: MarkExclusiveGlobal(FullAddress paddress, integer processorid, integer size)"><ins>MarkExclusiveGlobal</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>(memaddrdesc.paddress,</ins><del>,</del> <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><ins>ProcessorID</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>(), size);</ins><del>} &amp;&amp; !</del>

    <a href="shared_pseudocode.html#impl-shared.MarkExclusiveLocal.3" title="function: MarkExclusiveLocal(FullAddress paddress, integer processorid, integer size)"><ins>MarkExclusiveLocal</ins></a><a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><del>IsInHost</del></a><ins>(memaddrdesc.paddress,</ins><del>() then</del> <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><ins>ProcessorID</ins></a><a href="shared_pseudocode.html#AArch32.CheckSystemAccessEL2Traps.1" title="function: AArch32.CheckSystemAccessEL2Traps(bits(32) instr)"><del>AArch32.CheckSystemAccessEL2Traps</del></a><ins>(), size);</ins><del>(instr);
    if</del>

    <a href="shared_pseudocode.html#AArch32.MarkExclusiveVA.3" title="function: AArch32.MarkExclusiveVA(bits(32) address, integer processorid, integer size)"><ins>AArch32.MarkExclusiveVA</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>(address,</ins><del>(</del> <del>) &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; PSTATE.EL IN {</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>,</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>,</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>} then
        </del><a href="shared_pseudocode.html#AArch64.CheckAArch32SystemAccessEL3Traps.1" title="function: AArch64.CheckAArch32SystemAccessEL3Traps(bits(32) instr)"><del>AArch64.CheckAArch32SystemAccessEL3Traps</del></a><a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><ins>ProcessorID</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><ins>(), size);</ins><del>(instr);</del></p></div><div class="ps" psname="aarch32.functions.float.CheckAdvSIMDEnabled"><a id="aarch32.functions.float.CheckAdvSIMDEnabled" name="aarch32.functions.float.CheckAdvSIMDEnabled"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>float</ins><del>coproc</del>/<ins>CheckAdvSIMDEnabled</ins><del>AArch32.DecodeSysRegAccess</del></h3><p class="pseudocode"><ins>// CheckAdvSIMDEnabled()
// =====================</ins><del>// AArch32.DecodeSysRegAccess()
// ============================
// Decode an AArch32 System register access instruction into its operands.

(SystemAccessType, integer, integer, integer, integer, integer, boolean)</del>

<a id="impl-aarch32.CheckAdvSIMDEnabled.0" name="impl-aarch32.CheckAdvSIMDEnabled.0"></a><ins>CheckAdvSIMDEnabled()
</ins><del>AArch32.DecodeSysRegAccess(bits(32) instr)
</del>
<ins>    fpexc_check = TRUE;
    advsimd = TRUE;</ins><del>    cp_num =</del>

    <a href="shared_pseudocode.html#AArch32.CheckAdvSIMDOrFPEnabled.2" title="function: AArch32.CheckAdvSIMDOrFPEnabled(boolean fpexc_check, boolean advsimd)"><ins>AArch32.CheckAdvSIMDOrFPEnabled</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>(fpexc_check, advsimd);
    // Return from CheckAdvSIMDOrFPEnabled() occurs only if Advanced SIMD access is permitted
</ins><del>(instr&lt;11:8>);
</del>
<ins>    // Make temporary copy of D registers
    // _Dclone[] is used as input data for instruction pseudocode
    for i = 0 to 31
        _Dclone[i] =</ins><del>    // Decode the AArch32 System register access instruction
    if instr&lt;31:28> != '1111' &amp;&amp; instr&lt;27:24> == '1110' &amp;&amp; instr&lt;4> == '1' then   // MRC/MCR
        op    =</del> <del>;
        opc1  = </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(instr&lt;23:21>);
        opc2  = </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(instr&lt;7:5>);
        CRn   = </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(instr&lt;19:16>);
        CRm   = </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(instr&lt;3:0>);
        write = instr&lt;20> == '0';
    elsif instr&lt;31:28> != '1111' &amp;&amp; instr&lt;27:21> == '1100010' then                // MRRC/MCRR
        op    = </del><a href="shared_pseudocode.html#SystemAccessType_RRT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RRT</del></a><del>;
        opc1  = </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(instr&lt;7:4>);
        CRm   = </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(instr&lt;3:0>);
        write = instr&lt;20> == '0';
    elsif instr&lt;31:28> != '1111' &amp;&amp; instr&lt;27:25> == '110' then                    // LDC/STC
        op    = </del><a href="shared_pseudocode.html#SystemAccessType_DT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_DT</del></a><del>;
        CRn   = </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><a href="shared_pseudocode.html#impl-aarch32.D.read.1" title="accessor: bits(64) D[integer n]"><ins>D</ins></a><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><ins>[i];
</ins><del>(instr&lt;15:12>);
        write = instr&lt;20> == '0';
</del>
<ins>    return;</ins><del>    return (op, cp_num, opc1, CRn, CRm, opc2, write);</del></p></div><div class="ps" psname="aarch32.functions.float.CheckAdvSIMDOrVFPEnabled"><a id="aarch32.functions.float.CheckAdvSIMDOrVFPEnabled" name="aarch32.functions.float.CheckAdvSIMDOrVFPEnabled"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>float</ins><del>coproc</del>/<ins>CheckAdvSIMDOrVFPEnabled</ins><del>CP14DebugInstrDecode</del></h3><p class="pseudocode"><ins>// CheckAdvSIMDOrVFPEnabled()
// ==========================</ins><del>// Decodes an accepted access to a debug System register in the CP14 encoding space.
// Returns TRUE if the instruction is allocated at the current Exception level, FALSE otherwise.
boolean</del>

<a id="impl-aarch32.CheckAdvSIMDOrVFPEnabled.2" name="impl-aarch32.CheckAdvSIMDOrVFPEnabled.2"></a><ins>CheckAdvSIMDOrVFPEnabled(boolean include_fpexc_check, boolean advsimd)</ins><del>CP14DebugInstrDecode(bits(32) instr);</del>
    <a href="shared_pseudocode.html#AArch32.CheckAdvSIMDOrFPEnabled.2" title="function: AArch32.CheckAdvSIMDOrFPEnabled(boolean fpexc_check, boolean advsimd)"><ins>AArch32.CheckAdvSIMDOrFPEnabled</ins></a><ins>(include_fpexc_check, advsimd);
    // Return from CheckAdvSIMDOrFPEnabled() occurs only if VFP access is permitted
    return;</ins></p></div><div class="ps" psname="aarch32.functions.float.CheckCryptoEnabled32"><a id="aarch32.functions.float.CheckCryptoEnabled32" name="aarch32.functions.float.CheckCryptoEnabled32"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>float</ins><del>coproc</del>/<ins>CheckCryptoEnabled32</ins><del>CP14JazelleInstrDecode</del></h3><p class="pseudocode"><ins>// CheckCryptoEnabled32()
// ======================</ins><del>// Decodes an accepted access to a Jazelle System register in the CP14 encoding space.
// Returns TRUE if the instruction is allocated at the current Exception level, FALSE otherwise.
boolean</del>

<a id="impl-aarch32.CheckCryptoEnabled32.0" name="impl-aarch32.CheckCryptoEnabled32.0"></a><ins>CheckCryptoEnabled32()</ins><del>CP14JazelleInstrDecode(bits(32) instr);</del>
    <a href="shared_pseudocode.html#impl-aarch32.CheckAdvSIMDEnabled.0" title="function: CheckAdvSIMDEnabled()"><ins>CheckAdvSIMDEnabled</ins></a><ins>();
    // Return from CheckAdvSIMDEnabled() occurs only if access is permitted
    return;</ins></p></div><div class="ps" psname="aarch32.functions.float.CheckVFPEnabled"><a id="aarch32.functions.float.CheckVFPEnabled" name="aarch32.functions.float.CheckVFPEnabled"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>float</ins><del>coproc</del>/<ins>CheckVFPEnabled</ins><del>CP14TraceInstrDecode</del></h3><p class="pseudocode"><ins>// CheckVFPEnabled()
// =================</ins><del>// Decodes an accepted access to a trace System register in the CP14 encoding space.
// Returns TRUE if the instruction is allocated at the current Exception level, FALSE otherwise.
boolean</del>

<a id="impl-aarch32.CheckVFPEnabled.1" name="impl-aarch32.CheckVFPEnabled.1"></a><ins>CheckVFPEnabled(boolean include_fpexc_check)
    advsimd = FALSE;</ins><del>CP14TraceInstrDecode(bits(32) instr);</del>
    <a href="shared_pseudocode.html#AArch32.CheckAdvSIMDOrFPEnabled.2" title="function: AArch32.CheckAdvSIMDOrFPEnabled(boolean fpexc_check, boolean advsimd)"><ins>AArch32.CheckAdvSIMDOrFPEnabled</ins></a><ins>(include_fpexc_check, advsimd);
    // Return from CheckAdvSIMDOrFPEnabled() occurs only if VFP access is permitted
    return;</ins></p></div><div class="ps" psname="aarch32.functions.float.FPHalvedSub"><a id="aarch32.functions.float.FPHalvedSub" name="aarch32.functions.float.FPHalvedSub"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>float</ins><del>coproc</del>/<ins>FPHalvedSub</ins><del>CP15InstrDecode</del></h3><p class="pseudocode"><ins>// FPHalvedSub()
// =============

bits(N)</ins><del>// Decodes an accepted access to a System register in the CP15 encoding space.
// Returns TRUE if the instruction is allocated at the current Exception level, FALSE otherwise.
boolean</del> <a id="impl-aarch32.FPHalvedSub.3" name="impl-aarch32.FPHalvedSub.3"></a><ins>FPHalvedSub(bits(N) op1, bits(N) op2,</ins><del>CP15InstrDecode(bits(32) instr);</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><ins>FPCRType</ins></a><ins> fpcr)
    assert N IN {16,32,64};
    rounding = </ins><a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)"><ins>FPRoundingMode</ins></a><ins>(fpcr);
    (type1,sign1,value1) = </ins><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><ins>(op1, fpcr);
    (type2,sign2,value2) = </ins><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><ins>(op2, fpcr);
    (done,result) = </ins><a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2, FPCRType fpcr)"><ins>FPProcessNaNs</ins></a><ins>(type1, type2, op1, op2, fpcr);
    if !done then
        inf1 = (type1 == </ins><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><ins>);  inf2 = (type2 == </ins><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><ins>);
        zero1 = (type1 == </ins><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><ins>);     zero2 = (type2 == </ins><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><ins>);
        if inf1 &amp;&amp; inf2 &amp;&amp; sign1 == sign2 then
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.0" title="function: bits(N) FPDefaultNaN()"><ins>FPDefaultNaN</ins></a><ins>();
            </ins><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><ins>(</ins><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_InvalidOp</ins></a><ins>, fpcr);
        elsif (inf1 &amp;&amp; sign1 == '0') || (inf2 &amp;&amp; sign2 == '1') then
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><ins>FPInfinity</ins></a><ins>('0');
        elsif (inf1 &amp;&amp; sign1 == '1') || (inf2 &amp;&amp; sign2 == '0') then
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><ins>FPInfinity</ins></a><ins>('1');
        elsif zero1 &amp;&amp; zero2 &amp;&amp; sign1 != sign2 then
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><ins>FPZero</ins></a><ins>(sign1);
        else
            result_value = (value1 - value2) / 2.0;
            if result_value == 0.0 then  // Sign of exact zero result depends on rounding mode
                result_sign = if rounding == </ins><a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_NEGINF</ins></a><ins> then '1' else '0';
                result = </ins><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><ins>FPZero</ins></a><ins>(result_sign);
            else
                result = </ins><a href="shared_pseudocode.html#impl-shared.FPRound.2" title="function: bits(N) FPRound(real op, FPCRType fpcr)"><ins>FPRound</ins></a><ins>(result_value, fpcr);
    return result;</ins></p></div><div class="ps" psname="aarch32.functions.float.FPRSqrtStep"><a id="aarch32.functions.float.FPRSqrtStep" name="aarch32.functions.float.FPRSqrtStep"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>float</ins><del>exclusive</del>/<ins>FPRSqrtStep</ins><del>AArch32.ExclusiveMonitorsPass</del></h3><p class="pseudocode"><ins>// FPRSqrtStep()
// =============
</ins><del>// AArch32.ExclusiveMonitorsPass()
// ===============================
</del>
<ins>bits(N)</ins><del>// Return TRUE if the Exclusives monitors for the current PE include all of the addresses
// associated with the virtual address region of size bytes starting at address.
// The immediately following memory write must be to the same addresses.

boolean</del> <a id="impl-aarch32.FPRSqrtStep.2" name="impl-aarch32.FPRSqrtStep.2"></a><ins>FPRSqrtStep(bits(N) op1, bits(N) op2)
    assert N IN {16,32};</ins><del>AArch32.ExclusiveMonitorsPass(bits(32) address, integer size)

    // It is IMPLEMENTATION DEFINED whether the detection of memory aborts happens
    // before or after the check on the local Exclusives monitor. As a result a failure
    // of the local monitor can occur on some implementations even if the memory
    // access would give an memory abort.

    acctype =</del>
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><ins>FPCRType</ins></a><a href="shared_pseudocode.html#AccType_ATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ATOMIC</del></a> <ins>fpcr =</ins><del>;
    iswrite = TRUE;
    aligned = (address ==</del> <a href="shared_pseudocode.html#impl-aarch32.StandardFPSCRValue.0" title="function: FPCRType StandardFPSCRValue()"><ins>StandardFPSCRValue</ins></a><a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)"><del>Align</del></a><ins>();
    (type1,sign1,value1) =</ins><del>(address, size));

    if !aligned then
        secondstage = FALSE;</del> <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)"><del>AArch32.Abort</del></a><ins>(op1, fpcr);
    (type2,sign2,value2) =</ins><del>(address,</del> <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><a href="shared_pseudocode.html#AArch32.AlignmentFault.3" title="function: FaultRecord AArch32.AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)"><del>AArch32.AlignmentFault</del></a><ins>(op2, fpcr);
    (done,result) =</ins><del>(acctype, iswrite, secondstage));

    passed =</del> <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2, FPCRType fpcr)"><ins>FPProcessNaNs</ins></a><a href="shared_pseudocode.html#AArch32.IsExclusiveVA.3" title="function: boolean AArch32.IsExclusiveVA(bits(32) address, integer processorid, integer size)"><del>AArch32.IsExclusiveVA</del></a><ins>(type1, type2, op1, op2, fpcr);
    if !done then
        inf1 = (type1 ==</ins><del>(address,</del> <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><del>ProcessorID</del></a><ins>);  inf2 = (type2 ==</ins><del>(), size);
    if !passed then
        return FALSE;
    memaddrdesc =</del> <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><a href="shared_pseudocode.html#AArch32.TranslateAddress.5" title="function: AddressDescriptor AArch32.TranslateAddress(bits(32) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><del>AArch32.TranslateAddress</del></a><ins>);
        zero1 = (type1 ==</ins><del>(address, acctype, iswrite, aligned, size);

    // Check for aborts or debug exceptions
    if</del> <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><ins>);     zero2 = (type2 ==</ins><del>(memaddrdesc) then</del> <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)"><del>AArch32.Abort</del></a><ins>);
        bits(N) product;
        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            product =</ins><del>(address, memaddrdesc.fault);

    passed =</del> <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><ins>FPZero</ins></a><a href="shared_pseudocode.html#impl-shared.IsExclusiveLocal.3" title="function: boolean IsExclusiveLocal(FullAddress paddress, integer processorid, integer size)"><del>IsExclusiveLocal</del></a><ins>('0');
        else
            product =</ins><del>(memaddrdesc.paddress,</del> <a href="shared_pseudocode.html#impl-shared.FPMul.3" title="function: bits(N) FPMul(bits(N) op1, bits(N) op2, FPCRType fpcr)"><ins>FPMul</ins></a><a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><del>ProcessorID</del></a><ins>(op1, op2, fpcr);
        bits(N) three =</ins><del>(), size);

    if passed then</del> <a href="shared_pseudocode.html#impl-shared.FPThree.1" title="function: bits(N) FPThree(bit sign)"><ins>FPThree</ins></a><a href="shared_pseudocode.html#impl-shared.ClearExclusiveLocal.1" title="function: ClearExclusiveLocal(integer processorid)"><del>ClearExclusiveLocal</del></a><ins>('0');
        result =</ins><del>(</del> <del>());
        if memaddrdesc.memattrs.shareable then
            passed = </del><a href="shared_pseudocode.html#impl-shared.IsExclusiveGlobal.3" title="function: boolean IsExclusiveGlobal(FullAddress paddress, integer processorid, integer size)"><del>IsExclusiveGlobal</del></a><del>(memaddrdesc.paddress, </del><a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><del>ProcessorID</del></a><a href="shared_pseudocode.html#impl-aarch32.FPHalvedSub.3" title="function: bits(N) FPHalvedSub(bits(N) op1, bits(N) op2, FPCRType fpcr)"><ins>FPHalvedSub</ins></a><a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><del>ProcessorID</del></a><ins>(three, product, fpcr);
    return result;</ins><del>(), size);

    return passed;</del></p></div><div class="ps" psname="aarch32.functions.float.FPRecipStep"><a id="aarch32.functions.float.FPRecipStep" name="aarch32.functions.float.FPRecipStep"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>float</ins><del>exclusive</del>/<ins>FPRecipStep</ins><del>AArch32.IsExclusiveVA</del></h3><p class="pseudocode"><ins>// FPRecipStep()
// =============

bits(N)</ins><del>// An optional IMPLEMENTATION DEFINED test for an exclusive access to a virtual
// address region of size bytes starting at address.
//
// It is permitted (but not required) for this function to return FALSE and
// cause a store exclusive to fail if the virtual address region is not
// totally included within the region recorded by MarkExclusiveVA().
//
// It is always safe to return TRUE which will check the physical address only.
boolean</del> <a id="impl-aarch32.FPRecipStep.2" name="impl-aarch32.FPRecipStep.2"></a><ins>FPRecipStep(bits(N) op1, bits(N) op2)
    assert N IN {16,32};</ins><del>AArch32.IsExclusiveVA(bits(32) address, integer processorid, integer size);</del>
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><ins>FPCRType</ins></a><ins> fpcr = </ins><a href="shared_pseudocode.html#impl-aarch32.StandardFPSCRValue.0" title="function: FPCRType StandardFPSCRValue()"><ins>StandardFPSCRValue</ins></a><ins>();
    (type1,sign1,value1) = </ins><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><ins>(op1, fpcr);
    (type2,sign2,value2) = </ins><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><ins>(op2, fpcr);
    (done,result) = </ins><a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2, FPCRType fpcr)"><ins>FPProcessNaNs</ins></a><ins>(type1, type2, op1, op2, fpcr);
    if !done then
        inf1 = (type1 == </ins><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><ins>);  inf2 = (type2 == </ins><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><ins>);
        zero1 = (type1 == </ins><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><ins>);     zero2 = (type2 == </ins><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><ins>);
        bits(N) product;
        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            product = </ins><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><ins>FPZero</ins></a><ins>('0');
        else
            product = </ins><a href="shared_pseudocode.html#impl-shared.FPMul.3" title="function: bits(N) FPMul(bits(N) op1, bits(N) op2, FPCRType fpcr)"><ins>FPMul</ins></a><ins>(op1, op2, fpcr);
        bits(N) two = </ins><a href="shared_pseudocode.html#impl-shared.FPTwo.1" title="function: bits(N) FPTwo(bit sign)"><ins>FPTwo</ins></a><ins>('0');
        result = </ins><a href="shared_pseudocode.html#impl-shared.FPSub.3" title="function: bits(N) FPSub(bits(N) op1, bits(N) op2, FPCRType fpcr)"><ins>FPSub</ins></a><ins>(two, product, fpcr);
    return result;</ins></p></div><div class="ps" psname="aarch32.functions.float.StandardFPSCRValue"><a id="aarch32.functions.float.StandardFPSCRValue" name="aarch32.functions.float.StandardFPSCRValue"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>float</ins><del>exclusive</del>/<ins>StandardFPSCRValue</ins><del>AArch32.MarkExclusiveVA</del></h3><p class="pseudocode"><ins>// StandardFPSCRValue()
// ====================

FPCRType</ins><del>// Optionally record an exclusive access to the virtual address region of size bytes
// starting at address for processorid.</del> <a id="impl-aarch32.StandardFPSCRValue.0" name="impl-aarch32.StandardFPSCRValue.0"></a><ins>StandardFPSCRValue()
    return '00000' : FPSCR.AHP : '110000' : FPSCR.FZ16 : '0000000000000000000';</ins><del>AArch32.MarkExclusiveVA(bits(32) address, integer processorid, integer size);</del></p></div><div class="ps" psname="aarch32.functions.memory.AArch32.CheckAlignment"><a id="aarch32.functions.memory.AArch32.CheckAlignment" name="aarch32.functions.memory.AArch32.CheckAlignment"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>memory</ins><del>exclusive</del>/<ins>AArch32.CheckAlignment</ins><del>AArch32.SetExclusiveMonitors</del></h3><p class="pseudocode"><ins>// AArch32.CheckAlignment()
// ========================
</ins><del>// AArch32.SetExclusiveMonitors()
// ==============================
</del>
<ins>boolean</ins><del>// Sets the Exclusives monitors for the current PE to record the addresses associated
// with the virtual address region of size bytes starting at address.</del> <a id="AArch32.CheckAlignment.4" name="AArch32.CheckAlignment.4"></a><ins>AArch32.CheckAlignment(bits(32) address, integer alignment,</ins><del>AArch32.SetExclusiveMonitors(bits(32) address, integer size)

    acctype =</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><a href="shared_pseudocode.html#AccType_ATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ATOMIC</del></a> <ins>acctype,
                               boolean iswrite)

    if PSTATE.EL ==</ins><del>;
    iswrite = FALSE;
    aligned = (address ==</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins> &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><ins>()) then
        A = SCTLR[].A; //use AArch64 register, when higher Exception level is using AArch64
    elsif PSTATE.EL == </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins> then
        A = HSCTLR.A;
    else
        A = SCTLR.A;
    aligned = (address == </ins><a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a><ins>(address, alignment));
    atomic  = acctype IN {</ins><del>(address, size));
    memaddrdesc =</del> <a href="shared_pseudocode.html#AccType_ATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ATOMIC</ins></a><a href="shared_pseudocode.html#AArch32.TranslateAddress.5" title="function: AddressDescriptor AArch32.TranslateAddress(bits(32) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><del>AArch32.TranslateAddress</del></a><ins>,</ins><del>(address, acctype, iswrite, aligned, size);

    // Check for aborts or debug exceptions
    if</del> <a href="shared_pseudocode.html#AccType_ATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ATOMICRW</ins></a><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><ins>,</ins><del>(memaddrdesc) then
        return;

    if memaddrdesc.memattrs.shareable then</del> <a href="shared_pseudocode.html#AccType_ORDEREDATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ORDEREDATOMIC</ins></a><a href="shared_pseudocode.html#impl-shared.MarkExclusiveGlobal.3" title="function: MarkExclusiveGlobal(FullAddress paddress, integer processorid, integer size)"><del>MarkExclusiveGlobal</del></a><ins>,</ins><del>(memaddrdesc.paddress,</del> <a href="shared_pseudocode.html#AccType_ORDEREDATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ORDEREDATOMICRW</ins></a><a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><del>ProcessorID</del></a> <ins>};
    ordered = acctype IN {</ins><del>(), size);</del> <a href="shared_pseudocode.html#AccType_ORDERED" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ORDERED</ins></a><a href="shared_pseudocode.html#impl-shared.MarkExclusiveLocal.3" title="function: MarkExclusiveLocal(FullAddress paddress, integer processorid, integer size)"><del>MarkExclusiveLocal</del></a><ins>,</ins><del>(memaddrdesc.paddress,</del> <a href="shared_pseudocode.html#AccType_ORDEREDRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ORDEREDRW</ins></a><a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><del>ProcessorID</del></a><ins>,</ins><del>(), size);</del> <a href="shared_pseudocode.html#AccType_LIMITEDORDERED" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_LIMITEDORDERED</ins></a><a href="shared_pseudocode.html#AArch32.MarkExclusiveVA.3" title="function: AArch32.MarkExclusiveVA(bits(32) address, integer processorid, integer size)"><del>AArch32.MarkExclusiveVA</del></a><ins>,</ins><del>(address,</del> <a href="shared_pseudocode.html#AccType_ORDEREDATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ORDEREDATOMIC</ins></a><a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><del>ProcessorID</del></a><ins>, </ins><a href="shared_pseudocode.html#AccType_ORDEREDATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ORDEREDATOMICRW</ins></a><ins> };
    vector  = acctype == </ins><a href="shared_pseudocode.html#AccType_VEC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_VEC</ins></a><ins>;

    // AccType_VEC is used for SIMD element alignment checks only
    check = (atomic || ordered || vector || A == '1');

    if check &amp;&amp; !aligned then
        secondstage = FALSE;
        </ins><a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)"><ins>AArch32.Abort</ins></a><ins>(address, </ins><a href="shared_pseudocode.html#AArch32.AlignmentFault.3" title="function: FaultRecord AArch32.AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)"><ins>AArch32.AlignmentFault</ins></a><ins>(acctype, iswrite, secondstage));

    return aligned;</ins><del>(), size);</del></p></div><div class="ps" psname="aarch32.functions.memory.AArch32.MemSingle"><a id="aarch32.functions.memory.AArch32.MemSingle" name="aarch32.functions.memory.AArch32.MemSingle"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>memory</ins><del>float</del>/<ins>AArch32.MemSingle</ins><del>CheckAdvSIMDEnabled</del></h3><p class="pseudocode"><ins>// AArch32.MemSingle[] - non-assignment (read) form
// ================================================
// Perform an atomic, little-endian read of 'size' bytes.

bits(size*8)</ins><del>// CheckAdvSIMDEnabled()
// =====================</del> <a id="AArch32.MemSingle.read.4" name="AArch32.MemSingle.read.4"></a><ins>AArch32.MemSingle[bits(32) address, integer size,</ins><del>CheckAdvSIMDEnabled()

    fpexc_check = TRUE;
    advsimd = TRUE;</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><a href="shared_pseudocode.html#AArch32.CheckAdvSIMDOrFPEnabled.2" title="function: AArch32.CheckAdvSIMDOrFPEnabled(boolean fpexc_check, boolean advsimd)"><del>AArch32.CheckAdvSIMDOrFPEnabled</del></a> <ins>acctype, boolean wasaligned]
    assert size IN {1, 2, 4, 8, 16};
    assert address ==</ins><del>(fpexc_check, advsimd);
    // Return from CheckAdvSIMDOrFPEnabled() occurs only if Advanced SIMD access is permitted

    // Make temporary copy of D registers
    // _Dclone[] is used as input data for instruction pseudocode
    for i = 0 to 31
        _Dclone[i] =</del> <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)"><ins>Align</ins></a><a href="shared_pseudocode.html#impl-aarch32.D.read.1" title="accessor: bits(64) D[integer n]"><del>D</del></a><ins>(address, size);

    </ins><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><ins>AddressDescriptor</ins></a><ins> memaddrdesc;
    bits(size*8) value;
    iswrite = FALSE;

    // MMU or MPU
    memaddrdesc = </ins><a href="shared_pseudocode.html#AArch32.TranslateAddress.5" title="function: AddressDescriptor AArch32.TranslateAddress(bits(32) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><ins>AArch32.TranslateAddress</ins></a><ins>(address, acctype, iswrite, wasaligned, size);
    // Check for aborts or debug exceptions
    if </ins><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><ins>(memaddrdesc) then
        </ins><a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)"><ins>AArch32.Abort</ins></a><ins>(address, memaddrdesc.fault);

    // Memory array access
    accdesc = CreateAccessDescriptor(acctype);
    if </ins><a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()"><ins>HaveMTEExt</ins></a><ins>() then
        if </ins><a href="shared_pseudocode.html#impl-aarch32.AccessIsTagChecked.2" title="function: boolean AccessIsTagChecked(bits(64) vaddr, AccType acctype)"><ins>AccessIsTagChecked</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><ins>ZeroExtend</ins></a><ins>(address, 64), acctype) then
            bits(4) ptag = </ins><a href="shared_pseudocode.html#impl-aarch32.TransformTag.1" title="function: bits(4) TransformTag(bits(64) vaddr)"><ins>TransformTag</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><ins>ZeroExtend</ins></a><ins>(address, 64));
            if !</ins><a href="shared_pseudocode.html#impl-aarch32.CheckTag.3" title="function: boolean CheckTag(AddressDescriptor memaddrdesc, bits(4) ptag, boolean write)"><ins>CheckTag</ins></a><ins>(memaddrdesc, ptag, iswrite) then
                </ins><a href="shared_pseudocode.html#impl-aarch32.TagCheckFail.2" title="function: TagCheckFail(bits(64) vaddress, boolean iswrite)"><ins>TagCheckFail</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><ins>ZeroExtend</ins></a><ins>(address, 64), iswrite);
    value = _Mem[memaddrdesc, size, accdesc];
    return value;

// AArch32.MemSingle[] - assignment (write) form
// =============================================
// Perform an atomic, little-endian write of 'size' bytes.

</ins><a id="AArch32.MemSingle.write.4" name="AArch32.MemSingle.write.4"></a><ins>AArch32.MemSingle[bits(32) address, integer size, </ins><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><ins> acctype, boolean wasaligned] = bits(size*8) value
    assert size IN {1, 2, 4, 8, 16};
    assert address == </ins><a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)"><ins>Align</ins></a><ins>(address, size);

    </ins><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><ins>AddressDescriptor</ins></a><ins> memaddrdesc;
    iswrite = TRUE;

    // MMU or MPU
    memaddrdesc = </ins><a href="shared_pseudocode.html#AArch32.TranslateAddress.5" title="function: AddressDescriptor AArch32.TranslateAddress(bits(32) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><ins>AArch32.TranslateAddress</ins></a><ins>(address, acctype, iswrite, wasaligned, size);

    // Check for aborts or debug exceptions
    if </ins><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><ins>(memaddrdesc) then
        </ins><a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)"><ins>AArch32.Abort</ins></a><ins>(address, memaddrdesc.fault);

    // Effect on exclusives
    if memaddrdesc.memattrs.shareable then
        </ins><a href="shared_pseudocode.html#impl-shared.ClearExclusiveByAddress.3" title="function: ClearExclusiveByAddress(FullAddress paddress, integer processorid, integer size)"><ins>ClearExclusiveByAddress</ins></a><ins>(memaddrdesc.paddress, </ins><a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><ins>ProcessorID</ins></a><ins>(), size);

    // Memory array access
    accdesc = CreateAccessDescriptor(acctype);
    if </ins><a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()"><ins>HaveMTEExt</ins></a><ins>() then
        if </ins><a href="shared_pseudocode.html#impl-aarch32.AccessIsTagChecked.2" title="function: boolean AccessIsTagChecked(bits(64) vaddr, AccType acctype)"><ins>AccessIsTagChecked</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><ins>ZeroExtend</ins></a><ins>(address, 64), acctype) then
            bits(4) ptag = </ins><a href="shared_pseudocode.html#impl-aarch32.TransformTag.1" title="function: bits(4) TransformTag(bits(64) vaddr)"><ins>TransformTag</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><ins>ZeroExtend</ins></a><ins>(address, 64));
            if !</ins><a href="shared_pseudocode.html#impl-aarch32.CheckTag.3" title="function: boolean CheckTag(AddressDescriptor memaddrdesc, bits(4) ptag, boolean write)"><ins>CheckTag</ins></a><ins>(memaddrdesc, ptag, iswrite) then
                </ins><a href="shared_pseudocode.html#impl-aarch32.TagCheckFail.2" title="function: TagCheckFail(bits(64) vaddress, boolean iswrite)"><ins>TagCheckFail</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><ins>ZeroExtend</ins></a><ins>(address, 64), iswrite);
    _Mem[memaddrdesc, size, accdesc] = value;
</ins><del>[i];

</del>    return;</p></div><div class="ps" psname="aarch32.functions.memory.AddressWithAllocationTag"><a id="aarch32.functions.memory.AddressWithAllocationTag" name="aarch32.functions.memory.AddressWithAllocationTag"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>memory</ins><del>float</del>/<ins>AddressWithAllocationTag</ins><del>CheckAdvSIMDOrVFPEnabled</del></h3><p class="pseudocode"><ins>// AddressWithAllocationTag()
// ==========================
// Generate a 64-bit value containing a Logical Address Tag from a 64-bit
// virtual address and an Allocation Tag.
// If the extension is disabled, treats the Allocation Tag as â0000â.

bits(64)</ins><del>// CheckAdvSIMDOrVFPEnabled()
// ==========================</del> <a id="impl-shared.AddressWithAllocationTag.2" name="impl-shared.AddressWithAllocationTag.2"></a><ins>AddressWithAllocationTag(bits(64) address, bits(4) allocation_tag)
    bits(64) result = address;
    bits(4) tag = allocation_tag - ('000':address&lt;55>);
    result&lt;59:56> = tag;
    return result;</ins><del>CheckAdvSIMDOrVFPEnabled(boolean include_fpexc_check, boolean advsimd)</del><a href="shared_pseudocode.html#AArch32.CheckAdvSIMDOrFPEnabled.2" title="function: AArch32.CheckAdvSIMDOrFPEnabled(boolean fpexc_check, boolean advsimd)"><del>AArch32.CheckAdvSIMDOrFPEnabled</del></a><del>(include_fpexc_check, advsimd);
    // Return from CheckAdvSIMDOrFPEnabled() occurs only if VFP access is permitted
    return;</del></p></div><div class="ps" psname="aarch32.functions.memory.AllocationTagFromAddress"><a id="aarch32.functions.memory.AllocationTagFromAddress" name="aarch32.functions.memory.AllocationTagFromAddress"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>memory</ins><del>float</del>/<ins>AllocationTagFromAddress</ins><del>CheckCryptoEnabled32</del></h3><p class="pseudocode"><ins>// AllocationTagFromAddress()
// ==========================
// Generate a Tag from a 64-bit value containing a Logical Address Tag.
// If access to Allocation Tags is disabled, this function returns â0000â.

bits(4)</ins><del>// CheckCryptoEnabled32()
// ======================</del> <a id="impl-shared.AllocationTagFromAddress.1" name="impl-shared.AllocationTagFromAddress.1"></a><ins>AllocationTagFromAddress(bits(64) tagged_address)
    bits(4) logical_tag = tagged_address&lt;59:56>;
    bits(4) tag = logical_tag + ('000':tagged_address&lt;55>);
    return tag;</ins><del>CheckCryptoEnabled32()</del><a href="shared_pseudocode.html#impl-aarch32.CheckAdvSIMDEnabled.0" title="function: CheckAdvSIMDEnabled()"><del>CheckAdvSIMDEnabled</del></a><del>();
    // Return from CheckAdvSIMDEnabled() occurs only if access is permitted
    return;</del></p></div><div class="ps" psname="aarch32.functions.memory.CheckTag"><a id="aarch32.functions.memory.CheckTag" name="aarch32.functions.memory.CheckTag"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>memory</ins><del>float</del>/<ins>CheckTag</ins><del>CheckVFPEnabled</del></h3><p class="pseudocode"><ins>// CheckTag()
// ==========
// Performs a Tag Check operation for a memory access and returns
// whether the check passed

boolean</ins><del>// CheckVFPEnabled()
// =================</del> <a id="impl-shared.CheckTag.3" name="impl-shared.CheckTag.3"></a><ins>CheckTag(</ins><del>CheckVFPEnabled(boolean include_fpexc_check)
    advsimd = FALSE;</del><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><ins>AddressDescriptor</ins></a><a href="shared_pseudocode.html#AArch32.CheckAdvSIMDOrFPEnabled.2" title="function: AArch32.CheckAdvSIMDOrFPEnabled(boolean fpexc_check, boolean advsimd)"><del>AArch32.CheckAdvSIMDOrFPEnabled</del></a><ins> memaddrdesc, bits(4) ptag, boolean write)
    if memaddrdesc.memattrs.tagged then
        bits(64) paddress = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(memaddrdesc.paddress.address);
        return ptag == </ins><a href="shared_pseudocode.html#impl-aarch32.MemTag.read.1" title="accessor: bits(4) MemTag[bits(64) address]"><ins>MemTag</ins></a><ins>[paddress];
    else
        return TRUE;</ins><del>(include_fpexc_check, advsimd);
    // Return from CheckAdvSIMDOrFPEnabled() occurs only if VFP access is permitted
    return;</del></p></div><div class="ps" psname="aarch32.functions.memory.Hint_PreloadData"><a id="aarch32.functions.memory.Hint_PreloadData" name="aarch32.functions.memory.Hint_PreloadData"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>memory</ins><del>float</del>/<ins>Hint_PreloadData</ins><del>FPHalvedSub</del></h3><p class="pseudocode"><del>// FPHalvedSub()
// =============

bits(N) </del><a id="impl-aarch32.Hint_PreloadData.1" name="impl-aarch32.Hint_PreloadData.1"></a><del>FPHalvedSub(bits(N) op1, bits(N) op2, </del><a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><del>FPCRType</del></a><del> fpcr)
    assert N IN {16,32,64};
    rounding = </del><a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)"><del>FPRoundingMode</del></a><del>(fpcr);
    (type1,sign1,value1) = </del><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a><del>(op1, fpcr);
    (type2,sign2,value2) = </del><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a><del>(op2, fpcr);
    (done,result) = </del><a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2, FPCRType fpcr)"><del>FPProcessNaNs</del></a><del>(type1, type2, op1, op2, fpcr);
    if !done then
        inf1 = (type1 == </del><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a><del>);  inf2 = (type2 == </del><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a><del>);
        zero1 = (type1 == </del><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a><del>);     zero2 = (type2 == </del><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a><del>);
        if inf1 &amp;&amp; inf2 &amp;&amp; sign1 == sign2 then
            result = </del><a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.0" title="function: bits(N) FPDefaultNaN()"><del>FPDefaultNaN</del></a><del>();
            </del><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a><del>(</del><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_InvalidOp</del></a><del>, fpcr);
        elsif (inf1 &amp;&amp; sign1 == '0') || (inf2 &amp;&amp; sign2 == '1') then
            result = </del><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><del>FPInfinity</del></a><del>('0');
        elsif (inf1 &amp;&amp; sign1 == '1') || (inf2 &amp;&amp; sign2 == '0') then
            result = </del><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><del>FPInfinity</del></a><del>('1');
        elsif zero1 &amp;&amp; zero2 &amp;&amp; sign1 != sign2 then
            result = </del><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><del>FPZero</del></a><del>(sign1);
        else
            result_value = (value1 - value2) / 2.0;
            if result_value == 0.0 then  // Sign of exact zero result depends on rounding mode
                result_sign = if rounding == </del><a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_NEGINF</del></a><del> then '1' else '0';
                result = </del><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><del>FPZero</del></a><del>(result_sign);
            else
                result = </del><a href="shared_pseudocode.html#impl-shared.FPRound.2" title="function: bits(N) FPRound(real op, FPCRType fpcr)"><del>FPRound</del></a><ins>Hint_PreloadData(bits(32) address);</ins><del>(result_value, fpcr);
    return result;</del></p></div><div class="ps" psname="aarch32.functions.memory.Hint_PreloadDataForWrite"><a id="aarch32.functions.memory.Hint_PreloadDataForWrite" name="aarch32.functions.memory.Hint_PreloadDataForWrite"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>memory</ins><del>float</del>/<ins>Hint_PreloadDataForWrite</ins><del>FPRSqrtStep</del></h3><p class="pseudocode"><del>// FPRSqrtStep()
// =============

bits(N) </del><a id="impl-aarch32.Hint_PreloadDataForWrite.1" name="impl-aarch32.Hint_PreloadDataForWrite.1"></a><del>FPRSqrtStep(bits(N) op1, bits(N) op2)
    assert N IN {16,32};
    </del><a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><del>FPCRType</del></a><del> fpcr = </del><a href="shared_pseudocode.html#impl-aarch32.StandardFPSCRValue.0" title="function: FPCRType StandardFPSCRValue()"><del>StandardFPSCRValue</del></a><del>();
    (type1,sign1,value1) = </del><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a><del>(op1, fpcr);
    (type2,sign2,value2) = </del><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a><del>(op2, fpcr);
    (done,result) = </del><a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2, FPCRType fpcr)"><del>FPProcessNaNs</del></a><del>(type1, type2, op1, op2, fpcr);
    if !done then
        inf1 = (type1 == </del><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a><del>);  inf2 = (type2 == </del><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a><del>);
        zero1 = (type1 == </del><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a><del>);     zero2 = (type2 == </del><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a><del>);
        bits(N) product;
        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            product = </del><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><del>FPZero</del></a><del>('0');
        else
            product = </del><a href="shared_pseudocode.html#impl-shared.FPMul.3" title="function: bits(N) FPMul(bits(N) op1, bits(N) op2, FPCRType fpcr)"><del>FPMul</del></a><del>(op1, op2, fpcr);
        bits(N) three = </del><a href="shared_pseudocode.html#impl-shared.FPThree.1" title="function: bits(N) FPThree(bit sign)"><del>FPThree</del></a><del>('0');
        result = </del><a href="shared_pseudocode.html#impl-aarch32.FPHalvedSub.3" title="function: bits(N) FPHalvedSub(bits(N) op1, bits(N) op2, FPCRType fpcr)"><del>FPHalvedSub</del></a><ins>Hint_PreloadDataForWrite(bits(32) address);</ins><del>(three, product, fpcr);
    return result;</del></p></div><div class="ps" psname="aarch32.functions.memory.Hint_PreloadInstr"><a id="aarch32.functions.memory.Hint_PreloadInstr" name="aarch32.functions.memory.Hint_PreloadInstr"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>memory</ins><del>float</del>/<ins>Hint_PreloadInstr</ins><del>FPRecipStep</del></h3><p class="pseudocode"><del>// FPRecipStep()
// =============

bits(N) </del><a id="impl-aarch32.Hint_PreloadInstr.1" name="impl-aarch32.Hint_PreloadInstr.1"></a><del>FPRecipStep(bits(N) op1, bits(N) op2)
    assert N IN {16,32};
    </del><a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><del>FPCRType</del></a><del> fpcr = </del><a href="shared_pseudocode.html#impl-aarch32.StandardFPSCRValue.0" title="function: FPCRType StandardFPSCRValue()"><del>StandardFPSCRValue</del></a><del>();
    (type1,sign1,value1) = </del><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a><del>(op1, fpcr);
    (type2,sign2,value2) = </del><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a><del>(op2, fpcr);
    (done,result) = </del><a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2, FPCRType fpcr)"><del>FPProcessNaNs</del></a><del>(type1, type2, op1, op2, fpcr);
    if !done then
        inf1 = (type1 == </del><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a><del>);  inf2 = (type2 == </del><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a><del>);
        zero1 = (type1 == </del><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a><del>);     zero2 = (type2 == </del><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a><del>);
        bits(N) product;
        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            product = </del><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><del>FPZero</del></a><del>('0');
        else
            product = </del><a href="shared_pseudocode.html#impl-shared.FPMul.3" title="function: bits(N) FPMul(bits(N) op1, bits(N) op2, FPCRType fpcr)"><del>FPMul</del></a><del>(op1, op2, fpcr);
        bits(N) two = </del><a href="shared_pseudocode.html#impl-shared.FPTwo.1" title="function: bits(N) FPTwo(bit sign)"><del>FPTwo</del></a><del>('0');
        result = </del><a href="shared_pseudocode.html#impl-shared.FPSub.3" title="function: bits(N) FPSub(bits(N) op1, bits(N) op2, FPCRType fpcr)"><del>FPSub</del></a><ins>Hint_PreloadInstr(bits(32) address);</ins><del>(two, product, fpcr);
    return result;</del></p></div><div class="ps" psname="aarch32.functions.memory.MemA"><a id="aarch32.functions.memory.MemA" name="aarch32.functions.memory.MemA"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>memory</ins><del>float</del>/<ins>MemA</ins><del>StandardFPSCRValue</del></h3><p class="pseudocode"><ins>// MemA[] - non-assignment form
// ============================
</ins><del>// StandardFPSCRValue()
// ====================
</del>
<ins>bits(8*size)</ins><del>FPCRType</del> <a id="impl-aarch32.MemA.read.2" name="impl-aarch32.MemA.read.2"></a><ins>MemA[bits(32) address, integer size]
    acctype =</ins><del>StandardFPSCRValue()
    return '00000' : FPSCR.AHP : '110000' : FPSCR.FZ16 : '0000000000000000000';</del> <a href="shared_pseudocode.html#AccType_ATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ATOMIC</ins></a><ins>;
    return </ins><a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.read.3" title="accessor: bits(size*8) Mem_with_type[bits(32) address, integer size, AccType acctype]"><ins>Mem_with_type</ins></a><ins>[address, size, acctype];

// MemA[] - assignment form
// ========================

</ins><a id="impl-aarch32.MemA.write.2" name="impl-aarch32.MemA.write.2"></a><ins>MemA[bits(32) address, integer size] = bits(8*size) value
    acctype = </ins><a href="shared_pseudocode.html#AccType_ATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ATOMIC</ins></a><ins>;
    </ins><a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.write.3" title="accessor: Mem_with_type[bits(32) address, integer size, AccType acctype] = bits(size*8) value"><ins>Mem_with_type</ins></a><ins>[address, size, acctype] = value;
    return;</ins></p></div><div class="ps" psname="aarch32.functions.memory.MemO"><a id="aarch32.functions.memory.MemO" name="aarch32.functions.memory.MemO"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/<ins>MemO</ins><del>AArch32.CheckAlignment</del></h3><p class="pseudocode"><ins>// MemO[] - non-assignment form
// ============================
</ins><del>// AArch32.CheckAlignment()
// ========================
</del>
<ins>bits(8*size)</ins><del>boolean</del> <a id="impl-aarch32.MemO.read.2" name="impl-aarch32.MemO.read.2"></a><ins>MemO[bits(32) address, integer size]
    acctype =</ins><del>AArch32.CheckAlignment(bits(32) address, integer alignment,</del> <a href="shared_pseudocode.html#AccType_ORDERED" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ORDERED</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><ins>;
    return</ins><del>acctype,
                               boolean iswrite)

    if PSTATE.EL ==</del> <a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.read.3" title="accessor: bits(size*8) Mem_with_type[bits(32) address, integer size, AccType acctype]"><ins>Mem_with_type</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>[address, size, acctype];

// MemO[] - assignment form
// ========================</ins><del>&amp;&amp; !</del>

<a id="impl-aarch32.MemO.write.2" name="impl-aarch32.MemO.write.2"></a><ins>MemO[bits(32) address, integer size] = bits(8*size) value
    acctype =</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><del>()) then
        A = SCTLR[].A; //use AArch64 register, when higher Exception level is using AArch64
    elsif PSTATE.EL == </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del> then
        A = HSCTLR.A;
    else
        A = SCTLR.A;
    aligned = (address == </del><a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)"><del>Align</del></a><del>(address, alignment));
    atomic  = acctype IN { </del><a href="shared_pseudocode.html#AccType_ATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ATOMIC</del></a><del>, </del><a href="shared_pseudocode.html#AccType_ATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ATOMICRW</del></a><del>, </del><a href="shared_pseudocode.html#AccType_ORDEREDATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ORDEREDATOMIC</del></a><del>, </del><a href="shared_pseudocode.html#AccType_ORDEREDATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ORDEREDATOMICRW</del></a><del> };
    ordered = acctype IN { </del><a href="shared_pseudocode.html#AccType_ORDERED" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType_ORDERED</a><ins>;</ins><del>,</del>
    <del>, </del><a href="shared_pseudocode.html#AccType_LIMITEDORDERED" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_LIMITEDORDERED</del></a><del>, </del><a href="shared_pseudocode.html#AccType_ORDEREDATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ORDEREDATOMIC</del></a><del>, </del><a href="shared_pseudocode.html#AccType_ORDEREDATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ORDEREDATOMICRW</del></a><del> };
    vector  = acctype == </del><a href="shared_pseudocode.html#AccType_VEC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_VEC</del></a><del>;

    // AccType_VEC is used for SIMD element alignment checks only
    check = (atomic || ordered || vector || A == '1');

    if check &amp;&amp; !aligned then
        secondstage = FALSE;
        </del><a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)"><del>AArch32.Abort</del></a><del>(address, </del><a href="shared_pseudocode.html#AArch32.AlignmentFault.3" title="function: FaultRecord AArch32.AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)"><del>AArch32.AlignmentFault</del></a><a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.write.3" title="accessor: Mem_with_type[bits(32) address, integer size, AccType acctype] = bits(size*8) value"><ins>Mem_with_type</ins></a><a href="shared_pseudocode.html#AccType_ORDEREDRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ORDEREDRW</del></a><ins>[address, size, acctype] = value;
    return;</ins><del>(acctype, iswrite, secondstage));

    return aligned;</del></p></div><div class="ps" psname="aarch32.functions.memory.MemTag"><a id="aarch32.functions.memory.MemTag" name="aarch32.functions.memory.MemTag"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/<ins>MemTag</ins><del>AArch32.MemSingle</del></h3><p class="pseudocode"><ins>// MemTag[] - non-assignment (read) form
// =====================================
// Load an Allocation Tag from memory.
</ins><del>// AArch32.MemSingle[] - non-assignment (read) form
// ================================================
// Perform an atomic, little-endian read of 'size' bytes.
</del>
<ins>bits(4)</ins><del>bits(size*8)</del> <a id="impl-shared.MemTag.read.1" name="impl-shared.MemTag.read.1"></a><ins>MemTag[bits(64) address]</ins><del>AArch32.MemSingle[bits(32) address, integer size,</del>
    <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><del> acctype, boolean wasaligned]
    assert size IN {1, 2, 4, 8, 16};
    assert address == </del><a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)"><del>Align</del></a><del>(address, size);

    </del><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc;
<ins>    bits(4) value;
</ins><del>    bits(size*8) value;
</del>    iswrite = FALSE;

<del>    // MMU or MPU
</del>    memaddrdesc = <a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><ins>AArch64.TranslateAddress</ins></a><a href="shared_pseudocode.html#AArch32.TranslateAddress.5" title="function: AddressDescriptor AArch32.TranslateAddress(bits(32) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><del>AArch32.TranslateAddress</del></a><ins>(address,</ins><del>(address, acctype, iswrite, wasaligned, size);
    // Check for aborts or debug exceptions
    if</del> <a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NORMAL</ins></a><ins>, iswrite, TRUE, TAG_GRANULE);
    // Check for aborts or debug exceptions
    if </ins><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)"><ins>AArch64.Abort</ins></a><a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)"><del>AArch32.Abort</del></a>(address, memaddrdesc.fault);

<ins>    // Return the granule tag if tagging is enabled...
</ins><del>    // Memory array access
    accdesc = CreateAccessDescriptor(acctype);
</del>    if <a href="shared_pseudocode.html#impl-shared.AllocationTagAccessIsEnabled.0" title="function: boolean AllocationTagAccessIsEnabled()"><ins>AllocationTagAccessIsEnabled</ins></a><a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()"><del>HaveMTEExt</del></a><ins>() &amp;&amp; memaddrdesc.memattrs.tagged then
        return _MemTag[memaddrdesc];
    else
        // ...otherwise read tag as zero.
        return '0000';

// MemTag[] - assignment (write) form
// ==================================
// Store an Allocation Tag to memory.</ins><del>() then
        if</del>

<a href="shared_pseudocode.html#impl-aarch32.AccessIsTagChecked.2" title="function: boolean AccessIsTagChecked(bits(64) vaddr, AccType acctype)"><del>AccessIsTagChecked</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><del>ZeroExtend</del></a><del>(address, 64), acctype) then
            bits(4) ptag = </del><a href="shared_pseudocode.html#impl-aarch32.TransformTag.1" title="function: bits(4) TransformTag(bits(64) vaddr)"><del>TransformTag</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><del>ZeroExtend</del></a><del>(address, 64));
            if !</del><a href="shared_pseudocode.html#impl-aarch32.CheckTag.3" title="function: boolean CheckTag(AddressDescriptor memaddrdesc, bits(4) ptag, boolean write)"><del>CheckTag</del></a><del>(memaddrdesc, ptag, iswrite) then
                </del><a href="shared_pseudocode.html#impl-aarch32.TagCheckFail.2" title="function: TagCheckFail(bits(64) vaddress, boolean iswrite)"><del>TagCheckFail</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><del>ZeroExtend</del></a><del>(address, 64), iswrite);
    value = _Mem[memaddrdesc, size, accdesc];
    return value;

// AArch32.MemSingle[] - assignment (write) form
// =============================================
// Perform an atomic, little-endian write of 'size' bytes.

</del><a id="impl-shared.MemTag.write.1" name="impl-shared.MemTag.write.1"></a><ins>MemTag[bits(64) address] = bits(4) value</ins><del>AArch32.MemSingle[bits(32) address, integer size,</del>
    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><ins>AddressDescriptor</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a> <ins>memaddrdesc;
    iswrite = TRUE;

    // Stores of allocation tags must be aligned
    if address !=</ins><del>acctype, boolean wasaligned] = bits(size*8) value
    assert size IN {1, 2, 4, 8, 16};
    assert address ==</del> <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a><ins>(address, TAG_GRANULE) then
        boolean secondstage = FALSE;</ins><del>(address, size);</del>
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)"><ins>AArch64.Abort</ins></a><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><del>AddressDescriptor</del></a><ins>(address,</ins><del>memaddrdesc;
    iswrite = TRUE;

    // MMU or MPU
    memaddrdesc =</del> <a href="shared_pseudocode.html#AArch64.AlignmentFault.3" title="function: FaultRecord AArch64.AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)"><ins>AArch64.AlignmentFault</ins></a><a href="shared_pseudocode.html#AArch32.TranslateAddress.5" title="function: AddressDescriptor AArch32.TranslateAddress(bits(32) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><del>AArch32.TranslateAddress</del></a><ins>(</ins><del>(address, acctype, iswrite, wasaligned, size);

    // Check for aborts or debug exceptions
    if</del><a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NORMAL</ins></a><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><ins>, iswrite, secondstage));

    wasaligned = TRUE;
    memaddrdesc =</ins><del>(memaddrdesc) then</del> <a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><ins>AArch64.TranslateAddress</ins></a><a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)"><del>AArch32.Abort</del></a><ins>(address,</ins><del>(address, memaddrdesc.fault);

    // Effect on exclusives
    if memaddrdesc.memattrs.shareable then</del> <a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NORMAL</ins></a><a href="shared_pseudocode.html#impl-shared.ClearExclusiveByAddress.3" title="function: ClearExclusiveByAddress(FullAddress paddress, integer processorid, integer size)"><del>ClearExclusiveByAddress</del></a><ins>, iswrite, wasaligned, TAG_GRANULE);

    // Check for aborts or debug exceptions
    if</ins><del>(memaddrdesc.paddress,</del> <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><del>ProcessorID</del></a><ins>(memaddrdesc) then</ins><del>(), size);

    // Memory array access
    accdesc = CreateAccessDescriptor(acctype);
    if</del>
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)"><ins>AArch64.Abort</ins></a><a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()"><del>HaveMTEExt</del></a><ins>(address, memaddrdesc.fault);

    // Memory array access
    if</ins><del>() then
        if</del> <del>(</del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><del>ZeroExtend</del></a><del>(address, 64), acctype) then
            bits(4) ptag = </del><a href="shared_pseudocode.html#impl-aarch32.TransformTag.1" title="function: bits(4) TransformTag(bits(64) vaddr)"><del>TransformTag</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><del>ZeroExtend</del></a><del>(address, 64));
            if !</del><a href="shared_pseudocode.html#impl-aarch32.CheckTag.3" title="function: boolean CheckTag(AddressDescriptor memaddrdesc, bits(4) ptag, boolean write)"><del>CheckTag</del></a><del>(memaddrdesc, ptag, iswrite) then
                </del><a href="shared_pseudocode.html#impl-aarch32.TagCheckFail.2" title="function: TagCheckFail(bits(64) vaddress, boolean iswrite)"><del>TagCheckFail</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><del>ZeroExtend</del></a><a href="shared_pseudocode.html#impl-shared.AllocationTagAccessIsEnabled.0" title="function: boolean AllocationTagAccessIsEnabled()"><ins>AllocationTagAccessIsEnabled</ins></a><a href="shared_pseudocode.html#impl-aarch32.AccessIsTagChecked.2" title="function: boolean AccessIsTagChecked(bits(64) vaddr, AccType acctype)"><del>AccessIsTagChecked</del></a><ins>() &amp;&amp; memaddrdesc.memattrs.tagged then
        _MemTag[memaddrdesc] = value;</ins><del>(address, 64), iswrite);
    _Mem[memaddrdesc, size, accdesc] = value;
    return;</del></p></div><div class="ps" psname="aarch32.functions.memory.MemU"><a id="aarch32.functions.memory.MemU" name="aarch32.functions.memory.MemU"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/<ins>MemU</ins><del>AddressWithAllocationTag</del></h3><p class="pseudocode"><ins>// MemU[] - non-assignment form
// ============================
</ins><del>// AddressWithAllocationTag()
// ==========================
// Generate a 64-bit value containing a Logical Address Tag from a 64-bit
// virtual address and an Allocation Tag.
// If the extension is disabled, treats the Allocation Tag as â0000â.
</del>
<ins>bits(8*size)</ins><del>bits(64)</del> <a id="impl-aarch32.MemU.read.2" name="impl-aarch32.MemU.read.2"></a><ins>MemU[bits(32) address, integer size]
    acctype =</ins><del>AddressWithAllocationTag(bits(64) address, bits(4) allocation_tag)
    bits(64) result = address;
    bits(4) tag = allocation_tag - ('000':address&lt;55>);
    result&lt;59:56> = tag;
    return result;</del> <a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NORMAL</ins></a><ins>;
    return </ins><a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.read.3" title="accessor: bits(size*8) Mem_with_type[bits(32) address, integer size, AccType acctype]"><ins>Mem_with_type</ins></a><ins>[address, size, acctype];

// MemU[] - assignment form
// ========================

</ins><a id="impl-aarch32.MemU.write.2" name="impl-aarch32.MemU.write.2"></a><ins>MemU[bits(32) address, integer size] = bits(8*size) value
    acctype = </ins><a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NORMAL</ins></a><ins>;
    </ins><a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.write.3" title="accessor: Mem_with_type[bits(32) address, integer size, AccType acctype] = bits(size*8) value"><ins>Mem_with_type</ins></a><ins>[address, size, acctype] = value;
    return;</ins></p></div><div class="ps" psname="aarch32.functions.memory.MemU_unpriv"><a id="aarch32.functions.memory.MemU_unpriv" name="aarch32.functions.memory.MemU_unpriv"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/<ins>MemU_unpriv</ins><del>AllocationTagFromAddress</del></h3><p class="pseudocode"><ins>// MemU_unpriv[] - non-assignment form
// ===================================
</ins><del>// AllocationTagFromAddress()
// ==========================
// Generate a Tag from a 64-bit value containing a Logical Address Tag.
// If access to Allocation Tags is disabled, this function returns â0000â.
</del>
<ins>bits(8*size)</ins><del>bits(4)</del> <a id="impl-aarch32.MemU_unpriv.read.2" name="impl-aarch32.MemU_unpriv.read.2"></a><ins>MemU_unpriv[bits(32) address, integer size]
    acctype =</ins><del>AllocationTagFromAddress(bits(64) tagged_address)
    bits(4) logical_tag = tagged_address&lt;59:56>;
    bits(4) tag = logical_tag + ('000':tagged_address&lt;55>);
    return tag;</del> <a href="shared_pseudocode.html#AccType_UNPRIV" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_UNPRIV</ins></a><ins>;
    return </ins><a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.read.3" title="accessor: bits(size*8) Mem_with_type[bits(32) address, integer size, AccType acctype]"><ins>Mem_with_type</ins></a><ins>[address, size, acctype];

// MemU_unpriv[] - assignment form
// ===============================

</ins><a id="impl-aarch32.MemU_unpriv.write.2" name="impl-aarch32.MemU_unpriv.write.2"></a><ins>MemU_unpriv[bits(32) address, integer size] = bits(8*size) value
    acctype = </ins><a href="shared_pseudocode.html#AccType_UNPRIV" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_UNPRIV</ins></a><ins>;
    </ins><a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.write.3" title="accessor: Mem_with_type[bits(32) address, integer size, AccType acctype] = bits(size*8) value"><ins>Mem_with_type</ins></a><ins>[address, size, acctype] = value;
    return;</ins></p></div><div class="ps" psname="aarch32.functions.memory.Mem_with_type"><a id="aarch32.functions.memory.Mem_with_type" name="aarch32.functions.memory.Mem_with_type"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/<ins>Mem_with_type</ins><del>CheckTag</del></h3><p class="pseudocode"><ins>// Mem_with_type[] - non-assignment (read) form
// ============================================
// Perform a read of 'size' bytes. The access byte order is reversed for a big-endian access.
// Instruction fetches would call AArch32.MemSingle directly.
</ins><del>// CheckTag()
// ==========
// Performs a Tag Check operation for a memory access and returns
// whether the check passed
</del>
<ins>bits(size*8)</ins><del>boolean</del> <a id="impl-aarch32.Mem_with_type.read.3" name="impl-aarch32.Mem_with_type.read.3"></a><ins>Mem_with_type[bits(32) address, integer size,</ins><del>CheckTag(</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><del>AddressDescriptor</del></a> <ins>acctype]
    assert size IN {1, 2, 4, 8, 16};
    bits(size*8) value;
    boolean iswrite = FALSE;

    aligned =</ins><del>memaddrdesc, bits(4) ptag, boolean write)
    if memaddrdesc.memattrs.tagged then
        bits(64) paddress =</del> <a href="shared_pseudocode.html#AArch32.CheckAlignment.4" title="function: boolean AArch32.CheckAlignment(bits(32) address, integer alignment, AccType acctype, boolean iswrite)"><ins>AArch32.CheckAlignment</ins></a><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><ins>(address, size, acctype, iswrite);
    if !aligned then
        assert size > 1;
        value&lt;7:0> =</ins><del>(memaddrdesc.paddress.address);
        return ptag ==</del> <a href="shared_pseudocode.html#AArch32.MemSingle.read.4" title="accessor: bits(size*8) AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean wasaligned]"><ins>AArch32.MemSingle</ins></a><a href="shared_pseudocode.html#impl-aarch32.MemTag.read.1" title="accessor: bits(4) MemTag[bits(64) address]"><del>MemTag</del></a><ins>[address, 1, acctype, aligned];

        // For subsequent bytes it is CONSTRAINED UNPREDICTABLE whether an unaligned Device memory
        // access will generate an Alignment Fault, as to get this far means the first byte did
        // not, so we must be changing to a new translation page.
        c = </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><ins>ConstrainUnpredictable</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_DEVPAGE2" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_DEVPAGE2</ins></a><ins>);
        assert c IN {</ins><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FAULT</ins></a><ins>, </ins><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_NONE</ins></a><ins>};
        if c == </ins><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_NONE</ins></a><ins> then aligned = TRUE;

        for i = 1 to size-1
            value&lt;8*i+7:8*i> = </ins><a href="shared_pseudocode.html#AArch32.MemSingle.read.4" title="accessor: bits(size*8) AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean wasaligned]"><ins>AArch32.MemSingle</ins></a><ins>[address+i, 1, acctype, aligned];
    else
        value = </ins><a href="shared_pseudocode.html#AArch32.MemSingle.read.4" title="accessor: bits(size*8) AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean wasaligned]"><ins>AArch32.MemSingle</ins></a><ins>[address, size, acctype, aligned];

    if </ins><a href="shared_pseudocode.html#impl-shared.BigEndian.0" title="function: boolean BigEndian()"><ins>BigEndian</ins></a><ins>() then
        value = </ins><a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)"><ins>BigEndianReverse</ins></a><ins>(value);
    return value;

// Mem_with_type[] - assignment (write) form
// =========================================
// Perform a write of 'size' bytes. The byte order is reversed for a big-endian access.

</ins><a id="impl-aarch32.Mem_with_type.write.3" name="impl-aarch32.Mem_with_type.write.3"></a><ins>Mem_with_type[bits(32) address, integer size, </ins><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><ins> acctype] = bits(size*8) value
    boolean iswrite = TRUE;

    if </ins><a href="shared_pseudocode.html#impl-shared.BigEndian.0" title="function: boolean BigEndian()"><ins>BigEndian</ins></a><ins>() then
        value = </ins><a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)"><ins>BigEndianReverse</ins></a><ins>(value);

    aligned = </ins><a href="shared_pseudocode.html#AArch32.CheckAlignment.4" title="function: boolean AArch32.CheckAlignment(bits(32) address, integer alignment, AccType acctype, boolean iswrite)"><ins>AArch32.CheckAlignment</ins></a><ins>(address, size, acctype, iswrite);

    if !aligned then
        assert size > 1;
        </ins><a href="shared_pseudocode.html#AArch32.MemSingle.write.4" title="accessor: AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean wasaligned] = bits(size*8) value"><ins>AArch32.MemSingle</ins></a><ins>[address, 1, acctype, aligned] = value&lt;7:0>;

        // For subsequent bytes it is CONSTRAINED UNPREDICTABLE whether an unaligned Device memory
        // access will generate an Alignment Fault, as to get this far means the first byte did
        // not, so we must be changing to a new translation page.
        c = </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><ins>ConstrainUnpredictable</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_DEVPAGE2" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_DEVPAGE2</ins></a><ins>);
        assert c IN {</ins><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FAULT</ins></a><ins>, </ins><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_NONE</ins></a><ins>};
        if c == </ins><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_NONE</ins></a><ins> then aligned = TRUE;

        for i = 1 to size-1
            </ins><a href="shared_pseudocode.html#AArch32.MemSingle.write.4" title="accessor: AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean wasaligned] = bits(size*8) value"><ins>AArch32.MemSingle</ins></a><ins>[address+i, 1, acctype, aligned] = value&lt;8*i+7:8*i>;
    else
        </ins><a href="shared_pseudocode.html#AArch32.MemSingle.write.4" title="accessor: AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean wasaligned] = bits(size*8) value"><ins>AArch32.MemSingle</ins></a><ins>[address, size, acctype, aligned] = value;
    return;</ins><del>[paddress];
    else
        return TRUE;</del></p></div><div class="ps" psname="aarch32.functions.memory.TransformTag"><a id="aarch32.functions.memory.TransformTag" name="aarch32.functions.memory.TransformTag"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/<ins>TransformTag</ins><del>Hint_PreloadData</del></h3><p class="pseudocode"><ins>// TransformTag()
// ==============
// Apply tag transformation rules.

bits(4) </ins><a id="impl-shared.TransformTag.1" name="impl-shared.TransformTag.1"></a><ins>TransformTag(bits(64) vaddr)
    bits(4) vtag = vaddr&lt;59:56>;
    bits(4) tagdelta = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(vaddr&lt;55>);
    bits(4) ptag = vtag + tagdelta;
    return ptag;</ins><del>Hint_PreloadData(bits(32) address);</del></p></div><div class="ps" psname="aarch32.functions.memory.boolean"><a id="aarch32.functions.memory.boolean" name="aarch32.functions.memory.boolean"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/<ins>boolean</ins><del>Hint_PreloadDataForWrite</del></h3><p class="pseudocode"><ins>// boolean AccessIsTagChecked()
// ============================
// TRUE if a given access is tag-checked, FALSE otherwise.

boolean </ins><a id="impl-shared.AccessIsTagChecked.2" name="impl-shared.AccessIsTagChecked.2"></a><ins>AccessIsTagChecked(bits(64) vaddr, </ins><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><ins> acctype)
    if PSTATE.M&lt;4> == '1' then return FALSE;

    if </ins><a href="shared_pseudocode.html#impl-shared.EffectiveTBI.3" title="function: bit EffectiveTBI(bits(64) address, boolean IsInstr, bits(2) el)"><ins>EffectiveTBI</ins></a><ins>(vaddr, FALSE, PSTATE.EL) == '0' then
        return FALSE;

    if </ins><a href="shared_pseudocode.html#impl-shared.EffectiveTCMA.2" title="function: bit EffectiveTCMA(bits(64) address, bits(2) el)"><ins>EffectiveTCMA</ins></a><ins>(vaddr, PSTATE.EL) == '1' &amp;&amp; (vaddr&lt;59:55> == '00000' || vaddr&lt;59:55> == '11111') then
        return FALSE;

    if !</ins><a href="shared_pseudocode.html#impl-shared.AllocationTagAccessIsEnabled.0" title="function: boolean AllocationTagAccessIsEnabled()"><ins>AllocationTagAccessIsEnabled</ins></a><ins>() then
        return FALSE;

    if acctype IN {</ins><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><ins>, </ins><a href="shared_pseudocode.html#AccType_PTW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_PTW</ins></a><ins>} then
        return FALSE;

    if acctype == </ins><a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NV2REGISTER</ins></a> <ins>then
        return FALSE;

    if PSTATE.TCO=='1' then
        return FALSE;

    if IsNonTagCheckedInstruction() then
        return FALSE;

    return TRUE;</ins><del>Hint_PreloadDataForWrite(bits(32) address);</del></p></div><div class="ps" psname="aarch32.functions.ras.AArch32.ESBOperation"><a id="aarch32.functions.ras.AArch32.ESBOperation" name="aarch32.functions.ras.AArch32.ESBOperation"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>ras</ins><del>memory</del>/<ins>AArch32.ESBOperation</ins><del>Hint_PreloadInstr</del></h3><p class="pseudocode"><ins>// AArch32.ESBOperation()
// ======================
// Perform the AArch32 ESB operation for ESB executed in AArch32 state

</ins><a id="AArch32.ESBOperation.0" name="AArch32.ESBOperation.0"></a><ins>AArch32.ESBOperation()

    // Check if routed to AArch64 state
    route_to_aarch64 = PSTATE.EL == </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins> &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>);
    if !route_to_aarch64 &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>() &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) then
        route_to_aarch64 = HCR_EL2.TGE == '1' || HCR_EL2.AMO == '1';
    if !route_to_aarch64 &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) then
        route_to_aarch64 = SCR_EL3.EA == '1';

    if route_to_aarch64 then
        </ins><a href="shared_pseudocode.html#AArch64.ESBOperation.0" title="function: AArch64.ESBOperation()"><ins>AArch64.ESBOperation</ins></a><ins>();
        return;

    route_to_monitor = </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; SCR.EA == '1';
    route_to_hyp = </ins><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>() &amp;&amp; PSTATE.EL IN {</ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>,</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>} &amp;&amp; (HCR.TGE == '1' || HCR.AMO == '1');

    if route_to_monitor then
        target = </ins><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><ins>M32_Monitor</ins></a><ins>;
    elsif route_to_hyp || PSTATE.M == </ins><a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'"><ins>M32_Hyp</ins></a><ins> then
        target = </ins><a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'"><ins>M32_Hyp</ins></a><ins>;
    else
        target = </ins><a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'"><ins>M32_Abort</ins></a><ins>;

    if </ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>() then
        mask_active = TRUE;
    elsif target == </ins><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><ins>M32_Monitor</ins></a><ins> then
        mask_active = SCR.AW == '1' &amp;&amp; (!</ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) || (HCR.TGE == '0' &amp;&amp; HCR.AMO == '0'));
    else
        mask_active = target == </ins><a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'"><ins>M32_Abort</ins></a><ins> || PSTATE.M == </ins><a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'"><ins>M32_Hyp</ins></a><ins>;

    mask_set = PSTATE.A == '1';
    (-, el)  = </ins><a href="shared_pseudocode.html#impl-shared.ELFromM32.1" title="function: (boolean,bits(2)) ELFromM32(bits(5) mode)"><ins>ELFromM32</ins></a><ins>(target);
    intdis   = </ins><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><ins>Halted</ins></a><ins>() || </ins><a href="shared_pseudocode.html#impl-shared.ExternalDebugInterruptsDisabled.1" title="function: boolean ExternalDebugInterruptsDisabled(bits(2) target)"><ins>ExternalDebugInterruptsDisabled</ins></a><ins>(el);
    masked   = intdis || (mask_active &amp;&amp; mask_set);

    // Check for a masked Physical SError pending
    if </ins><a href="shared_pseudocode.html#impl-shared.IsPhysicalSErrorPending.0" title="function: boolean IsPhysicalSErrorPending()"><ins>IsPhysicalSErrorPending</ins></a><ins>() &amp;&amp; masked then
        syndrome32 = </ins><a href="shared_pseudocode.html#AArch32.PhysicalSErrorSyndrome.0" title="function: AArch32.SErrorSyndrome AArch32.PhysicalSErrorSyndrome()"><ins>AArch32.PhysicalSErrorSyndrome</ins></a><ins>();
        DISR = </ins><a href="shared_pseudocode.html#AArch32.ReportDeferredSError.2" title="function: bits(32) AArch32.ReportDeferredSError(bits(2) AET, bit ExT)"><ins>AArch32.ReportDeferredSError</ins></a><ins>(syndrome32.AET, syndrome32.ExT);
        </ins><a href="shared_pseudocode.html#impl-shared.ClearPendingPhysicalSError.0" title="function: ClearPendingPhysicalSError()"><ins>ClearPendingPhysicalSError</ins></a><ins>();

    return;</ins><del>Hint_PreloadInstr(bits(32) address);</del></p></div><div class="ps" psname="aarch32.functions.ras.AArch32.PhysicalSErrorSyndrome"><a id="aarch32.functions.ras.AArch32.PhysicalSErrorSyndrome" name="aarch32.functions.ras.AArch32.PhysicalSErrorSyndrome"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>ras</ins><del>memory</del>/<ins>AArch32.PhysicalSErrorSyndrome</ins><del>MemA</del></h3><p class="pseudocode"><ins>// Return the SError syndrome
AArch32.SErrorSyndrome</ins><del>// MemA[] - non-assignment form
// ============================

bits(8*size)</del> <a id="AArch32.PhysicalSErrorSyndrome.0" name="AArch32.PhysicalSErrorSyndrome.0"></a><ins>AArch32.PhysicalSErrorSyndrome();</ins><del>MemA[bits(32) address, integer size]
    acctype =</del><a href="shared_pseudocode.html#AccType_ATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ATOMIC</del></a><del>;
    return </del><a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.read.3" title="accessor: bits(size*8) Mem_with_type[bits(32) address, integer size, AccType acctype]"><del>Mem_with_type</del></a><del>[address, size, acctype];

// MemA[] - assignment form
// ========================

</del><a id="impl-aarch32.MemA.write.2" name="impl-aarch32.MemA.write.2"></a><del>MemA[bits(32) address, integer size] = bits(8*size) value
    acctype = </del><a href="shared_pseudocode.html#AccType_ATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ATOMIC</del></a><del>;
    </del><a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.write.3" title="accessor: Mem_with_type[bits(32) address, integer size, AccType acctype] = bits(size*8) value"><del>Mem_with_type</del></a><del>[address, size, acctype] = value;
    return;</del></p></div><div class="ps" psname="aarch32.functions.ras.AArch32.ReportDeferredSError"><a id="aarch32.functions.ras.AArch32.ReportDeferredSError" name="aarch32.functions.ras.AArch32.ReportDeferredSError"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>ras</ins><del>memory</del>/<ins>AArch32.ReportDeferredSError</ins><del>MemO</del></h3><p class="pseudocode"><ins>// AArch32.ReportDeferredSError()
// ==============================
// Return deferred SError syndrome
</ins><del>// MemO[] - non-assignment form
// ============================
</del>
<ins>bits(32)</ins><del>bits(8*size)</del> <a id="AArch32.ReportDeferredSError.2" name="AArch32.ReportDeferredSError.2"></a><ins>AArch32.ReportDeferredSError(bits(2) AET, bit ExT)
    bits(32) target;
    target&lt;31> = '1';                       // A
    syndrome =</ins><del>MemO[bits(32) address, integer size]
    acctype =</del> <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><a href="shared_pseudocode.html#AccType_ORDERED" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ORDERED</del></a><ins>(16);
    if PSTATE.EL ==</ins><del>;
    return</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.read.3" title="accessor: bits(size*8) Mem_with_type[bits(32) address, integer size, AccType acctype]"><del>Mem_with_type</del></a> <ins>then
        syndrome&lt;11:10> = AET;              // AET
        syndrome&lt;9>     = ExT;              // EA
        syndrome&lt;5:0>   = '010001';         // DFSC
    else
        syndrome&lt;15:14> = AET;              // AET
        syndrome&lt;12>    = ExT;              // ExT
        syndrome&lt;9>     = TTBCR.EAE;        // LPAE
        if TTBCR.EAE == '1' then            // Long-descriptor format
            syndrome&lt;5:0>    = '010001';    // STATUS
        else                                // Short-descriptor format
            syndrome&lt;10,3:0> = '10110';     // FS
    if</ins><del>[address, size, acctype];

// MemO[] - assignment form
// ========================</del> <a href="shared_pseudocode.html#impl-shared.HaveAnyAArch64.0" title="function: boolean HaveAnyAArch64()"><ins>HaveAnyAArch64</ins></a><ins>() then
        target&lt;24:0> =</ins><del>MemO[bits(32) address, integer size] = bits(8*size) value
    acctype =</del> <del>;
    </del><a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.write.3" title="accessor: Mem_with_type[bits(32) address, integer size, AccType acctype] = bits(size*8) value"><del>Mem_with_type</del></a><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><a href="shared_pseudocode.html#AccType_ORDERED" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ORDERED</del></a><ins>(syndrome);// Any RES0 fields must be set to zero
    else
        target&lt;15:0> = syndrome;
    return target;</ins><del>[address, size, acctype] = value;
    return;</del></p></div><div class="ps" psname="aarch32.functions.ras.AArch32.SErrorSyndrome"><a id="aarch32.functions.ras.AArch32.SErrorSyndrome" name="aarch32.functions.ras.AArch32.SErrorSyndrome"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>ras</ins><del>memory</del>/<ins>AArch32.SErrorSyndrome</ins><del>MemTag</del></h3><p class="pseudocode"><ins>type</ins><del>// MemTag[] - non-assignment (read) form
// =====================================
// Load an Allocation Tag from memory.

bits(4)</del> <a id="AArch32.SErrorSyndrome" name="AArch32.SErrorSyndrome"></a><ins>AArch32.SErrorSyndrome is (
    bits(2) AET,
    bit ExT
)</ins><del>MemTag[bits(64) address]</del><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><del>AddressDescriptor</del></a><del> memaddrdesc;
    bits(4) value;
    iswrite = FALSE;

    memaddrdesc = </del><a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><del>AArch64.TranslateAddress</del></a><del>(address, </del><a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NORMAL</del></a><del>, iswrite, TRUE, TAG_GRANULE);
    // Check for aborts or debug exceptions
    if </del><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><del>(memaddrdesc) then
        </del><a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)"><del>AArch64.Abort</del></a><del>(address, memaddrdesc.fault);

    // Return the granule tag if tagging is enabled...
    if </del><a href="shared_pseudocode.html#impl-shared.AllocationTagAccessIsEnabled.0" title="function: boolean AllocationTagAccessIsEnabled()"><del>AllocationTagAccessIsEnabled</del></a><del>() then
        return _MemTag[memaddrdesc];
    else
        // ...otherwise read tag as zero.
        return '0000';

// MemTag[] - assignment (write) form
// ==================================
// Store an Allocation Tag to memory.

</del><a id="impl-shared.MemTag.write.1" name="impl-shared.MemTag.write.1"></a><del>MemTag[bits(64) address] = bits(4) value
    </del><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><del>AddressDescriptor</del></a><del> memaddrdesc;
    iswrite = TRUE;

    // Stores of allocation tags must be aligned
    if address != </del><a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)"><del>Align</del></a><del>(address, TAG_GRANULE) then
        boolean secondstage = FALSE;
        </del><a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)"><del>AArch64.Abort</del></a><del>(address, </del><a href="shared_pseudocode.html#AArch64.AlignmentFault.3" title="function: FaultRecord AArch64.AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)"><del>AArch64.AlignmentFault</del></a><del>(</del><a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NORMAL</del></a><del>, iswrite, secondstage));

    wasaligned = TRUE;
    memaddrdesc = </del><a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><del>AArch64.TranslateAddress</del></a><del>(address, </del><a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NORMAL</del></a><del>, iswrite, wasaligned, TAG_GRANULE);

    // Check for aborts or debug exceptions
    if </del><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><del>(memaddrdesc) then
        </del><a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)"><del>AArch64.Abort</del></a><del>(address, memaddrdesc.fault);

    // Memory array access
    if </del><a href="shared_pseudocode.html#impl-shared.AllocationTagAccessIsEnabled.0" title="function: boolean AllocationTagAccessIsEnabled()"><del>AllocationTagAccessIsEnabled</del></a><del>() then
        _MemTag[memaddrdesc] = value;</del></p></div><div class="ps" psname="aarch32.functions.ras.AArch32.vESBOperation"><a id="aarch32.functions.ras.AArch32.vESBOperation" name="aarch32.functions.ras.AArch32.vESBOperation"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>ras</ins><del>memory</del>/<ins>AArch32.vESBOperation</ins><del>MemU</del></h3><p class="pseudocode"><ins>// AArch32.vESBOperation()
// =======================
// Perform the ESB operation for virtual SError interrupts executed in AArch32 state</ins><del>// MemU[] - non-assignment form
// ============================

bits(8*size)</del>

<a id="AArch32.vESBOperation.0" name="AArch32.vESBOperation.0"></a><ins>AArch32.vESBOperation()
    assert</ins><del>MemU[bits(32) address, integer size]
    acctype =</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NORMAL</del></a><ins>() &amp;&amp; PSTATE.EL IN {</ins><del>;
    return</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.read.3" title="accessor: bits(size*8) Mem_with_type[bits(32) address, integer size, AccType acctype]"><del>Mem_with_type</del></a><ins>,</ins><del>[address, size, acctype];

// MemU[] - assignment form
// ========================</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>};

    // Check for EL2 using AArch64 state
    if !</ins><del>MemU[bits(32) address, integer size] = bits(8*size) value
    acctype =</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NORMAL</del></a><ins>(</ins><del>;</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.write.3" title="accessor: Mem_with_type[bits(32) address, integer size, AccType acctype] = bits(size*8) value"><del>Mem_with_type</del></a><ins>) then
        </ins><a href="shared_pseudocode.html#AArch64.vESBOperation.0" title="function: AArch64.vESBOperation()"><ins>AArch64.vESBOperation</ins></a><ins>();
        return;

    // If physical SError interrupts are routed to Hyp mode, and TGE is not set, then a
    // virtual SError interrupt might be pending
    vSEI_enabled = HCR.TGE == '0' &amp;&amp; HCR.AMO == '1';
    vSEI_pending = vSEI_enabled &amp;&amp; HCR.VA == '1';
    vintdis      = </ins><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><ins>Halted</ins></a><ins>() || </ins><a href="shared_pseudocode.html#impl-shared.ExternalDebugInterruptsDisabled.1" title="function: boolean ExternalDebugInterruptsDisabled(bits(2) target)"><ins>ExternalDebugInterruptsDisabled</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>);
    vmasked      = vintdis || PSTATE.A == '1';

    // Check for a masked virtual SError pending
    if vSEI_pending &amp;&amp; vmasked then
        VDISR = </ins><a href="shared_pseudocode.html#AArch32.ReportDeferredSError.2" title="function: bits(32) AArch32.ReportDeferredSError(bits(2) AET, bit ExT)"><ins>AArch32.ReportDeferredSError</ins></a><ins>(VDFSR&lt;15:14>, VDFSR&lt;12>);
        HCR.VA = '0';                       // Clear pending virtual SError

</ins><del>[address, size, acctype] = value;
</del>    return;</p></div><div class="ps" psname="aarch32.functions.registers.AArch32.ResetGeneralRegisters"><a id="aarch32.functions.registers.AArch32.ResetGeneralRegisters" name="aarch32.functions.registers.AArch32.ResetGeneralRegisters"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>registers</ins><del>memory</del>/<ins>AArch32.ResetGeneralRegisters</ins><del>MemU_unpriv</del></h3><p class="pseudocode"><ins>// AArch32.ResetGeneralRegisters()
// ===============================</ins><del>// MemU_unpriv[] - non-assignment form
// ===================================

bits(8*size)</del>

<a id="AArch32.ResetGeneralRegisters.0" name="AArch32.ResetGeneralRegisters.0"></a><ins>AArch32.ResetGeneralRegisters()

    for i = 0 to 7</ins><del>MemU_unpriv[bits(32) address, integer size]
    acctype =</del>
        <a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value"><ins>R</ins></a><a href="shared_pseudocode.html#AccType_UNPRIV" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_UNPRIV</del></a><ins>[i] = bits(32) UNKNOWN;
    for i = 8 to 12</ins><del>;
    return</del>
        <a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value"><ins>Rmode</ins></a><a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.read.3" title="accessor: bits(size*8) Mem_with_type[bits(32) address, integer size, AccType acctype]"><del>Mem_with_type</del></a><ins>[i,</ins><del>[address, size, acctype];

// MemU_unpriv[] - assignment form
// ===============================</del> <a href="shared_pseudocode.html#M32_User" title="constant bits(5) M32_User = '10000'"><ins>M32_User</ins></a><ins>] = bits(32) UNKNOWN;</ins><del>MemU_unpriv[bits(32) address, integer size] = bits(8*size) value
    acctype =</del>
        <a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value"><ins>Rmode</ins></a><a href="shared_pseudocode.html#AccType_UNPRIV" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_UNPRIV</del></a><ins>[i,</ins><del>;</del> <a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'"><ins>M32_FIQ</ins></a><a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.write.3" title="accessor: Mem_with_type[bits(32) address, integer size, AccType acctype] = bits(size*8) value"><del>Mem_with_type</del></a><ins>] = bits(32) UNKNOWN;
    if </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) then </ins><a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value"><ins>Rmode</ins></a><ins>[13, </ins><a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'"><ins>M32_Hyp</ins></a><ins>] = bits(32) UNKNOWN;   // No R14_hyp
    for i = 13 to 14
        </ins><a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value"><ins>Rmode</ins></a><ins>[i, </ins><a href="shared_pseudocode.html#M32_User" title="constant bits(5) M32_User = '10000'"><ins>M32_User</ins></a><ins>] = bits(32) UNKNOWN;
        </ins><a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value"><ins>Rmode</ins></a><ins>[i, </ins><a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'"><ins>M32_FIQ</ins></a><ins>] = bits(32) UNKNOWN;
        </ins><a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value"><ins>Rmode</ins></a><ins>[i, </ins><a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'"><ins>M32_IRQ</ins></a><ins>] = bits(32) UNKNOWN;
        </ins><a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value"><ins>Rmode</ins></a><ins>[i, </ins><a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'"><ins>M32_Svc</ins></a><ins>] = bits(32) UNKNOWN;
        </ins><a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value"><ins>Rmode</ins></a><ins>[i, </ins><a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'"><ins>M32_Abort</ins></a><ins>] = bits(32) UNKNOWN;
        </ins><a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value"><ins>Rmode</ins></a><ins>[i, </ins><a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'"><ins>M32_Undef</ins></a><ins>] = bits(32) UNKNOWN;
        if </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) then </ins><a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value"><ins>Rmode</ins></a><ins>[i, </ins><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><ins>M32_Monitor</ins></a><ins>] = bits(32) UNKNOWN;

</ins><del>[address, size, acctype] = value;
</del>    return;</p></div><div class="ps" psname="aarch32.functions.registers.AArch32.ResetSIMDFPRegisters"><a id="aarch32.functions.registers.AArch32.ResetSIMDFPRegisters" name="aarch32.functions.registers.AArch32.ResetSIMDFPRegisters"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>registers</ins><del>memory</del>/<ins>AArch32.ResetSIMDFPRegisters</ins><del>Mem_with_type</del></h3><p class="pseudocode"><ins>// AArch32.ResetSIMDFPRegisters()
// ==============================</ins><del>// Mem_with_type[] - non-assignment (read) form
// ============================================
// Perform a read of 'size' bytes. The access byte order is reversed for a big-endian access.
// Instruction fetches would call AArch32.MemSingle directly.

bits(size*8)</del>

<a id="AArch32.ResetSIMDFPRegisters.0" name="AArch32.ResetSIMDFPRegisters.0"></a><ins>AArch32.ResetSIMDFPRegisters()

    for i = 0 to 15</ins><del>Mem_with_type[bits(32) address, integer size,</del>
        <del> acctype]
    assert size IN {1, 2, 4, 8, 16};
    bits(size*8) value;
    boolean iswrite = FALSE;

    aligned = </del><a href="shared_pseudocode.html#AArch32.CheckAlignment.4" title="function: boolean AArch32.CheckAlignment(bits(32) address, integer alignment, AccType acctype, boolean iswrite)"><del>AArch32.CheckAlignment</del></a><del>(address, size, acctype, iswrite);
    if !aligned then
        assert size > 1;
        value&lt;7:0> = </del><a href="shared_pseudocode.html#AArch32.MemSingle.read.4" title="accessor: bits(size*8) AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean wasaligned]"><del>AArch32.MemSingle</del></a><del>[address, 1, acctype, aligned];

        // For subsequent bytes it is CONSTRAINED UNPREDICTABLE whether an unaligned Device memory
        // access will generate an Alignment Fault, as to get this far means the first byte did
        // not, so we must be changing to a new translation page.
        c = </del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><del>ConstrainUnpredictable</del></a><del>(</del><a href="shared_pseudocode.html#Unpredictable_DEVPAGE2" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_DEVPAGE2</del></a><del>);
        assert c IN {</del><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FAULT</del></a><del>, </del><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_NONE</del></a><del>};
        if c == </del><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_NONE</del></a><del> then aligned = TRUE;

        for i = 1 to size-1
            value&lt;8*i+7:8*i> = </del><a href="shared_pseudocode.html#AArch32.MemSingle.read.4" title="accessor: bits(size*8) AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean wasaligned]"><del>AArch32.MemSingle</del></a><del>[address+i, 1, acctype, aligned];
    else
        value = </del><a href="shared_pseudocode.html#AArch32.MemSingle.read.4" title="accessor: bits(size*8) AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean wasaligned]"><del>AArch32.MemSingle</del></a><del>[address, size, acctype, aligned];

    if </del><a href="shared_pseudocode.html#impl-shared.BigEndian.0" title="function: boolean BigEndian()"><del>BigEndian</del></a><del>() then
        value = </del><a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)"><del>BigEndianReverse</del></a><del>(value);
    return value;

// Mem_with_type[] - assignment (write) form
// =========================================
// Perform a write of 'size' bytes. The byte order is reversed for a big-endian access.

</del><a id="impl-aarch32.Mem_with_type.write.3" name="impl-aarch32.Mem_with_type.write.3"></a><del>Mem_with_type[bits(32) address, integer size, </del><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><del> acctype] = bits(size*8) value
    boolean iswrite = TRUE;

    if </del><a href="shared_pseudocode.html#impl-shared.BigEndian.0" title="function: boolean BigEndian()"><del>BigEndian</del></a><del>() then
        value = </del><a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)"><del>BigEndianReverse</del></a><del>(value);

    aligned = </del><a href="shared_pseudocode.html#AArch32.CheckAlignment.4" title="function: boolean AArch32.CheckAlignment(bits(32) address, integer alignment, AccType acctype, boolean iswrite)"><del>AArch32.CheckAlignment</del></a><del>(address, size, acctype, iswrite);

    if !aligned then
        assert size > 1;
        </del><a href="shared_pseudocode.html#AArch32.MemSingle.write.4" title="accessor: AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean wasaligned] = bits(size*8) value"><del>AArch32.MemSingle</del></a><del>[address, 1, acctype, aligned] = value&lt;7:0>;

        // For subsequent bytes it is CONSTRAINED UNPREDICTABLE whether an unaligned Device memory
        // access will generate an Alignment Fault, as to get this far means the first byte did
        // not, so we must be changing to a new translation page.
        c = </del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><del>ConstrainUnpredictable</del></a><del>(</del><a href="shared_pseudocode.html#Unpredictable_DEVPAGE2" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_DEVPAGE2</del></a><del>);
        assert c IN {</del><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FAULT</del></a><del>, </del><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_NONE</del></a><del>};
        if c == </del><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_NONE</del></a><del> then aligned = TRUE;

        for i = 1 to size-1
            </del><a href="shared_pseudocode.html#AArch32.MemSingle.write.4" title="accessor: AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean wasaligned] = bits(size*8) value"><del>AArch32.MemSingle</del></a><del>[address+i, 1, acctype, aligned] = value&lt;8*i+7:8*i>;
    else
        </del><a href="shared_pseudocode.html#AArch32.MemSingle.write.4" title="accessor: AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean wasaligned] = bits(size*8) value"><del>AArch32.MemSingle</del></a><a href="shared_pseudocode.html#impl-aarch32.Q.write.1" title="accessor: Q[integer n] = bits(128) value"><ins>Q</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><ins>[i] = bits(128) UNKNOWN;

</ins><del>[address, size, acctype, aligned] = value;
</del>    return;</p></div><div class="ps" psname="aarch32.functions.registers.AArch32.ResetSpecialRegisters"><a id="aarch32.functions.registers.AArch32.ResetSpecialRegisters" name="aarch32.functions.registers.AArch32.ResetSpecialRegisters"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>registers</ins><del>memory</del>/<ins>AArch32.ResetSpecialRegisters</ins><del>TransformTag</del></h3><p class="pseudocode"><ins>// AArch32.ResetSpecialRegisters()
// ===============================</ins><del>// TransformTag()
// ==============
// Apply tag transformation rules.

bits(4)</del>

<a id="AArch32.ResetSpecialRegisters.0" name="AArch32.ResetSpecialRegisters.0"></a><ins>AArch32.ResetSpecialRegisters()

    // AArch32 special registers
    SPSR_fiq = bits(32) UNKNOWN;
    SPSR_irq = bits(32) UNKNOWN;
    SPSR_svc = bits(32) UNKNOWN;
    SPSR_abt = bits(32) UNKNOWN;
    SPSR_und = bits(32) UNKNOWN;
    if</ins><del>TransformTag(bits(64) vaddr)
    bits(4) vtag = vaddr&lt;59:56>;
    bits(4) tagdelta =</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) then
        SPSR_hyp = bits(32) UNKNOWN;
        ELR_hyp = bits(32) UNKNOWN;
    if </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) then
        SPSR_mon = bits(32) UNKNOWN;

    // External debug special registers
    DLR = bits(32) UNKNOWN;
    DSPSR = bits(32) UNKNOWN;

    return;</ins><del>(vaddr&lt;55>);
    bits(4) ptag = vtag + tagdelta;
    return ptag;</del></p></div><div class="ps" psname="aarch32.functions.registers.AArch32.ResetSystemRegisters"><a id="aarch32.functions.registers.AArch32.ResetSystemRegisters" name="aarch32.functions.registers.AArch32.ResetSystemRegisters"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>registers</ins><del>memory</del>/<ins>AArch32.ResetSystemRegisters</ins><del>boolean</del></h3><p class="pseudocode"><del>// boolean AccessIsTagChecked()
// ============================
// TRUE if a given access is tag-checked, FALSE otherwise.

boolean </del><a id="AArch32.ResetSystemRegisters.1" name="AArch32.ResetSystemRegisters.1"></a><del>AccessIsTagChecked(bits(64) vaddr, </del><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><del> acctype)
    if PSTATE.M&lt;4> == '1' then return FALSE;

    if </del><a href="shared_pseudocode.html#impl-shared.EffectiveTBI.3" title="function: bit EffectiveTBI(bits(64) address, boolean IsInstr, bits(2) el)"><del>EffectiveTBI</del></a><del>(vaddr, FALSE, PSTATE.EL) == '0' then
        return FALSE;

    if </del><a href="shared_pseudocode.html#impl-shared.EffectiveTCMA.2" title="function: bit EffectiveTCMA(bits(64) address, bits(2) el)"><del>EffectiveTCMA</del></a><del>(vaddr, PSTATE.EL) == '1' &amp;&amp; (vaddr&lt;59:55> == '00000' || vaddr&lt;59:55> == '11111') then
        return FALSE;

    if !</del><a href="shared_pseudocode.html#impl-shared.AllocationTagAccessIsEnabled.0" title="function: boolean AllocationTagAccessIsEnabled()"><del>AllocationTagAccessIsEnabled</del></a><del>() then
        return FALSE;

    if acctype IN {</del><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IFETCH</del></a><del>, </del><a href="shared_pseudocode.html#AccType_PTW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_PTW</del></a><del>} then
        return FALSE;

    if acctype == </del><a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NV2REGISTER</del></a><ins>AArch32.ResetSystemRegisters(boolean cold_reset);</ins><del>then
        return FALSE;

    if PSTATE.TCO=='1' then
        return FALSE;

    if IsNonTagCheckedInstruction() then
        return FALSE;

    return TRUE;</del></p></div><div class="ps" psname="aarch32.functions.registers.ALUExceptionReturn"><a id="aarch32.functions.registers.ALUExceptionReturn" name="aarch32.functions.registers.ALUExceptionReturn"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>registers</ins><del>ras</del>/<ins>ALUExceptionReturn</ins><del>AArch32.ESBOperation</del></h3><p class="pseudocode"><ins>// ALUExceptionReturn()
// ====================</ins><del>// AArch32.ESBOperation()
// ======================
// Perform the AArch32 ESB operation for ESB executed in AArch32 state</del>

<a id="impl-aarch32.ALUExceptionReturn.1" name="impl-aarch32.ALUExceptionReturn.1"></a><ins>ALUExceptionReturn(bits(32) address)
    if PSTATE.EL ==</ins><del>AArch32.ESBOperation()

    // Check if routed to AArch64 state
    route_to_aarch64 = PSTATE.EL ==</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del> &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>);
    if !route_to_aarch64 &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> <ins>then
        UNDEFINED;
    elsif PSTATE.M IN {</ins><del>) then
        route_to_aarch64 = HCR_EL2.TGE == '1' || HCR_EL2.AMO == '1';
    if !route_to_aarch64 &amp;&amp;</del><a href="shared_pseudocode.html#M32_User" title="constant bits(5) M32_User = '10000'"><ins>M32_User</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>,</ins><del>(</del><a href="shared_pseudocode.html#M32_System" title="constant bits(5) M32_System = '11111'"><ins>M32_System</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><ins>} then
        UNPREDICTABLE;          // UNDEFINED or NOP
    else</ins><del>) &amp;&amp; !</del>
        <a href="shared_pseudocode.html#AArch32.ExceptionReturn.2" title="function: AArch32.ExceptionReturn(bits(32) new_pc, bits(32) spsr)"><ins>AArch32.ExceptionReturn</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><ins>(address,</ins><del>(</del> <del>) then
        route_to_aarch64 = SCR_EL3.EA == '1';

    if route_to_aarch64 then
        </del><a href="shared_pseudocode.html#AArch64.ESBOperation.0" title="function: AArch64.ESBOperation()"><del>AArch64.ESBOperation</del></a><del>();
        return;

    route_to_monitor = </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; SCR.EA == '1';
    route_to_hyp = </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; PSTATE.EL IN {</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>,</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>} &amp;&amp; (HCR.TGE == '1' || HCR.AMO == '1');

    if route_to_monitor then
        target = </del><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><del>M32_Monitor</del></a><del>;
    elsif route_to_hyp || PSTATE.M == </del><a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'"><del>M32_Hyp</del></a><del> then
        target = </del><a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'"><del>M32_Hyp</del></a><del>;
    else
        target = </del><a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'"><del>M32_Abort</del></a><del>;

    if </del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>() then
        mask_active = TRUE;
    elsif target == </del><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><del>M32_Monitor</del></a><del> then
        mask_active = SCR.AW == '1' &amp;&amp; (!</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) || (HCR.TGE == '0' &amp;&amp; HCR.AMO == '0'));
    else
        mask_active = target == </del><a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'"><del>M32_Abort</del></a><del> || PSTATE.M == </del><a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'"><del>M32_Hyp</del></a><del>;

    mask_set = PSTATE.A == '1';
    (-, el)  = </del><a href="shared_pseudocode.html#impl-shared.ELFromM32.1" title="function: (boolean,bits(2)) ELFromM32(bits(5) mode)"><del>ELFromM32</del></a><del>(target);
    intdis   = </del><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><del>Halted</del></a><del>() || </del><a href="shared_pseudocode.html#impl-shared.ExternalDebugInterruptsDisabled.1" title="function: boolean ExternalDebugInterruptsDisabled(bits(2) target)"><del>ExternalDebugInterruptsDisabled</del></a><del>(el);
    masked   = intdis || (mask_active &amp;&amp; mask_set);

    // Check for a masked Physical SError pending
    if </del><a href="shared_pseudocode.html#impl-shared.IsPhysicalSErrorPending.0" title="function: boolean IsPhysicalSErrorPending()"><del>IsPhysicalSErrorPending</del></a><del>() &amp;&amp; masked then
        syndrome32 = </del><a href="shared_pseudocode.html#AArch32.PhysicalSErrorSyndrome.0" title="function: AArch32.SErrorSyndrome AArch32.PhysicalSErrorSyndrome()"><del>AArch32.PhysicalSErrorSyndrome</del></a><del>();
        DISR = </del><a href="shared_pseudocode.html#AArch32.ReportDeferredSError.2" title="function: bits(32) AArch32.ReportDeferredSError(bits(2) AET, bit ExT)"><del>AArch32.ReportDeferredSError</del></a><del>(syndrome32.AET, syndrome32.ExT);
        </del><a href="shared_pseudocode.html#impl-shared.ClearPendingPhysicalSError.0" title="function: ClearPendingPhysicalSError()"><del>ClearPendingPhysicalSError</del></a><a href="shared_pseudocode.html#impl-shared.SPSR.read.0" title="accessor: bits(32) SPSR[]"><ins>SPSR</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><ins>[]);</ins><del>();

    return;</del></p></div><div class="ps" psname="aarch32.functions.registers.ALUWritePC"><a id="aarch32.functions.registers.ALUWritePC" name="aarch32.functions.registers.ALUWritePC"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>registers</ins><del>ras</del>/<ins>ALUWritePC</ins><del>AArch32.PhysicalSErrorSyndrome</del></h3><p class="pseudocode"><ins>// ALUWritePC()
// ============</ins><del>// Return the SError syndrome
AArch32.SErrorSyndrome</del>

<a id="impl-aarch32.ALUWritePC.1" name="impl-aarch32.ALUWritePC.1"></a><ins>ALUWritePC(bits(32) address)
    if</ins><del>AArch32.PhysicalSErrorSyndrome();</del> <a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()"><ins>CurrentInstrSet</ins></a><ins>() == </ins><a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><ins>InstrSet_A32</ins></a><ins> then
        </ins><a href="shared_pseudocode.html#impl-aarch32.BXWritePC.2" title="function: BXWritePC(bits(32) address, BranchType branch_type)"><ins>BXWritePC</ins></a><ins>(address, </ins><a href="shared_pseudocode.html#BranchType_INDIR" title="enumeration BranchType { BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}"><ins>BranchType_INDIR</ins></a><ins>);
    else
        </ins><a href="shared_pseudocode.html#impl-aarch32.BranchWritePC.2" title="function: BranchWritePC(bits(32) address, BranchType branch_type)"><ins>BranchWritePC</ins></a><ins>(address, </ins><a href="shared_pseudocode.html#BranchType_INDIR" title="enumeration BranchType { BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}"><ins>BranchType_INDIR</ins></a><ins>);</ins></p></div><div class="ps" psname="aarch32.functions.registers.BXWritePC"><a id="aarch32.functions.registers.BXWritePC" name="aarch32.functions.registers.BXWritePC"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>registers</ins><del>ras</del>/<ins>BXWritePC</ins><del>AArch32.ReportDeferredSError</del></h3><p class="pseudocode"><ins>// BXWritePC()
// ===========</ins><del>// AArch32.ReportDeferredSError()
// ==============================
// Return deferred SError syndrome

bits(32)</del>

<a id="impl-aarch32.BXWritePC.2" name="impl-aarch32.BXWritePC.2"></a><ins>BXWritePC(bits(32) address,</ins><del>AArch32.ReportDeferredSError(bits(2) AET, bit ExT)
    bits(32) target;
    target&lt;31> = '1';                       // A
    syndrome =</del> <a href="shared_pseudocode.html#BranchType" title="enumeration BranchType { BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}"><ins>BranchType</ins></a><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a> <ins>branch_type)
    if address&lt;0> == '1' then</ins><del>(16);
    if PSTATE.EL ==</del>
        <a href="shared_pseudocode.html#impl-aarch32.SelectInstrSet.1" title="function: SelectInstrSet(InstrSet iset)"><ins>SelectInstrSet</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>(</ins><del>then
        syndrome&lt;11:10> = AET;              // AET
        syndrome&lt;9>     = ExT;              // EA
        syndrome&lt;5:0>   = '010001';         // DFSC
    else
        syndrome&lt;15:14> = AET;              // AET
        syndrome&lt;12>    = ExT;              // ExT
        syndrome&lt;9>     = TTBCR.EAE;        // LPAE
        if TTBCR.EAE == '1' then            // Long-descriptor format
            syndrome&lt;5:0>    = '010001';    // STATUS
        else                                // Short-descriptor format
            syndrome&lt;10,3:0> = '10110';     // FS
    if</del><a href="shared_pseudocode.html#InstrSet_T32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><ins>InstrSet_T32</ins></a><a href="shared_pseudocode.html#impl-shared.HaveAnyAArch64.0" title="function: boolean HaveAnyAArch64()"><del>HaveAnyAArch64</del></a><ins>);
        address&lt;0> = '0';
    else</ins><del>() then
        target&lt;24:0> =</del>
        <a href="shared_pseudocode.html#impl-aarch32.SelectInstrSet.1" title="function: SelectInstrSet(InstrSet iset)"><ins>SelectInstrSet</ins></a><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><ins>(</ins><a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><ins>InstrSet_A32</ins></a><ins>);
        // For branches to an unaligned PC counter in A32 state, the processor takes the branch
        // and does one of:
        // * Forces the address to be aligned
        // * Leaves the PC unaligned, meaning the target generates a PC Alignment fault.
        if address&lt;1> == '1' &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><ins>ConstrainUnpredictableBool</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_A32FORCEALIGNPC" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_A32FORCEALIGNPC</ins></a><ins>) then
            address&lt;1> = '0';
    </ins><a href="shared_pseudocode.html#impl-shared.BranchTo.2" title="function: BranchTo(bits(N) target, BranchType branch_type)"><ins>BranchTo</ins></a><ins>(address, branch_type);</ins><del>(syndrome);// Any RES0 fields must be set to zero
    else
        target&lt;15:0> = syndrome;
    return target;</del></p></div><div class="ps" psname="aarch32.functions.registers.BranchWritePC"><a id="aarch32.functions.registers.BranchWritePC" name="aarch32.functions.registers.BranchWritePC"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>registers</ins><del>ras</del>/<ins>BranchWritePC</ins><del>AArch32.SErrorSyndrome</del></h3><p class="pseudocode"><ins>// BranchWritePC()
// ===============</ins><del>type</del>

<a id="impl-aarch32.BranchWritePC.2" name="impl-aarch32.BranchWritePC.2"></a><ins>BranchWritePC(bits(32) address,</ins><del>AArch32.SErrorSyndrome is (
    bits(2) AET,
    bit ExT
)</del> <a href="shared_pseudocode.html#BranchType" title="enumeration BranchType { BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}"><ins>BranchType</ins></a><ins> branch_type)
    if </ins><a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()"><ins>CurrentInstrSet</ins></a><ins>() == </ins><a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><ins>InstrSet_A32</ins></a><ins> then
        address&lt;1:0> = '00';
    else
        address&lt;0> = '0';
    </ins><a href="shared_pseudocode.html#impl-shared.BranchTo.2" title="function: BranchTo(bits(N) target, BranchType branch_type)"><ins>BranchTo</ins></a><ins>(address, branch_type);</ins></p></div><div class="ps" psname="aarch32.functions.registers.D"><a id="aarch32.functions.registers.D" name="aarch32.functions.registers.D"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>registers</ins><del>ras</del>/<ins>D</ins><del>AArch32.vESBOperation</del></h3><p class="pseudocode"><ins>// D[] - non-assignment form
// =========================

bits(64)</ins><del>// AArch32.vESBOperation()
// =======================
// Perform the ESB operation for virtual SError interrupts executed in AArch32 state</del> <a id="impl-aarch32.D.read.1" name="impl-aarch32.D.read.1"></a><ins>D[integer n]
    assert n >= 0 &amp;&amp; n &lt;= 31;
    base = (n MOD 2) * 64;
    return _V[n DIV 2]&lt;base+63:base>;

// D[] - assignment form
// =====================</ins><del>AArch32.vESBOperation()
    assert</del>

<del>() &amp;&amp; PSTATE.EL IN {</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>,</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>};

    // Check for EL2 using AArch64 state
    if !</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) then
        </del><a href="shared_pseudocode.html#AArch64.vESBOperation.0" title="function: AArch64.vESBOperation()"><del>AArch64.vESBOperation</del></a><del>();
        return;

    // If physical SError interrupts are routed to Hyp mode, and TGE is not set, then a
    // virtual SError interrupt might be pending
    vSEI_enabled = HCR.TGE == '0' &amp;&amp; HCR.AMO == '1';
    vSEI_pending = vSEI_enabled &amp;&amp; HCR.VA == '1';
    vintdis      = </del><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><del>Halted</del></a><del>() || </del><a href="shared_pseudocode.html#impl-shared.ExternalDebugInterruptsDisabled.1" title="function: boolean ExternalDebugInterruptsDisabled(bits(2) target)"><del>ExternalDebugInterruptsDisabled</del></a><del>(</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>);
    vmasked      = vintdis || PSTATE.A == '1';

    // Check for a masked virtual SError pending
    if vSEI_pending &amp;&amp; vmasked then
        VDISR = </del><a href="shared_pseudocode.html#AArch32.ReportDeferredSError.2" title="function: bits(32) AArch32.ReportDeferredSError(bits(2) AET, bit ExT)"><del>AArch32.ReportDeferredSError</del></a><a id="impl-aarch32.D.write.1" name="impl-aarch32.D.write.1"></a><ins>D[integer n] = bits(64) value
    assert n >= 0 &amp;&amp; n &lt;= 31;
    base = (n MOD 2) * 64;
    _V[n DIV 2]&lt;base+63:base> = value;
</ins><del>(VDFSR&lt;15:14>, VDFSR&lt;12>);
        HCR.VA = '0';                       // Clear pending virtual SError

</del>    return;</p></div><div class="ps" psname="aarch32.functions.registers.Din"><a id="aarch32.functions.registers.Din" name="aarch32.functions.registers.Din"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/<ins>Din</ins><del>AArch32.ResetGeneralRegisters</del></h3><p class="pseudocode"><ins>// Din[] - non-assignment form
// ===========================

bits(64)</ins><del>// AArch32.ResetGeneralRegisters()
// ===============================</del> <a id="impl-aarch32.Din.read.1" name="impl-aarch32.Din.read.1"></a><ins>Din[integer n]
    assert n >= 0 &amp;&amp; n &lt;= 31;
    return _Dclone[n];</ins><del>AArch32.ResetGeneralRegisters()

    for i = 0 to 7</del><a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value"><del>R</del></a><del>[i] = bits(32) UNKNOWN;
    for i = 8 to 12
        </del><a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value"><del>Rmode</del></a><del>[i, </del><a href="shared_pseudocode.html#M32_User" title="constant bits(5) M32_User = '10000'"><del>M32_User</del></a><del>] = bits(32) UNKNOWN;
        </del><a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value"><del>Rmode</del></a><del>[i, </del><a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'"><del>M32_FIQ</del></a><del>] = bits(32) UNKNOWN;
    if </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) then </del><a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value"><del>Rmode</del></a><del>[13, </del><a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'"><del>M32_Hyp</del></a><del>] = bits(32) UNKNOWN;   // No R14_hyp
    for i = 13 to 14
        </del><a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value"><del>Rmode</del></a><del>[i, </del><a href="shared_pseudocode.html#M32_User" title="constant bits(5) M32_User = '10000'"><del>M32_User</del></a><del>] = bits(32) UNKNOWN;
        </del><a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value"><del>Rmode</del></a><del>[i, </del><a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'"><del>M32_FIQ</del></a><del>] = bits(32) UNKNOWN;
        </del><a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value"><del>Rmode</del></a><del>[i, </del><a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'"><del>M32_IRQ</del></a><del>] = bits(32) UNKNOWN;
        </del><a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value"><del>Rmode</del></a><del>[i, </del><a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'"><del>M32_Svc</del></a><del>] = bits(32) UNKNOWN;
        </del><a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value"><del>Rmode</del></a><del>[i, </del><a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'"><del>M32_Abort</del></a><del>] = bits(32) UNKNOWN;
        </del><a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value"><del>Rmode</del></a><del>[i, </del><a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'"><del>M32_Undef</del></a><del>] = bits(32) UNKNOWN;
        if </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) then </del><a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value"><del>Rmode</del></a><del>[i, </del><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><del>M32_Monitor</del></a><del>] = bits(32) UNKNOWN;

    return;</del></p></div><div class="ps" psname="aarch32.functions.registers.LR"><a id="aarch32.functions.registers.LR" name="aarch32.functions.registers.LR"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/<ins>LR</ins><del>AArch32.ResetSIMDFPRegisters</del></h3><p class="pseudocode"><ins>// LR - assignment form
// ====================</ins><del>// AArch32.ResetSIMDFPRegisters()
// ==============================</del>

<a id="impl-aarch32.LR.write.none" name="impl-aarch32.LR.write.none"></a><ins>LR = bits(32) value</ins><del>AArch32.ResetSIMDFPRegisters()

    for i = 0 to 15</del>
    <a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value"><ins>R</ins></a><a href="shared_pseudocode.html#impl-aarch32.Q.write.1" title="accessor: Q[integer n] = bits(128) value"><del>Q</del></a><ins>[14] = value;
    return;

// LR - non-assignment form
// ========================

bits(32) LR
    return </ins><a href="shared_pseudocode.html#impl-aarch32.R.read.1" title="accessor: bits(32) R[integer n]"><ins>R</ins></a><ins>[14];</ins><del>[i] = bits(128) UNKNOWN;

    return;</del></p></div><div class="ps" psname="aarch32.functions.registers.LoadWritePC"><a id="aarch32.functions.registers.LoadWritePC" name="aarch32.functions.registers.LoadWritePC"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/<ins>LoadWritePC</ins><del>AArch32.ResetSpecialRegisters</del></h3><p class="pseudocode"><ins>// LoadWritePC()
// =============</ins><del>// AArch32.ResetSpecialRegisters()
// ===============================</del>

<a id="impl-aarch32.LoadWritePC.1" name="impl-aarch32.LoadWritePC.1"></a><ins>LoadWritePC(bits(32) address)</ins><del>AArch32.ResetSpecialRegisters()

    // AArch32 special registers
    SPSR_fiq = bits(32) UNKNOWN;
    SPSR_irq = bits(32) UNKNOWN;
    SPSR_svc = bits(32) UNKNOWN;
    SPSR_abt = bits(32) UNKNOWN;
    SPSR_und = bits(32) UNKNOWN;
    if</del>
    <a href="shared_pseudocode.html#impl-aarch32.BXWritePC.2" title="function: BXWritePC(bits(32) address, BranchType branch_type)"><ins>BXWritePC</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>(address,</ins><del>(</del> <del>) then
        SPSR_hyp = bits(32) UNKNOWN;
        ELR_hyp = bits(32) UNKNOWN;
    if </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><a href="shared_pseudocode.html#BranchType_INDIR" title="enumeration BranchType { BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}"><ins>BranchType_INDIR</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>);</ins><del>) then
        SPSR_mon = bits(32) UNKNOWN;

    // External debug special registers
    DLR = bits(32) UNKNOWN;
    DSPSR = bits(32) UNKNOWN;

    return;</del></p></div><div class="ps" psname="aarch32.functions.registers.LookUpRIndex"><a id="aarch32.functions.registers.LookUpRIndex" name="aarch32.functions.registers.LookUpRIndex"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/<ins>LookUpRIndex</ins><del>AArch32.ResetSystemRegisters</del></h3><p class="pseudocode"><ins>// LookUpRIndex()
// ==============

integer </ins><a id="impl-aarch32.LookUpRIndex.2" name="impl-aarch32.LookUpRIndex.2"></a><ins>LookUpRIndex(integer n, bits(5) mode)
    assert n >= 0 &amp;&amp; n &lt;= 14;

    case n of  // Select  index by mode:     usr fiq irq svc abt und hyp
        when 8     result = </ins><a href="shared_pseudocode.html#impl-aarch32.RBankSelect.8" title="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq, integer svc, integer abt, integer und, integer hyp)"><ins>RBankSelect</ins></a><ins>(mode,  8, 24,  8,  8,  8,  8,  8);
        when 9     result = </ins><a href="shared_pseudocode.html#impl-aarch32.RBankSelect.8" title="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq, integer svc, integer abt, integer und, integer hyp)"><ins>RBankSelect</ins></a><ins>(mode,  9, 25,  9,  9,  9,  9,  9);
        when 10    result = </ins><a href="shared_pseudocode.html#impl-aarch32.RBankSelect.8" title="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq, integer svc, integer abt, integer und, integer hyp)"><ins>RBankSelect</ins></a><ins>(mode, 10, 26, 10, 10, 10, 10, 10);
        when 11    result = </ins><a href="shared_pseudocode.html#impl-aarch32.RBankSelect.8" title="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq, integer svc, integer abt, integer und, integer hyp)"><ins>RBankSelect</ins></a><ins>(mode, 11, 27, 11, 11, 11, 11, 11);
        when 12    result = </ins><a href="shared_pseudocode.html#impl-aarch32.RBankSelect.8" title="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq, integer svc, integer abt, integer und, integer hyp)"><ins>RBankSelect</ins></a><ins>(mode, 12, 28, 12, 12, 12, 12, 12);
        when 13    result = </ins><a href="shared_pseudocode.html#impl-aarch32.RBankSelect.8" title="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq, integer svc, integer abt, integer und, integer hyp)"><ins>RBankSelect</ins></a><ins>(mode, 13, 29, 17, 19, 21, 23, 15);
        when 14    result = </ins><a href="shared_pseudocode.html#impl-aarch32.RBankSelect.8" title="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq, integer svc, integer abt, integer und, integer hyp)"><ins>RBankSelect</ins></a><ins>(mode, 14, 30, 16, 18, 20, 22, 14);
        otherwise  result = n;

    return result;</ins><del>AArch32.ResetSystemRegisters(boolean cold_reset);</del></p></div><div class="ps" psname="aarch32.functions.registers.Monitor_mode_registers"><a id="aarch32.functions.registers.Monitor_mode_registers" name="aarch32.functions.registers.Monitor_mode_registers"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/<ins>Monitor_mode_registers</ins><del>ALUExceptionReturn</del></h3><p class="pseudocode"><ins>bits(32) SP_mon;
bits(32) LR_mon;</ins><del>// ALUExceptionReturn()
// ====================</del><a id="impl-aarch32.ALUExceptionReturn.1" name="impl-aarch32.ALUExceptionReturn.1"></a><del>ALUExceptionReturn(bits(32) address)
    if PSTATE.EL == </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del> then
        UNDEFINED;
    elsif PSTATE.M IN {</del><a href="shared_pseudocode.html#M32_User" title="constant bits(5) M32_User = '10000'"><del>M32_User</del></a><del>,</del><a href="shared_pseudocode.html#M32_System" title="constant bits(5) M32_System = '11111'"><del>M32_System</del></a><del>} then
        UNPREDICTABLE;          // UNDEFINED or NOP
    else
        </del><a href="shared_pseudocode.html#AArch32.ExceptionReturn.2" title="function: AArch32.ExceptionReturn(bits(32) new_pc, bits(32) spsr)"><del>AArch32.ExceptionReturn</del></a><del>(address, </del><a href="shared_pseudocode.html#impl-shared.SPSR.read.0" title="accessor: bits(32) SPSR[]"><del>SPSR</del></a><del>[]);</del></p></div><div class="ps" psname="aarch32.functions.registers.PC"><a id="aarch32.functions.registers.PC" name="aarch32.functions.registers.PC"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/<ins>PC</ins><del>ALUWritePC</del></h3><p class="pseudocode"><ins>// PC - non-assignment form
// ========================

bits(32) PC
    return</ins><del>// ALUWritePC()
// ============</del> <del>ALUWritePC(bits(32) address)
    if </del><a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()"><del>CurrentInstrSet</del></a><del>() == </del><a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><del>InstrSet_A32</del></a><del> then
        </del><a href="shared_pseudocode.html#impl-aarch32.BXWritePC.2" title="function: BXWritePC(bits(32) address, BranchType branch_type)"><del>BXWritePC</del></a><del>(address, </del><a href="shared_pseudocode.html#BranchType_INDIR" title="enumeration BranchType { BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}"><del>BranchType_INDIR</del></a><del>);
    else
        </del><a href="shared_pseudocode.html#impl-aarch32.BranchWritePC.2" title="function: BranchWritePC(bits(32) address, BranchType branch_type)"><del>BranchWritePC</del></a><del>(address, </del><a href="shared_pseudocode.html#BranchType_INDIR" title="enumeration BranchType { BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}"><del>BranchType_INDIR</del></a><a href="shared_pseudocode.html#impl-aarch32.R.read.1" title="accessor: bits(32) R[integer n]"><ins>R</ins></a><ins>[15];               // This includes the offset from AArch32 state</ins><del>);</del></p></div><div class="ps" psname="aarch32.functions.registers.PCStoreValue"><a id="aarch32.functions.registers.PCStoreValue" name="aarch32.functions.registers.PCStoreValue"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/<ins>PCStoreValue</ins><del>BXWritePC</del></h3><p class="pseudocode"><ins>// PCStoreValue()
// ==============

bits(32)</ins><del>// BXWritePC()
// ===========</del> <a id="impl-aarch32.PCStoreValue.0" name="impl-aarch32.PCStoreValue.0"></a><ins>PCStoreValue()
    // This function returns the PC value. On architecture versions before Armv7, it
    // is permitted to instead return PC+4, provided it does so consistently. It is
    // used only to describe A32 instructions, so it returns the address of the current
    // instruction plus 8 (normally) or 12 (when the alternative is permitted).
    return PC;</ins><del>BXWritePC(bits(32) address,</del><a href="shared_pseudocode.html#BranchType" title="enumeration BranchType { BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}"><del>BranchType</del></a><del> branch_type)
    if address&lt;0> == '1' then
        </del><a href="shared_pseudocode.html#impl-aarch32.SelectInstrSet.1" title="function: SelectInstrSet(InstrSet iset)"><del>SelectInstrSet</del></a><del>(</del><a href="shared_pseudocode.html#InstrSet_T32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><del>InstrSet_T32</del></a><del>);
        address&lt;0> = '0';
    else
        </del><a href="shared_pseudocode.html#impl-aarch32.SelectInstrSet.1" title="function: SelectInstrSet(InstrSet iset)"><del>SelectInstrSet</del></a><del>(</del><a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><del>InstrSet_A32</del></a><del>);
        // For branches to an unaligned PC counter in A32 state, the processor takes the branch
        // and does one of:
        // * Forces the address to be aligned
        // * Leaves the PC unaligned, meaning the target generates a PC Alignment fault.
        if address&lt;1> == '1' &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><del>ConstrainUnpredictableBool</del></a><del>(</del><a href="shared_pseudocode.html#Unpredictable_A32FORCEALIGNPC" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_A32FORCEALIGNPC</del></a><del>) then
            address&lt;1> = '0';
    </del><a href="shared_pseudocode.html#impl-shared.BranchTo.2" title="function: BranchTo(bits(N) target, BranchType branch_type)"><del>BranchTo</del></a><del>(address, branch_type);</del></p></div><div class="ps" psname="aarch32.functions.registers.Q"><a id="aarch32.functions.registers.Q" name="aarch32.functions.registers.Q"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/<ins>Q</ins><del>BranchWritePC</del></h3><p class="pseudocode"><ins>// Q[] - non-assignment form
// =========================

bits(128)</ins><del>// BranchWritePC()
// ===============</del> <a id="impl-aarch32.Q.read.1" name="impl-aarch32.Q.read.1"></a><ins>Q[integer n]
    assert n >= 0 &amp;&amp; n &lt;= 15;
    return _V[n];

// Q[] - assignment form
// =====================</ins><del>BranchWritePC(bits(32) address,</del>

<del> branch_type)
    if </del><a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()"><del>CurrentInstrSet</del></a><del>() == </del><a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><del>InstrSet_A32</del></a><del> then
        address&lt;1:0> = '00';
    else
        address&lt;0> = '0';
    </del><a href="shared_pseudocode.html#impl-shared.BranchTo.2" title="function: BranchTo(bits(N) target, BranchType branch_type)"><del>BranchTo</del></a><a id="impl-aarch32.Q.write.1" name="impl-aarch32.Q.write.1"></a><ins>Q[integer n] = bits(128) value
    assert n >= 0 &amp;&amp; n &lt;= 15;
    _V[n] = value;
    return;</ins><del>(address, branch_type);</del></p></div><div class="ps" psname="aarch32.functions.registers.Qin"><a id="aarch32.functions.registers.Qin" name="aarch32.functions.registers.Qin"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/<ins>Qin</ins><del>D</del></h3><p class="pseudocode"><ins>// Qin[] - non-assignment form
// ===========================
</ins><del>// D[] - non-assignment form
// =========================
</del>
<ins>bits(128)</ins><del>bits(64)</del> <a id="impl-aarch32.Qin.read.1" name="impl-aarch32.Qin.read.1"></a><ins>Qin[integer n]
    assert n >= 0 &amp;&amp; n &lt;= 15;
    return</ins><del>D[integer n]
    assert n >= 0 &amp;&amp; n &lt;= 31;
    base = (n MOD 2) * 64;
    return _V[n DIV 2]&lt;base+63:base>;

// D[] - assignment form
// =====================</del> <a href="shared_pseudocode.html#impl-aarch32.Din.read.1" title="accessor: bits(64) Din[integer n]"><ins>Din</ins></a><ins>[2*n+1]:</ins><a href="shared_pseudocode.html#impl-aarch32.Din.read.1" title="accessor: bits(64) Din[integer n]"><ins>Din</ins></a><ins>[2*n];</ins><del>D[integer n] = bits(64) value
    assert n >= 0 &amp;&amp; n &lt;= 31;
    base = (n MOD 2) * 64;
    _V[n DIV 2]&lt;base+63:base> = value;
    return;</del></p></div><div class="ps" psname="aarch32.functions.registers.R"><a id="aarch32.functions.registers.R" name="aarch32.functions.registers.R"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/<ins>R</ins><del>Din</del></h3><p class="pseudocode"><ins>// R[] - assignment form
// =====================</ins><del>// Din[] - non-assignment form
// ===========================

bits(64)</del>

<a id="impl-aarch32.R.write.1" name="impl-aarch32.R.write.1"></a><ins>R[integer n] = bits(32) value</ins><del>Din[integer n]
    assert n >= 0 &amp;&amp; n &lt;= 31;
    return _Dclone[n];</del>
    <a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value"><ins>Rmode</ins></a><ins>[n, PSTATE.M] = value;
    return;

// R[] - non-assignment form
// =========================

bits(32) </ins><a id="impl-aarch32.R.read.1" name="impl-aarch32.R.read.1"></a><ins>R[integer n]
    if n == 15 then
        offset = (if </ins><a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()"><ins>CurrentInstrSet</ins></a><ins>() == </ins><a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><ins>InstrSet_A32</ins></a><ins> then 8 else 4);
        return _PC&lt;31:0> + offset;
    else
        return </ins><a href="shared_pseudocode.html#impl-aarch32.Rmode.read.2" title="accessor: bits(32) Rmode[integer n, bits(5) mode]"><ins>Rmode</ins></a><ins>[n, PSTATE.M];</ins></p></div><div class="ps" psname="aarch32.functions.registers.RBankSelect"><a id="aarch32.functions.registers.RBankSelect" name="aarch32.functions.registers.RBankSelect"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/<ins>RBankSelect</ins><del>LR</del></h3><p class="pseudocode"><ins>// RBankSelect()
// =============

integer</ins><del>// LR - assignment form
// ====================</del> <a id="impl-aarch32.RBankSelect.8" name="impl-aarch32.RBankSelect.8"></a><ins>RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq,
                    integer svc, integer abt, integer und, integer hyp)

    case mode of
        when</ins><del>LR = bits(32) value</del> <a href="shared_pseudocode.html#M32_User" title="constant bits(5) M32_User = '10000'"><ins>M32_User</ins></a><a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value"><del>R</del></a>    <ins>result = usr;  // User mode
        when</ins><del>[14] = value;
    return;

// LR - non-assignment form
// ========================

bits(32) LR
    return</del> <a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'"><ins>M32_FIQ</ins></a><a href="shared_pseudocode.html#impl-aarch32.R.read.1" title="accessor: bits(32) R[integer n]"><del>R</del></a><ins>     result = fiq;  // FIQ mode
        when </ins><a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'"><ins>M32_IRQ</ins></a><ins>     result = irq;  // IRQ mode
        when </ins><a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'"><ins>M32_Svc</ins></a><ins>     result = svc;  // Supervisor mode
        when </ins><a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'"><ins>M32_Abort</ins></a><ins>   result = abt;  // Abort mode
        when </ins><a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'"><ins>M32_Hyp</ins></a><ins>     result = hyp;  // Hyp mode
        when </ins><a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'"><ins>M32_Undef</ins></a><ins>   result = und;  // Undefined mode
        when </ins><a href="shared_pseudocode.html#M32_System" title="constant bits(5) M32_System = '11111'"><ins>M32_System</ins></a><ins>  result = usr;  // System mode uses User mode registers
        otherwise        </ins><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><ins>Unreachable</ins></a><ins>(); // Monitor mode

    return result;</ins><del>[14];</del></p></div><div class="ps" psname="aarch32.functions.registers.Rmode"><a id="aarch32.functions.registers.Rmode" name="aarch32.functions.registers.Rmode"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/<ins>Rmode</ins><del>LoadWritePC</del></h3><p class="pseudocode"><ins>// Rmode[] - non-assignment form
// =============================

bits(32)</ins><del>// LoadWritePC()
// =============</del> <a id="impl-aarch32.Rmode.read.2" name="impl-aarch32.Rmode.read.2"></a><ins>Rmode[integer n, bits(5) mode]
    assert n >= 0 &amp;&amp; n &lt;= 14;

    // Check for attempted use of Monitor mode in Non-secure state.
    if !</ins><del>LoadWritePC(bits(32) address)</del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><a href="shared_pseudocode.html#impl-aarch32.BXWritePC.2" title="function: BXWritePC(bits(32) address, BranchType branch_type)"><del>BXWritePC</del></a><ins>() then assert mode !=</ins><del>(address,</del> <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><ins>M32_Monitor</ins></a><a href="shared_pseudocode.html#BranchType_INDIR" title="enumeration BranchType { BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}"><del>BranchType_INDIR</del></a><ins>;
    assert !</ins><a href="shared_pseudocode.html#impl-aarch32.BadMode.1" title="function: boolean BadMode(bits(5) mode)"><ins>BadMode</ins></a><ins>(mode);

    if mode == </ins><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><ins>M32_Monitor</ins></a><ins> then
        if n == 13 then return SP_mon;
        elsif n == 14 then return LR_mon;
        else return _R[n]&lt;31:0>;
    else
        return _R[</ins><a href="shared_pseudocode.html#impl-aarch32.LookUpRIndex.2" title="function: integer LookUpRIndex(integer n, bits(5) mode)"><ins>LookUpRIndex</ins></a><ins>(n, mode)]&lt;31:0>;

// Rmode[] - assignment form
// =========================

</ins><a id="impl-aarch32.Rmode.write.2" name="impl-aarch32.Rmode.write.2"></a><ins>Rmode[integer n, bits(5) mode] = bits(32) value
    assert n >= 0 &amp;&amp; n &lt;= 14;

    // Check for attempted use of Monitor mode in Non-secure state.
    if !</ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>() then assert mode != </ins><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><ins>M32_Monitor</ins></a><ins>;
    assert !</ins><a href="shared_pseudocode.html#impl-aarch32.BadMode.1" title="function: boolean BadMode(bits(5) mode)"><ins>BadMode</ins></a><ins>(mode);

    if mode == </ins><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><ins>M32_Monitor</ins></a><ins> then
        if n == 13 then SP_mon = value;
        elsif n == 14 then LR_mon = value;
        else _R[n]&lt;31:0> = value;
    else
        // It is CONSTRAINED UNPREDICTABLE whether the upper 32 bits of the X
        // register are unchanged or set to zero. This is also tested for on
        // exception entry, as this applies to all AArch32 registers.
        if !</ins><a href="shared_pseudocode.html#impl-shared.HighestELUsingAArch32.0" title="function: boolean HighestELUsingAArch32()"><ins>HighestELUsingAArch32</ins></a><ins>() &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><ins>ConstrainUnpredictableBool</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_ZEROUPPER" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_ZEROUPPER</ins></a><ins>) then
            _R[</ins><a href="shared_pseudocode.html#impl-aarch32.LookUpRIndex.2" title="function: integer LookUpRIndex(integer n, bits(5) mode)"><ins>LookUpRIndex</ins></a><ins>(n, mode)] = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(value);
        else
            _R[</ins><a href="shared_pseudocode.html#impl-aarch32.LookUpRIndex.2" title="function: integer LookUpRIndex(integer n, bits(5) mode)"><ins>LookUpRIndex</ins></a><ins>(n, mode)]&lt;31:0> = value;

    return;</ins><del>);</del></p></div><div class="ps" psname="aarch32.functions.registers.S"><a id="aarch32.functions.registers.S" name="aarch32.functions.registers.S"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/<ins>S</ins><del>LookUpRIndex</del></h3><p class="pseudocode"><ins>// S[] - non-assignment form
// =========================
</ins><del>// LookUpRIndex()
// ==============
</del>
<ins>bits(32)</ins><del>integer</del> <a id="impl-aarch32.S.read.1" name="impl-aarch32.S.read.1"></a><ins>S[integer n]
    assert n >= 0 &amp;&amp; n &lt;= 31;
    base = (n MOD 4) * 32;
    return _V[n DIV 4]&lt;base+31:base>;
</ins><del>LookUpRIndex(integer n, bits(5) mode)
    assert n >= 0 &amp;&amp; n &lt;= 14;
</del>
<ins>// S[] - assignment form
// =====================</ins><del>    case n of  // Select  index by mode:     usr fiq irq svc abt und hyp
        when 8     result =</del>

<del>(mode,  8, 24,  8,  8,  8,  8,  8);
        when 9     result = </del><a href="shared_pseudocode.html#impl-aarch32.RBankSelect.8" title="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq, integer svc, integer abt, integer und, integer hyp)"><del>RBankSelect</del></a><del>(mode,  9, 25,  9,  9,  9,  9,  9);
        when 10    result = </del><a href="shared_pseudocode.html#impl-aarch32.RBankSelect.8" title="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq, integer svc, integer abt, integer und, integer hyp)"><del>RBankSelect</del></a><del>(mode, 10, 26, 10, 10, 10, 10, 10);
        when 11    result = </del><a href="shared_pseudocode.html#impl-aarch32.RBankSelect.8" title="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq, integer svc, integer abt, integer und, integer hyp)"><del>RBankSelect</del></a><del>(mode, 11, 27, 11, 11, 11, 11, 11);
        when 12    result = </del><a href="shared_pseudocode.html#impl-aarch32.RBankSelect.8" title="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq, integer svc, integer abt, integer und, integer hyp)"><del>RBankSelect</del></a><del>(mode, 12, 28, 12, 12, 12, 12, 12);
        when 13    result = </del><a href="shared_pseudocode.html#impl-aarch32.RBankSelect.8" title="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq, integer svc, integer abt, integer und, integer hyp)"><del>RBankSelect</del></a><del>(mode, 13, 29, 17, 19, 21, 23, 15);
        when 14    result = </del><a href="shared_pseudocode.html#impl-aarch32.RBankSelect.8" title="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq, integer svc, integer abt, integer und, integer hyp)"><del>RBankSelect</del></a><a id="impl-aarch32.S.write.1" name="impl-aarch32.S.write.1"></a><ins>S[integer n] = bits(32) value
    assert n >= 0 &amp;&amp; n &lt;= 31;
    base = (n MOD 4) * 32;
    _V[n DIV 4]&lt;base+31:base> = value;
    return;</ins><del>(mode, 14, 30, 16, 18, 20, 22, 14);
        otherwise  result = n;

    return result;</del></p></div><div class="ps" psname="aarch32.functions.registers.SP"><a id="aarch32.functions.registers.SP" name="aarch32.functions.registers.SP"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/<ins>SP</ins><del>Monitor_mode_registers</del></h3><p class="pseudocode"><ins>// SP - assignment form
// ====================</ins><del>bits(32) SP_mon;
bits(32) LR_mon;</del>

<a id="impl-aarch32.SP.write.none" name="impl-aarch32.SP.write.none"></a><ins>SP = bits(32) value
    </ins><a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value"><ins>R</ins></a><ins>[13] = value;
    return;

// SP - non-assignment form
// ========================

bits(32) SP
    return </ins><a href="shared_pseudocode.html#impl-aarch32.R.read.1" title="accessor: bits(32) R[integer n]"><ins>R</ins></a><ins>[13];</ins></p></div><div class="ps" psname="aarch32.functions.registers._Dclone"><a id="aarch32.functions.registers._Dclone" name="aarch32.functions.registers._Dclone"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/<ins>_Dclone</ins><del>PC</del></h3><p class="pseudocode"><ins>array bits(64) _Dclone[0..31];</ins><del>// PC - non-assignment form
// ========================

bits(32) PC
    return</del><a href="shared_pseudocode.html#impl-aarch32.R.read.1" title="accessor: bits(32) R[integer n]"><del>R</del></a><del>[15];               // This includes the offset from AArch32 state</del></p></div><div class="ps" psname="aarch32.functions.system.AArch32.ExceptionReturn"><a id="aarch32.functions.system.AArch32.ExceptionReturn" name="aarch32.functions.system.AArch32.ExceptionReturn"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>system</ins><del>registers</del>/<ins>AArch32.ExceptionReturn</ins><del>PCStoreValue</del></h3><p class="pseudocode"><ins>// AArch32.ExceptionReturn()
// =========================</ins><del>// PCStoreValue()
// ==============

bits(32)</del>

<a id="AArch32.ExceptionReturn.2" name="AArch32.ExceptionReturn.2"></a><ins>AArch32.ExceptionReturn(bits(32) new_pc, bits(32) spsr)</ins><del>PCStoreValue()
    // This function returns the PC value. On architecture versions before ARMv7, it
    // is permitted to instead return PC+4, provided it does so consistently. It is
    // used only to describe A32 instructions, so it returns the address of the current
    // instruction plus 8 (normally) or 12 (when the alternative is permitted).
    return PC;</del>

    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()"><ins>SynchronizeContext</ins></a><ins>();

    // Attempts to change to an illegal mode or state will invoke the Illegal Execution state
    // mechanism
    </ins><a href="shared_pseudocode.html#impl-shared.SetPSTATEFromPSR.1" title="function: SetPSTATEFromPSR(bits(32) spsr)"><ins>SetPSTATEFromPSR</ins></a><ins>(spsr);
    </ins><a href="shared_pseudocode.html#impl-shared.ClearExclusiveLocal.1" title="function: ClearExclusiveLocal(integer processorid)"><ins>ClearExclusiveLocal</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><ins>ProcessorID</ins></a><ins>());
    </ins><a href="shared_pseudocode.html#impl-shared.SendEventLocal.0" title="function: SendEventLocal()"><ins>SendEventLocal</ins></a><ins>();

    if PSTATE.IL == '1' then
        // If the exception return is illegal, PC[1:0] are UNKNOWN
        new_pc&lt;1:0> = bits(2) UNKNOWN;
    else
        // LR[1:0] or LR[0] are treated as being 0, depending on the target instruction set state
        if PSTATE.T == '1' then
            new_pc&lt;0> = '0';                 // T32
        else
            new_pc&lt;1:0> = '00';              // A32

    </ins><a href="shared_pseudocode.html#impl-shared.BranchTo.2" title="function: BranchTo(bits(N) target, BranchType branch_type)"><ins>BranchTo</ins></a><ins>(new_pc, </ins><a href="shared_pseudocode.html#BranchType_ERET" title="enumeration BranchType { BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}"><ins>BranchType_ERET</ins></a><ins>);</ins></p></div><div class="ps" psname="aarch32.functions.system.AArch32.ExecutingATS1xPInstr"><a id="aarch32.functions.system.AArch32.ExecutingATS1xPInstr" name="aarch32.functions.system.AArch32.ExecutingATS1xPInstr"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>system</ins><del>registers</del>/<ins>AArch32.ExecutingATS1xPInstr</ins><del>Q</del></h3><p class="pseudocode"><ins>// AArch32.ExecutingATS1xPInstr()
// ==============================
// Return TRUE if current instruction is AT S1CPR/WP
</ins><del>// Q[] - non-assignment form
// =========================
</del>
<ins>boolean</ins><del>bits(128)</del> <a id="AArch32.ExecutingATS1xPInstr.0" name="AArch32.ExecutingATS1xPInstr.0"></a><ins>AArch32.ExecutingATS1xPInstr()
    if !</ins><del>Q[integer n]
    assert n >= 0 &amp;&amp; n &lt;= 15;
    return _V[n];

// Q[] - assignment form
// =====================</del><a href="shared_pseudocode.html#impl-shared.HavePrivATExt.0" title="function: boolean HavePrivATExt()"><ins>HavePrivATExt</ins></a><ins>() then return FALSE;

    instr = </ins><a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()"><ins>ThisInstr</ins></a><ins>();
    if instr&lt;24+:4> == '1110' &amp;&amp; instr&lt;8+:4> == '1110' then
        op1 = instr&lt;21+:3>;
        CRn = instr&lt;16+:4>;
        CRm = instr&lt;0+:4>;
        op2 = instr&lt;5+:3>;
        return (op1 == '000' &amp;&amp; CRn == '0111' &amp;&amp; CRm == '1001' &amp;&amp; op2 IN {'000','001'});
    else
        return FALSE;</ins><del>Q[integer n] = bits(128) value
    assert n >= 0 &amp;&amp; n &lt;= 15;
    _V[n] = value;
    return;</del></p></div><div class="ps" psname="aarch32.functions.system.AArch32.ExecutingCP10or11Instr"><a id="aarch32.functions.system.AArch32.ExecutingCP10or11Instr" name="aarch32.functions.system.AArch32.ExecutingCP10or11Instr"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>system</ins><del>registers</del>/<ins>AArch32.ExecutingCP10or11Instr</ins><del>Qin</del></h3><p class="pseudocode"><ins>// AArch32.ExecutingCP10or11Instr()
// ================================
</ins><del>// Qin[] - non-assignment form
// ===========================
</del>
<ins>boolean</ins><del>bits(128)</del> <a id="AArch32.ExecutingCP10or11Instr.0" name="AArch32.ExecutingCP10or11Instr.0"></a><ins>AArch32.ExecutingCP10or11Instr()
    instr =</ins><del>Qin[integer n]
    assert n >= 0 &amp;&amp; n &lt;= 15;
    return</del>  <a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()"><ins>ThisInstr</ins></a><a href="shared_pseudocode.html#impl-aarch32.Din.read.1" title="accessor: bits(64) Din[integer n]"><del>Din</del></a><ins>();
    instr_set =</ins><del>[2*n+1]:</del> <a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()"><ins>CurrentInstrSet</ins></a><a href="shared_pseudocode.html#impl-aarch32.Din.read.1" title="accessor: bits(64) Din[integer n]"><del>Din</del></a><ins>();
    assert instr_set IN {</ins><a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><ins>InstrSet_A32</ins></a><ins>, </ins><a href="shared_pseudocode.html#InstrSet_T32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><ins>InstrSet_T32</ins></a><ins>};

    if instr_set == </ins><a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><ins>InstrSet_A32</ins></a> <ins>then
        return ((instr&lt;27:24> == '1110' || instr&lt;27:25> == '110') &amp;&amp; instr&lt;11:8> == '101x');
    else // InstrSet_T32
        return (instr&lt;31:28> == '111x' &amp;&amp; (instr&lt;27:24> == '1110' || instr&lt;27:25> == '110') &amp;&amp; instr&lt;11:8> == '101x');</ins><del>[2*n];</del></p></div><div class="ps" psname="aarch32.functions.system.AArch32.ExecutingLSMInstr"><a id="aarch32.functions.system.AArch32.ExecutingLSMInstr" name="aarch32.functions.system.AArch32.ExecutingLSMInstr"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>system</ins><del>registers</del>/<ins>AArch32.ExecutingLSMInstr</ins><del>R</del></h3><p class="pseudocode"><ins>// AArch32.ExecutingLSMInstr()
// ===========================
// Returns TRUE if processor is executing a Load/Store Multiple instruction

boolean</ins><del>// R[] - assignment form
// =====================</del> <a id="AArch32.ExecutingLSMInstr.0" name="AArch32.ExecutingLSMInstr.0"></a><ins>AArch32.ExecutingLSMInstr()
    instr =</ins><del>R[integer n] = bits(32) value</del>  <a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()"><ins>ThisInstr</ins></a><a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value"><del>Rmode</del></a><ins>();
    instr_set =</ins><del>[n, PSTATE.M] = value;
    return;

// R[] - non-assignment form
// =========================

bits(32)</del> <a id="impl-aarch32.R.read.1" name="impl-aarch32.R.read.1"></a><del>R[integer n]
    if n == 15 then
        offset = (if </del><a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a><ins>();
    assert instr_set IN {</ins><del>() ==</del><a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a><ins>,</ins><del>then 8 else 4);
        return _PC&lt;31:0> + offset;
    else
        return</del> <a href="shared_pseudocode.html#InstrSet_T32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><ins>InstrSet_T32</ins></a><a href="shared_pseudocode.html#impl-aarch32.Rmode.read.2" title="accessor: bits(32) Rmode[integer n, bits(5) mode]"><del>Rmode</del></a><ins>};

    if instr_set == </ins><a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><ins>InstrSet_A32</ins></a><ins> then
        return (instr&lt;28+:4> != '1111' &amp;&amp; instr&lt;25+:3> == '100');
    else // InstrSet_T32
        if </ins><a href="shared_pseudocode.html#impl-shared.ThisInstrLength.0" title="function: integer ThisInstrLength()"><ins>ThisInstrLength</ins></a><ins>() == 16 then
            return (instr&lt;12+:4> == '1100');
        else
            return (instr&lt;25+:7> == '1110100' &amp;&amp; instr&lt;22> == '0');</ins><del>[n, PSTATE.M];</del></p></div><div class="ps" psname="aarch32.functions.system.AArch32.ITAdvance"><a id="aarch32.functions.system.AArch32.ITAdvance" name="aarch32.functions.system.AArch32.ITAdvance"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>system</ins><del>registers</del>/<ins>AArch32.ITAdvance</ins><del>RBankSelect</del></h3><p class="pseudocode"><ins>// AArch32.ITAdvance()
// ===================</ins><del>// RBankSelect()
// =============

integer</del>

<a id="AArch32.ITAdvance.0" name="AArch32.ITAdvance.0"></a><ins>AArch32.ITAdvance()
    if PSTATE.IT&lt;2:0> == '000' then
        PSTATE.IT = '00000000';
    else
        PSTATE.IT&lt;4:0> =</ins><del>RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq,
                    integer svc, integer abt, integer und, integer hyp)

    case mode of
        when</del> <del>    result = usr;  // User mode
        when </del><a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'"><del>M32_FIQ</del></a><del>     result = fiq;  // FIQ mode
        when </del><a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'"><del>M32_IRQ</del></a><del>     result = irq;  // IRQ mode
        when </del><a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'"><del>M32_Svc</del></a><del>     result = svc;  // Supervisor mode
        when </del><a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'"><del>M32_Abort</del></a><del>   result = abt;  // Abort mode
        when </del><a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'"><del>M32_Hyp</del></a><del>     result = hyp;  // Hyp mode
        when </del><a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'"><del>M32_Undef</del></a><del>   result = und;  // Undefined mode
        when </del><a href="shared_pseudocode.html#M32_System" title="constant bits(5) M32_System = '11111'"><del>M32_System</del></a><del>  result = usr;  // System mode uses User mode registers
        otherwise        </del><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><del>Unreachable</del></a><a href="shared_pseudocode.html#impl-shared.LSL.2" title="function: bits(N) LSL(bits(N) x, integer shift)"><ins>LSL</ins></a><a href="shared_pseudocode.html#M32_User" title="constant bits(5) M32_User = '10000'"><del>M32_User</del></a><ins>(PSTATE.IT&lt;4:0>, 1);
    return;</ins><del>(); // Monitor mode

    return result;</del></p></div><div class="ps" psname="aarch32.functions.system.AArch32.SysRegRead"><a id="aarch32.functions.system.AArch32.SysRegRead" name="aarch32.functions.system.AArch32.SysRegRead"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>system</ins><del>registers</del>/<ins>AArch32.SysRegRead</ins><del>Rmode</del></h3><p class="pseudocode"><ins>// Read from a 32-bit AArch32 System register and return the register's contents.
</ins><del>// Rmode[] - non-assignment form
// =============================

</del>bits(32) <a id="AArch32.SysRegRead.2" name="AArch32.SysRegRead.2"></a><ins>AArch32.SysRegRead(integer cp_num, bits(32) instr);</ins><del>Rmode[integer n, bits(5) mode]
    assert n >= 0 &amp;&amp; n &lt;= 14;

    // Check for attempted use of Monitor mode in Non-secure state.
    if !</del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>() then assert mode != </del><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><del>M32_Monitor</del></a><del>;
    assert !</del><a href="shared_pseudocode.html#impl-aarch32.BadMode.1" title="function: boolean BadMode(bits(5) mode)"><del>BadMode</del></a><del>(mode);

    if mode == </del><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><del>M32_Monitor</del></a><del> then
        if n == 13 then return SP_mon;
        elsif n == 14 then return LR_mon;
        else return _R[n]&lt;31:0>;
    else
        return _R[</del><a href="shared_pseudocode.html#impl-aarch32.LookUpRIndex.2" title="function: integer LookUpRIndex(integer n, bits(5) mode)"><del>LookUpRIndex</del></a><del>(n, mode)]&lt;31:0>;

// Rmode[] - assignment form
// =========================

</del><a id="impl-aarch32.Rmode.write.2" name="impl-aarch32.Rmode.write.2"></a><del>Rmode[integer n, bits(5) mode] = bits(32) value
    assert n >= 0 &amp;&amp; n &lt;= 14;

    // Check for attempted use of Monitor mode in Non-secure state.
    if !</del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>() then assert mode != </del><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><del>M32_Monitor</del></a><del>;
    assert !</del><a href="shared_pseudocode.html#impl-aarch32.BadMode.1" title="function: boolean BadMode(bits(5) mode)"><del>BadMode</del></a><del>(mode);

    if mode == </del><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><del>M32_Monitor</del></a><del> then
        if n == 13 then SP_mon = value;
        elsif n == 14 then LR_mon = value;
        else _R[n]&lt;31:0> = value;
    else
        // It is CONSTRAINED UNPREDICTABLE whether the upper 32 bits of the X
        // register are unchanged or set to zero. This is also tested for on
        // exception entry, as this applies to all AArch32 registers.
        if !</del><a href="shared_pseudocode.html#impl-shared.HighestELUsingAArch32.0" title="function: boolean HighestELUsingAArch32()"><del>HighestELUsingAArch32</del></a><del>() &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><del>ConstrainUnpredictableBool</del></a><del>(</del><a href="shared_pseudocode.html#Unpredictable_ZEROUPPER" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_ZEROUPPER</del></a><del>) then
            _R[</del><a href="shared_pseudocode.html#impl-aarch32.LookUpRIndex.2" title="function: integer LookUpRIndex(integer n, bits(5) mode)"><del>LookUpRIndex</del></a><del>(n, mode)] = </del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><del>(value);
        else
            _R[</del><a href="shared_pseudocode.html#impl-aarch32.LookUpRIndex.2" title="function: integer LookUpRIndex(integer n, bits(5) mode)"><del>LookUpRIndex</del></a><del>(n, mode)]&lt;31:0> = value;

    return;</del></p></div><div class="ps" psname="aarch32.functions.system.AArch32.SysRegRead64"><a id="aarch32.functions.system.AArch32.SysRegRead64" name="aarch32.functions.system.AArch32.SysRegRead64"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>system</ins><del>registers</del>/<ins>AArch32.SysRegRead64</ins><del>S</del></h3><p class="pseudocode"><ins>// Read from a 64-bit AArch32 System register and return the register's contents.
bits(64)</ins><del>// S[] - non-assignment form
// =========================

bits(32)</del> <a id="AArch32.SysRegRead64.2" name="AArch32.SysRegRead64.2"></a><ins>AArch32.SysRegRead64(integer cp_num, bits(32) instr);</ins><del>S[integer n]
    assert n >= 0 &amp;&amp; n &lt;= 31;
    base = (n MOD 4) * 32;
    return _V[n DIV 4]&lt;base+31:base>;

// S[] - assignment form
// =====================</del><a id="impl-aarch32.S.write.1" name="impl-aarch32.S.write.1"></a><del>S[integer n] = bits(32) value
    assert n >= 0 &amp;&amp; n &lt;= 31;
    base = (n MOD 4) * 32;
    _V[n DIV 4]&lt;base+31:base> = value;
    return;</del></p></div><div class="ps" psname="aarch32.functions.system.AArch32.SysRegReadCanWriteAPSR"><a id="aarch32.functions.system.AArch32.SysRegReadCanWriteAPSR" name="aarch32.functions.system.AArch32.SysRegReadCanWriteAPSR"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>system</ins><del>registers</del>/<ins>AArch32.SysRegReadCanWriteAPSR</ins><del>SP</del></h3><p class="pseudocode"><ins>// AArch32.SysRegReadCanWriteAPSR()
// ================================
// Determines whether the AArch32 System register read instruction can write to APSR flags.

boolean</ins><del>// SP - assignment form
// ====================</del> <a id="AArch32.SysRegReadCanWriteAPSR.2" name="AArch32.SysRegReadCanWriteAPSR.2"></a><ins>AArch32.SysRegReadCanWriteAPSR(integer cp_num, bits(32) instr)
    assert</ins><del>SP = bits(32) value</del> <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value"><del>R</del></a><ins>();
    assert (cp_num IN {14,15});
    assert cp_num ==</ins><del>[13] = value;
    return;

// SP - non-assignment form
// ========================

bits(32) SP
    return</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#impl-aarch32.R.read.1" title="accessor: bits(32) R[integer n]"><del>R</del></a><ins>(instr&lt;11:8>);

    opc1 = </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(instr&lt;23:21>);
    opc2 = </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(instr&lt;7:5>);
    CRn  = </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(instr&lt;19:16>);
    CRm  = </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(instr&lt;3:0>);

    if cp_num == 14 &amp;&amp; opc1 == 0 &amp;&amp; CRn == 0 &amp;&amp; CRm == 1 &amp;&amp; opc2 == 0 then // DBGDSCRint
        return TRUE;

    return FALSE;</ins><del>[13];</del></p></div><div class="ps" psname="aarch32.functions.system.AArch32.SysRegWrite"><a id="aarch32.functions.system.AArch32.SysRegWrite" name="aarch32.functions.system.AArch32.SysRegWrite"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>system</ins><del>registers</del>/<ins>AArch32.SysRegWrite</ins><del>_Dclone</del></h3><p class="pseudocode"><ins>// Write to a 32-bit AArch32 System register.</ins><del>array bits(64) _Dclone[0..31];</del>
<a id="AArch32.SysRegWrite.3" name="AArch32.SysRegWrite.3"></a><ins>AArch32.SysRegWrite(integer cp_num, bits(32) instr, bits(32) val);</ins></p></div><div class="ps" psname="aarch32.functions.system.AArch32.SysRegWrite64"><a id="aarch32.functions.system.AArch32.SysRegWrite64" name="aarch32.functions.system.AArch32.SysRegWrite64"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/<ins>AArch32.SysRegWrite64</ins><del>AArch32.ExceptionReturn</del></h3><p class="pseudocode"><ins>// Write to a 64-bit AArch32 System register.</ins><del>// AArch32.ExceptionReturn()
// =========================</del>
<a id="AArch32.SysRegWrite64.3" name="AArch32.SysRegWrite64.3"></a><ins>AArch32.SysRegWrite64(integer cp_num, bits(32) instr, bits(64) val);</ins><del>AArch32.ExceptionReturn(bits(32) new_pc, bits(32) spsr)</del><a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()"><del>SynchronizeContext</del></a><del>();

    // Attempts to change to an illegal mode or state will invoke the Illegal Execution state
    // mechanism
    </del><a href="shared_pseudocode.html#impl-shared.SetPSTATEFromPSR.1" title="function: SetPSTATEFromPSR(bits(32) spsr)"><del>SetPSTATEFromPSR</del></a><del>(spsr);
    </del><a href="shared_pseudocode.html#impl-shared.ClearExclusiveLocal.1" title="function: ClearExclusiveLocal(integer processorid)"><del>ClearExclusiveLocal</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><del>ProcessorID</del></a><del>());
    </del><a href="shared_pseudocode.html#impl-shared.SendEventLocal.0" title="function: SendEventLocal()"><del>SendEventLocal</del></a><del>();

    if PSTATE.IL == '1' then
        // If the exception return is illegal, PC[1:0] are UNKNOWN
        new_pc&lt;1:0> = bits(2) UNKNOWN;
    else
        // LR[1:0] or LR[0] are treated as being 0, depending on the target instruction set state
        if PSTATE.T == '1' then
            new_pc&lt;0> = '0';                 // T32
        else
            new_pc&lt;1:0> = '00';              // A32

    </del><a href="shared_pseudocode.html#impl-shared.BranchTo.2" title="function: BranchTo(bits(N) target, BranchType branch_type)"><del>BranchTo</del></a><del>(new_pc, </del><a href="shared_pseudocode.html#BranchType_ERET" title="enumeration BranchType { BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}"><del>BranchType_ERET</del></a><del>);</del></p></div><div class="ps" psname="aarch32.functions.system.AArch32.WriteMode"><a id="aarch32.functions.system.AArch32.WriteMode" name="aarch32.functions.system.AArch32.WriteMode"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/<ins>AArch32.WriteMode</ins><del>AArch32.ExecutingATS1xPInstr</del></h3><p class="pseudocode"><ins>// AArch32.WriteMode()
// ===================
// Function for dealing with writes to PSTATE.M from AArch32 state only.
// This ensures that PSTATE.EL and PSTATE.SP are always valid.</ins><del>// AArch32.ExecutingATS1xPInstr()
// ==============================
// Return TRUE if current instruction is AT S1CPR/WP

boolean</del>

<a id="AArch32.WriteMode.1" name="AArch32.WriteMode.1"></a><ins>AArch32.WriteMode(bits(5) mode)
    (valid,el) =</ins><del>AArch32.ExecutingATS1xPInstr()
    if !</del> <a href="shared_pseudocode.html#impl-shared.ELFromM32.1" title="function: (boolean,bits(2)) ELFromM32(bits(5) mode)"><ins>ELFromM32</ins></a><a href="shared_pseudocode.html#impl-shared.HavePrivATExt.0" title="function: boolean HavePrivATExt()"><del>HavePrivATExt</del></a><ins>(mode);
    assert valid;
    PSTATE.M   = mode;
    PSTATE.EL  = el;
    PSTATE.nRW = '1';
    PSTATE.SP  = (if mode IN {</ins><del>() then return FALSE;

    instr =</del><a href="shared_pseudocode.html#M32_User" title="constant bits(5) M32_User = '10000'"><ins>M32_User</ins></a><a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()"><del>ThisInstr</del></a><ins>,</ins><a href="shared_pseudocode.html#M32_System" title="constant bits(5) M32_System = '11111'"><ins>M32_System</ins></a><ins>} then '0' else '1');
    return;</ins><del>();
    if instr&lt;24+:4> == '1110' &amp;&amp; instr&lt;8+:4> == '1110' then
        op1 = instr&lt;21+:3>;
        CRn = instr&lt;16+:4>;
        CRm = instr&lt;0+:4>;
        op2 = instr&lt;5+:3>;
        return (op1 == '000' &amp;&amp; CRn == '0111' &amp;&amp; CRm == '1001' &amp;&amp; op2 IN {'000','001'});
    else
        return FALSE;</del></p></div><div class="ps" psname="aarch32.functions.system.AArch32.WriteModeByInstr"><a id="aarch32.functions.system.AArch32.WriteModeByInstr" name="aarch32.functions.system.AArch32.WriteModeByInstr"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/<ins>AArch32.WriteModeByInstr</ins><del>AArch32.ExecutingCP10or11Instr</del></h3><p class="pseudocode"><ins>// AArch32.WriteModeByInstr()
// ==========================
// Function for dealing with writes to PSTATE.M from an AArch32 instruction, and ensuring that
// illegal state changes are correctly flagged in PSTATE.IL.</ins><del>// AArch32.ExecutingCP10or11Instr()
// ================================

boolean</del>

<a id="AArch32.WriteModeByInstr.1" name="AArch32.WriteModeByInstr.1"></a><ins>AArch32.WriteModeByInstr(bits(5) mode)
    (valid,el) =</ins><del>AArch32.ExecutingCP10or11Instr()
    instr =</del> <a href="shared_pseudocode.html#impl-shared.ELFromM32.1" title="function: (boolean,bits(2)) ELFromM32(bits(5) mode)"><ins>ELFromM32</ins></a><a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()"><del>ThisInstr</del></a><ins>(mode);

    // 'valid' is set to FALSE if' mode' is invalid for this implementation or the current value
    // of SCR.NS/SCR_EL3.NS. Additionally, it is illegal for an instruction to write 'mode' to
    // PSTATE.EL if it would result in any of:
    // * A change to a mode that would cause entry to a higher Exception level.
    if</ins><del>();
    instr_set =</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()"><del>CurrentInstrSet</del></a><ins>(el) ></ins><del>();
    assert instr_set IN {</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><del>InstrSet_A32</del></a><ins>(PSTATE.EL) then
        valid = FALSE;

    // * A change to or from Hyp mode.
    if (PSTATE.M ==</ins><del>,</del> <a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'"><ins>M32_Hyp</ins></a><a href="shared_pseudocode.html#InstrSet_T32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><del>InstrSet_T32</del></a> <ins>|| mode ==</ins><del>};

    if instr_set ==</del> <a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'"><ins>M32_Hyp</ins></a><a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><del>InstrSet_A32</del></a><ins>) &amp;&amp; PSTATE.M != mode then
        valid = FALSE;

    // * When EL2 is implemented, the value of HCR.TGE is '1', a change to a Non-secure EL1 mode.
    if PSTATE.M == </ins><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><ins>M32_Monitor</ins></a><ins> &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) &amp;&amp; el == </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins> &amp;&amp; SCR.NS == '1' &amp;&amp; HCR.TGE == '1' then
        valid = FALSE;

    if !valid then
        PSTATE.IL = '1';
    else
        </ins><a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)"><ins>AArch32.WriteMode</ins></a><ins>(mode);</ins><del>then
        return ((instr&lt;27:24> == '1110' || instr&lt;27:25> == '110') &amp;&amp; instr&lt;11:8> == '101x');
    else // InstrSet_T32
        return (instr&lt;31:28> == '111x' &amp;&amp; (instr&lt;27:24> == '1110' || instr&lt;27:25> == '110') &amp;&amp; instr&lt;11:8> == '101x');</del></p></div><div class="ps" psname="aarch32.functions.system.BadMode"><a id="aarch32.functions.system.BadMode" name="aarch32.functions.system.BadMode"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/<ins>BadMode</ins><del>AArch32.ExecutingLSMInstr</del></h3><p class="pseudocode"><ins>// BadMode()
// =========
</ins><del>// AArch32.ExecutingLSMInstr()
// ===========================
// Returns TRUE if processor is executing a Load/Store Multiple instruction
</del>
boolean <a id="impl-aarch32.BadMode.1" name="impl-aarch32.BadMode.1"></a><ins>BadMode(bits(5) mode)
    // Return TRUE if 'mode' encodes a mode that is not valid for this implementation
    case mode of
        when</ins><del>AArch32.ExecutingLSMInstr()
    instr =</del> <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><ins>M32_Monitor</ins></a><a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()"><del>ThisInstr</del></a>
            <ins>valid =</ins><del>();
    instr_set =</del> <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)"><ins>HaveAArch32EL</ins></a><a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()"><del>CurrentInstrSet</del></a><ins>(</ins><del>();
    assert instr_set IN {</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><del>InstrSet_A32</del></a><ins>);
        when</ins><del>,</del> <a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'"><ins>M32_Hyp</ins></a><a href="shared_pseudocode.html#InstrSet_T32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><del>InstrSet_T32</del></a>
            <ins>valid =</ins><del>};

    if instr_set ==</del> <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)"><ins>HaveAArch32EL</ins></a><a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><del>InstrSet_A32</del></a><ins>(</ins><del>then
        return (instr&lt;28+:4> != '1111' &amp;&amp; instr&lt;25+:3> == '100');
    else // InstrSet_T32
        if</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-shared.ThisInstrLength.0" title="function: integer ThisInstrLength()"><del>ThisInstrLength</del></a><ins>);
        when </ins><a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'"><ins>M32_FIQ</ins></a><ins>, </ins><a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'"><ins>M32_IRQ</ins></a><ins>, </ins><a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'"><ins>M32_Svc</ins></a><ins>, </ins><a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'"><ins>M32_Abort</ins></a><ins>, </ins><a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'"><ins>M32_Undef</ins></a><ins>, </ins><a href="shared_pseudocode.html#M32_System" title="constant bits(5) M32_System = '11111'"><ins>M32_System</ins></a><ins>
            // If EL3 is implemented and using AArch32, then these modes are EL3 modes in Secure
            // state, and EL1 modes in Non-secure state. If EL3 is not implemented or is using
            // AArch64, then these modes are EL1 modes.
            // Therefore it is sufficient to test this implementation supports EL1 using AArch32.
            valid = </ins><a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)"><ins>HaveAArch32EL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>);
        when </ins><a href="shared_pseudocode.html#M32_User" title="constant bits(5) M32_User = '10000'"><ins>M32_User</ins></a><ins>
            valid = </ins><a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)"><ins>HaveAArch32EL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>);
        otherwise
            valid = FALSE;           // Passed an illegal mode value
    return !valid;</ins><del>() == 16 then
            return (instr&lt;12+:4> == '1100');
        else
            return (instr&lt;25+:7> == '1110100' &amp;&amp; instr&lt;22> == '0');</del></p></div><div class="ps" psname="aarch32.functions.system.BankedRegisterAccessValid"><a id="aarch32.functions.system.BankedRegisterAccessValid" name="aarch32.functions.system.BankedRegisterAccessValid"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/<ins>BankedRegisterAccessValid</ins><del>AArch32.ITAdvance</del></h3><p class="pseudocode"><ins>// BankedRegisterAccessValid()
// ===========================
// Checks for MRS (Banked register) or MSR (Banked register) accesses to registers
// other than the SPSRs that are invalid. This includes ELR_hyp accesses.</ins><del>// AArch32.ITAdvance()
// ===================</del>

<a id="impl-aarch32.BankedRegisterAccessValid.2" name="impl-aarch32.BankedRegisterAccessValid.2"></a><ins>BankedRegisterAccessValid(bits(5) SYSm, bits(5) mode)

    case SYSm of
        when '000xx', '00100'                          // R8_usr to R12_usr
            if mode !=</ins><del>AArch32.ITAdvance()
    if PSTATE.IT&lt;2:0> == '000' then
        PSTATE.IT = '00000000';
    else
        PSTATE.IT&lt;4:0> =</del> <a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'"><ins>M32_FIQ</ins></a><a href="shared_pseudocode.html#impl-shared.LSL.2" title="function: bits(N) LSL(bits(N) x, integer shift)"><del>LSL</del></a><ins> then UNPREDICTABLE;
        when '00101'                                   // SP_usr
            if mode == </ins><a href="shared_pseudocode.html#M32_System" title="constant bits(5) M32_System = '11111'"><ins>M32_System</ins></a><ins> then UNPREDICTABLE;
        when '00110'                                   // LR_usr
            if mode IN {</ins><a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'"><ins>M32_Hyp</ins></a><ins>,</ins><a href="shared_pseudocode.html#M32_System" title="constant bits(5) M32_System = '11111'"><ins>M32_System</ins></a><ins>} then UNPREDICTABLE;
        when '010xx', '0110x', '01110'                 // R8_fiq to R12_fiq, SP_fiq, LR_fiq
            if mode == </ins><a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'"><ins>M32_FIQ</ins></a><ins> then UNPREDICTABLE;
        when '1000x'                                   // LR_irq, SP_irq
            if mode == </ins><a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'"><ins>M32_IRQ</ins></a><ins> then UNPREDICTABLE;
        when '1001x'                                   // LR_svc, SP_svc
            if mode == </ins><a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'"><ins>M32_Svc</ins></a><ins> then UNPREDICTABLE;
        when '1010x'                                   // LR_abt, SP_abt
            if mode == </ins><a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'"><ins>M32_Abort</ins></a><ins> then UNPREDICTABLE;
        when '1011x'                                   // LR_und, SP_und
            if mode == </ins><a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'"><ins>M32_Undef</ins></a><ins> then UNPREDICTABLE;
        when '1110x'                                   // LR_mon, SP_mon
            if !</ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) || !</ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>() || mode == </ins><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><ins>M32_Monitor</ins></a><ins> then UNPREDICTABLE;
        when '11110'                                   // ELR_hyp, only from Monitor or Hyp mode
            if !</ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) || !(mode IN {</ins><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><ins>M32_Monitor</ins></a><ins>,</ins><a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'"><ins>M32_Hyp</ins></a><ins>}) then UNPREDICTABLE;
        when '11111'                                   // SP_hyp, only from Monitor mode
            if !</ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) || mode != </ins><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><ins>M32_Monitor</ins></a> <ins>then UNPREDICTABLE;
        otherwise
            UNPREDICTABLE;

</ins><del>(PSTATE.IT&lt;4:0>, 1);
</del>    return;</p></div><div class="ps" psname="aarch32.functions.system.CPSRWriteByInstr"><a id="aarch32.functions.system.CPSRWriteByInstr" name="aarch32.functions.system.CPSRWriteByInstr"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/<ins>CPSRWriteByInstr</ins><del>AArch32.SysRegRead</del></h3><p class="pseudocode"><ins>// CPSRWriteByInstr()
// ==================
// Update PSTATE.&lt;N,Z,C,V,Q,GE,E,A,I,F,M> from a CPSR value written by an MSR instruction.</ins><del>// Read from a 32-bit AArch32 System register and return the register's contents.
bits(32)</del>

<a id="impl-aarch32.CPSRWriteByInstr.2" name="impl-aarch32.CPSRWriteByInstr.2"></a><ins>CPSRWriteByInstr(bits(32) value, bits(4) bytemask)
    privileged = PSTATE.EL !=</ins><del>AArch32.SysRegRead(integer cp_num, bits(32) instr);</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>;              // PSTATE.&lt;A,I,F,M> are not writable at EL0

    // Write PSTATE from 'value', ignoring bytes masked by 'bytemask'
    if bytemask&lt;3> == '1' then
        PSTATE.&lt;N,Z,C,V,Q> = value&lt;31:27>;
        // Bits &lt;26:24> are ignored

    if bytemask&lt;2> == '1' then
        // Bit &lt;23> is RES0
        if privileged then
            PSTATE.PAN = value&lt;22>;
        // Bits &lt;21:20> are RES0
        PSTATE.GE = value&lt;19:16>;
    if bytemask&lt;1> == '1' then
        // Bits &lt;15:10> are RES0
        PSTATE.E = value&lt;9>;                    // PSTATE.E is writable at EL0
        if privileged then
            PSTATE.A = value&lt;8>;

    if bytemask&lt;0> == '1' then
        if privileged then
            PSTATE.&lt;I,F> = value&lt;7:6>;
            // Bit &lt;5> is RES0
            // AArch32.WriteModeByInstr() sets PSTATE.IL to 1 if this is an illegal mode change.
            </ins><a href="shared_pseudocode.html#AArch32.WriteModeByInstr.1" title="function: AArch32.WriteModeByInstr(bits(5) mode)"><ins>AArch32.WriteModeByInstr</ins></a><ins>(value&lt;4:0>);

    return;</ins></p></div><div class="ps" psname="aarch32.functions.system.ConditionPassed"><a id="aarch32.functions.system.ConditionPassed" name="aarch32.functions.system.ConditionPassed"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/<ins>ConditionPassed</ins><del>AArch32.SysRegRead64</del></h3><p class="pseudocode"><ins>// ConditionPassed()
// =================

boolean</ins><del>// Read from a 64-bit AArch32 System register and return the register's contents.
bits(64)</del> <a id="impl-aarch32.ConditionPassed.0" name="impl-aarch32.ConditionPassed.0"></a><ins>ConditionPassed()
    return</ins><del>AArch32.SysRegRead64(integer cp_num, bits(32) instr);</del> <a href="shared_pseudocode.html#impl-shared.ConditionHolds.1" title="function: boolean ConditionHolds(bits(4) cond)"><ins>ConditionHolds</ins></a><ins>(</ins><a href="shared_pseudocode.html#AArch32.CurrentCond.0" title="function: bits(4) AArch32.CurrentCond()"><ins>AArch32.CurrentCond</ins></a><ins>());</ins></p></div><div class="ps" psname="aarch32.functions.system.CurrentCond"><a id="aarch32.functions.system.CurrentCond" name="aarch32.functions.system.CurrentCond"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/<ins>CurrentCond</ins><del>AArch32.SysRegReadCanWriteAPSR</del></h3><p class="pseudocode"><ins>bits(4)</ins><del>// AArch32.SysRegReadCanWriteAPSR()
// ================================
// Determines whether the AArch32 System register read instruction can write to APSR flags.

boolean</del> <a id="AArch32.CurrentCond.0" name="AArch32.CurrentCond.0"></a><ins>AArch32.CurrentCond();</ins><del>AArch32.SysRegReadCanWriteAPSR(integer cp_num, bits(32) instr)
    assert</del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>();
    assert (cp_num IN {14,15});
    assert cp_num == </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(instr&lt;11:8>);

    opc1 = </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(instr&lt;23:21>);
    opc2 = </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(instr&lt;7:5>);
    CRn  = </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(instr&lt;19:16>);
    CRm  = </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(instr&lt;3:0>);

    if cp_num == 14 &amp;&amp; opc1 == 0 &amp;&amp; CRn == 0 &amp;&amp; CRm == 1 &amp;&amp; opc2 == 0 then // DBGDSCRint
        return TRUE;

    return FALSE;</del></p></div><div class="ps" psname="aarch32.functions.system.InITBlock"><a id="aarch32.functions.system.InITBlock" name="aarch32.functions.system.InITBlock"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/<ins>InITBlock</ins><del>AArch32.SysRegWrite</del></h3><p class="pseudocode"><ins>// InITBlock()
// ===========

boolean</ins><del>// Write to a 32-bit AArch32 System register.</del> <a id="impl-aarch32.InITBlock.0" name="impl-aarch32.InITBlock.0"></a><ins>InITBlock()
    if</ins><del>AArch32.SysRegWrite(integer cp_num, bits(32) instr, bits(32) val);</del> <a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()"><ins>CurrentInstrSet</ins></a><ins>() == </ins><a href="shared_pseudocode.html#InstrSet_T32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><ins>InstrSet_T32</ins></a><ins> then
        return PSTATE.IT&lt;3:0> != '0000';
    else
        return FALSE;</ins></p></div><div class="ps" psname="aarch32.functions.system.LastInITBlock"><a id="aarch32.functions.system.LastInITBlock" name="aarch32.functions.system.LastInITBlock"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/<ins>LastInITBlock</ins><del>AArch32.SysRegWrite64</del></h3><p class="pseudocode"><ins>// LastInITBlock()
// ===============

boolean</ins><del>// Write to a 64-bit AArch32 System register.</del> <a id="impl-aarch32.LastInITBlock.0" name="impl-aarch32.LastInITBlock.0"></a><ins>LastInITBlock()
    return (PSTATE.IT&lt;3:0> == '1000');</ins><del>AArch32.SysRegWrite64(integer cp_num, bits(32) instr, bits(64) val);</del></p></div><div class="ps" psname="aarch32.functions.system.SPSRWriteByInstr"><a id="aarch32.functions.system.SPSRWriteByInstr" name="aarch32.functions.system.SPSRWriteByInstr"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/<ins>SPSRWriteByInstr</ins><del>AArch32.WriteMode</del></h3><p class="pseudocode"><ins>// SPSRWriteByInstr()
// ==================</ins><del>// AArch32.WriteMode()
// ===================
// Function for dealing with writes to PSTATE.M from AArch32 state only.
// This ensures that PSTATE.EL and PSTATE.SP are always valid.</del>

<a id="impl-aarch32.SPSRWriteByInstr.2" name="impl-aarch32.SPSRWriteByInstr.2"></a><ins>SPSRWriteByInstr(bits(32) value, bits(4) bytemask)

    new_spsr =</ins><del>AArch32.WriteMode(bits(5) mode)
    (valid,el) =</del> <a href="shared_pseudocode.html#impl-shared.SPSR.read.0" title="accessor: bits(32) SPSR[]"><ins>SPSR</ins></a><a href="shared_pseudocode.html#impl-shared.ELFromM32.1" title="function: (boolean,bits(2)) ELFromM32(bits(5) mode)"><del>ELFromM32</del></a><ins>[];

    if bytemask&lt;3> == '1' then
        new_spsr&lt;31:24> = value&lt;31:24>;  // N,Z,C,V,Q flags, IT[1:0],J bits

    if bytemask&lt;2> == '1' then
        new_spsr&lt;23:16> = value&lt;23:16>;  // IL bit, GE[3:0] flags

    if bytemask&lt;1> == '1' then
        new_spsr&lt;15:8> = value&lt;15:8>;    // IT[7:2] bits, E bit, A interrupt mask

    if bytemask&lt;0> == '1' then
        new_spsr&lt;7:0> = value&lt;7:0>;      // I,F interrupt masks, T bit, Mode bits</ins><del>(mode);
    assert valid;
    PSTATE.M   = mode;
    PSTATE.EL  = el;
    PSTATE.nRW = '1';
    PSTATE.SP  = (if mode IN {</del>

    <del>,</del><a href="shared_pseudocode.html#M32_System" title="constant bits(5) M32_System = '11111'"><del>M32_System</del></a><a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(32) value"><ins>SPSR</ins></a><a href="shared_pseudocode.html#M32_User" title="constant bits(5) M32_User = '10000'"><del>M32_User</del></a><ins>[] = new_spsr;                   // UNPREDICTABLE if User or System mode

</ins><del>} then '0' else '1');
</del>    return;</p></div><div class="ps" psname="aarch32.functions.system.SPSRaccessValid"><a id="aarch32.functions.system.SPSRaccessValid" name="aarch32.functions.system.SPSRaccessValid"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/<ins>SPSRaccessValid</ins><del>AArch32.WriteModeByInstr</del></h3><p class="pseudocode"><ins>// SPSRaccessValid()
// =================
// Checks for MRS (Banked register) or MSR (Banked register) accesses to the SPSRs
// that are UNPREDICTABLE</ins><del>// AArch32.WriteModeByInstr()
// ==========================
// Function for dealing with writes to PSTATE.M from an AArch32 instruction, and ensuring that
// illegal state changes are correctly flagged in PSTATE.IL.</del>

<a id="impl-aarch32.SPSRaccessValid.2" name="impl-aarch32.SPSRaccessValid.2"></a><ins>SPSRaccessValid(bits(5) SYSm, bits(5) mode)
    case SYSm of
        when '01110'                                                   // SPSR_fiq
            if mode ==</ins><del>AArch32.WriteModeByInstr(bits(5) mode)
    (valid,el) =</del> <a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'"><ins>M32_FIQ</ins></a><a href="shared_pseudocode.html#impl-shared.ELFromM32.1" title="function: (boolean,bits(2)) ELFromM32(bits(5) mode)"><del>ELFromM32</del></a>   <ins>then UNPREDICTABLE;
        when '10000'                                                   // SPSR_irq
            if mode ==</ins><del>(mode);

    // 'valid' is set to FALSE if' mode' is invalid for this implementation or the current value
    // of SCR.NS/SCR_EL3.NS. Additionally, it is illegal for an instruction to write 'mode' to
    // PSTATE.EL if it would result in any of:
    // * A change to a mode that would cause entry to a higher Exception level.
    if</del> <a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'"><ins>M32_IRQ</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a>   <ins>then UNPREDICTABLE;
        when '10010'                                                   // SPSR_svc
            if mode ==</ins><del>(el) ></del> <a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'"><ins>M32_Svc</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a>   <ins>then UNPREDICTABLE;
        when '10100'                                                   // SPSR_abt
            if mode ==</ins><del>(PSTATE.EL) then
        valid = FALSE;

    // * A change to or from Hyp mode.
    if (PSTATE.M ==</del> <a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'"><ins>M32_Abort</ins></a><a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'"><del>M32_Hyp</del></a> <ins>then UNPREDICTABLE;
        when '10110'                                                   // SPSR_und
            if mode ==</ins><del>|| mode ==</del> <a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'"><ins>M32_Undef</ins></a><a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'"><del>M32_Hyp</del></a> <ins>then UNPREDICTABLE;
        when '11100'                                                   // SPSR_mon
            if !</ins><del>) &amp;&amp; PSTATE.M != mode then
        valid = FALSE;

    // * When EL2 is implemented, the value of HCR.TGE is '1', a change to a Non-secure EL1 mode.
    if PSTATE.M ==</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) || mode == </ins><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> <ins>|| !</ins><del>&amp;&amp;</del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>() then UNPREDICTABLE;
        when '11110'                                                   // SPSR_hyp
            if !</ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a><ins>) || mode !=</ins><del>) &amp;&amp; el ==</del> <del> &amp;&amp; SCR.NS == '1' &amp;&amp; HCR.TGE == '1' then
        valid = FALSE;

    if !valid then
        PSTATE.IL = '1';
    else
        </del><a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)"><del>AArch32.WriteMode</del></a><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><ins>M32_Monitor</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a> <ins>then UNPREDICTABLE;
        otherwise
            UNPREDICTABLE;

    return;</ins><del>(mode);</del></p></div><div class="ps" psname="aarch32.functions.system.SelectInstrSet"><a id="aarch32.functions.system.SelectInstrSet" name="aarch32.functions.system.SelectInstrSet"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/<ins>SelectInstrSet</ins><del>BadMode</del></h3><p class="pseudocode"><ins>// SelectInstrSet()
// ================</ins><del>// BadMode()
// =========

boolean</del>

<a id="impl-aarch32.SelectInstrSet.1" name="impl-aarch32.SelectInstrSet.1"></a><ins>SelectInstrSet(</ins><del>BadMode(bits(5) mode)
    // Return TRUE if 'mode' encodes a mode that is not valid for this implementation
    case mode of
        when</del><a href="shared_pseudocode.html#InstrSet" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><ins>InstrSet</ins></a><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><del>M32_Monitor</del></a> <ins>iset)
    assert</ins><del>valid =</del> <a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()"><ins>CurrentInstrSet</ins></a><a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)"><del>HaveAArch32EL</del></a><ins>() IN {</ins><del>(</del><a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><ins>InstrSet_A32</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><ins>,</ins><del>);
        when</del> <a href="shared_pseudocode.html#InstrSet_T32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><ins>InstrSet_T32</ins></a><a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'"><del>M32_Hyp</del></a><ins>};
    assert iset IN {</ins><del>valid =</del><a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><ins>InstrSet_A32</ins></a><a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)"><del>HaveAArch32EL</del></a><ins>,</ins><del>(</del> <a href="shared_pseudocode.html#InstrSet_T32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><ins>InstrSet_T32</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>};

    PSTATE.T = if iset ==</ins><del>);
        when</del> <del>, </del><a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'"><del>M32_IRQ</del></a><del>, </del><a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'"><del>M32_Svc</del></a><del>, </del><a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'"><del>M32_Abort</del></a><del>, </del><a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'"><del>M32_Undef</del></a><del>, </del><a href="shared_pseudocode.html#M32_System" title="constant bits(5) M32_System = '11111'"><del>M32_System</del></a><del>
            // If EL3 is implemented and using AArch32, then these modes are EL3 modes in Secure
            // state, and EL1 modes in Non-secure state. If EL3 is not implemented or is using
            // AArch64, then these modes are EL1 modes.
            // Therefore it is sufficient to test this implementation supports EL1 using AArch32.
            valid = </del><a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)"><del>HaveAArch32EL</del></a><del>(</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>);
        when </del><a href="shared_pseudocode.html#M32_User" title="constant bits(5) M32_User = '10000'"><del>M32_User</del></a><del>
            valid = </del><a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)"><del>HaveAArch32EL</del></a><del>(</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><ins>InstrSet_A32</ins></a><a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'"><del>M32_FIQ</del></a> <ins>then '0' else '1';

    return;</ins><del>);
        otherwise
            valid = FALSE;           // Passed an illegal mode value
    return !valid;</del></p></div><div class="ps" psname="aarch32.functions.v6simd.Sat"><a id="aarch32.functions.v6simd.Sat" name="aarch32.functions.v6simd.Sat"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>v6simd</ins><del>system</del>/<ins>Sat</ins><del>BankedRegisterAccessValid</del></h3><p class="pseudocode"><ins>// Sat()
// =====

bits(N)</ins><del>// BankedRegisterAccessValid()
// ===========================
// Checks for MRS (Banked register) or MSR (Banked register) accesses to registers
// other than the SPSRs that are invalid. This includes ELR_hyp accesses.</del> <a id="impl-aarch32.Sat.3" name="impl-aarch32.Sat.3"></a><ins>Sat(integer i, integer N, boolean unsigned)
    result = if unsigned then</ins><del>BankedRegisterAccessValid(bits(5) SYSm, bits(5) mode)

    case SYSm of
        when '000xx', '00100'                          // R8_usr to R12_usr
            if mode !=</del> <a href="shared_pseudocode.html#impl-aarch32.UnsignedSat.2" title="function: bits(N) UnsignedSat(integer i, integer N)"><ins>UnsignedSat</ins></a><a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'"><del>M32_FIQ</del></a><ins>(i, N) else</ins><del>then UNPREDICTABLE;
        when '00101'                                   // SP_usr
            if mode ==</del> <del> then UNPREDICTABLE;
        when '00110'                                   // LR_usr
            if mode IN {</del><a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'"><del>M32_Hyp</del></a><del>,</del><a href="shared_pseudocode.html#M32_System" title="constant bits(5) M32_System = '11111'"><del>M32_System</del></a><del>} then UNPREDICTABLE;
        when '010xx', '0110x', '01110'                 // R8_fiq to R12_fiq, SP_fiq, LR_fiq
            if mode == </del><a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'"><del>M32_FIQ</del></a><del> then UNPREDICTABLE;
        when '1000x'                                   // LR_irq, SP_irq
            if mode == </del><a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'"><del>M32_IRQ</del></a><del> then UNPREDICTABLE;
        when '1001x'                                   // LR_svc, SP_svc
            if mode == </del><a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'"><del>M32_Svc</del></a><del> then UNPREDICTABLE;
        when '1010x'                                   // LR_abt, SP_abt
            if mode == </del><a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'"><del>M32_Abort</del></a><del> then UNPREDICTABLE;
        when '1011x'                                   // LR_und, SP_und
            if mode == </del><a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'"><del>M32_Undef</del></a><del> then UNPREDICTABLE;
        when '1110x'                                   // LR_mon, SP_mon
            if !</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) || !</del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>() || mode == </del><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><del>M32_Monitor</del></a><del> then UNPREDICTABLE;
        when '11110'                                   // ELR_hyp, only from Monitor or Hyp mode
            if !</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) || !(mode IN {</del><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><del>M32_Monitor</del></a><del>,</del><a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'"><del>M32_Hyp</del></a><del>}) then UNPREDICTABLE;
        when '11111'                                   // SP_hyp, only from Monitor mode
            if !</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) || mode != </del><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><del>M32_Monitor</del></a><a href="shared_pseudocode.html#impl-aarch32.SignedSat.2" title="function: bits(N) SignedSat(integer i, integer N)"><ins>SignedSat</ins></a><a href="shared_pseudocode.html#M32_System" title="constant bits(5) M32_System = '11111'"><del>M32_System</del></a><ins>(i, N);
    return result;</ins><del>then UNPREDICTABLE;
        otherwise
            UNPREDICTABLE;

    return;</del></p></div><div class="ps" psname="aarch32.functions.v6simd.SignedSat"><a id="aarch32.functions.v6simd.SignedSat" name="aarch32.functions.v6simd.SignedSat"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>v6simd</ins><del>system</del>/<ins>SignedSat</ins><del>CPSRWriteByInstr</del></h3><p class="pseudocode"><ins>// SignedSat()
// ===========

bits(N)</ins><del>// CPSRWriteByInstr()
// ==================
// Update PSTATE.&lt;N,Z,C,V,Q,GE,E,A,I,F,M> from a CPSR value written by an MSR instruction.</del> <a id="impl-aarch32.SignedSat.2" name="impl-aarch32.SignedSat.2"></a><ins>SignedSat(integer i, integer N)
    (result, -) =</ins><del>CPSRWriteByInstr(bits(32) value, bits(4) bytemask)
    privileged = PSTATE.EL !=</del> <del>;              // PSTATE.&lt;A,I,F,M> are not writable at EL0

    // Write PSTATE from 'value', ignoring bytes masked by 'bytemask'
    if bytemask&lt;3> == '1' then
        PSTATE.&lt;N,Z,C,V,Q> = value&lt;31:27>;
        // Bits &lt;26:24> are ignored

    if bytemask&lt;2> == '1' then
        // Bit &lt;23> is RES0
        if privileged then
            PSTATE.PAN = value&lt;22>;
        // Bits &lt;21:20> are RES0
        PSTATE.GE = value&lt;19:16>;
    if bytemask&lt;1> == '1' then
        // Bits &lt;15:10> are RES0
        PSTATE.E = value&lt;9>;                    // PSTATE.E is writable at EL0
        if privileged then
            PSTATE.A = value&lt;8>;

    if bytemask&lt;0> == '1' then
        if privileged then
            PSTATE.&lt;I,F> = value&lt;7:6>;
            // Bit &lt;5> is RES0
            // AArch32.WriteModeByInstr() sets PSTATE.IL to 1 if this is an illegal mode change.
            </del><a href="shared_pseudocode.html#AArch32.WriteModeByInstr.1" title="function: AArch32.WriteModeByInstr(bits(5) mode)"><del>AArch32.WriteModeByInstr</del></a><a href="shared_pseudocode.html#impl-shared.SignedSatQ.2" title="function: (bits(N), boolean) SignedSatQ(integer i, integer N)"><ins>SignedSatQ</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>(i, N);
    return result;</ins><del>(value&lt;4:0>);

    return;</del></p></div><div class="ps" psname="aarch32.functions.v6simd.UnsignedSat"><a id="aarch32.functions.v6simd.UnsignedSat" name="aarch32.functions.v6simd.UnsignedSat"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/<ins>v6simd</ins><del>system</del>/<ins>UnsignedSat</ins><del>ConditionPassed</del></h3><p class="pseudocode"><ins>// UnsignedSat()
// =============
</ins><del>// ConditionPassed()
// =================
</del>
<ins>bits(N)</ins><del>boolean</del> <a id="impl-aarch32.UnsignedSat.2" name="impl-aarch32.UnsignedSat.2"></a><ins>UnsignedSat(integer i, integer N)
    (result, -) =</ins><del>ConditionPassed()
    return</del> <del>(</del><a href="shared_pseudocode.html#AArch32.CurrentCond.0" title="function: bits(4) AArch32.CurrentCond()"><del>AArch32.CurrentCond</del></a><a href="shared_pseudocode.html#impl-shared.UnsignedSatQ.2" title="function: (bits(N), boolean) UnsignedSatQ(integer i, integer N)"><ins>UnsignedSatQ</ins></a><a href="shared_pseudocode.html#impl-shared.ConditionHolds.1" title="function: boolean ConditionHolds(bits(4) cond)"><del>ConditionHolds</del></a><ins>(i, N);
    return result;</ins><del>());</del></p></div><div class="ps" psname="aarch32.translation.attrs.AArch32.DefaultTEXDecode"><a id="aarch32.translation.attrs.AArch32.DefaultTEXDecode" name="aarch32.translation.attrs.AArch32.DefaultTEXDecode"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/<ins>translation</ins><del>functions</del>/<ins>attrs</ins><del>system</del>/<ins>AArch32.DefaultTEXDecode</ins><del>CurrentCond</del></h3><p class="pseudocode"><ins>// AArch32.DefaultTEXDecode()
// ==========================

MemoryAttributes</ins><del>bits(4)</del> <a id="AArch32.DefaultTEXDecode.5" name="AArch32.DefaultTEXDecode.5"></a><ins>AArch32.DefaultTEXDecode(bits(3) TEX, bit C, bit B, bit S,</ins><del>AArch32.CurrentCond();</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><ins> acctype)

    </ins><a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType type, DeviceType device, MemAttrHints inner, MemAttrHints outer, boolean tagged, boolean shareable, boolean outershareable )"><ins>MemoryAttributes</ins></a><ins> memattrs;

    // Reserved values map to allocated values
    if (TEX == '001' &amp;&amp; C:B == '01') || (TEX == '010' &amp;&amp; C:B != '00') || TEX == '011' then
        bits(5) texcb;
        (-, texcb) = </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)"><ins>ConstrainUnpredictableBits</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_RESTEXCB" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESTEXCB</ins></a><ins>);
        TEX = texcb&lt;4:2>;  C = texcb&lt;1>;  B = texcb&lt;0>;

    case TEX:C:B of
        when '00000'
            // Device-nGnRnE
            memattrs.type = </ins><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Device</ins></a><ins>;
            memattrs.device = </ins><a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType_nGnRnE</ins></a><ins>;
        when '00001', '01000'
            // Device-nGnRE
            memattrs.type = </ins><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Device</ins></a><ins>;
            memattrs.device = </ins><a href="shared_pseudocode.html#DeviceType_nGnRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType_nGnRE</ins></a><ins>;
        when '00010', '00011', '00100'
            // Write-back or Write-through Read allocate, or Non-cacheable
            memattrs.type = </ins><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Normal</ins></a><ins>;
            memattrs.inner = </ins><a href="shared_pseudocode.html#impl-shared.ShortConvertAttrsHints.3" title="function: MemAttrHints ShortConvertAttrsHints(bits(2) RGN, AccType acctype, boolean secondstage)"><ins>ShortConvertAttrsHints</ins></a><ins>(C:B, acctype, FALSE);
            memattrs.outer = </ins><a href="shared_pseudocode.html#impl-shared.ShortConvertAttrsHints.3" title="function: MemAttrHints ShortConvertAttrsHints(bits(2) RGN, AccType acctype, boolean secondstage)"><ins>ShortConvertAttrsHints</ins></a><ins>(C:B, acctype, FALSE);
            memattrs.shareable = (S == '1');
        when '00110'
            memattrs = </ins><a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType type, DeviceType device, MemAttrHints inner, MemAttrHints outer, boolean tagged, boolean shareable, boolean outershareable )"><ins>MemoryAttributes</ins></a><ins> IMPLEMENTATION_DEFINED;
        when '00111'
            // Write-back Read and Write allocate
            memattrs.type = </ins><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Normal</ins></a><ins>;
            memattrs.inner = </ins><a href="shared_pseudocode.html#impl-shared.ShortConvertAttrsHints.3" title="function: MemAttrHints ShortConvertAttrsHints(bits(2) RGN, AccType acctype, boolean secondstage)"><ins>ShortConvertAttrsHints</ins></a><ins>('01', acctype, FALSE);
            memattrs.outer = </ins><a href="shared_pseudocode.html#impl-shared.ShortConvertAttrsHints.3" title="function: MemAttrHints ShortConvertAttrsHints(bits(2) RGN, AccType acctype, boolean secondstage)"><ins>ShortConvertAttrsHints</ins></a><ins>('01', acctype, FALSE);
            memattrs.shareable = (S == '1');
        when '1xxxx'
            // Cacheable, TEX&lt;1:0> = Outer attrs, {C,B} = Inner attrs
            memattrs.type = </ins><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Normal</ins></a><ins>;
            memattrs.inner = </ins><a href="shared_pseudocode.html#impl-shared.ShortConvertAttrsHints.3" title="function: MemAttrHints ShortConvertAttrsHints(bits(2) RGN, AccType acctype, boolean secondstage)"><ins>ShortConvertAttrsHints</ins></a><ins>(C:B, acctype, FALSE);
            memattrs.outer = </ins><a href="shared_pseudocode.html#impl-shared.ShortConvertAttrsHints.3" title="function: MemAttrHints ShortConvertAttrsHints(bits(2) RGN, AccType acctype, boolean secondstage)"><ins>ShortConvertAttrsHints</ins></a><ins>(TEX&lt;1:0>, acctype, FALSE);
            memattrs.shareable = (S == '1');
        otherwise
            // Reserved, handled above
            </ins><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><ins>Unreachable</ins></a><ins>();

    // transient bits are not supported in this format
    memattrs.inner.transient = FALSE;
    memattrs.outer.transient = FALSE;

    // distinction between inner and outer shareable is not supported in this format
    memattrs.outershareable = memattrs.shareable;
    memattrs.tagged = FALSE;

    return </ins><a href="shared_pseudocode.html#impl-shared.MemAttrDefaults.1" title="function: MemoryAttributes MemAttrDefaults(MemoryAttributes memattrs)"><ins>MemAttrDefaults</ins></a><ins>(memattrs);</ins></p></div><div class="ps" psname="aarch32.translation.attrs.AArch32.InstructionDevice"><a id="aarch32.translation.attrs.AArch32.InstructionDevice" name="aarch32.translation.attrs.AArch32.InstructionDevice"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/<ins>translation</ins><del>functions</del>/<ins>attrs</ins><del>system</del>/<ins>AArch32.InstructionDevice</ins><del>InITBlock</del></h3><p class="pseudocode"><ins>// AArch32.InstructionDevice()
// ===========================
// Instruction fetches from memory marked as Device but not execute-never might generate a
// Permission Fault but are otherwise treated as if from Normal Non-cacheable memory.
</ins><del>// InITBlock()
// ===========
</del>
<ins>AddressDescriptor</ins><del>boolean</del> <a id="AArch32.InstructionDevice.9" name="AArch32.InstructionDevice.9"></a><ins>AArch32.InstructionDevice(</ins><del>InITBlock()
    if</del><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><ins>AddressDescriptor</ins></a><a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()"><del>CurrentInstrSet</del></a> <ins>addrdesc, bits(32) vaddress,
                                            bits(40) ipaddress, integer level,  bits(4) domain,</ins><del>() ==</del>
                                            <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><a href="shared_pseudocode.html#InstrSet_T32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><del>InstrSet_T32</del></a><ins> acctype, boolean iswrite, boolean secondstage,
                                            boolean s2fs1walk)

    c = </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><ins>ConstrainUnpredictable</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_INSTRDEVICE" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_INSTRDEVICE</ins></a><ins>);
    assert c IN {</ins><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_NONE</ins></a><ins>, </ins><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FAULT</ins></a><ins>};

    if c == </ins><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FAULT</ins></a><ins> then
        addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch32.PermissionFault.7" title="function: FaultRecord AArch32.PermissionFault(bits(40) ipaddress, bits(4) domain, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><ins>AArch32.PermissionFault</ins></a><ins>(ipaddress,  domain, level, acctype, iswrite,
                                                 secondstage, s2fs1walk);
    else
        addrdesc.memattrs.type = </ins><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Normal</ins></a><ins>;
        addrdesc.memattrs.inner.attrs = </ins><a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'"><ins>MemAttr_NC</ins></a><ins>;
        addrdesc.memattrs.inner.hints = </ins><a href="shared_pseudocode.html#MemHint_No" title="constant bits(2) MemHint_No = '00'"><ins>MemHint_No</ins></a><ins>;
        addrdesc.memattrs.outer = addrdesc.memattrs.inner;
        addrdesc.memattrs.tagged = FALSE;
        addrdesc.memattrs = </ins><a href="shared_pseudocode.html#impl-shared.MemAttrDefaults.1" title="function: MemoryAttributes MemAttrDefaults(MemoryAttributes memattrs)"><ins>MemAttrDefaults</ins></a><ins>(addrdesc.memattrs);

    return addrdesc;</ins><del>then
        return PSTATE.IT&lt;3:0> != '0000';
    else
        return FALSE;</del></p></div><div class="ps" psname="aarch32.translation.attrs.AArch32.RemappedTEXDecode"><a id="aarch32.translation.attrs.AArch32.RemappedTEXDecode" name="aarch32.translation.attrs.AArch32.RemappedTEXDecode"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/<ins>translation</ins><del>functions</del>/<ins>attrs</ins><del>system</del>/<ins>AArch32.RemappedTEXDecode</ins><del>LastInITBlock</del></h3><p class="pseudocode"><ins>// AArch32.RemappedTEXDecode()
// ===========================
</ins><del>// LastInITBlock()
// ===============
</del>
<ins>MemoryAttributes</ins><del>boolean</del> <a id="AArch32.RemappedTEXDecode.5" name="AArch32.RemappedTEXDecode.5"></a><ins>AArch32.RemappedTEXDecode(bits(3) TEX, bit C, bit B, bit S,</ins><del>LastInITBlock()
    return (PSTATE.IT&lt;3:0> == '1000');</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><ins> acctype)

    </ins><a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType type, DeviceType device, MemAttrHints inner, MemAttrHints outer, boolean tagged, boolean shareable, boolean outershareable )"><ins>MemoryAttributes</ins></a><ins> memattrs;

    region = </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(TEX&lt;0>:C:B);         // TEX&lt;2:1> are ignored in this mapping scheme
    if region == 6 then
        memattrs = </ins><a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType type, DeviceType device, MemAttrHints inner, MemAttrHints outer, boolean tagged, boolean shareable, boolean outershareable )"><ins>MemoryAttributes</ins></a><ins> IMPLEMENTATION_DEFINED;
    else
        base = 2 * region;
        attrfield = PRRR&lt;base+1:base>;

        if attrfield == '11' then      // Reserved, maps to allocated value
            (-, attrfield) = </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)"><ins>ConstrainUnpredictableBits</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_RESPRRR" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESPRRR</ins></a><ins>);

        case attrfield of
            when '00'                  // Device-nGnRnE
                memattrs.type = </ins><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Device</ins></a><ins>;
                memattrs.device = </ins><a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType_nGnRnE</ins></a><ins>;
            when '01'                  // Device-nGnRE
                memattrs.type = </ins><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Device</ins></a><ins>;
                memattrs.device = </ins><a href="shared_pseudocode.html#DeviceType_nGnRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType_nGnRE</ins></a><ins>;
            when '10'
                memattrs.type = </ins><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Normal</ins></a><ins>;
                memattrs.inner = </ins><a href="shared_pseudocode.html#impl-shared.ShortConvertAttrsHints.3" title="function: MemAttrHints ShortConvertAttrsHints(bits(2) RGN, AccType acctype, boolean secondstage)"><ins>ShortConvertAttrsHints</ins></a><ins>(NMRR&lt;base+1:base>, acctype, FALSE);
                memattrs.outer = </ins><a href="shared_pseudocode.html#impl-shared.ShortConvertAttrsHints.3" title="function: MemAttrHints ShortConvertAttrsHints(bits(2) RGN, AccType acctype, boolean secondstage)"><ins>ShortConvertAttrsHints</ins></a><ins>(NMRR&lt;base+17:base+16>, acctype, FALSE);
                s_bit = if S == '0' then PRRR.NS0 else PRRR.NS1;
                memattrs.shareable = (s_bit == '1');
                memattrs.outershareable = (s_bit == '1' &amp;&amp; PRRR&lt;region+24> == '0');
            when '11'
                </ins><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><ins>Unreachable</ins></a><ins>();

    // transient bits are not supported in this format
    memattrs.inner.transient = FALSE;
    memattrs.outer.transient = FALSE;
    memattrs.tagged = FALSE;

    return </ins><a href="shared_pseudocode.html#impl-shared.MemAttrDefaults.1" title="function: MemoryAttributes MemAttrDefaults(MemoryAttributes memattrs)"><ins>MemAttrDefaults</ins></a><ins>(memattrs);</ins></p></div><div class="ps" psname="aarch32.translation.attrs.AArch32.S1AttrDecode"><a id="aarch32.translation.attrs.AArch32.S1AttrDecode" name="aarch32.translation.attrs.AArch32.S1AttrDecode"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/<ins>translation</ins><del>functions</del>/<ins>attrs</ins><del>system</del>/<ins>AArch32.S1AttrDecode</ins><del>SPSRWriteByInstr</del></h3><p class="pseudocode"><ins>// AArch32.S1AttrDecode()
// ======================
// Converts the Stage 1 attribute fields, using the MAIR, to orthogonal
// attributes and hints.

MemoryAttributes</ins><del>// SPSRWriteByInstr()
// ==================</del> <a id="AArch32.S1AttrDecode.3" name="AArch32.S1AttrDecode.3"></a><ins>AArch32.S1AttrDecode(bits(2) SH, bits(3) attr,</ins><del>SPSRWriteByInstr(bits(32) value, bits(4) bytemask)

    new_spsr =</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><a href="shared_pseudocode.html#impl-shared.SPSR.read.0" title="accessor: bits(32) SPSR[]"><del>SPSR</del></a> <ins>acctype)</ins><del>[];

    if bytemask&lt;3> == '1' then
        new_spsr&lt;31:24> = value&lt;31:24>;  // N,Z,C,V,Q flags, IT[1:0],J bits

    if bytemask&lt;2> == '1' then
        new_spsr&lt;23:16> = value&lt;23:16>;  // IL bit, GE[3:0] flags

    if bytemask&lt;1> == '1' then
        new_spsr&lt;15:8> = value&lt;15:8>;    // IT[7:2] bits, E bit, A interrupt mask

    if bytemask&lt;0> == '1' then
        new_spsr&lt;7:0> = value&lt;7:0>;      // I,F interrupt masks, T bit, Mode bits</del>

    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType type, DeviceType device, MemAttrHints inner, MemAttrHints outer, boolean tagged, boolean shareable, boolean outershareable )"><ins>MemoryAttributes</ins></a><a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(32) value"><del>SPSR</del></a><ins> memattrs;

    if PSTATE.EL == </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins> then
        mair = HMAIR1:HMAIR0;
    else
        mair = MAIR1:MAIR0;
    index = 8 * </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(attr);
    attrfield = mair&lt;index+7:index>;

    memattrs.tagged = FALSE;
    if ((attrfield&lt;7:4> != '0000' &amp;&amp; attrfield&lt;7:4> != '1111' &amp;&amp; attrfield&lt;3:0> == '0000') ||
        (attrfield&lt;7:4> == '0000' &amp;&amp; attrfield&lt;3:0> != 'xx00')) then
        // Reserved, maps to an allocated value
        (-, attrfield) = </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)"><ins>ConstrainUnpredictableBits</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_RESMAIR" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESMAIR</ins></a><ins>);
    if !</ins><a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()"><ins>HaveMTEExt</ins></a><ins>() &amp;&amp; attrfield&lt;7:4> == '1111' &amp;&amp; attrfield&lt;3:0> == '0000' then
        // Reserved, maps to an allocated value
        (-, attrfield) = </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)"><ins>ConstrainUnpredictableBits</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_RESMAIR" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESMAIR</ins></a><ins>);

    if attrfield&lt;7:4> == '0000' then            // Device
        memattrs.type = </ins><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Device</ins></a><ins>;
        case attrfield&lt;3:0> of
            when '0000'  memattrs.device = </ins><a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType_nGnRnE</ins></a><ins>;
            when '0100'  memattrs.device = </ins><a href="shared_pseudocode.html#DeviceType_nGnRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType_nGnRE</ins></a><ins>;
            when '1000'  memattrs.device = </ins><a href="shared_pseudocode.html#DeviceType_nGRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType_nGRE</ins></a><ins>;
            when '1100'  memattrs.device = </ins><a href="shared_pseudocode.html#DeviceType_GRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType_GRE</ins></a><ins>;
            otherwise    </ins><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><ins>Unreachable</ins></a><ins>();         // Reserved, handled above

    elsif attrfield&lt;3:0> != '0000'  then        // Normal
        memattrs.type = </ins><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Normal</ins></a><ins>;
        memattrs.outer = </ins><a href="shared_pseudocode.html#impl-shared.LongConvertAttrsHints.2" title="function: MemAttrHints LongConvertAttrsHints(bits(4) attrfield, AccType acctype)"><ins>LongConvertAttrsHints</ins></a><ins>(attrfield&lt;7:4>, acctype);
        memattrs.inner = </ins><a href="shared_pseudocode.html#impl-shared.LongConvertAttrsHints.2" title="function: MemAttrHints LongConvertAttrsHints(bits(4) attrfield, AccType acctype)"><ins>LongConvertAttrsHints</ins></a><ins>(attrfield&lt;3:0>, acctype);
        memattrs.shareable = SH&lt;1> == '1';
        memattrs.outershareable = SH == '10';
    elsif </ins><a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()"><ins>HaveMTEExt</ins></a><ins>() &amp;&amp; attrfield == '11110000' then // Tagged, Normal
        memattrs.tagged = TRUE;
        memattrs.type = </ins><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Normal</ins></a><ins>;
        memattrs.outer.attrs = </ins><a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'"><ins>MemAttr_WB</ins></a><ins>;
        memattrs.inner.attrs = </ins><a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'"><ins>MemAttr_WB</ins></a><ins>;
        memattrs.outer.hints = </ins><a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'"><ins>MemHint_RWA</ins></a><ins>;
        memattrs.inner.hints = </ins><a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'"><ins>MemHint_RWA</ins></a><ins>;
        memattrs.shareable = SH&lt;1> == '1';
        memattrs.outershareable = SH == '10';
    else
        </ins><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><ins>Unreachable</ins></a><ins>();                          // Reserved, handled above

    return </ins><a href="shared_pseudocode.html#impl-shared.MemAttrDefaults.1" title="function: MemoryAttributes MemAttrDefaults(MemoryAttributes memattrs)"><ins>MemAttrDefaults</ins></a><ins>(memattrs);</ins><del>[] = new_spsr;                   // UNPREDICTABLE if User or System mode

    return;</del></p></div><div class="ps" psname="aarch32.translation.attrs.AArch32.TranslateAddressS1Off"><a id="aarch32.translation.attrs.AArch32.TranslateAddressS1Off" name="aarch32.translation.attrs.AArch32.TranslateAddressS1Off"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/<ins>translation</ins><del>functions</del>/<ins>attrs</ins><del>system</del>/<ins>AArch32.TranslateAddressS1Off</ins><del>SPSRaccessValid</del></h3><p class="pseudocode"><ins>// AArch32.TranslateAddressS1Off()
// ===============================
// Called for stage 1 translations when translation is disabled to supply a default translation.
// Note that there are additional constraints on instruction prefetching that are not described in
// this pseudocode.

TLBRecord</ins><del>// SPSRaccessValid()
// =================
// Checks for MRS (Banked register) or MSR (Banked register) accesses to the SPSRs
// that are UNPREDICTABLE</del> <a id="AArch32.TranslateAddressS1Off.3" name="AArch32.TranslateAddressS1Off.3"></a><ins>AArch32.TranslateAddressS1Off(bits(32) vaddress,</ins><del>SPSRaccessValid(bits(5) SYSm, bits(5) mode)
    case SYSm of
        when '01110'                                                   // SPSR_fiq
            if mode ==</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'"><del>M32_FIQ</del></a> <ins>acctype, boolean iswrite)
    assert</ins><del>then UNPREDICTABLE;
        when '10000'                                                   // SPSR_irq
            if mode ==</del> <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'"><del>M32_IRQ</del></a><ins>(</ins><del>then UNPREDICTABLE;
        when '10010'                                                   // SPSR_svc
            if mode ==</del><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'"><del>M32_Svc</del></a><ins>());</ins><del>then UNPREDICTABLE;
        when '10100'                                                   // SPSR_abt
            if mode ==</del>

    <a href="shared_pseudocode.html#TLBRecord" title="type TLBRecord is ( Permissions perms, bit nG, bits(4) domain, bit GP, boolean contiguous, integer level, integer blocksize, DescriptorUpdate descupdate, bit CnP, AddressDescriptor addrdesc )"><ins>TLBRecord</ins></a><a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'"><del>M32_Abort</del></a> <ins>result;

    default_cacheable = (</ins><del>then UNPREDICTABLE;
        when '10110'                                                   // SPSR_und
            if mode ==</del><a href="shared_pseudocode.html#impl-shared.HasS2Translation.0" title="function: boolean HasS2Translation()"><ins>HasS2Translation</ins></a><a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'"><del>M32_Undef</del></a><ins>() &amp;&amp; ((if</ins><del>then UNPREDICTABLE;
        when '11100'                                                   // SPSR_mon
            if !</del> <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><ins>) then HCR.DC else HCR_EL2.DC) == '1'));

    if default_cacheable then
        // Use default cacheable settings
        result.addrdesc.memattrs.type =</ins><del>) || mode ==</del> <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Normal</ins></a><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><del>M32_Monitor</del></a><ins>;
        result.addrdesc.memattrs.inner.attrs =</ins><del>|| !</del> <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'"><ins>MemAttr_WB</ins></a><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><ins>;      // Write-back
        result.addrdesc.memattrs.inner.hints =</ins><del>() then UNPREDICTABLE;
        when '11110'                                                   // SPSR_hyp
            if !</del> <a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'"><ins>MemHint_RWA</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>;
        result.addrdesc.memattrs.shareable = FALSE;
        result.addrdesc.memattrs.outershareable = FALSE;
        result.addrdesc.memattrs.tagged = HCR_EL2.DCT == '1';
    elsif acctype !=</ins><del>(</del> <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><ins> then
        // Treat data as Device
        result.addrdesc.memattrs.type = </ins><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Device</ins></a><ins>;
        result.addrdesc.memattrs.device = </ins><a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType_nGnRnE</ins></a><ins>;
        result.addrdesc.memattrs.inner = </ins><a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )"><ins>MemAttrHints</ins></a><ins> UNKNOWN;
        result.addrdesc.memattrs.tagged = FALSE;
    else
        // Instruction cacheability controlled by SCTLR/HSCTLR.I
        if PSTATE.EL == </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> <ins>then
            cacheable = HSCTLR.I == '1';
        else
            cacheable = SCTLR.I == '1';
        result.addrdesc.memattrs.type =</ins><del>) || mode !=</del> <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Normal</ins></a><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><del>M32_Monitor</del></a><ins>;
        if cacheable then
            result.addrdesc.memattrs.inner.attrs = </ins><a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'"><ins>MemAttr_WT</ins></a><ins>;
            result.addrdesc.memattrs.inner.hints = </ins><a href="shared_pseudocode.html#MemHint_RA" title="constant bits(2) MemHint_RA = '10'"><ins>MemHint_RA</ins></a><ins>;
        else
            result.addrdesc.memattrs.inner.attrs = </ins><a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'"><ins>MemAttr_NC</ins></a><ins>;
            result.addrdesc.memattrs.inner.hints = </ins><a href="shared_pseudocode.html#MemHint_No" title="constant bits(2) MemHint_No = '00'"><ins>MemHint_No</ins></a><ins>;
        result.addrdesc.memattrs.shareable = TRUE;
        result.addrdesc.memattrs.outershareable = TRUE;
        result.addrdesc.memattrs.tagged = FALSE;

    result.addrdesc.memattrs.outer = result.addrdesc.memattrs.inner;

    result.addrdesc.memattrs = </ins><a href="shared_pseudocode.html#impl-shared.MemAttrDefaults.1" title="function: MemoryAttributes MemAttrDefaults(MemoryAttributes memattrs)"><ins>MemAttrDefaults</ins></a><ins>(result.addrdesc.memattrs);

    result.perms.ap = bits(3) UNKNOWN;
    result.perms.xn = '0';
    result.perms.pxn = '0';

    result.nG = bit UNKNOWN;
    result.contiguous = boolean UNKNOWN;
    result.domain = bits(4) UNKNOWN;
    result.level = integer UNKNOWN;
    result.blocksize = integer UNKNOWN;
    result.addrdesc.paddress.address = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(vaddress);
    result.addrdesc.paddress.NS = if </ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>() then '0' else '1';
    result.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch32.NoFault.0" title="function: FaultRecord AArch32.NoFault()"><ins>AArch32.NoFault</ins></a><ins>();
    return result;</ins><del>then UNPREDICTABLE;
        otherwise
            UNPREDICTABLE;

    return;</del></p></div><div class="ps" psname="aarch32.translation.checks.AArch32.AccessIsPrivileged"><a id="aarch32.translation.checks.AArch32.AccessIsPrivileged" name="aarch32.translation.checks.AArch32.AccessIsPrivileged"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/<ins>translation</ins><del>functions</del>/<ins>checks</ins><del>system</del>/<ins>AArch32.AccessIsPrivileged</ins><del>SelectInstrSet</del></h3><p class="pseudocode"><ins>// AArch32.AccessIsPrivileged()
// ============================

boolean</ins><del>// SelectInstrSet()
// ================</del> <a id="AArch32.AccessIsPrivileged.1" name="AArch32.AccessIsPrivileged.1"></a><ins>AArch32.AccessIsPrivileged(</ins><del>SelectInstrSet(</del><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><a href="shared_pseudocode.html#InstrSet" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><del>InstrSet</del></a> <ins>acctype)

    el =</ins><del>iset)
    assert</del> <a href="shared_pseudocode.html#AArch32.AccessUsesEL.1" title="function: bits(2) AArch32.AccessUsesEL(AccType acctype)"><ins>AArch32.AccessUsesEL</ins></a><a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()"><del>CurrentInstrSet</del></a><ins>(acctype);

    if el ==</ins><del>() IN {</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><del>InstrSet_A32</del></a> <ins>then
        ispriv = FALSE;
    elsif el !=</ins><del>,</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#InstrSet_T32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><del>InstrSet_T32</del></a> <ins>then
        ispriv = TRUE;
    else
        ispriv = (acctype !=</ins><del>};
    assert iset IN {</del> <del>, </del><a href="shared_pseudocode.html#InstrSet_T32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><del>InstrSet_T32</del></a><del>};

    PSTATE.T = if iset == </del><a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><del>InstrSet_A32</del></a><a href="shared_pseudocode.html#AccType_UNPRIV" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_UNPRIV</ins></a><a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><del>InstrSet_A32</del></a><ins>);
</ins><del>then '0' else '1';
</del>
<ins>    return ispriv;</ins><del>    return;</del></p></div><div class="ps" psname="aarch32.translation.checks.AArch32.AccessUsesEL"><a id="aarch32.translation.checks.AArch32.AccessUsesEL" name="aarch32.translation.checks.AArch32.AccessUsesEL"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/<ins>translation</ins><del>functions</del>/<ins>checks</ins><del>v6simd</del>/<ins>AArch32.AccessUsesEL</ins><del>Sat</del></h3><p class="pseudocode"><ins>// AArch32.AccessUsesEL()
// ======================
// Returns the Exception Level of the regime that will manage the translation for a given access type.
</ins><del>// Sat()
// =====
</del>
<ins>bits(2)</ins><del>bits(N)</del> <a id="AArch32.AccessUsesEL.1" name="AArch32.AccessUsesEL.1"></a><ins>AArch32.AccessUsesEL(</ins><del>Sat(integer i, integer N, boolean unsigned)
    result = if unsigned then</del><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><a href="shared_pseudocode.html#impl-aarch32.UnsignedSat.2" title="function: bits(N) UnsignedSat(integer i, integer N)"><del>UnsignedSat</del></a> <ins>acctype)
    if acctype ==</ins><del>(i, N) else</del> <a href="shared_pseudocode.html#AccType_UNPRIV" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_UNPRIV</ins></a><a href="shared_pseudocode.html#impl-aarch32.SignedSat.2" title="function: bits(N) SignedSat(integer i, integer N)"><del>SignedSat</del></a><ins> then
        return </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>;
    else
        return PSTATE.EL;</ins><del>(i, N);
    return result;</del></p></div><div class="ps" psname="aarch32.translation.checks.AArch32.CheckDomain"><a id="aarch32.translation.checks.AArch32.CheckDomain" name="aarch32.translation.checks.AArch32.CheckDomain"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/<ins>translation</ins><del>functions</del>/<ins>checks</ins><del>v6simd</del>/<ins>AArch32.CheckDomain</ins><del>SignedSat</del></h3><p class="pseudocode"><ins>// AArch32.CheckDomain()
// =====================
</ins><del>// SignedSat()
// ===========
</del>
<ins>(boolean, FaultRecord)</ins><del>bits(N)</del> <a id="AArch32.CheckDomain.5" name="AArch32.CheckDomain.5"></a><ins>AArch32.CheckDomain(bits(4) domain, bits(32) vaddress, integer level,</ins><del>SignedSat(integer i, integer N)
    (result, -) =</del>
                                           <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><a href="shared_pseudocode.html#impl-shared.SignedSatQ.2" title="function: (bits(N), boolean) SignedSatQ(integer i, integer N)"><del>SignedSatQ</del></a><ins> acctype, boolean iswrite)

    index = 2 * </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(domain);
    attrfield = DACR&lt;index+1:index>;

    if attrfield == '10' then          // Reserved, maps to an allocated value
        // Reserved value maps to an allocated value
        (-, attrfield) = </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)"><ins>ConstrainUnpredictableBits</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_RESDACR" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESDACR</ins></a><ins>);

    if attrfield == '00' then
        fault = </ins><a href="shared_pseudocode.html#AArch32.DomainFault.4" title="function: FaultRecord AArch32.DomainFault(bits(4) domain, integer level, AccType acctype, boolean iswrite)"><ins>AArch32.DomainFault</ins></a><ins>(domain, level, acctype, iswrite);
    else
        fault = </ins><a href="shared_pseudocode.html#AArch32.NoFault.0" title="function: FaultRecord AArch32.NoFault()"><ins>AArch32.NoFault</ins></a><ins>();

    permissioncheck = (attrfield == '01');

    return (permissioncheck, fault);</ins><del>(i, N);
    return result;</del></p></div><div class="ps" psname="aarch32.translation.checks.AArch32.CheckPermission"><a id="aarch32.translation.checks.AArch32.CheckPermission" name="aarch32.translation.checks.AArch32.CheckPermission"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/<ins>translation</ins><del>functions</del>/<ins>checks</ins><del>v6simd</del>/<ins>AArch32.CheckPermission</ins><del>UnsignedSat</del></h3><p class="pseudocode"><ins>// AArch32.CheckPermission()
// =========================
// Function used for permission checking from AArch32 stage 1 translations
</ins><del>// UnsignedSat()
// =============
</del>
<ins>FaultRecord</ins><del>bits(N)</del> <a id="AArch32.CheckPermission.7" name="AArch32.CheckPermission.7"></a><ins>AArch32.CheckPermission(</ins><del>UnsignedSat(integer i, integer N)
    (result, -) =</del><a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(3) ap, bit xn, bit xxn, bit pxn )"><ins>Permissions</ins></a><a href="shared_pseudocode.html#impl-shared.UnsignedSatQ.2" title="function: (bits(N), boolean) UnsignedSatQ(integer i, integer N)"><del>UnsignedSatQ</del></a><ins> perms, bits(32) vaddress, integer level,
                                    bits(4) domain, bit NS, </ins><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><ins> acctype, boolean iswrite)
    assert </ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><ins>());

    if PSTATE.EL != </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins> then
        wxn = SCTLR.WXN == '1';
        if TTBCR.EAE == '1' || SCTLR.AFE == '1' || perms.ap&lt;0> == '1' then
            priv_r = TRUE;
            priv_w = perms.ap&lt;2> == '0';
            user_r = perms.ap&lt;1> == '1';
            user_w = perms.ap&lt;2:1> == '01';
        else
            priv_r = perms.ap&lt;2:1> != '00';
            priv_w = perms.ap&lt;2:1> == '01';
            user_r = perms.ap&lt;1> == '1';
            user_w = FALSE;
        uwxn = SCTLR.UWXN == '1';

        ispriv = </ins><a href="shared_pseudocode.html#AArch32.AccessIsPrivileged.1" title="function: boolean AArch32.AccessIsPrivileged(AccType acctype)"><ins>AArch32.AccessIsPrivileged</ins></a><ins>(acctype);

        pan = if </ins><a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()"><ins>HavePANExt</ins></a><ins>() then PSTATE.PAN else '0';
        is_ldst   = !(acctype IN {</ins><a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_DC</ins></a><ins>, </ins><a href="shared_pseudocode.html#AccType_DC_UNPRIV" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_DC_UNPRIV</ins></a><ins>, </ins><a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_AT</ins></a><ins>, </ins><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><ins>});
        is_ats1xp = (acctype == </ins><a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_AT</ins></a><ins> &amp;&amp; </ins><a href="shared_pseudocode.html#AArch32.ExecutingATS1xPInstr.0" title="function: boolean AArch32.ExecutingATS1xPInstr()"><ins>AArch32.ExecutingATS1xPInstr</ins></a><ins>());
        if pan == '1' &amp;&amp; user_r &amp;&amp; ispriv &amp;&amp; (is_ldst || is_ats1xp) then
            priv_r = FALSE;
            priv_w = FALSE;

        user_xn = !user_r || perms.xn == '1' || (user_w &amp;&amp; wxn);
        priv_xn = (!priv_r || perms.xn == '1' || perms.pxn == '1' ||
                   (priv_w &amp;&amp; wxn) || (user_w &amp;&amp; uwxn));

        if ispriv then
            (r, w, xn) = (priv_r, priv_w, priv_xn);
        else
            (r, w, xn) = (user_r, user_w, user_xn);
    else
        // Access from EL2
        wxn = HSCTLR.WXN == '1';
        r = TRUE;
        w = perms.ap&lt;2> == '0';
        xn = perms.xn == '1' || (w &amp;&amp; wxn);

    // Restriction on Secure instruction fetch
    if </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>() &amp;&amp; NS == '1' then
        secure_instr_fetch = if </ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) then SCR.SIF else SCR_EL3.SIF;
        if secure_instr_fetch == '1' then xn = TRUE;

    if acctype == </ins><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><ins> then
        fail = xn;
        failedread = TRUE;
    elsif acctype IN { </ins><a href="shared_pseudocode.html#AccType_ATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ATOMICRW</ins></a><ins>, </ins><a href="shared_pseudocode.html#AccType_ORDEREDRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ORDEREDRW</ins></a><ins>, </ins><a href="shared_pseudocode.html#AccType_ORDEREDATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ORDEREDATOMICRW</ins></a><ins> } then
        fail = !r || !w;
        failedread = !r;
    elsif acctype == </ins><a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_DC</ins></a><ins> then
        // DC maintenance instructions operating by VA, cannot fault from stage 1 translation.
        fail = FALSE;
    elsif iswrite then
        fail = !w;
        failedread = FALSE;
    else
        fail = !r;
        failedread = TRUE;

    if fail then
        secondstage = FALSE;
        s2fs1walk = FALSE;
        ipaddress = bits(40) UNKNOWN;
        return </ins><a href="shared_pseudocode.html#AArch32.PermissionFault.7" title="function: FaultRecord AArch32.PermissionFault(bits(40) ipaddress, bits(4) domain, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><ins>AArch32.PermissionFault</ins></a><ins>(ipaddress,  domain, level, acctype,
                                       !failedread, secondstage, s2fs1walk);
    else
        return </ins><a href="shared_pseudocode.html#AArch32.NoFault.0" title="function: FaultRecord AArch32.NoFault()"><ins>AArch32.NoFault</ins></a><ins>();</ins><del>(i, N);
    return result;</del></p></div><div class="ps" psname="aarch32.translation.checks.AArch32.CheckS2Permission"><a id="aarch32.translation.checks.AArch32.CheckS2Permission" name="aarch32.translation.checks.AArch32.CheckS2Permission"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/<ins>checks</ins><del>attrs</del>/<ins>AArch32.CheckS2Permission</ins><del>AArch32.DefaultTEXDecode</del></h3><p class="pseudocode"><ins>// AArch32.CheckS2Permission()
// ===========================
// Function used for permission checking from AArch32 stage 2 translations
</ins><del>// AArch32.DefaultTEXDecode()
// ==========================
</del>
<ins>FaultRecord</ins><del>MemoryAttributes</del> <a id="AArch32.CheckS2Permission.7" name="AArch32.CheckS2Permission.7"></a><ins>AArch32.CheckS2Permission(</ins><del>AArch32.DefaultTEXDecode(bits(3) TEX, bit C, bit B, bit S,</del><a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(3) ap, bit xn, bit xxn, bit pxn )"><ins>Permissions</ins></a><ins> perms, bits(32) vaddress, bits(40) ipaddress,
                                      integer level, </ins><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType</a> <ins>acctype, boolean iswrite,
                                      boolean s2fs1walk)

    assert</ins><del>acctype)</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType type, DeviceType device, MemAttrHints inner, MemAttrHints outer, boolean tagged, boolean shareable, boolean outershareable )"><del>MemoryAttributes</del></a><ins>(</ins><del>memattrs;

    // Reserved values map to allocated values
    if (TEX == '001' &amp;&amp; C:B == '01') || (TEX == '010' &amp;&amp; C:B != '00') || TEX == '011' then
        bits(5) texcb;
        (-, texcb) =</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)"><del>ConstrainUnpredictableBits</del></a><ins>) &amp;&amp; !</ins><del>(</del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><a href="shared_pseudocode.html#Unpredictable_RESTEXCB" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESTEXCB</del></a><ins>() &amp;&amp;</ins><del>);
        TEX = texcb&lt;4:2>;  C = texcb&lt;1>;  B = texcb&lt;0>;

    case TEX:C:B of
        when '00000'
            // Device-nGnRnE
            memattrs.type =</del> <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Device</del></a><ins>(</ins><del>;
            memattrs.device =</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType_nGnRnE</del></a><ins>) &amp;&amp;</ins><del>;
        when '00001', '01000'
            // Device-nGnRE
            memattrs.type =</del> <a href="shared_pseudocode.html#impl-shared.HasS2Translation.0" title="function: boolean HasS2Translation()"><ins>HasS2Translation</ins></a><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Device</del></a><ins>();

    r = perms.ap&lt;1> == '1';
    w = perms.ap&lt;2> == '1';
    if</ins><del>;
            memattrs.device =</del> <a href="shared_pseudocode.html#impl-shared.HaveExtendedExecuteNeverExt.0" title="function: boolean HaveExtendedExecuteNeverExt()"><ins>HaveExtendedExecuteNeverExt</ins></a><a href="shared_pseudocode.html#DeviceType_nGnRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType_nGnRE</del></a><ins>() then
        case perms.xn:perms.xxn of
            when '00'  xn = !r;
            when '01'  xn = !r || PSTATE.EL ==</ins><del>;
        when '00010', '00011', '00100'
            // Write-back or Write-through Read allocate, or Non-cacheable
            memattrs.type =</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Normal</del></a>;
<ins>            when '10'  xn = TRUE;
            when '11'  xn = !r || PSTATE.EL ==</ins><del>            memattrs.inner =</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#impl-shared.ShortConvertAttrsHints.3" title="function: MemAttrHints ShortConvertAttrsHints(bits(2) RGN, AccType acctype, boolean secondstage)"><del>ShortConvertAttrsHints</del></a><ins>;
    else
        xn = !r || perms.xn == '1';
    // Stage 1 walk is checked as a read, regardless of the original type
    if acctype ==</ins><del>(C:B, acctype, FALSE);
            memattrs.outer =</del> <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><a href="shared_pseudocode.html#impl-shared.ShortConvertAttrsHints.3" title="function: MemAttrHints ShortConvertAttrsHints(bits(2) RGN, AccType acctype, boolean secondstage)"><del>ShortConvertAttrsHints</del></a> <ins>&amp;&amp; !s2fs1walk then
        fail = xn;
        failedread = TRUE;
    elsif (acctype IN {</ins><del>(C:B, acctype, FALSE);
            memattrs.shareable = (S == '1');
        when '00110'
            memattrs =</del> <a href="shared_pseudocode.html#AccType_ATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ATOMICRW</ins></a><a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType type, DeviceType device, MemAttrHints inner, MemAttrHints outer, boolean tagged, boolean shareable, boolean outershareable )"><del>MemoryAttributes</del></a><ins>,</ins><del>IMPLEMENTATION_DEFINED;
        when '00111'
            // Write-back Read and Write allocate
            memattrs.type =</del> <a href="shared_pseudocode.html#AccType_ORDEREDRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ORDEREDRW</ins></a><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Normal</del></a><ins>,</ins><del>;
            memattrs.inner =</del> <a href="shared_pseudocode.html#AccType_ORDEREDATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ORDEREDATOMICRW</ins></a><a href="shared_pseudocode.html#impl-shared.ShortConvertAttrsHints.3" title="function: MemAttrHints ShortConvertAttrsHints(bits(2) RGN, AccType acctype, boolean secondstage)"><del>ShortConvertAttrsHints</del></a> <ins>}) &amp;&amp; !s2fs1walk then
        fail = !r || !w;
        failedread = !r;
    elsif acctype ==</ins><del>('01', acctype, FALSE);
            memattrs.outer =</del> <a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_DC</ins></a><a href="shared_pseudocode.html#impl-shared.ShortConvertAttrsHints.3" title="function: MemAttrHints ShortConvertAttrsHints(bits(2) RGN, AccType acctype, boolean secondstage)"><del>ShortConvertAttrsHints</del></a> <ins>&amp;&amp; !s2fs1walk then
        // DC maintenance instructions operating by VA, do not generate Permission faults
        // from stage 2 translation, other than from stage 1 translation table walk.
        fail = FALSE;
    elsif iswrite &amp;&amp; !s2fs1walk then
        fail = !w;
        failedread = FALSE;
    else
        fail = !r;
        failedread = !iswrite;

    if fail then
        domain = bits(4) UNKNOWN;
        secondstage = TRUE;
        return</ins><del>('01', acctype, FALSE);
            memattrs.shareable = (S == '1');
        when '1xxxx'
            // Cacheable, TEX&lt;1:0> = Outer attrs, {C,B} = Inner attrs
            memattrs.type =</del> <a href="shared_pseudocode.html#AArch32.PermissionFault.7" title="function: FaultRecord AArch32.PermissionFault(bits(40) ipaddress, bits(4) domain, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><ins>AArch32.PermissionFault</ins></a><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Normal</del></a><ins>(ipaddress,  domain, level, acctype,
                                       !failedread, secondstage, s2fs1walk);
    else
        return</ins><del>;
            memattrs.inner =</del> <del>(C:B, acctype, FALSE);
            memattrs.outer = </del><a href="shared_pseudocode.html#impl-shared.ShortConvertAttrsHints.3" title="function: MemAttrHints ShortConvertAttrsHints(bits(2) RGN, AccType acctype, boolean secondstage)"><del>ShortConvertAttrsHints</del></a><del>(TEX&lt;1:0>, acctype, FALSE);
            memattrs.shareable = (S == '1');
        otherwise
            // Reserved, handled above
            </del><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><del>Unreachable</del></a><del>();

    // transient bits are not supported in this format
    memattrs.inner.transient = FALSE;
    memattrs.outer.transient = FALSE;

    // distinction between inner and outer shareable is not supported in this format
    memattrs.outershareable = memattrs.shareable;
    memattrs.tagged = FALSE;

    return </del><a href="shared_pseudocode.html#impl-shared.MemAttrDefaults.1" title="function: MemoryAttributes MemAttrDefaults(MemoryAttributes memattrs)"><del>MemAttrDefaults</del></a><a href="shared_pseudocode.html#AArch32.NoFault.0" title="function: FaultRecord AArch32.NoFault()"><ins>AArch32.NoFault</ins></a><a href="shared_pseudocode.html#impl-shared.ShortConvertAttrsHints.3" title="function: MemAttrHints ShortConvertAttrsHints(bits(2) RGN, AccType acctype, boolean secondstage)"><del>ShortConvertAttrsHints</del></a><ins>();</ins><del>(memattrs);</del></p></div><div class="ps" psname="aarch32.translation.debug.AArch32.CheckBreakpoint"><a id="aarch32.translation.debug.AArch32.CheckBreakpoint" name="aarch32.translation.debug.AArch32.CheckBreakpoint"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/<ins>debug</ins><del>attrs</del>/<ins>AArch32.CheckBreakpoint</ins><del>AArch32.InstructionDevice</del></h3><p class="pseudocode"><ins>// AArch32.CheckBreakpoint()
// =========================
// Called before executing the instruction of length "size" bytes at "vaddress" in an AArch32
// translation regime.
// The breakpoint can in fact be evaluated well ahead of execution, for example, at instruction
// fetch. This is the simple sequential execution of the program.
</ins><del>// AArch32.InstructionDevice()
// ===========================
// Instruction fetches from memory marked as Device but not execute-never might generate a
// Permission Fault but are otherwise treated as if from Normal Non-cacheable memory.
</del>
<ins>FaultRecord</ins><del>AddressDescriptor</del> <a id="AArch32.CheckBreakpoint.2" name="AArch32.CheckBreakpoint.2"></a><ins>AArch32.CheckBreakpoint(bits(32) vaddress,  integer size)
    assert</ins><del>AArch32.InstructionDevice(</del> <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><del>AddressDescriptor</del></a><ins>(</ins><del>addrdesc, bits(32) vaddress,
                                            bits(40) ipaddress, integer level,  bits(4) domain,</del><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><ins>());
    assert size IN {2,4};
</ins><del>acctype, boolean iswrite, boolean secondstage,
                                            boolean s2fs1walk)
</del>
<ins>    match = FALSE;
    mismatch = FALSE;

    for i = 0 to</ins><del>    c =</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><del>ConstrainUnpredictable</del></a><ins>(DBGDIDR.BRPs)
        (match_i, mismatch_i) =</ins><del>(</del> <a href="shared_pseudocode.html#AArch32.BreakpointMatch.3" title="function: (boolean,boolean) AArch32.BreakpointMatch(integer n, bits(32) vaddress,  integer size)"><ins>AArch32.BreakpointMatch</ins></a><a href="shared_pseudocode.html#Unpredictable_INSTRDEVICE" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_INSTRDEVICE</del></a><ins>(i, vaddress, size);
        match = match || match_i;
        mismatch = mismatch || mismatch_i;

    if match &amp;&amp;</ins><del>);
    assert c IN {</del> <a href="shared_pseudocode.html#impl-shared.HaltOnBreakpointOrWatchpoint.0" title="function: boolean HaltOnBreakpointOrWatchpoint()"><ins>HaltOnBreakpointOrWatchpoint</ins></a><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_NONE</del></a><ins>() then
        reason =</ins><del>,</del> <a href="shared_pseudocode.html#DebugHalt_Breakpoint" title="constant bits(6) DebugHalt_Breakpoint = '000111'"><ins>DebugHalt_Breakpoint</ins></a><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FAULT</del></a><ins>;</ins><del>};

    if c ==</del>
        <a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)"><ins>Halt</ins></a><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FAULT</del></a><ins>(reason);
    elsif (match || mismatch) &amp;&amp; DBGDSCRext.MDBGen == '1' &amp;&amp;</ins><del>then
        addrdesc.fault =</del> <a href="shared_pseudocode.html#AArch32.GenerateDebugExceptions.0" title="function: boolean AArch32.GenerateDebugExceptions()"><ins>AArch32.GenerateDebugExceptions</ins></a><a href="shared_pseudocode.html#AArch32.PermissionFault.7" title="function: FaultRecord AArch32.PermissionFault(bits(40) ipaddress, bits(4) domain, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><del>AArch32.PermissionFault</del></a><ins>() then
        acctype =</ins><del>(ipaddress,  domain, level, acctype, iswrite,
                                                 secondstage, s2fs1walk);
    else
        addrdesc.memattrs.type =</del> <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Normal</del></a>;
<ins>        iswrite = FALSE;
        debugmoe =</ins><del>        addrdesc.memattrs.inner.attrs =</del> <a href="shared_pseudocode.html#DebugException_Breakpoint" title="constant bits(4) DebugException_Breakpoint = '0001'"><ins>DebugException_Breakpoint</ins></a><a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'"><del>MemAttr_NC</del></a>;
<ins>        return</ins><del>        addrdesc.memattrs.inner.hints =</del> <a href="shared_pseudocode.html#AArch32.DebugFault.3" title="function: FaultRecord AArch32.DebugFault(AccType acctype, boolean iswrite, bits(4) debugmoe)"><ins>AArch32.DebugFault</ins></a><a href="shared_pseudocode.html#MemHint_No" title="constant bits(2) MemHint_No = '00'"><del>MemHint_No</del></a><ins>(acctype, iswrite, debugmoe);
    else
        return</ins><del>;
        addrdesc.memattrs.outer = addrdesc.memattrs.inner;
        addrdesc.memattrs.tagged = FALSE;
        addrdesc.memattrs =</del> <a href="shared_pseudocode.html#AArch32.NoFault.0" title="function: FaultRecord AArch32.NoFault()"><ins>AArch32.NoFault</ins></a><a href="shared_pseudocode.html#impl-shared.MemAttrDefaults.1" title="function: MemoryAttributes MemAttrDefaults(MemoryAttributes memattrs)"><del>MemAttrDefaults</del></a><ins>();</ins><del>(addrdesc.memattrs);

    return addrdesc;</del></p></div><div class="ps" psname="aarch32.translation.debug.AArch32.CheckDebug"><a id="aarch32.translation.debug.AArch32.CheckDebug" name="aarch32.translation.debug.AArch32.CheckDebug"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/<ins>debug</ins><del>attrs</del>/<ins>AArch32.CheckDebug</ins><del>AArch32.RemappedTEXDecode</del></h3><p class="pseudocode"><ins>// AArch32.CheckDebug()
// ====================
// Called on each access to check for a debug exception or entry to Debug state.
</ins><del>// AArch32.RemappedTEXDecode()
// ===========================
</del>
<ins>FaultRecord</ins><del>MemoryAttributes</del> <a id="AArch32.CheckDebug.4" name="AArch32.CheckDebug.4"></a><ins>AArch32.CheckDebug(bits(32) vaddress,</ins><del>AArch32.RemappedTEXDecode(bits(3) TEX, bit C, bit B, bit S,</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType</a> <ins>acctype, boolean iswrite, integer size)</ins><del>acctype)</del>

    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><ins>FaultRecord</ins></a><a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType type, DeviceType device, MemAttrHints inner, MemAttrHints outer, boolean tagged, boolean shareable, boolean outershareable )"><del>MemoryAttributes</del></a> <ins>fault =</ins><del>memattrs;

    region =</del> <a href="shared_pseudocode.html#AArch32.NoFault.0" title="function: FaultRecord AArch32.NoFault()"><ins>AArch32.NoFault</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>();

    d_side = (acctype !=</ins><del>(TEX&lt;0>:C:B);         // TEX&lt;2:1> are ignored in this mapping scheme
    if region == 6 then
        memattrs =</del> <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType type, DeviceType device, MemAttrHints inner, MemAttrHints outer, boolean tagged, boolean shareable, boolean outershareable )"><del>MemoryAttributes</del></a><ins>);
    generate_exception =</ins><del>IMPLEMENTATION_DEFINED;
    else
        base = 2 * region;
        attrfield = PRRR&lt;base+1:base>;

        if attrfield == '11' then      // Reserved, maps to allocated value
            (-, attrfield) =</del> <a href="shared_pseudocode.html#AArch32.GenerateDebugExceptions.0" title="function: boolean AArch32.GenerateDebugExceptions()"><ins>AArch32.GenerateDebugExceptions</ins></a><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)"><del>ConstrainUnpredictableBits</del></a><ins>() &amp;&amp; DBGDSCRext.MDBGen == '1';
    halt =</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.HaltOnBreakpointOrWatchpoint.0" title="function: boolean HaltOnBreakpointOrWatchpoint()"><ins>HaltOnBreakpointOrWatchpoint</ins></a><a href="shared_pseudocode.html#Unpredictable_RESPRRR" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESPRRR</del></a><ins>();
    // Relative priority of Vector Catch and Breakpoint exceptions not defined in the architecture
    vector_catch_first =</ins><del>);

        case attrfield of
            when '00'                  // Device-nGnRnE
                memattrs.type =</del> <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><ins>ConstrainUnpredictableBool</ins></a><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Device</del></a><ins>(</ins><del>;
                memattrs.device =</del><a href="shared_pseudocode.html#Unpredictable_BPVECTORCATCHPRI" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_BPVECTORCATCHPRI</ins></a><a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType_nGnRnE</del></a><ins>);

    if !d_side &amp;&amp; vector_catch_first &amp;&amp; generate_exception then
        fault =</ins><del>;
            when '01'                  // Device-nGnRE
                memattrs.type =</del> <a href="shared_pseudocode.html#AArch32.CheckVectorCatch.2" title="function: FaultRecord AArch32.CheckVectorCatch(bits(32) vaddress, integer size)"><ins>AArch32.CheckVectorCatch</ins></a><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Device</del></a><ins>(vaddress, size);

    if fault.type ==</ins><del>;
                memattrs.device =</del> <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_None</ins></a><a href="shared_pseudocode.html#DeviceType_nGnRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType_nGnRE</del></a> <ins>&amp;&amp; (generate_exception || halt) then
        if d_side then
            fault =</ins><del>;
            when '10'
                memattrs.type =</del> <a href="shared_pseudocode.html#AArch32.CheckWatchpoint.4" title="function: FaultRecord AArch32.CheckWatchpoint(bits(32) vaddress, AccType acctype, boolean iswrite, integer size)"><ins>AArch32.CheckWatchpoint</ins></a><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Normal</del></a><ins>(vaddress, acctype, iswrite, size);
        else
            fault =</ins><del>;
                memattrs.inner =</del> <a href="shared_pseudocode.html#AArch32.CheckBreakpoint.2" title="function: FaultRecord AArch32.CheckBreakpoint(bits(32) vaddress,  integer size)"><ins>AArch32.CheckBreakpoint</ins></a><a href="shared_pseudocode.html#impl-shared.ShortConvertAttrsHints.3" title="function: MemAttrHints ShortConvertAttrsHints(bits(2) RGN, AccType acctype, boolean secondstage)"><del>ShortConvertAttrsHints</del></a><ins>(vaddress, size);

    if fault.type ==</ins><del>(NMRR&lt;base+1:base>, acctype, FALSE);
                memattrs.outer =</del> <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_None</ins></a><a href="shared_pseudocode.html#impl-shared.ShortConvertAttrsHints.3" title="function: MemAttrHints ShortConvertAttrsHints(bits(2) RGN, AccType acctype, boolean secondstage)"><del>ShortConvertAttrsHints</del></a> <ins>&amp;&amp; !d_side &amp;&amp; !vector_catch_first &amp;&amp; generate_exception then
        return</ins><del>(NMRR&lt;base+17:base+16>, acctype, FALSE);
                s_bit = if S == '0' then PRRR.NS0 else PRRR.NS1;
                memattrs.shareable = (s_bit == '1');
                memattrs.outershareable = (s_bit == '1' &amp;&amp; PRRR&lt;region+24> == '0');
            when '11'</del> <del>();

    // transient bits are not supported in this format
    memattrs.inner.transient = FALSE;
    memattrs.outer.transient = FALSE;
    memattrs.tagged = FALSE;

    return </del><a href="shared_pseudocode.html#impl-shared.MemAttrDefaults.1" title="function: MemoryAttributes MemAttrDefaults(MemoryAttributes memattrs)"><del>MemAttrDefaults</del></a><a href="shared_pseudocode.html#AArch32.CheckVectorCatch.2" title="function: FaultRecord AArch32.CheckVectorCatch(bits(32) vaddress, integer size)"><ins>AArch32.CheckVectorCatch</ins></a><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><del>Unreachable</del></a><ins>(vaddress, size);

    return fault;</ins><del>(memattrs);</del></p></div><div class="ps" psname="aarch32.translation.debug.AArch32.CheckVectorCatch"><a id="aarch32.translation.debug.AArch32.CheckVectorCatch" name="aarch32.translation.debug.AArch32.CheckVectorCatch"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/<ins>debug</ins><del>attrs</del>/<ins>AArch32.CheckVectorCatch</ins><del>AArch32.S1AttrDecode</del></h3><p class="pseudocode"><ins>// AArch32.CheckVectorCatch()
// ==========================
// Called before executing the instruction of length "size" bytes at "vaddress" in an AArch32
// translation regime.
// Vector Catch can in fact be evaluated well ahead of execution, for example, at instruction
// fetch. This is the simple sequential execution of the program.
</ins><del>// AArch32.S1AttrDecode()
// ======================
// Converts the Stage 1 attribute fields, using the MAIR, to orthogonal
// attributes and hints.
</del>
<ins>FaultRecord</ins><del>MemoryAttributes</del> <a id="AArch32.CheckVectorCatch.2" name="AArch32.CheckVectorCatch.2"></a><ins>AArch32.CheckVectorCatch(bits(32) vaddress, integer size)
    assert</ins><del>AArch32.S1AttrDecode(bits(2) SH, bits(3) attr,</del> <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><ins>(</ins><del>acctype)</del><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType type, DeviceType device, MemAttrHints inner, MemAttrHints outer, boolean tagged, boolean shareable, boolean outershareable )"><del>MemoryAttributes</del></a><ins>());
</ins><del>memattrs;
</del>
<ins>    match =</ins><del>    if PSTATE.EL ==</del> <a href="shared_pseudocode.html#AArch32.VCRMatch.1" title="function: boolean AArch32.VCRMatch(bits(32) vaddress)"><ins>AArch32.VCRMatch</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>(vaddress);
    if size == 4 &amp;&amp; !match &amp;&amp;</ins><del>then
        mair = HMAIR1:HMAIR0;
    else
        mair = MAIR1:MAIR0;
    index = 8 *</del> <a href="shared_pseudocode.html#AArch32.VCRMatch.1" title="function: boolean AArch32.VCRMatch(bits(32) vaddress)"><ins>AArch32.VCRMatch</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>(vaddress + 2) then
        match =</ins><del>(attr);
    attrfield = mair&lt;index+7:index>;

    memattrs.tagged = FALSE;
    if ((attrfield&lt;7:4> != '0000' &amp;&amp; attrfield&lt;7:4> != '1111' &amp;&amp; attrfield&lt;3:0> == '0000') ||
        (attrfield&lt;7:4> == '0000' &amp;&amp; attrfield&lt;3:0> != 'xx00')) then
        // Reserved, maps to an allocated value
        (-, attrfield) =</del> <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><ins>ConstrainUnpredictableBool</ins></a><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)"><del>ConstrainUnpredictableBits</del></a>(<a href="shared_pseudocode.html#Unpredictable_VCMATCHHALF" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_VCMATCHHALF</ins></a><a href="shared_pseudocode.html#Unpredictable_RESMAIR" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESMAIR</del></a>);
<ins>
    if match &amp;&amp; DBGDSCRext.MDBGen == '1' &amp;&amp;</ins><del>    if !</del> <a href="shared_pseudocode.html#AArch32.GenerateDebugExceptions.0" title="function: boolean AArch32.GenerateDebugExceptions()"><ins>AArch32.GenerateDebugExceptions</ins></a><a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()"><del>HaveMTEExt</del></a><ins>() then
        acctype =</ins><del>() &amp;&amp; attrfield&lt;7:4> == '1111' &amp;&amp; attrfield&lt;3:0> == '0000' then
        // Reserved, maps to an allocated value
        (-, attrfield) =</del> <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)"><del>ConstrainUnpredictableBits</del></a><ins>;
        iswrite = FALSE;
        debugmoe =</ins><del>(</del> <a href="shared_pseudocode.html#DebugException_VectorCatch" title="constant bits(4) DebugException_VectorCatch = '0101'"><ins>DebugException_VectorCatch</ins></a><a href="shared_pseudocode.html#Unpredictable_RESMAIR" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESMAIR</del></a><ins>;
        return</ins><del>);

    if attrfield&lt;7:4> == '0000' then            // Device
        memattrs.type =</del> <a href="shared_pseudocode.html#AArch32.DebugFault.3" title="function: FaultRecord AArch32.DebugFault(AccType acctype, boolean iswrite, bits(4) debugmoe)"><ins>AArch32.DebugFault</ins></a><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Device</del></a><ins>(acctype, iswrite, debugmoe);
    else
        return</ins><del>;
        case attrfield&lt;3:0> of
            when '0000'  memattrs.device =</del> <del>;
            when '0100'  memattrs.device = </del><a href="shared_pseudocode.html#DeviceType_nGnRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType_nGnRE</del></a><del>;
            when '1000'  memattrs.device = </del><a href="shared_pseudocode.html#DeviceType_nGRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType_nGRE</del></a><del>;
            when '1100'  memattrs.device = </del><a href="shared_pseudocode.html#DeviceType_GRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType_GRE</del></a><del>;
            otherwise    </del><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><del>Unreachable</del></a><del>();         // Reserved, handled above

    elsif attrfield&lt;3:0> != '0000'  then        // Normal
        memattrs.type = </del><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Normal</del></a><del>;
        memattrs.outer = </del><a href="shared_pseudocode.html#impl-shared.LongConvertAttrsHints.2" title="function: MemAttrHints LongConvertAttrsHints(bits(4) attrfield, AccType acctype)"><del>LongConvertAttrsHints</del></a><del>(attrfield&lt;7:4>, acctype);
        memattrs.inner = </del><a href="shared_pseudocode.html#impl-shared.LongConvertAttrsHints.2" title="function: MemAttrHints LongConvertAttrsHints(bits(4) attrfield, AccType acctype)"><del>LongConvertAttrsHints</del></a><del>(attrfield&lt;3:0>, acctype);
        memattrs.shareable = SH&lt;1> == '1';
        memattrs.outershareable = SH == '10';
    elsif </del><a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()"><del>HaveMTEExt</del></a><del>() &amp;&amp; attrfield == '11110000' then // Tagged, Normal
        memattrs.tagged = TRUE;
        memattrs.type = </del><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Normal</del></a><del>;
        memattrs.outer.attrs = </del><a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'"><del>MemAttr_WB</del></a><del>;
        memattrs.inner.attrs = </del><a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'"><del>MemAttr_WB</del></a><del>;
        memattrs.outer.hints = </del><a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'"><del>MemHint_RWA</del></a><del>;
        memattrs.inner.hints = </del><a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'"><del>MemHint_RWA</del></a><del>;
        memattrs.shareable = SH&lt;1> == '1';
        memattrs.outershareable = SH == '10';
    else
        </del><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><del>Unreachable</del></a><del>();                          // Reserved, handled above

    return </del><a href="shared_pseudocode.html#impl-shared.MemAttrDefaults.1" title="function: MemoryAttributes MemAttrDefaults(MemoryAttributes memattrs)"><del>MemAttrDefaults</del></a><a href="shared_pseudocode.html#AArch32.NoFault.0" title="function: FaultRecord AArch32.NoFault()"><ins>AArch32.NoFault</ins></a><a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType_nGnRnE</del></a><ins>();</ins><del>(memattrs);</del></p></div><div class="ps" psname="aarch32.translation.debug.AArch32.CheckWatchpoint"><a id="aarch32.translation.debug.AArch32.CheckWatchpoint" name="aarch32.translation.debug.AArch32.CheckWatchpoint"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/<ins>debug</ins><del>attrs</del>/<ins>AArch32.CheckWatchpoint</ins><del>AArch32.TranslateAddressS1Off</del></h3><p class="pseudocode"><ins>// AArch32.CheckWatchpoint()
// =========================
// Called before accessing the memory location of "size" bytes at "address".
</ins><del>// AArch32.TranslateAddressS1Off()
// ===============================
// Called for stage 1 translations when translation is disabled to supply a default translation.
// Note that there are additional constraints on instruction prefetching that are not described in
// this pseudocode.
</del>
<ins>FaultRecord</ins><del>TLBRecord</del> <a id="AArch32.CheckWatchpoint.4" name="AArch32.CheckWatchpoint.4"></a><ins>AArch32.CheckWatchpoint(bits(32) vaddress,</ins><del>AArch32.TranslateAddressS1Off(bits(32) vaddress,</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType</a> <ins>acctype,
                                    boolean iswrite, integer size)
</ins><del>acctype, boolean iswrite)
</del>    assert <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a><ins>());

    match = FALSE;
    ispriv =</ins><del>());</del> <a href="shared_pseudocode.html#AArch32.AccessIsPrivileged.1" title="function: boolean AArch32.AccessIsPrivileged(AccType acctype)"><ins>AArch32.AccessIsPrivileged</ins></a><a href="shared_pseudocode.html#TLBRecord" title="type TLBRecord is ( Permissions perms, bit nG, bits(4) domain, bit GP, boolean contiguous, integer level, integer blocksize, DescriptorUpdate descupdate, bit CnP, AddressDescriptor addrdesc )"><del>TLBRecord</del></a><ins>(acctype);
</ins><del>result;
</del>
<ins>    for i = 0 to</ins><del>    default_cacheable = (</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#impl-shared.HasS2Translation.0" title="function: boolean HasS2Translation()"><del>HasS2Translation</del></a><ins>(DBGDIDR.WRPs)
        match = match ||</ins><del>() &amp;&amp; ((if</del> <a href="shared_pseudocode.html#AArch32.WatchpointMatch.5" title="function: boolean AArch32.WatchpointMatch(integer n, bits(32) vaddress, integer size, boolean ispriv, boolean iswrite)"><ins>AArch32.WatchpointMatch</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><ins>(i, vaddress, size, ispriv, iswrite);

    if match &amp;&amp;</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.HaltOnBreakpointOrWatchpoint.0" title="function: boolean HaltOnBreakpointOrWatchpoint()"><ins>HaltOnBreakpointOrWatchpoint</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>() then
        reason =</ins><del>) then HCR.DC else HCR_EL2.DC) == '1'));

    if default_cacheable then
        // Use default cacheable settings
        result.addrdesc.memattrs.type =</del> <a href="shared_pseudocode.html#DebugHalt_Watchpoint" title="constant bits(6) DebugHalt_Watchpoint = '101011'"><ins>DebugHalt_Watchpoint</ins></a><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Normal</del></a><ins>;</ins><del>;
        result.addrdesc.memattrs.inner.attrs =</del>
        <a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)"><ins>Halt</ins></a><a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'"><del>MemAttr_WB</del></a><ins>(reason);
    elsif match &amp;&amp; DBGDSCRext.MDBGen == '1' &amp;&amp;</ins><del>;      // Write-back
        result.addrdesc.memattrs.inner.hints =</del> <a href="shared_pseudocode.html#AArch32.GenerateDebugExceptions.0" title="function: boolean AArch32.GenerateDebugExceptions()"><ins>AArch32.GenerateDebugExceptions</ins></a><a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'"><del>MemHint_RWA</del></a><ins>() then
        debugmoe =</ins><del>;
        result.addrdesc.memattrs.shareable = FALSE;
        result.addrdesc.memattrs.outershareable = FALSE;
        result.addrdesc.memattrs.tagged = HCR_EL2.DCT == '1';
    elsif acctype !=</del> <a href="shared_pseudocode.html#DebugException_Watchpoint" title="constant bits(4) DebugException_Watchpoint = '1010'"><ins>DebugException_Watchpoint</ins></a><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IFETCH</del></a><ins>;
        return</ins><del>then
        // Treat data as Device
        result.addrdesc.memattrs.type =</del> <del>;
        result.addrdesc.memattrs.device = </del><a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType_nGnRnE</del></a><del>;
        result.addrdesc.memattrs.inner = </del><a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )"><del>MemAttrHints</del></a><del> UNKNOWN;
        result.addrdesc.memattrs.tagged = FALSE;
    else
        // Instruction cacheability controlled by SCTLR/HSCTLR.I
        if PSTATE.EL == </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del> then
            cacheable = HSCTLR.I == '1';
        else
            cacheable = SCTLR.I == '1';
        result.addrdesc.memattrs.type = </del><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Normal</del></a><del>;
        if cacheable then
            result.addrdesc.memattrs.inner.attrs = </del><a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'"><del>MemAttr_WT</del></a><del>;
            result.addrdesc.memattrs.inner.hints = </del><a href="shared_pseudocode.html#MemHint_RA" title="constant bits(2) MemHint_RA = '10'"><del>MemHint_RA</del></a><del>;
        else
            result.addrdesc.memattrs.inner.attrs = </del><a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'"><del>MemAttr_NC</del></a><del>;
            result.addrdesc.memattrs.inner.hints = </del><a href="shared_pseudocode.html#MemHint_No" title="constant bits(2) MemHint_No = '00'"><del>MemHint_No</del></a><del>;
        result.addrdesc.memattrs.shareable = TRUE;
        result.addrdesc.memattrs.outershareable = TRUE;
        result.addrdesc.memattrs.tagged = FALSE;

    result.addrdesc.memattrs.outer = result.addrdesc.memattrs.inner;

    result.addrdesc.memattrs = </del><a href="shared_pseudocode.html#impl-shared.MemAttrDefaults.1" title="function: MemoryAttributes MemAttrDefaults(MemoryAttributes memattrs)"><del>MemAttrDefaults</del></a><del>(result.addrdesc.memattrs);

    result.perms.ap = bits(3) UNKNOWN;
    result.perms.xn = '0';
    result.perms.pxn = '0';

    result.nG = bit UNKNOWN;
    result.contiguous = boolean UNKNOWN;
    result.domain = bits(4) UNKNOWN;
    result.level = integer UNKNOWN;
    result.blocksize = integer UNKNOWN;
    result.addrdesc.paddress.address = </del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><del>(vaddress);
    result.addrdesc.paddress.NS = if </del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><a href="shared_pseudocode.html#AArch32.DebugFault.3" title="function: FaultRecord AArch32.DebugFault(AccType acctype, boolean iswrite, bits(4) debugmoe)"><ins>AArch32.DebugFault</ins></a><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Device</del></a><ins>(acctype, iswrite, debugmoe);
    else
        return</ins><del>() then '0' else '1';
    result.addrdesc.fault =</del> <a href="shared_pseudocode.html#AArch32.NoFault.0" title="function: FaultRecord AArch32.NoFault()">AArch32.NoFault</a><ins>();</ins><del>();
    return result;</del></p></div><div class="ps" psname="aarch32.translation.faults.AArch32.AccessFlagFault"><a id="aarch32.translation.faults.AArch32.AccessFlagFault" name="aarch32.translation.faults.AArch32.AccessFlagFault"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/<ins>faults</ins><del>checks</del>/<ins>AArch32.AccessFlagFault</ins><del>AArch32.AccessIsPrivileged</del></h3><p class="pseudocode"><ins>// AArch32.AccessFlagFault()
// =========================
</ins><del>// AArch32.AccessIsPrivileged()
// ============================
</del>
<ins>FaultRecord</ins><del>boolean</del> <a id="AArch32.AccessFlagFault.7" name="AArch32.AccessFlagFault.7"></a><ins>AArch32.AccessFlagFault(bits(40) ipaddress, bits(4) domain, integer level,</ins><del>AArch32.AccessIsPrivileged(</del>
                                    <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType</a> <ins>acctype, boolean iswrite, boolean secondstage,
                                    boolean s2fs1walk)
</ins><del>acctype)
</del>
<ins>    extflag = bit UNKNOWN;
    debugmoe = bits(4) UNKNOWN;
    errortype = bits(2) UNKNOWN;
    return</ins><del>    el =</del> <a href="shared_pseudocode.html#AArch32.CreateFaultRecord.11" title="function: FaultRecord AArch32.CreateFaultRecord(Fault type, bits(40) ipaddress,   bits(4) domain, integer level, AccType acctype, boolean write, bit extflag, bits(4) debugmoe, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><ins>AArch32.CreateFaultRecord</ins></a><a href="shared_pseudocode.html#AArch32.AccessUsesEL.1" title="function: bits(2) AArch32.AccessUsesEL(AccType acctype)"><del>AArch32.AccessUsesEL</del></a><ins>(</ins><del>(acctype);

    if el ==</del><del> then
        ispriv = FALSE;
    elsif el != </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del> then
        ispriv = TRUE;
    else
        ispriv = (acctype != </del><a href="shared_pseudocode.html#AccType_UNPRIV" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_UNPRIV</del></a><a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_AccessFlag</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>, ipaddress,  domain, level, acctype, iswrite,
                                     extflag, debugmoe, errortype, secondstage, s2fs1walk);</ins><del>);

    return ispriv;</del></p></div><div class="ps" psname="aarch32.translation.faults.AArch32.AddressSizeFault"><a id="aarch32.translation.faults.AArch32.AddressSizeFault" name="aarch32.translation.faults.AArch32.AddressSizeFault"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/<ins>faults</ins><del>checks</del>/<ins>AArch32.AddressSizeFault</ins><del>AArch32.AccessUsesEL</del></h3><p class="pseudocode"><ins>// AArch32.AddressSizeFault()
// ==========================
</ins><del>// AArch32.AccessUsesEL()
// ======================
// Returns the Exception Level of the regime that will manage the translation for a given access type.
</del>
<ins>FaultRecord</ins><del>bits(2)</del> <a id="AArch32.AddressSizeFault.7" name="AArch32.AddressSizeFault.7"></a><ins>AArch32.AddressSizeFault(bits(40) ipaddress, bits(4) domain, integer level,</ins><del>AArch32.AccessUsesEL(</del>
                                     <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType</a> <ins>acctype, boolean iswrite, boolean secondstage,
                                     boolean s2fs1walk)

    extflag = bit UNKNOWN;
    debugmoe = bits(4) UNKNOWN;
    errortype = bits(2) UNKNOWN;
    return</ins><del>acctype)
    if acctype ==</del> <a href="shared_pseudocode.html#AArch32.CreateFaultRecord.11" title="function: FaultRecord AArch32.CreateFaultRecord(Fault type, bits(40) ipaddress,   bits(4) domain, integer level, AccType acctype, boolean write, bit extflag, bits(4) debugmoe, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><ins>AArch32.CreateFaultRecord</ins></a><a href="shared_pseudocode.html#AccType_UNPRIV" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_UNPRIV</del></a><ins>(</ins><del>then
        return</del><a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_AddressSize</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>, ipaddress,  domain, level, acctype, iswrite,
                                     extflag, debugmoe, errortype, secondstage, s2fs1walk);</ins><del>;
    else
        return PSTATE.EL;</del></p></div><div class="ps" psname="aarch32.translation.faults.AArch32.AlignmentFault"><a id="aarch32.translation.faults.AArch32.AlignmentFault" name="aarch32.translation.faults.AArch32.AlignmentFault"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/<ins>faults</ins><del>checks</del>/<ins>AArch32.AlignmentFault</ins><del>AArch32.CheckDomain</del></h3><p class="pseudocode"><ins>// AArch32.AlignmentFault()
// ========================
</ins><del>// AArch32.CheckDomain()
// =====================
</del>
<ins>FaultRecord</ins><del>(boolean, FaultRecord)</del> <a id="AArch32.AlignmentFault.3" name="AArch32.AlignmentFault.3"></a><ins>AArch32.AlignmentFault(</ins><del>AArch32.CheckDomain(bits(4) domain, bits(32) vaddress, integer level,</del><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType</a> <ins>acctype, boolean iswrite, boolean secondstage)
</ins><del>acctype, boolean iswrite)
</del>
<ins>    ipaddress = bits(40) UNKNOWN;
    domain = bits(4) UNKNOWN;
    level = integer UNKNOWN;
    extflag = bit UNKNOWN;
    debugmoe = bits(4) UNKNOWN;
    errortype = bits(2) UNKNOWN;
    s2fs1walk = boolean UNKNOWN;

    return</ins><del>    index = 2 *</del> <a href="shared_pseudocode.html#AArch32.CreateFaultRecord.11" title="function: FaultRecord AArch32.CreateFaultRecord(Fault type, bits(40) ipaddress,   bits(4) domain, integer level, AccType acctype, boolean write, bit extflag, bits(4) debugmoe, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><ins>AArch32.CreateFaultRecord</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>(</ins><del>(domain);
    attrfield = DACR&lt;index+1:index>;

    if attrfield == '10' then          // Reserved, maps to an allocated value
        // Reserved value maps to an allocated value
        (-, attrfield) =</del><del>(</del><a href="shared_pseudocode.html#Unpredictable_RESDACR" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESDACR</del></a><del>);

    if attrfield == '00' then
        fault = </del><a href="shared_pseudocode.html#AArch32.DomainFault.4" title="function: FaultRecord AArch32.DomainFault(bits(4) domain, integer level, AccType acctype, boolean iswrite)"><del>AArch32.DomainFault</del></a><del>(domain, level, acctype, iswrite);
    else
        fault = </del><a href="shared_pseudocode.html#AArch32.NoFault.0" title="function: FaultRecord AArch32.NoFault()"><del>AArch32.NoFault</del></a><a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_Alignment</ins></a><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)"><del>ConstrainUnpredictableBits</del></a><ins>, ipaddress,  domain, level, acctype, iswrite,
                                     extflag, debugmoe, errortype, secondstage, s2fs1walk);</ins><del>();

    permissioncheck = (attrfield == '01');

    return (permissioncheck, fault);</del></p></div><div class="ps" psname="aarch32.translation.faults.AArch32.AsynchExternalAbort"><a id="aarch32.translation.faults.AArch32.AsynchExternalAbort" name="aarch32.translation.faults.AArch32.AsynchExternalAbort"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/<ins>faults</ins><del>checks</del>/<ins>AArch32.AsynchExternalAbort</ins><del>AArch32.CheckPermission</del></h3><p class="pseudocode"><ins>// AArch32.AsynchExternalAbort()
// =============================
// Wrapper function for asynchronous external aborts
</ins><del>// AArch32.CheckPermission()
// =========================
// Function used for permission checking from AArch32 stage 1 translations
</del>
FaultRecord <a id="AArch32.AsynchExternalAbort.3" name="AArch32.AsynchExternalAbort.3"></a><ins>AArch32.AsynchExternalAbort(boolean parity, bits(2) errortype, bit extflag)

    type = if parity then</ins><del>AArch32.CheckPermission(</del> <a href="shared_pseudocode.html#Fault_AsyncParity" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_AsyncParity</ins></a><a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(3) ap, bit xn, bit xxn, bit pxn )"><del>Permissions</del></a> <ins>else</ins><del>perms, bits(32) vaddress, integer level,
                                    bits(4) domain, bit NS,</del> <a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_AsyncExternal</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><ins>;
    ipaddress = bits(40) UNKNOWN;
    domain = bits(4) UNKNOWN;
    level = integer UNKNOWN;
    acctype =</ins><del>acctype, boolean iswrite)
    assert</del> <a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NORMAL</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><ins>;
    iswrite = boolean UNKNOWN;
    debugmoe = bits(4) UNKNOWN;
    secondstage = FALSE;
    s2fs1walk = FALSE;

    return</ins><del>(</del> <del>());

    if PSTATE.EL != </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del> then
        wxn = SCTLR.WXN == '1';
        if TTBCR.EAE == '1' || SCTLR.AFE == '1' || perms.ap&lt;0> == '1' then
            priv_r = TRUE;
            priv_w = perms.ap&lt;2> == '0';
            user_r = perms.ap&lt;1> == '1';
            user_w = perms.ap&lt;2:1> == '01';
        else
            priv_r = perms.ap&lt;2:1> != '00';
            priv_w = perms.ap&lt;2:1> == '01';
            user_r = perms.ap&lt;1> == '1';
            user_w = FALSE;
        uwxn = SCTLR.UWXN == '1';

        ispriv = </del><a href="shared_pseudocode.html#AArch32.AccessIsPrivileged.1" title="function: boolean AArch32.AccessIsPrivileged(AccType acctype)"><del>AArch32.AccessIsPrivileged</del></a><del>(acctype);

        pan = if </del><a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()"><del>HavePANExt</del></a><del>() then PSTATE.PAN else '0';
        is_ldst   = !(acctype IN {</del><a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_DC</del></a><del>, </del><a href="shared_pseudocode.html#AccType_DC_UNPRIV" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_DC_UNPRIV</del></a><del>, </del><a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_AT</del></a><del>, </del><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IFETCH</del></a><del>});
        is_ats1xp = (acctype == </del><a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_AT</del></a><del> &amp;&amp; </del><a href="shared_pseudocode.html#AArch32.ExecutingATS1xPInstr.0" title="function: boolean AArch32.ExecutingATS1xPInstr()"><del>AArch32.ExecutingATS1xPInstr</del></a><del>());
        if pan == '1' &amp;&amp; user_r &amp;&amp; ispriv &amp;&amp; (is_ldst || is_ats1xp) then
            priv_r = FALSE;
            priv_w = FALSE;

        user_xn = !user_r || perms.xn == '1' || (user_w &amp;&amp; wxn);
        priv_xn = (!priv_r || perms.xn == '1' || perms.pxn == '1' ||
                   (priv_w &amp;&amp; wxn) || (user_w &amp;&amp; uwxn));

        if ispriv then
            (r, w, xn) = (priv_r, priv_w, priv_xn);
        else
            (r, w, xn) = (user_r, user_w, user_xn);
    else
        // Access from EL2
        wxn = HSCTLR.WXN == '1';
        r = TRUE;
        w = perms.ap&lt;2> == '0';
        xn = perms.xn == '1' || (w &amp;&amp; wxn);

    // Restriction on Secure instruction fetch
    if </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>() &amp;&amp; NS == '1' then
        secure_instr_fetch = if </del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) then SCR.SIF else SCR_EL3.SIF;
        if secure_instr_fetch == '1' then xn = TRUE;

    if acctype == </del><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IFETCH</del></a><del> then
        fail = xn;
        failedread = TRUE;
    elsif acctype IN { </del><a href="shared_pseudocode.html#AccType_ATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ATOMICRW</del></a><del>, </del><a href="shared_pseudocode.html#AccType_ORDEREDRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ORDEREDRW</del></a><del>, </del><a href="shared_pseudocode.html#AccType_ORDEREDATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ORDEREDATOMICRW</del></a><del> } then
        fail = !r || !w;
        failedread = !r;
    elsif acctype == </del><a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_DC</del></a><del> then
        // DC maintenance instructions operating by VA, cannot fault from stage 1 translation.
        fail = FALSE;
    elsif iswrite then
        fail = !w;
        failedread = FALSE;
    else
        fail = !r;
        failedread = TRUE;

    if fail then
        secondstage = FALSE;
        s2fs1walk = FALSE;
        ipaddress = bits(40) UNKNOWN;
        return </del><a href="shared_pseudocode.html#AArch32.PermissionFault.7" title="function: FaultRecord AArch32.PermissionFault(bits(40) ipaddress, bits(4) domain, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><del>AArch32.PermissionFault</del></a><del>(ipaddress,  domain, level, acctype,
                                       !failedread, secondstage, s2fs1walk);
    else
        return </del><a href="shared_pseudocode.html#AArch32.NoFault.0" title="function: FaultRecord AArch32.NoFault()"><del>AArch32.NoFault</del></a><a href="shared_pseudocode.html#AArch32.CreateFaultRecord.11" title="function: FaultRecord AArch32.CreateFaultRecord(Fault type, bits(40) ipaddress,   bits(4) domain, integer level, AccType acctype, boolean write, bit extflag, bits(4) debugmoe, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><ins>AArch32.CreateFaultRecord</ins></a><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><ins>(type, ipaddress,  domain, level, acctype, iswrite, extflag,
                                     debugmoe,  errortype, secondstage, s2fs1walk);</ins><del>();</del></p></div><div class="ps" psname="aarch32.translation.faults.AArch32.DebugFault"><a id="aarch32.translation.faults.AArch32.DebugFault" name="aarch32.translation.faults.AArch32.DebugFault"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/<ins>faults</ins><del>checks</del>/<ins>AArch32.DebugFault</ins><del>AArch32.CheckS2Permission</del></h3><p class="pseudocode"><ins>// AArch32.DebugFault()
// ====================
</ins><del>// AArch32.CheckS2Permission()
// ===========================
// Function used for permission checking from AArch32 stage 2 translations
</del>
FaultRecord <a id="AArch32.DebugFault.3" name="AArch32.DebugFault.3"></a><ins>AArch32.DebugFault(</ins><del>AArch32.CheckS2Permission(</del><a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(3) ap, bit xn, bit xxn, bit pxn )"><del>Permissions</del></a><del> perms, bits(32) vaddress, bits(40) ipaddress,
                                      integer level, </del><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType</a> <ins>acctype, boolean iswrite, bits(4) debugmoe)
</ins><del>acctype, boolean iswrite,
                                      boolean s2fs1walk)
</del>
<ins>    ipaddress = bits(40) UNKNOWN;
    domain = bits(4) UNKNOWN;
    errortype = bits(2) UNKNOWN;
    level = integer UNKNOWN;
    extflag = bit UNKNOWN;
    secondstage = FALSE;
    s2fs1walk = FALSE;

    return</ins><del>    assert</del> <a href="shared_pseudocode.html#AArch32.CreateFaultRecord.11" title="function: FaultRecord AArch32.CreateFaultRecord(Fault type, bits(40) ipaddress,   bits(4) domain, integer level, AccType acctype, boolean write, bit extflag, bits(4) debugmoe, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><ins>AArch32.CreateFaultRecord</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a>(<del>) &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>() &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.HasS2Translation.0" title="function: boolean HasS2Translation()"><del>HasS2Translation</del></a><del>();

    r = perms.ap&lt;1> == '1';
    w = perms.ap&lt;2> == '1';
    if </del><a href="shared_pseudocode.html#impl-shared.HaveExtendedExecuteNeverExt.0" title="function: boolean HaveExtendedExecuteNeverExt()"><del>HaveExtendedExecuteNeverExt</del></a><del>() then
        case perms.xn:perms.xxn of
            when '00'  xn = !r;
            when '01'  xn = !r || PSTATE.EL == </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>;
            when '10'  xn = TRUE;
            when '11'  xn = !r || PSTATE.EL == </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>;
    else
        xn = !r || perms.xn == '1';
    // Stage 1 walk is checked as a read, regardless of the original type
    if acctype == </del><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IFETCH</del></a><del> &amp;&amp; !s2fs1walk then
        fail = xn;
        failedread = TRUE;
    elsif (acctype IN { </del><a href="shared_pseudocode.html#AccType_ATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ATOMICRW</del></a><del>, </del><a href="shared_pseudocode.html#AccType_ORDEREDRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ORDEREDRW</del></a><del>, </del><a href="shared_pseudocode.html#AccType_ORDEREDATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ORDEREDATOMICRW</del></a><del> }) &amp;&amp; !s2fs1walk then
        fail = !r || !w;
        failedread = !r;
    elsif acctype == </del><a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_DC</del></a><del> &amp;&amp; !s2fs1walk then
        // DC maintenance instructions operating by VA, do not generate Permission faults
        // from stage 2 translation, other than from stage 1 translation table walk.
        fail = FALSE;
    elsif iswrite &amp;&amp; !s2fs1walk then
        fail = !w;
        failedread = FALSE;
    else
        fail = !r;
        failedread = !iswrite;

    if fail then
        domain = bits(4) UNKNOWN;
        secondstage = TRUE;
        return </del><a href="shared_pseudocode.html#AArch32.PermissionFault.7" title="function: FaultRecord AArch32.PermissionFault(bits(40) ipaddress, bits(4) domain, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><del>AArch32.PermissionFault</del></a><del>(ipaddress,  domain, level, acctype,
                                       !failedread, secondstage, s2fs1walk);
    else
        return </del><a href="shared_pseudocode.html#AArch32.NoFault.0" title="function: FaultRecord AArch32.NoFault()"><del>AArch32.NoFault</del></a><a href="shared_pseudocode.html#Fault_Debug" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_Debug</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>, ipaddress,  domain, level, acctype, iswrite,
                                     extflag, debugmoe, errortype, secondstage, s2fs1walk);</ins><del>();</del></p></div><div class="ps" psname="aarch32.translation.faults.AArch32.DomainFault"><a id="aarch32.translation.faults.AArch32.DomainFault" name="aarch32.translation.faults.AArch32.DomainFault"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/<ins>faults</ins><del>debug</del>/<ins>AArch32.DomainFault</ins><del>AArch32.CheckBreakpoint</del></h3><p class="pseudocode"><ins>// AArch32.DomainFault()
// =====================
</ins><del>// AArch32.CheckBreakpoint()
// =========================
// Called before executing the instruction of length "size" bytes at "vaddress" in an AArch32
// translation regime.
// The breakpoint can in fact be evaluated well ahead of execution, for example, at instruction
// fetch. This is the simple sequential execution of the program.
</del>
FaultRecord <a id="AArch32.DomainFault.4" name="AArch32.DomainFault.4"></a><ins>AArch32.DomainFault(bits(4) domain, integer level,</ins><del>AArch32.CheckBreakpoint(bits(32) vaddress,  integer size)
    assert</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a> <ins>acctype, boolean iswrite)

    ipaddress = bits(40) UNKNOWN;
    extflag = bit UNKNOWN;
    debugmoe = bits(4) UNKNOWN;
    errortype = bits(2) UNKNOWN;
    secondstage = FALSE;
    s2fs1walk = FALSE;

    return</ins><del>(</del> <a href="shared_pseudocode.html#AArch32.CreateFaultRecord.11" title="function: FaultRecord AArch32.CreateFaultRecord(Fault type, bits(40) ipaddress,   bits(4) domain, integer level, AccType acctype, boolean write, bit extflag, bits(4) debugmoe, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><ins>AArch32.CreateFaultRecord</ins></a><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><ins>(</ins><del>());
    assert size IN {2,4};

    match = FALSE;
    mismatch = FALSE;

    for i = 0 to</del><del>(DBGDIDR.BRPs)
        (match_i, mismatch_i) = </del><a href="shared_pseudocode.html#AArch32.BreakpointMatch.3" title="function: (boolean,boolean) AArch32.BreakpointMatch(integer n, bits(32) vaddress,  integer size)"><del>AArch32.BreakpointMatch</del></a><del>(i, vaddress, size);
        match = match || match_i;
        mismatch = mismatch || mismatch_i;

    if match &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.HaltOnBreakpointOrWatchpoint.0" title="function: boolean HaltOnBreakpointOrWatchpoint()"><del>HaltOnBreakpointOrWatchpoint</del></a><del>() then
        reason = </del><a href="shared_pseudocode.html#DebugHalt_Breakpoint" title="constant bits(6) DebugHalt_Breakpoint = '000111'"><del>DebugHalt_Breakpoint</del></a><del>;
        </del><a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)"><del>Halt</del></a><del>(reason);
    elsif (match || mismatch) &amp;&amp; DBGDSCRext.MDBGen == '1' &amp;&amp; </del><a href="shared_pseudocode.html#AArch32.GenerateDebugExceptions.0" title="function: boolean AArch32.GenerateDebugExceptions()"><del>AArch32.GenerateDebugExceptions</del></a><del>() then
        acctype = </del><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IFETCH</del></a><del>;
        iswrite = FALSE;
        debugmoe = </del><a href="shared_pseudocode.html#DebugException_Breakpoint" title="constant bits(4) DebugException_Breakpoint = '0001'"><del>DebugException_Breakpoint</del></a><del>;
        return </del><a href="shared_pseudocode.html#AArch32.DebugFault.3" title="function: FaultRecord AArch32.DebugFault(AccType acctype, boolean iswrite, bits(4) debugmoe)"><del>AArch32.DebugFault</del></a><del>(acctype, iswrite, debugmoe);
    else
        return </del><a href="shared_pseudocode.html#AArch32.NoFault.0" title="function: FaultRecord AArch32.NoFault()"><del>AArch32.NoFault</del></a><a href="shared_pseudocode.html#Fault_Domain" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_Domain</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>, ipaddress,  domain, level, acctype, iswrite,
                                     extflag, debugmoe, errortype, secondstage, s2fs1walk);</ins><del>();</del></p></div><div class="ps" psname="aarch32.translation.faults.AArch32.NoFault"><a id="aarch32.translation.faults.AArch32.NoFault" name="aarch32.translation.faults.AArch32.NoFault"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/<ins>faults</ins><del>debug</del>/<ins>AArch32.NoFault</ins><del>AArch32.CheckDebug</del></h3><p class="pseudocode"><ins>// AArch32.NoFault()
// =================
</ins><del>// AArch32.CheckDebug()
// ====================
// Called on each access to check for a debug exception or entry to Debug state.
</del>
FaultRecord <a id="AArch32.NoFault.0" name="AArch32.NoFault.0"></a><ins>AArch32.NoFault()

    ipaddress = bits(40) UNKNOWN;
    domain = bits(4) UNKNOWN;
    level = integer UNKNOWN;
    acctype =</ins><del>AArch32.CheckDebug(bits(32) vaddress,</del> <a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NORMAL</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><ins>;
    iswrite = boolean UNKNOWN;
    extflag = bit UNKNOWN;
    debugmoe = bits(4) UNKNOWN;
    errortype = bits(2) UNKNOWN;
    secondstage = FALSE;
    s2fs1walk = FALSE;

    return</ins><del>acctype, boolean iswrite, integer size)</del> <a href="shared_pseudocode.html#AArch32.CreateFaultRecord.11" title="function: FaultRecord AArch32.CreateFaultRecord(Fault type, bits(40) ipaddress,   bits(4) domain, integer level, AccType acctype, boolean write, bit extflag, bits(4) debugmoe, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><ins>AArch32.CreateFaultRecord</ins></a><a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><del>FaultRecord</del></a><ins>(</ins><del>fault =</del><a href="shared_pseudocode.html#AArch32.NoFault.0" title="function: FaultRecord AArch32.NoFault()"><del>AArch32.NoFault</del></a><del>();

    d_side = (acctype != </del><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IFETCH</del></a><del>);
    generate_exception = </del><a href="shared_pseudocode.html#AArch32.GenerateDebugExceptions.0" title="function: boolean AArch32.GenerateDebugExceptions()"><del>AArch32.GenerateDebugExceptions</del></a><del>() &amp;&amp; DBGDSCRext.MDBGen == '1';
    halt = </del><a href="shared_pseudocode.html#impl-shared.HaltOnBreakpointOrWatchpoint.0" title="function: boolean HaltOnBreakpointOrWatchpoint()"><del>HaltOnBreakpointOrWatchpoint</del></a><del>();
    // Relative priority of Vector Catch and Breakpoint exceptions not defined in the architecture
    vector_catch_first = </del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><del>ConstrainUnpredictableBool</del></a><del>(</del><a href="shared_pseudocode.html#Unpredictable_BPVECTORCATCHPRI" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_BPVECTORCATCHPRI</del></a><del>);

    if !d_side &amp;&amp; vector_catch_first &amp;&amp; generate_exception then
        fault = </del><a href="shared_pseudocode.html#AArch32.CheckVectorCatch.2" title="function: FaultRecord AArch32.CheckVectorCatch(bits(32) vaddress, integer size)"><del>AArch32.CheckVectorCatch</del></a><del>(vaddress, size);

    if fault.type == </del><a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}">Fault_None</a><del> &amp;&amp; (generate_exception || halt) then
        if d_side then
            fault = </del><a href="shared_pseudocode.html#AArch32.CheckWatchpoint.4" title="function: FaultRecord AArch32.CheckWatchpoint(bits(32) vaddress, AccType acctype, boolean iswrite, integer size)"><del>AArch32.CheckWatchpoint</del></a><del>(vaddress, acctype, iswrite, size);
        else
            fault = </del><a href="shared_pseudocode.html#AArch32.CheckBreakpoint.2" title="function: FaultRecord AArch32.CheckBreakpoint(bits(32) vaddress,  integer size)"><del>AArch32.CheckBreakpoint</del></a><del>(vaddress, size);

    if fault.type == </del><a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_None</del></a><del> &amp;&amp; !d_side &amp;&amp; !vector_catch_first &amp;&amp; generate_exception then
        return </del><a href="shared_pseudocode.html#AArch32.CheckVectorCatch.2" title="function: FaultRecord AArch32.CheckVectorCatch(bits(32) vaddress, integer size)"><del>AArch32.CheckVectorCatch</del></a><ins>, ipaddress,  domain, level, acctype, iswrite,
                                     extflag, debugmoe, errortype, secondstage, s2fs1walk);</ins><del>(vaddress, size);

    return fault;</del></p></div><div class="ps" psname="aarch32.translation.faults.AArch32.PermissionFault"><a id="aarch32.translation.faults.AArch32.PermissionFault" name="aarch32.translation.faults.AArch32.PermissionFault"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/<ins>faults</ins><del>debug</del>/<ins>AArch32.PermissionFault</ins><del>AArch32.CheckVectorCatch</del></h3><p class="pseudocode"><ins>// AArch32.PermissionFault()
// =========================
</ins><del>// AArch32.CheckVectorCatch()
// ==========================
// Called before executing the instruction of length "size" bytes at "vaddress" in an AArch32
// translation regime.
// Vector Catch can in fact be evaluated well ahead of execution, for example, at instruction
// fetch. This is the simple sequential execution of the program.
</del>
FaultRecord <a id="AArch32.PermissionFault.7" name="AArch32.PermissionFault.7"></a><ins>AArch32.PermissionFault(bits(40) ipaddress, bits(4) domain, integer level,</ins><del>AArch32.CheckVectorCatch(bits(32) vaddress, integer size)
    assert</del>
                                    <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a> <ins>acctype, boolean iswrite, boolean secondstage,
                                    boolean s2fs1walk)

    extflag = bit UNKNOWN;
    debugmoe = bits(4) UNKNOWN;
    errortype = bits(2) UNKNOWN;
    return</ins><del>(</del> <a href="shared_pseudocode.html#AArch32.CreateFaultRecord.11" title="function: FaultRecord AArch32.CreateFaultRecord(Fault type, bits(40) ipaddress,   bits(4) domain, integer level, AccType acctype, boolean write, bit extflag, bits(4) debugmoe, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><ins>AArch32.CreateFaultRecord</ins></a><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><ins>(</ins><del>());

    match =</del><del>(vaddress);
    if size == 4 &amp;&amp; !match &amp;&amp; </del><a href="shared_pseudocode.html#AArch32.VCRMatch.1" title="function: boolean AArch32.VCRMatch(bits(32) vaddress)"><del>AArch32.VCRMatch</del></a><del>(vaddress + 2) then
        match = </del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><del>ConstrainUnpredictableBool</del></a><del>(</del><a href="shared_pseudocode.html#Unpredictable_VCMATCHHALF" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_VCMATCHHALF</del></a><del>);

    if match &amp;&amp; DBGDSCRext.MDBGen == '1' &amp;&amp; </del><a href="shared_pseudocode.html#AArch32.GenerateDebugExceptions.0" title="function: boolean AArch32.GenerateDebugExceptions()"><del>AArch32.GenerateDebugExceptions</del></a><del>() then
        acctype = </del><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IFETCH</del></a><del>;
        iswrite = FALSE;
        debugmoe = </del><a href="shared_pseudocode.html#DebugException_VectorCatch" title="constant bits(4) DebugException_VectorCatch = '0101'"><del>DebugException_VectorCatch</del></a><del>;
        return </del><a href="shared_pseudocode.html#AArch32.DebugFault.3" title="function: FaultRecord AArch32.DebugFault(AccType acctype, boolean iswrite, bits(4) debugmoe)"><del>AArch32.DebugFault</del></a><del>(acctype, iswrite, debugmoe);
    else
        return </del><a href="shared_pseudocode.html#AArch32.NoFault.0" title="function: FaultRecord AArch32.NoFault()"><del>AArch32.NoFault</del></a><a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_Permission</ins></a><a href="shared_pseudocode.html#AArch32.VCRMatch.1" title="function: boolean AArch32.VCRMatch(bits(32) vaddress)"><del>AArch32.VCRMatch</del></a><ins>, ipaddress,  domain, level, acctype, iswrite,
                                     extflag, debugmoe, errortype, secondstage, s2fs1walk);</ins><del>();</del></p></div><div class="ps" psname="aarch32.translation.faults.AArch32.TranslationFault"><a id="aarch32.translation.faults.AArch32.TranslationFault" name="aarch32.translation.faults.AArch32.TranslationFault"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/<ins>faults</ins><del>debug</del>/<ins>AArch32.TranslationFault</ins><del>AArch32.CheckWatchpoint</del></h3><p class="pseudocode"><ins>// AArch32.TranslationFault()
// ==========================
</ins><del>// AArch32.CheckWatchpoint()
// =========================
// Called before accessing the memory location of "size" bytes at "address".
</del>
FaultRecord <a id="AArch32.TranslationFault.7" name="AArch32.TranslationFault.7"></a><ins>AArch32.TranslationFault(bits(40) ipaddress,  bits(4) domain, integer level,</ins><del>AArch32.CheckWatchpoint(bits(32) vaddress,</del>
                                     <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType</a> <ins>acctype, boolean iswrite, boolean secondstage,
                                     boolean s2fs1walk)

    extflag = bit UNKNOWN;
    debugmoe = bits(4) UNKNOWN;
    errortype = bits(2) UNKNOWN;
    return</ins><del>acctype,
                                    boolean iswrite, integer size)
    assert</del> <a href="shared_pseudocode.html#AArch32.CreateFaultRecord.11" title="function: FaultRecord AArch32.CreateFaultRecord(Fault type, bits(40) ipaddress,   bits(4) domain, integer level, AccType acctype, boolean write, bit extflag, bits(4) debugmoe, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><ins>AArch32.CreateFaultRecord</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a>(<del>());

    match = FALSE;
    ispriv = </del><a href="shared_pseudocode.html#AArch32.AccessIsPrivileged.1" title="function: boolean AArch32.AccessIsPrivileged(AccType acctype)"><del>AArch32.AccessIsPrivileged</del></a><del>(acctype);

    for i = 0 to </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(DBGDIDR.WRPs)
        match = match || </del><a href="shared_pseudocode.html#AArch32.WatchpointMatch.5" title="function: boolean AArch32.WatchpointMatch(integer n, bits(32) vaddress, integer size, boolean ispriv, boolean iswrite)"><del>AArch32.WatchpointMatch</del></a><del>(i, vaddress, size, ispriv, iswrite);

    if match &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.HaltOnBreakpointOrWatchpoint.0" title="function: boolean HaltOnBreakpointOrWatchpoint()"><del>HaltOnBreakpointOrWatchpoint</del></a><del>() then
        reason = </del><a href="shared_pseudocode.html#DebugHalt_Watchpoint" title="constant bits(6) DebugHalt_Watchpoint = '101011'"><del>DebugHalt_Watchpoint</del></a><del>;
        </del><a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)"><del>Halt</del></a><del>(reason);
    elsif match &amp;&amp; DBGDSCRext.MDBGen == '1' &amp;&amp; </del><a href="shared_pseudocode.html#AArch32.GenerateDebugExceptions.0" title="function: boolean AArch32.GenerateDebugExceptions()"><del>AArch32.GenerateDebugExceptions</del></a><del>() then
        debugmoe = </del><a href="shared_pseudocode.html#DebugException_Watchpoint" title="constant bits(4) DebugException_Watchpoint = '1010'"><del>DebugException_Watchpoint</del></a><del>;
        return </del><a href="shared_pseudocode.html#AArch32.DebugFault.3" title="function: FaultRecord AArch32.DebugFault(AccType acctype, boolean iswrite, bits(4) debugmoe)"><del>AArch32.DebugFault</del></a><del>(acctype, iswrite, debugmoe);
    else
        return </del><a href="shared_pseudocode.html#AArch32.NoFault.0" title="function: FaultRecord AArch32.NoFault()"><del>AArch32.NoFault</del></a><a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_Translation</ins></a><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><ins>, ipaddress,  domain, level, acctype, iswrite,
                                     extflag, debugmoe, errortype, secondstage, s2fs1walk);</ins><del>();</del></p></div><div class="ps" psname="aarch32.translation.translation.AArch32.FirstStageTranslate"><a id="aarch32.translation.translation.AArch32.FirstStageTranslate" name="aarch32.translation.translation.AArch32.FirstStageTranslate"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/<ins>translation</ins><del>faults</del>/<ins>AArch32.FirstStageTranslate</ins><del>AArch32.AccessFlagFault</del></h3><p class="pseudocode"><ins>// AArch32.FirstStageTranslate()
// =============================
// Perform a stage 1 translation walk. The function used by Address Translation operations is
// similar except it uses the translation regime specified for the instruction.
</ins><del>// AArch32.AccessFlagFault()
// =========================
</del>
<ins>AddressDescriptor</ins><del>FaultRecord</del> <a id="AArch32.FirstStageTranslate.5" name="AArch32.FirstStageTranslate.5"></a><ins>AArch32.FirstStageTranslate(bits(32) vaddress,</ins><del>AArch32.AccessFlagFault(bits(40) ipaddress, bits(4) domain, integer level,</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType</a> <ins>acctype, boolean iswrite,
                                              boolean wasaligned, integer size)
</ins><del>acctype, boolean iswrite, boolean secondstage,
                                    boolean s2fs1walk)
</del>
<ins>    if PSTATE.EL ==</ins><del>    extflag = bit UNKNOWN;
    debugmoe = bits(4) UNKNOWN;
    errortype = bits(2) UNKNOWN;
    return</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#AArch32.CreateFaultRecord.11" title="function: FaultRecord AArch32.CreateFaultRecord(Fault type, bits(40) ipaddress,   bits(4) domain, integer level, AccType acctype, boolean write, bit extflag, bits(4) debugmoe, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><del>AArch32.CreateFaultRecord</del></a> <ins>then
        s1_enabled = HSCTLR.M == '1';
    elsif</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_AccessFlag</del></a><ins>() then
        tge = (if </ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) then HCR.TGE else HCR_EL2.TGE);
        dc = (if </ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) then HCR.DC else HCR_EL2.DC);
        s1_enabled = tge == '0' &amp;&amp; dc == '0' &amp;&amp; SCTLR.M == '1';
    else
        s1_enabled = SCTLR.M == '1';

    ipaddress = bits(40) UNKNOWN;
    secondstage = FALSE;
    s2fs1walk = FALSE;

    if s1_enabled then                         // First stage enabled
        use_long_descriptor_format = PSTATE.EL == </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins> || TTBCR.EAE == '1';
        if use_long_descriptor_format then
            S1 = </ins><a href="shared_pseudocode.html#AArch32.TranslationTableWalkLD.7" title="function: TLBRecord AArch32.TranslationTableWalkLD(bits(40) ipaddress, bits(32) vaddress, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk, integer size)"><ins>AArch32.TranslationTableWalkLD</ins></a><ins>(ipaddress, vaddress, acctype, iswrite, secondstage,
                                                s2fs1walk, size);
            permissioncheck = TRUE;  domaincheck = FALSE;
        else
            S1 = </ins><a href="shared_pseudocode.html#AArch32.TranslationTableWalkSD.4" title="function: TLBRecord AArch32.TranslationTableWalkSD(bits(32) vaddress, AccType acctype, boolean iswrite, integer size)"><ins>AArch32.TranslationTableWalkSD</ins></a><ins>(vaddress, acctype, iswrite, size);
            permissioncheck = TRUE;  domaincheck = TRUE;
    else
        S1 = </ins><a href="shared_pseudocode.html#AArch32.TranslateAddressS1Off.3" title="function: TLBRecord AArch32.TranslateAddressS1Off(bits(32) vaddress, AccType acctype, boolean iswrite)"><ins>AArch32.TranslateAddressS1Off</ins></a><ins>(vaddress, acctype, iswrite);
        permissioncheck = FALSE;  domaincheck = FALSE;
        if </ins><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>() &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.HaveTrapLoadStoreMultipleDeviceExt.0" title="function: boolean HaveTrapLoadStoreMultipleDeviceExt()"><ins>HaveTrapLoadStoreMultipleDeviceExt</ins></a><ins>() &amp;&amp; </ins><a href="shared_pseudocode.html#AArch32.ExecutingLSMInstr.0" title="function: boolean AArch32.ExecutingLSMInstr()"><ins>AArch32.ExecutingLSMInstr</ins></a><ins>() then
            if S1.addrdesc.memattrs.type == </ins><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Device</ins></a><ins> &amp;&amp; S1.addrdesc.memattrs.device != </ins><a href="shared_pseudocode.html#DeviceType_GRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType_GRE</ins></a><ins> then
                nTLSMD = if </ins><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><ins>() == </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins> then HSCTLR.nTLSMD else SCTLR.nTLSMD;
                if nTLSMD == '0' then
                    S1.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch32.AlignmentFault.3" title="function: FaultRecord AArch32.AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)"><ins>AArch32.AlignmentFault</ins></a><ins>(acctype, iswrite, secondstage);

    // Check for unaligned data accesses to Device memory
    if ((!wasaligned &amp;&amp; acctype != </ins><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><ins>) || (acctype == </ins><a href="shared_pseudocode.html#AccType_DCZVA" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_DCZVA</ins></a><ins>))
        &amp;&amp; S1.addrdesc.memattrs.type == </ins><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Device</ins></a><ins> &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><ins>(S1.addrdesc) then
        S1.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch32.AlignmentFault.3" title="function: FaultRecord AArch32.AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)"><ins>AArch32.AlignmentFault</ins></a><ins>(acctype, iswrite, secondstage);
    if !</ins><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><ins>(S1.addrdesc) &amp;&amp; domaincheck then
        (permissioncheck, abort) = </ins><a href="shared_pseudocode.html#AArch32.CheckDomain.5" title="function: (boolean, FaultRecord) AArch32.CheckDomain(bits(4) domain, bits(32) vaddress, integer level, AccType acctype, boolean iswrite)"><ins>AArch32.CheckDomain</ins></a><ins>(S1.domain, vaddress, S1.level, acctype,
                                                       iswrite);
        S1.addrdesc.fault = abort;

    if !</ins><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><ins>(S1.addrdesc) &amp;&amp; permissioncheck then
        S1.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch32.CheckPermission.7" title="function: FaultRecord AArch32.CheckPermission(Permissions perms, bits(32) vaddress, integer level, bits(4) domain, bit NS, AccType acctype, boolean iswrite)"><ins>AArch32.CheckPermission</ins></a><ins>(S1.perms, vaddress, S1.level,
                                                    S1.domain, S1.addrdesc.paddress.NS,
                                                    acctype, iswrite);

    // Check for instruction fetches from Device memory not marked as execute-never. If there has
    // not been a Permission Fault then the memory is not marked execute-never.
    if (!</ins><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><ins>(S1.addrdesc) &amp;&amp; S1.addrdesc.memattrs.type == </ins><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Device</ins></a><ins> &amp;&amp;
        acctype == </ins><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><ins>) then
        S1.addrdesc = </ins><a href="shared_pseudocode.html#AArch32.InstructionDevice.9" title="function: AddressDescriptor AArch32.InstructionDevice(AddressDescriptor addrdesc, bits(32) vaddress, bits(40) ipaddress, integer level,  bits(4) domain, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><ins>AArch32.InstructionDevice</ins></a><ins>(S1.addrdesc, vaddress, ipaddress, S1.level,
                                                S1.domain, acctype, iswrite,
                                                secondstage, s2fs1walk);

    return S1.addrdesc;</ins><del>, ipaddress,  domain, level, acctype, iswrite,
                                     extflag, debugmoe, errortype, secondstage, s2fs1walk);</del></p></div><div class="ps" psname="aarch32.translation.translation.AArch32.FullTranslate"><a id="aarch32.translation.translation.AArch32.FullTranslate" name="aarch32.translation.translation.AArch32.FullTranslate"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/<ins>translation</ins><del>faults</del>/<ins>AArch32.FullTranslate</ins><del>AArch32.AddressSizeFault</del></h3><p class="pseudocode"><ins>// AArch32.FullTranslate()
// =======================
// Perform both stage 1 and stage 2 translation walks for the current translation regime. The
// function used by Address Translation operations is similar except it uses the translation
// regime specified for the instruction.
</ins><del>// AArch32.AddressSizeFault()
// ==========================
</del>
<ins>AddressDescriptor</ins><del>FaultRecord</del> <a id="AArch32.FullTranslate.5" name="AArch32.FullTranslate.5"></a><ins>AArch32.FullTranslate(bits(32) vaddress,</ins><del>AArch32.AddressSizeFault(bits(40) ipaddress, bits(4) domain, integer level,</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType</a> <ins>acctype, boolean iswrite,
                                        boolean wasaligned, integer size)
</ins><del>acctype, boolean iswrite, boolean secondstage,
                                     boolean s2fs1walk)
</del>
<ins>    // First Stage Translation
    S1 =</ins><del>    extflag = bit UNKNOWN;
    debugmoe = bits(4) UNKNOWN;
    errortype = bits(2) UNKNOWN;
    return</del> <a href="shared_pseudocode.html#AArch32.FirstStageTranslate.5" title="function: AddressDescriptor AArch32.FirstStageTranslate(bits(32) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><ins>AArch32.FirstStageTranslate</ins></a><a href="shared_pseudocode.html#AArch32.CreateFaultRecord.11" title="function: FaultRecord AArch32.CreateFaultRecord(Fault type, bits(40) ipaddress,   bits(4) domain, integer level, AccType acctype, boolean write, bit extflag, bits(4) debugmoe, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><del>AArch32.CreateFaultRecord</del></a><ins>(vaddress, acctype, iswrite, wasaligned, size);
    if !</ins><del>(</del><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_AddressSize</del></a><ins>(S1) &amp;&amp; !(</ins><a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()"><ins>HaveNV2Ext</ins></a><ins>() &amp;&amp; acctype == </ins><a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NV2REGISTER</ins></a><ins>) &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.HasS2Translation.0" title="function: boolean HasS2Translation()"><ins>HasS2Translation</ins></a><ins>() then
        s2fs1walk = FALSE;
        result = </ins><a href="shared_pseudocode.html#AArch32.SecondStageTranslate.7" title="function: AddressDescriptor AArch32.SecondStageTranslate(AddressDescriptor S1, bits(32) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, boolean s2fs1walk, integer size)"><ins>AArch32.SecondStageTranslate</ins></a><ins>(S1, vaddress, acctype, iswrite, wasaligned, s2fs1walk,
                                              size);
    else
        result = S1;

    return result;</ins><del>, ipaddress,  domain, level, acctype, iswrite,
                                     extflag, debugmoe, errortype, secondstage, s2fs1walk);</del></p></div><div class="ps" psname="aarch32.translation.translation.AArch32.SecondStageTranslate"><a id="aarch32.translation.translation.AArch32.SecondStageTranslate" name="aarch32.translation.translation.AArch32.SecondStageTranslate"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/<ins>translation</ins><del>faults</del>/<ins>AArch32.SecondStageTranslate</ins><del>AArch32.AlignmentFault</del></h3><p class="pseudocode"><ins>// AArch32.SecondStageTranslate()
// ==============================
// Perform a stage 2 translation walk. The function used by Address Translation operations is
// similar except it uses the translation regime specified for the instruction.
</ins><del>// AArch32.AlignmentFault()
// ========================
</del>
<ins>AddressDescriptor</ins><del>FaultRecord</del> <a id="AArch32.SecondStageTranslate.7" name="AArch32.SecondStageTranslate.7"></a><ins>AArch32.SecondStageTranslate(</ins><del>AArch32.AlignmentFault(</del><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><ins>AddressDescriptor</ins></a><ins> S1, bits(32) vaddress,
                                               </ins><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType</a> <ins>acctype, boolean iswrite, boolean wasaligned,
                                               boolean s2fs1walk, integer size)
    assert</ins><del>acctype, boolean iswrite, boolean secondstage)

    ipaddress = bits(40) UNKNOWN;
    domain = bits(4) UNKNOWN;
    level = integer UNKNOWN;
    extflag = bit UNKNOWN;
    debugmoe = bits(4) UNKNOWN;
    errortype = bits(2) UNKNOWN;
    s2fs1walk = boolean UNKNOWN;

    return</del> <a href="shared_pseudocode.html#impl-shared.HasS2Translation.0" title="function: boolean HasS2Translation()"><ins>HasS2Translation</ins></a><a href="shared_pseudocode.html#AArch32.CreateFaultRecord.11" title="function: FaultRecord AArch32.CreateFaultRecord(Fault type, bits(40) ipaddress,   bits(4) domain, integer level, AccType acctype, boolean write, bit extflag, bits(4) debugmoe, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><del>AArch32.CreateFaultRecord</del></a><ins>();
    assert</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_Alignment</del></a><ins>(S1.paddress.address&lt;47:40>);
    hwupdatewalk = FALSE;
    if !</ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) then
        return </ins><a href="shared_pseudocode.html#AArch64.SecondStageTranslate.8" title="function: AddressDescriptor AArch64.SecondStageTranslate(AddressDescriptor S1, bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, boolean s2fs1walk, integer size, boolean hwupdatewalk)"><ins>AArch64.SecondStageTranslate</ins></a><ins>(S1, </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><ins>ZeroExtend</ins></a><ins>(vaddress, 64), acctype, iswrite,
                                            wasaligned, s2fs1walk, size, hwupdatewalk);

    s2_enabled = HCR.VM == '1' || HCR.DC == '1';
    secondstage = TRUE;

    if s2_enabled then                        // Second stage enabled
        ipaddress = S1.paddress.address&lt;39:0>;
        S2 = </ins><a href="shared_pseudocode.html#AArch32.TranslationTableWalkLD.7" title="function: TLBRecord AArch32.TranslationTableWalkLD(bits(40) ipaddress, bits(32) vaddress, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk, integer size)"><ins>AArch32.TranslationTableWalkLD</ins></a><ins>(ipaddress, vaddress, acctype, iswrite, secondstage,
                                            s2fs1walk, size);

        // Check for unaligned data accesses to Device memory
        if ((!wasaligned &amp;&amp; acctype != </ins><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><ins>) || (acctype == </ins><a href="shared_pseudocode.html#AccType_DCZVA" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_DCZVA</ins></a><ins>))
            &amp;&amp; S2.addrdesc.memattrs.type == </ins><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Device</ins></a><ins> &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><ins>(S2.addrdesc) then
            S2.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch32.AlignmentFault.3" title="function: FaultRecord AArch32.AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)"><ins>AArch32.AlignmentFault</ins></a><ins>(acctype, iswrite, secondstage);

        // Check for permissions on Stage2 translations
        if !</ins><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><ins>(S2.addrdesc) then
            S2.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch32.CheckS2Permission.7" title="function: FaultRecord AArch32.CheckS2Permission(Permissions perms, bits(32) vaddress, bits(40) ipaddress, integer level, AccType acctype, boolean iswrite, boolean s2fs1walk)"><ins>AArch32.CheckS2Permission</ins></a><ins>(S2.perms, vaddress, ipaddress, S2.level,
                                                          acctype, iswrite, s2fs1walk);

        // Check for instruction fetches from Device memory not marked as execute-never. As there
        // has not been a Permission Fault then the memory is not marked execute-never.
        if (!s2fs1walk &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><ins>(S2.addrdesc) &amp;&amp; S2.addrdesc.memattrs.type == </ins><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Device</ins></a><ins> &amp;&amp;
            acctype == </ins><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><ins>) then
            domain = bits(4) UNKNOWN;
            S2.addrdesc = </ins><a href="shared_pseudocode.html#AArch32.InstructionDevice.9" title="function: AddressDescriptor AArch32.InstructionDevice(AddressDescriptor addrdesc, bits(32) vaddress, bits(40) ipaddress, integer level,  bits(4) domain, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><ins>AArch32.InstructionDevice</ins></a><ins>(S2.addrdesc, vaddress, ipaddress, S2.level,
                                                    domain, acctype, iswrite,
                                                    secondstage, s2fs1walk);

        // Check for protected table walk
        if (s2fs1walk &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><ins>(S2.addrdesc) &amp;&amp; HCR.PTW == '1' &amp;&amp;
            S2.addrdesc.memattrs.type == </ins><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Device</ins></a><ins>) then
            domain = bits(4) UNKNOWN;
            S2.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch32.PermissionFault.7" title="function: FaultRecord AArch32.PermissionFault(bits(40) ipaddress, bits(4) domain, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><ins>AArch32.PermissionFault</ins></a><ins>(ipaddress,   domain, S2.level, acctype,
                                                        iswrite, secondstage, s2fs1walk);

        result = </ins><a href="shared_pseudocode.html#impl-shared.CombineS1S2Desc.2" title="function: AddressDescriptor CombineS1S2Desc(AddressDescriptor s1desc, AddressDescriptor s2desc)"><ins>CombineS1S2Desc</ins></a><ins>(S1, S2.addrdesc);
    else
        result = S1;

    return result;</ins><del>, ipaddress,  domain, level, acctype, iswrite,
                                     extflag, debugmoe, errortype, secondstage, s2fs1walk);</del></p></div><div class="ps" psname="aarch32.translation.translation.AArch32.SecondStageWalk"><a id="aarch32.translation.translation.AArch32.SecondStageWalk" name="aarch32.translation.translation.AArch32.SecondStageWalk"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/<ins>translation</ins><del>faults</del>/<ins>AArch32.SecondStageWalk</ins><del>AArch32.AsynchExternalAbort</del></h3><p class="pseudocode"><ins>// AArch32.SecondStageWalk()
// =========================
// Perform a stage 2 translation on a stage 1 translation page table walk access.
</ins><del>// AArch32.AsynchExternalAbort()
// =============================
// Wrapper function for asynchronous external aborts
</del>
<ins>AddressDescriptor</ins><del>FaultRecord</del> <a id="AArch32.SecondStageWalk.5" name="AArch32.SecondStageWalk.5"></a><ins>AArch32.SecondStageWalk(</ins><del>AArch32.AsynchExternalAbort(boolean parity, bits(2) errortype, bit extflag)

    type = if parity then</del><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><ins>AddressDescriptor</ins></a><a href="shared_pseudocode.html#Fault_AsyncParity" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_AsyncParity</del></a> <ins>S1, bits(32) vaddress,</ins><del>else</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_AsyncExternal</del></a> <ins>acctype,
                                          boolean iswrite, integer size)

    assert</ins><del>;
    ipaddress = bits(40) UNKNOWN;
    domain = bits(4) UNKNOWN;
    level = integer UNKNOWN;
    acctype =</del> <a href="shared_pseudocode.html#impl-shared.HasS2Translation.0" title="function: boolean HasS2Translation()"><ins>HasS2Translation</ins></a><a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NORMAL</del></a><ins>();
</ins><del>;
    iswrite = boolean UNKNOWN;
    debugmoe = bits(4) UNKNOWN;
    secondstage = FALSE;
    s2fs1walk = FALSE;
</del>
<ins>    s2fs1walk = TRUE;
    wasaligned = TRUE;
</ins>    return <a href="shared_pseudocode.html#AArch32.SecondStageTranslate.7" title="function: AddressDescriptor AArch32.SecondStageTranslate(AddressDescriptor S1, bits(32) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, boolean s2fs1walk, integer size)"><ins>AArch32.SecondStageTranslate</ins></a><a href="shared_pseudocode.html#AArch32.CreateFaultRecord.11" title="function: FaultRecord AArch32.CreateFaultRecord(Fault type, bits(40) ipaddress,   bits(4) domain, integer level, AccType acctype, boolean write, bit extflag, bits(4) debugmoe, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><del>AArch32.CreateFaultRecord</del></a><ins>(S1, vaddress, acctype, iswrite, wasaligned, s2fs1walk,
                                        size);</ins><del>(type, ipaddress,  domain, level, acctype, iswrite, extflag,
                                     debugmoe,  errortype, secondstage, s2fs1walk);</del></p></div><div class="ps" psname="aarch32.translation.translation.AArch32.TranslateAddress"><a id="aarch32.translation.translation.AArch32.TranslateAddress" name="aarch32.translation.translation.AArch32.TranslateAddress"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/<ins>translation</ins><del>faults</del>/<ins>AArch32.TranslateAddress</ins><del>AArch32.DebugFault</del></h3><p class="pseudocode"><ins>// AArch32.TranslateAddress()
// ==========================
// Main entry point for translating an address
</ins><del>// AArch32.DebugFault()
// ====================
</del>
<ins>AddressDescriptor</ins><del>FaultRecord</del> <a id="AArch32.TranslateAddress.5" name="AArch32.TranslateAddress.5"></a><ins>AArch32.TranslateAddress(bits(32) vaddress,</ins><del>AArch32.DebugFault(</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType</a> <ins>acctype, boolean iswrite,
                                           boolean wasaligned, integer size)
</ins><del>acctype, boolean iswrite, bits(4) debugmoe)
</del>
<ins>    if !</ins><del>    ipaddress = bits(40) UNKNOWN;
    domain = bits(4) UNKNOWN;
    errortype = bits(2) UNKNOWN;
    level = integer UNKNOWN;
    extflag = bit UNKNOWN;
    secondstage = FALSE;
    s2fs1walk = FALSE;

    return</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><a href="shared_pseudocode.html#AArch32.CreateFaultRecord.11" title="function: FaultRecord AArch32.CreateFaultRecord(Fault type, bits(40) ipaddress,   bits(4) domain, integer level, AccType acctype, boolean write, bit extflag, bits(4) debugmoe, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><del>AArch32.CreateFaultRecord</del></a>(<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><a href="shared_pseudocode.html#Fault_Debug" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_Debug</del></a><ins>()) then
        return </ins><a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><ins>AArch64.TranslateAddress</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><ins>ZeroExtend</ins></a><ins>(vaddress, 64), acctype, iswrite, wasaligned,
                                        size);
    result = </ins><a href="shared_pseudocode.html#AArch32.FullTranslate.5" title="function: AddressDescriptor AArch32.FullTranslate(bits(32) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><ins>AArch32.FullTranslate</ins></a><ins>(vaddress, acctype, iswrite, wasaligned, size);

    if !(acctype IN {</ins><a href="shared_pseudocode.html#AccType_PTW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_PTW</ins></a><ins>, </ins><a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IC</ins></a><ins>, </ins><a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_AT</ins></a><ins>}) &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><ins>(result) then
        result.fault = </ins><a href="shared_pseudocode.html#AArch32.CheckDebug.4" title="function: FaultRecord AArch32.CheckDebug(bits(32) vaddress, AccType acctype, boolean iswrite, integer size)"><ins>AArch32.CheckDebug</ins></a><ins>(vaddress, acctype, iswrite, size);

    // Update virtual address for abort functions
    result.vaddress = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(vaddress);

    return result;</ins><del>, ipaddress,  domain, level, acctype, iswrite,
                                     extflag, debugmoe, errortype, secondstage, s2fs1walk);</del></p></div><div class="ps" psname="aarch32.translation.walk.AArch32.TranslationTableWalkLD"><a id="aarch32.translation.walk.AArch32.TranslationTableWalkLD" name="aarch32.translation.walk.AArch32.TranslationTableWalkLD"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/<ins>walk</ins><del>faults</del>/<ins>AArch32.TranslationTableWalkLD</ins><del>AArch32.DomainFault</del></h3><p class="pseudocode"><ins>// AArch32.TranslationTableWalkLD()
// ================================
// Returns a result of a translation table walk using the Long-descriptor format
//
// Implementations might cache information from memory in any number of non-coherent TLB
// caching structures, and so avoid memory accesses that have been expressed in this
// pseudocode. The use of such TLBs is not expressed in this pseudocode.
</ins><del>// AArch32.DomainFault()
// =====================
</del>
<ins>TLBRecord</ins><del>FaultRecord</del> <a id="AArch32.TranslationTableWalkLD.7" name="AArch32.TranslationTableWalkLD.7"></a><ins>AArch32.TranslationTableWalkLD(bits(40) ipaddress, bits(32) vaddress,</ins><del>AArch32.DomainFault(bits(4) domain, integer level,</del>
                                         <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType</a> <ins>acctype, boolean iswrite, boolean secondstage,
                                         boolean s2fs1walk, integer size)
    if !secondstage then
        assert</ins><del>acctype, boolean iswrite)

    ipaddress = bits(40) UNKNOWN;
    extflag = bit UNKNOWN;
    debugmoe = bits(4) UNKNOWN;
    errortype = bits(2) UNKNOWN;
    secondstage = FALSE;
    s2fs1walk = FALSE;

    return</del> <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><a href="shared_pseudocode.html#AArch32.CreateFaultRecord.11" title="function: FaultRecord AArch32.CreateFaultRecord(Fault type, bits(40) ipaddress,   bits(4) domain, integer level, AccType acctype, boolean write, bit extflag, bits(4) debugmoe, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><del>AArch32.CreateFaultRecord</del></a>(<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><a href="shared_pseudocode.html#Fault_Domain" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_Domain</del></a><ins>());
    else
        assert </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>() &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.HasS2Translation.0" title="function: boolean HasS2Translation()"><ins>HasS2Translation</ins></a><ins>();

    </ins><a href="shared_pseudocode.html#TLBRecord" title="type TLBRecord is ( Permissions perms, bit nG, bits(4) domain, bit GP, boolean contiguous, integer level, integer blocksize, DescriptorUpdate descupdate, bit CnP, AddressDescriptor addrdesc )"><ins>TLBRecord</ins></a><ins> result;
    </ins><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><ins>AddressDescriptor</ins></a><ins> descaddr;
    bits(64) baseregister;
    bits(40) inputaddr;        // Input Address is 'vaddress' for stage 1, 'ipaddress' for stage 2

    domain = bits(4) UNKNOWN;

    descaddr.memattrs.type = </ins><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Normal</ins></a><ins>;

    // Fixed parameters for the page table walk:
    //  grainsize = Log2(Size of Table)         - Size of Table is 4KB in AArch32
    //  stride = Log2(Address per Level)        - Bits of address consumed at each level
    constant integer grainsize = 12;                    // Log2(4KB page size)
    constant integer stride = grainsize - 3;            // Log2(page size / 8 bytes)

    // Derived parameters for the page table walk:
    //  inputsize = Log2(Size of Input Address) - Input Address size in bits
    //  level = Level to start walk from
    // This means that the number of levels after start level = 3-level

    if !secondstage then
        // First stage translation
        inputaddr = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(vaddress);
        el = </ins><a href="shared_pseudocode.html#AArch32.AccessUsesEL.1" title="function: bits(2) AArch32.AccessUsesEL(AccType acctype)"><ins>AArch32.AccessUsesEL</ins></a><ins>(acctype);
        if el == </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins> then
            inputsize = 32 - </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(HTCR.T0SZ);
            basefound = inputsize == 32 || </ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(inputaddr&lt;31:inputsize>);
            disabled = FALSE;
            baseregister = HTTBR;
            descaddr.memattrs = </ins><a href="shared_pseudocode.html#impl-shared.WalkAttrDecode.4" title="function: MemoryAttributes WalkAttrDecode(bits(2) SH, bits(2) ORGN, bits(2) IRGN, boolean secondstage)"><ins>WalkAttrDecode</ins></a><ins>(HTCR.SH0, HTCR.ORGN0, HTCR.IRGN0, secondstage);
            reversedescriptors = HSCTLR.EE == '1';
            lookupsecure = FALSE;
            singlepriv = TRUE;
            hierattrsdisabled = </ins><a href="shared_pseudocode.html#AArch32.HaveHPDExt.0" title="function: boolean AArch32.HaveHPDExt()"><ins>AArch32.HaveHPDExt</ins></a><ins>() &amp;&amp; HTCR.HPD == '1';
        else
            basefound = FALSE;
            disabled = FALSE;
            t0size = </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(TTBCR.T0SZ);
            if t0size == 0 || </ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(inputaddr&lt;31:(32-t0size)>) then
                inputsize = 32 - t0size;
                basefound = TRUE;
                baseregister = TTBR0;
                descaddr.memattrs = </ins><a href="shared_pseudocode.html#impl-shared.WalkAttrDecode.4" title="function: MemoryAttributes WalkAttrDecode(bits(2) SH, bits(2) ORGN, bits(2) IRGN, boolean secondstage)"><ins>WalkAttrDecode</ins></a><ins>(TTBCR.SH0, TTBCR.ORGN0, TTBCR.IRGN0, secondstage);
                hierattrsdisabled = </ins><a href="shared_pseudocode.html#AArch32.HaveHPDExt.0" title="function: boolean AArch32.HaveHPDExt()"><ins>AArch32.HaveHPDExt</ins></a><ins>() &amp;&amp; TTBCR.T2E == '1' &amp;&amp;  TTBCR2.HPD0 == '1';
            t1size = </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(TTBCR.T1SZ);
            if (t1size == 0 &amp;&amp; !basefound) || (t1size > 0 &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)"><ins>IsOnes</ins></a><ins>(inputaddr&lt;31:(32-t1size)>)) then
                inputsize = 32 - t1size;
                basefound = TRUE;
                baseregister = TTBR1;
                descaddr.memattrs = </ins><a href="shared_pseudocode.html#impl-shared.WalkAttrDecode.4" title="function: MemoryAttributes WalkAttrDecode(bits(2) SH, bits(2) ORGN, bits(2) IRGN, boolean secondstage)"><ins>WalkAttrDecode</ins></a><ins>(TTBCR.SH1, TTBCR.ORGN1, TTBCR.IRGN1, secondstage);
                hierattrsdisabled = </ins><a href="shared_pseudocode.html#AArch32.HaveHPDExt.0" title="function: boolean AArch32.HaveHPDExt()"><ins>AArch32.HaveHPDExt</ins></a><ins>() &amp;&amp; TTBCR.T2E == '1' &amp;&amp;  TTBCR2.HPD1 == '1';
            reversedescriptors = SCTLR.EE == '1';
            lookupsecure = </ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>();
            singlepriv = FALSE;
        // The starting level is the number of strides needed to consume the input address
        level = 4 - </ins><a href="shared_pseudocode.html#impl-shared.RoundUp.1" title="function: integer RoundUp(real x)"><ins>RoundUp</ins></a><ins>(Real(inputsize - grainsize) / Real(stride));

    else
        // Second stage translation
        inputaddr = ipaddress;
        inputsize = 32 - </ins><a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)"><ins>SInt</ins></a><ins>(VTCR.T0SZ);
        // VTCR.S must match VTCR.T0SZ[3]
        if VTCR.S != VTCR.T0SZ&lt;3> then
            (-, inputsize) = </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableInteger.3" title="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high, Unpredictable which)"><ins>ConstrainUnpredictableInteger</ins></a><ins>(32-7, 32+8, </ins><a href="shared_pseudocode.html#Unpredictable_RESVTCRS" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESVTCRS</ins></a><ins>);
        basefound = inputsize == 40 || </ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(inputaddr&lt;39:inputsize>);
        disabled = FALSE;
        descaddr.memattrs = </ins><a href="shared_pseudocode.html#impl-shared.WalkAttrDecode.4" title="function: MemoryAttributes WalkAttrDecode(bits(2) SH, bits(2) ORGN, bits(2) IRGN, boolean secondstage)"><ins>WalkAttrDecode</ins></a><ins>(VTCR.SH0, VTCR.ORGN0, VTCR.IRGN0, secondstage);
        reversedescriptors = HSCTLR.EE == '1';
        singlepriv = TRUE;

        lookupsecure = FALSE;
        baseregister = VTTBR;
        startlevel = </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(VTCR.SL0);
        level = 2 - startlevel;
        if level &lt;= 0 then basefound = FALSE;

        // Number of entries in the starting level table =
        //     (Size of Input Address)/((Address per level)^(Num levels remaining)*(Size of Table))
        startsizecheck = inputsize - ((3 - level)*stride + grainsize); // Log2(Num of entries)

        // Check for starting level table with fewer than 2 entries or longer than 16 pages.
        // Lower bound check is:  startsizecheck &lt; Log2(2 entries)
        //   That is, VTCR.SL0 == '00' and SInt(VTCR.T0SZ) > 1, Size of Input Address &lt; 2^31 bytes
        // Upper bound check is:  startsizecheck > Log2(pagesize/8*16)
        //   That is, VTCR.SL0 == '01' and SInt(VTCR.T0SZ) &lt; -2, Size of Input Address > 2^34 bytes
        if startsizecheck &lt; 1 || startsizecheck > stride + 4 then basefound = FALSE;

    if !basefound || disabled then
        level = 1;           // AArch64 reports this as a level 0 fault
        result.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch32.TranslationFault.7" title="function: FaultRecord AArch32.TranslationFault(bits(40) ipaddress,  bits(4) domain, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><ins>AArch32.TranslationFault</ins></a><ins>(ipaddress,   domain, level, acctype, iswrite,
                                                         secondstage, s2fs1walk);
        return result;

    if !</ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(baseregister&lt;47:40>) then
        level = 0;
        result.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch32.AddressSizeFault.7" title="function: FaultRecord AArch32.AddressSizeFault(bits(40) ipaddress, bits(4) domain, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><ins>AArch32.AddressSizeFault</ins></a><ins>(ipaddress,  domain, level, acctype, iswrite,
                                                         secondstage, s2fs1walk);
        return result;

    // Bottom bound of the Base address is:
    //     Log2(8 bytes per entry)+Log2(Number of entries in starting level table)
    // Number of entries in starting level table =
    //     (Size of Input Address)/((Address per level)^(Num levels remaining)*(Size of Table))
    baselowerbound = 3 + inputsize - ((3-level)*stride + grainsize);  // Log2(Num of entries*8)
    baseaddress = baseregister&lt;39:baselowerbound>:</ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(baselowerbound);

    ns_table = if lookupsecure then '0' else '1';
    ap_table = '00';
    xn_table = '0';
    pxn_table = '0';

    addrselecttop = inputsize - 1;

    repeat
        addrselectbottom = (3-level)*stride + grainsize;

        bits(40) index = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(inputaddr&lt;addrselecttop:addrselectbottom>:'000');
        descaddr.paddress.address = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(baseaddress OR index);
        descaddr.paddress.NS = ns_table;

        // If there are two stages of translation, then the first stage table walk addresses
        // are themselves subject to translation
        if secondstage || !</ins><a href="shared_pseudocode.html#impl-shared.HasS2Translation.0" title="function: boolean HasS2Translation()"><ins>HasS2Translation</ins></a><ins>() || (</ins><a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()"><ins>HaveNV2Ext</ins></a><ins>() &amp;&amp; acctype == </ins><a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NV2REGISTER</ins></a><ins>) then
            descaddr2 = descaddr;
        else
            descaddr2 = </ins><a href="shared_pseudocode.html#AArch32.SecondStageWalk.5" title="function: AddressDescriptor AArch32.SecondStageWalk(AddressDescriptor S1, bits(32) vaddress, AccType acctype, boolean iswrite, integer size)"><ins>AArch32.SecondStageWalk</ins></a><ins>(descaddr, vaddress, acctype, iswrite, 8);
            // Check for a fault on the stage 2 walk
            if </ins><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><ins>(descaddr2) then
                result.addrdesc.fault = descaddr2.fault;
                return result;

        // Update virtual address for abort functions
        descaddr2.vaddress = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(vaddress);

        accdesc = CreateAccessDescriptorPTW(acctype, secondstage, s2fs1walk, level);
        desc = _Mem[descaddr2, 8, accdesc];

        if reversedescriptors then desc = </ins><a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)"><ins>BigEndianReverse</ins></a><ins>(desc);

        if desc&lt;0> == '0' || (desc&lt;1:0> == '01' &amp;&amp; level == 3) then
             // Fault (00), Reserved (10), or Block (01) at level 3.
            result.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch32.TranslationFault.7" title="function: FaultRecord AArch32.TranslationFault(bits(40) ipaddress,  bits(4) domain, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><ins>AArch32.TranslationFault</ins></a><ins>(ipaddress,  domain, level, acctype,
                                                             iswrite, secondstage, s2fs1walk);
            return result;

        // Valid Block, Page, or Table entry
        if desc&lt;1:0> == '01' || level == 3 then                 // Block (01) or Page (11)
            blocktranslate = TRUE;
        else                                                    // Table (11)
            if !</ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(desc&lt;47:40>) then
                result.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch32.AddressSizeFault.7" title="function: FaultRecord AArch32.AddressSizeFault(bits(40) ipaddress, bits(4) domain, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><ins>AArch32.AddressSizeFault</ins></a><ins>(ipaddress,  domain, level, acctype,
                                                                 iswrite, secondstage, s2fs1walk);
                return result;

            baseaddress = desc&lt;39:grainsize>:</ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(grainsize);
            if !secondstage then
                // Unpack the upper and lower table attributes
                ns_table    = ns_table    OR desc&lt;63>;
            if !secondstage &amp;&amp; !hierattrsdisabled then
                ap_table&lt;1> = ap_table&lt;1> OR desc&lt;62>;       // read-only

                xn_table    = xn_table    OR desc&lt;60>;
                // pxn_table and ap_table[0] apply only in EL1&amp;0 translation regimes
                if !singlepriv then
                    pxn_table   = pxn_table   OR desc&lt;59>;
                    ap_table&lt;0> = ap_table&lt;0> OR desc&lt;61>;   // privileged

            level = level + 1;
            addrselecttop = addrselectbottom - 1;
            blocktranslate = FALSE;
    until blocktranslate;

    // Check the output address is inside the supported range
    if !</ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(desc&lt;47:40>) then
        result.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch32.AddressSizeFault.7" title="function: FaultRecord AArch32.AddressSizeFault(bits(40) ipaddress, bits(4) domain, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><ins>AArch32.AddressSizeFault</ins></a><ins>(ipaddress,  domain, level, acctype,
                                                         iswrite, secondstage, s2fs1walk);
        return result;

    // Unpack the descriptor into address and upper and lower block attributes
    outputaddress = desc&lt;39:addrselectbottom>:inputaddr&lt;addrselectbottom-1:0>;
    // Check the access flag
    if desc&lt;10> == '0' then
        result.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch32.AccessFlagFault.7" title="function: FaultRecord AArch32.AccessFlagFault(bits(40) ipaddress, bits(4) domain, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><ins>AArch32.AccessFlagFault</ins></a><ins>(ipaddress,  domain, level, acctype,
                                                        iswrite, secondstage, s2fs1walk);
        return result;
    xn = desc&lt;54>;                                            // Bit[54] of the block/page descriptor holds UXN
    pxn = desc&lt;53>;                                           // Bit[53] of the block/page descriptor holds PXN
    ap = desc&lt;7:6>:'1';                                       // Bits[7:6] of the block/page descriptor hold AP[2:1]
    contiguousbit = desc&lt;52>;
    nG = desc&lt;11>;
    sh = desc&lt;9:8>;
    memattr = desc&lt;5:2>;                                      // AttrIndx and NS bit in stage 1

    result.domain = bits(4) UNKNOWN;                          // Domains not used
    result.level = level;
    result.blocksize = 2^((3-level)*stride + grainsize);

    // Stage 1 translation regimes also inherit attributes from the tables
    if !secondstage then
        result.perms.xn      = xn OR xn_table;
        result.perms.ap&lt;2>   = ap&lt;2> OR ap_table&lt;1>;          // Force read-only
        // PXN, nG and AP[1] apply only in EL1&amp;0 stage 1 translation regimes
        if !singlepriv then
            result.perms.ap&lt;1> = ap&lt;1> AND NOT(ap_table&lt;0>);  // Force privileged only
            result.perms.pxn   = pxn OR pxn_table;
            // Pages from Non-secure tables are marked non-global in Secure EL1&amp;0
            if </ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>() then
                result.nG = nG OR ns_table;
            else
                result.nG = nG;
        else
            result.perms.ap&lt;1> = '1';
            result.perms.pxn   = '0';
            result.nG          = '0';
        result.GP = desc&lt;50>;                                 // Stage 1 block or pages might be guarded
        result.perms.ap&lt;0>   = '1';
        result.addrdesc.memattrs = </ins><a href="shared_pseudocode.html#AArch32.S1AttrDecode.3" title="function: MemoryAttributes AArch32.S1AttrDecode(bits(2) SH, bits(3) attr, AccType acctype)"><ins>AArch32.S1AttrDecode</ins></a><ins>(sh, memattr&lt;2:0>, acctype);
        result.addrdesc.paddress.NS = memattr&lt;3> OR ns_table;
    else
        result.perms.ap&lt;2:1> = ap&lt;2:1>;
        result.perms.ap&lt;0>   = '1';
        result.perms.xn      = xn;
        if </ins><a href="shared_pseudocode.html#impl-shared.HaveExtendedExecuteNeverExt.0" title="function: boolean HaveExtendedExecuteNeverExt()"><ins>HaveExtendedExecuteNeverExt</ins></a><ins>() then result.perms.xxn = desc&lt;53>;
        result.perms.pxn     = '0';
        result.nG            = '0';
        if s2fs1walk then
            result.addrdesc.memattrs = </ins><a href="shared_pseudocode.html#impl-shared.S2AttrDecode.3" title="function: MemoryAttributes S2AttrDecode(bits(2) SH, bits(4) attr, AccType acctype)"><ins>S2AttrDecode</ins></a><ins>(sh, memattr, </ins><a href="shared_pseudocode.html#AccType_PTW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_PTW</ins></a><ins>);
        else
            result.addrdesc.memattrs = </ins><a href="shared_pseudocode.html#impl-shared.S2AttrDecode.3" title="function: MemoryAttributes S2AttrDecode(bits(2) SH, bits(4) attr, AccType acctype)"><ins>S2AttrDecode</ins></a><ins>(sh, memattr, acctype);
        result.addrdesc.paddress.NS = '1';

    result.addrdesc.paddress.address = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(outputaddress);
    result.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch32.NoFault.0" title="function: FaultRecord AArch32.NoFault()"><ins>AArch32.NoFault</ins></a><ins>();
    result.contiguous = contiguousbit == '1';
    if </ins><a href="shared_pseudocode.html#impl-shared.HaveCommonNotPrivateTransExt.0" title="function: boolean HaveCommonNotPrivateTransExt()"><ins>HaveCommonNotPrivateTransExt</ins></a><ins>() then result.CnP = baseregister&lt;0>;

    return result;</ins><del>, ipaddress,  domain, level, acctype, iswrite,
                                     extflag, debugmoe, errortype, secondstage, s2fs1walk);</del></p></div><div class="ps" psname="aarch32.translation.walk.AArch32.TranslationTableWalkSD"><a id="aarch32.translation.walk.AArch32.TranslationTableWalkSD" name="aarch32.translation.walk.AArch32.TranslationTableWalkSD"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/<ins>walk</ins><del>faults</del>/<ins>AArch32.TranslationTableWalkSD</ins><del>AArch32.NoFault</del></h3><p class="pseudocode"><ins>// AArch32.TranslationTableWalkSD()
// ================================
// Returns a result of a translation table walk using the Short-descriptor format
//
// Implementations might cache information from memory in any number of non-coherent TLB
// caching structures, and so avoid memory accesses that have been expressed in this
// pseudocode. The use of such TLBs is not expressed in this pseudocode.
</ins><del>// AArch32.NoFault()
// =================
</del>
<ins>TLBRecord</ins><del>FaultRecord</del> <a id="AArch32.TranslationTableWalkSD.4" name="AArch32.TranslationTableWalkSD.4"></a><ins>AArch32.TranslationTableWalkSD(bits(32) vaddress,</ins><del>AArch32.NoFault()

    ipaddress = bits(40) UNKNOWN;
    domain = bits(4) UNKNOWN;
    level = integer UNKNOWN;
    acctype =</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NORMAL</del></a> <ins>acctype, boolean iswrite,
                                         integer size)
    assert</ins><del>;
    iswrite = boolean UNKNOWN;
    extflag = bit UNKNOWN;
    debugmoe = bits(4) UNKNOWN;
    errortype = bits(2) UNKNOWN;
    secondstage = FALSE;
    s2fs1walk = FALSE;

    return</del> <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><a href="shared_pseudocode.html#AArch32.CreateFaultRecord.11" title="function: FaultRecord AArch32.CreateFaultRecord(Fault type, bits(40) ipaddress,   bits(4) domain, integer level, AccType acctype, boolean write, bit extflag, bits(4) debugmoe, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><del>AArch32.CreateFaultRecord</del></a>(<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_None</del></a><ins>());

    // This is only called when address translation is enabled
    </ins><a href="shared_pseudocode.html#TLBRecord" title="type TLBRecord is ( Permissions perms, bit nG, bits(4) domain, bit GP, boolean contiguous, integer level, integer blocksize, DescriptorUpdate descupdate, bit CnP, AddressDescriptor addrdesc )"><ins>TLBRecord</ins></a><ins>         result;
    </ins><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><ins>AddressDescriptor</ins></a><ins> l1descaddr;
    </ins><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><ins>AddressDescriptor</ins></a><ins> l2descaddr;
    bits(40)      outputaddress;

    // Variables for Abort functions
    ipaddress = bits(40) UNKNOWN;
    secondstage = FALSE;
    s2fs1walk = FALSE;
    NS = bit UNKNOWN;

    // Default setting of the domain
    domain = bits(4) UNKNOWN;

    // Determine correct Translation Table Base Register to use.
    bits(64) ttbr;
    n = </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(TTBCR.N);
    if n == 0 || </ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(vaddress&lt;31:(32-n)>) then
        ttbr = TTBR0;
        disabled = (TTBCR.PD0 == '1');
    else
        ttbr = TTBR1;
        disabled = (TTBCR.PD1 == '1');
        n = 0;  // TTBR1 translation always works like N=0 TTBR0 translation

    // Check this Translation Table Base Register is not disabled.
    if disabled then
        level = 1;
        result.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch32.TranslationFault.7" title="function: FaultRecord AArch32.TranslationFault(bits(40) ipaddress,  bits(4) domain, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><ins>AArch32.TranslationFault</ins></a><ins>(ipaddress, domain, level, acctype, iswrite,
                                                         secondstage, s2fs1walk);
        return result;

    // Obtain descriptor from initial lookup.
    l1descaddr.paddress.address = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(ttbr&lt;31:14-n>:vaddress&lt;31-n:20>:'00');
    l1descaddr.paddress.NS = if </ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>() then '0' else '1';
    IRGN = ttbr&lt;0>:ttbr&lt;6>;             // TTBR.IRGN
    RGN = ttbr&lt;4:3>;                    // TTBR.RGN
    SH = ttbr&lt;1>:ttbr&lt;5>;               // TTBR.S:TTBR.NOS
    l1descaddr.memattrs = </ins><a href="shared_pseudocode.html#impl-shared.WalkAttrDecode.4" title="function: MemoryAttributes WalkAttrDecode(bits(2) SH, bits(2) ORGN, bits(2) IRGN, boolean secondstage)"><ins>WalkAttrDecode</ins></a><ins>(SH, RGN, IRGN, secondstage);

    if !</ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) || (</ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>() &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()"><ins>IsSecureEL2Enabled</ins></a><ins>()) then
        // if only 1 stage of translation
        l1descaddr2 = l1descaddr;
    else
        l1descaddr2 = </ins><a href="shared_pseudocode.html#AArch32.SecondStageWalk.5" title="function: AddressDescriptor AArch32.SecondStageWalk(AddressDescriptor S1, bits(32) vaddress, AccType acctype, boolean iswrite, integer size)"><ins>AArch32.SecondStageWalk</ins></a><ins>(l1descaddr, vaddress, acctype, iswrite, 4);
        // Check for a fault on the stage 2 walk
        if </ins><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><ins>(l1descaddr2) then
            result.addrdesc.fault = l1descaddr2.fault;
            return result;

    // Update virtual address for abort functions
    l1descaddr2.vaddress = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(vaddress);

    accdesc = CreateAccessDescriptorPTW(acctype, secondstage, s2fs1walk, level);
    l1desc = _Mem[l1descaddr2, 4,accdesc];

    if SCTLR.EE == '1' then l1desc = </ins><a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)"><ins>BigEndianReverse</ins></a><ins>(l1desc);

    // Process descriptor from initial lookup.
    case l1desc&lt;1:0> of
        when '00'                                              // Fault, Reserved
            level = 1;
            result.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch32.TranslationFault.7" title="function: FaultRecord AArch32.TranslationFault(bits(40) ipaddress,  bits(4) domain, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><ins>AArch32.TranslationFault</ins></a><ins>(ipaddress, domain, level, acctype,
                                                             iswrite, secondstage, s2fs1walk);
            return result;

        when '01'                                              // Large page or Small page
            domain = l1desc&lt;8:5>;
            level = 2;
            pxn = l1desc&lt;2>;
            NS = l1desc&lt;3>;

            // Obtain descriptor from level 2 lookup.
            l2descaddr.paddress.address = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(l1desc&lt;31:10>:vaddress&lt;19:12>:'00');
            l2descaddr.paddress.NS = if </ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>() then '0' else '1';
            l2descaddr.memattrs = l1descaddr.memattrs;

            if !</ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) || (</ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>() &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()"><ins>IsSecureEL2Enabled</ins></a><ins>()) then
                // if only 1 stage of translation
                l2descaddr2 = l2descaddr;
            else
                l2descaddr2 = </ins><a href="shared_pseudocode.html#AArch32.SecondStageWalk.5" title="function: AddressDescriptor AArch32.SecondStageWalk(AddressDescriptor S1, bits(32) vaddress, AccType acctype, boolean iswrite, integer size)"><ins>AArch32.SecondStageWalk</ins></a><ins>(l2descaddr, vaddress, acctype, iswrite, 4);
                // Check for a fault on the stage 2 walk
                if </ins><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><ins>(l2descaddr2) then
                    result.addrdesc.fault = l2descaddr2.fault;
                    return result;

            // Update virtual address for abort functions
            l2descaddr2.vaddress = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(vaddress);

            accdesc = CreateAccessDescriptorPTW(acctype, secondstage, s2fs1walk, level);
            l2desc = _Mem[l2descaddr2, 4, accdesc];

            if SCTLR.EE == '1' then l2desc = </ins><a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)"><ins>BigEndianReverse</ins></a><ins>(l2desc);

            // Process descriptor from level 2 lookup.
            if l2desc&lt;1:0> == '00' then
                result.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch32.TranslationFault.7" title="function: FaultRecord AArch32.TranslationFault(bits(40) ipaddress,  bits(4) domain, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><ins>AArch32.TranslationFault</ins></a><ins>(ipaddress, domain, level, acctype,
                                                                 iswrite, secondstage, s2fs1walk);
                return result;

            nG = l2desc&lt;11>;
            S = l2desc&lt;10>;
            ap = l2desc&lt;9,5:4>;

            if SCTLR.AFE == '1' &amp;&amp; l2desc&lt;4> == '0' then
                // Armv8 VMSAv8-32 does not support hardware management of the Access flag.
                result.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch32.AccessFlagFault.7" title="function: FaultRecord AArch32.AccessFlagFault(bits(40) ipaddress, bits(4) domain, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><ins>AArch32.AccessFlagFault</ins></a><ins>(ipaddress, domain, level, acctype,
                                                                iswrite, secondstage, s2fs1walk);
                return result;

            if l2desc&lt;1> == '0' then                           // Large page
                xn = l2desc&lt;15>;
                tex = l2desc&lt;14:12>;
                c = l2desc&lt;3>;
                b = l2desc&lt;2>;
                blocksize = 64;
                outputaddress = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(l2desc&lt;31:16>:vaddress&lt;15:0>);
            else                                               // Small page
                tex = l2desc&lt;8:6>;
                c = l2desc&lt;3>;
                b = l2desc&lt;2>;
                xn = l2desc&lt;0>;
                blocksize = 4;
                outputaddress = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(l2desc&lt;31:12>:vaddress&lt;11:0>);

        when '1x'                                              // Section or Supersection
            NS = l1desc&lt;19>;
            nG = l1desc&lt;17>;
            S = l1desc&lt;16>;
            ap = l1desc&lt;15,11:10>;
            tex = l1desc&lt;14:12>;
            xn = l1desc&lt;4>;
            c = l1desc&lt;3>;
            b = l1desc&lt;2>;
            pxn = l1desc&lt;0>;
            level = 1;

            if SCTLR.AFE == '1' &amp;&amp; l1desc&lt;10> == '0' then
                // Armv8 VMSAv8-32 does not support hardware management of the Access flag.
                result.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch32.AccessFlagFault.7" title="function: FaultRecord AArch32.AccessFlagFault(bits(40) ipaddress, bits(4) domain, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><ins>AArch32.AccessFlagFault</ins></a><ins>(ipaddress, domain, level, acctype,
                                                                iswrite, secondstage, s2fs1walk);
                return result;

            if l1desc&lt;18> == '0' then                          // Section
                domain = l1desc&lt;8:5>;
                blocksize = 1024;
                outputaddress = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(l1desc&lt;31:20>:vaddress&lt;19:0>);
            else                                               // Supersection
                domain = '0000';
                blocksize = 16384;
                outputaddress = l1desc&lt;8:5>:l1desc&lt;23:20>:l1desc&lt;31:24>:vaddress&lt;23:0>;

    // Decode the TEX, C, B and S bits to produce the TLBRecord's memory attributes
    if SCTLR.TRE == '0' then
        if </ins><a href="shared_pseudocode.html#impl-aarch32.RemapRegsHaveResetValues.0" title="function: boolean RemapRegsHaveResetValues()"><ins>RemapRegsHaveResetValues</ins></a><ins>() then
            result.addrdesc.memattrs = </ins><a href="shared_pseudocode.html#AArch32.DefaultTEXDecode.5" title="function: MemoryAttributes AArch32.DefaultTEXDecode(bits(3) TEX, bit C, bit B, bit S, AccType acctype)"><ins>AArch32.DefaultTEXDecode</ins></a><ins>(tex, c, b, S, acctype);
        else
            result.addrdesc.memattrs = </ins><a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType type, DeviceType device, MemAttrHints inner, MemAttrHints outer, boolean tagged, boolean shareable, boolean outershareable )"><ins>MemoryAttributes</ins></a><ins> IMPLEMENTATION_DEFINED;
    else
        result.addrdesc.memattrs = </ins><a href="shared_pseudocode.html#AArch32.RemappedTEXDecode.5" title="function: MemoryAttributes AArch32.RemappedTEXDecode(bits(3) TEX, bit C, bit B, bit S, AccType acctype)"><ins>AArch32.RemappedTEXDecode</ins></a><ins>(tex, c, b, S, acctype);

    // Set the rest of the TLBRecord, try to add it to the TLB, and return it.
    result.perms.ap = ap;
    result.perms.xn = xn;
    result.perms.pxn = pxn;
    result.nG = nG;
    result.domain = domain;
    result.level = level;
    result.blocksize = blocksize;
    result.addrdesc.paddress.address = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(outputaddress);
    result.addrdesc.paddress.NS = if </ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>() then NS else '1';
    result.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch32.NoFault.0" title="function: FaultRecord AArch32.NoFault()"><ins>AArch32.NoFault</ins></a><ins>();

    return result;</ins><del>, ipaddress,  domain, level, acctype, iswrite,
                                     extflag, debugmoe, errortype, secondstage, s2fs1walk);</del></p></div><div class="ps" psname="aarch32.translation.walk.RemapRegsHaveResetValues"><a id="aarch32.translation.walk.RemapRegsHaveResetValues" name="aarch32.translation.walk.RemapRegsHaveResetValues"></a><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/<ins>walk</ins><del>faults</del>/<ins>RemapRegsHaveResetValues</ins><del>AArch32.PermissionFault</del></h3><p class="pseudocode"><ins>boolean</ins><del>// AArch32.PermissionFault()
// =========================

FaultRecord</del> <a id="impl-aarch32.RemapRegsHaveResetValues.0" name="impl-aarch32.RemapRegsHaveResetValues.0"></a><ins>RemapRegsHaveResetValues();</ins><del>AArch32.PermissionFault(bits(40) ipaddress, bits(4) domain, integer level,</del><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><del> acctype, boolean iswrite, boolean secondstage,
                                    boolean s2fs1walk)

    extflag = bit UNKNOWN;
    debugmoe = bits(4) UNKNOWN;
    errortype = bits(2) UNKNOWN;
    return </del><a href="shared_pseudocode.html#AArch32.CreateFaultRecord.11" title="function: FaultRecord AArch32.CreateFaultRecord(Fault type, bits(40) ipaddress,   bits(4) domain, integer level, AccType acctype, boolean write, bit extflag, bits(4) debugmoe, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><del>AArch32.CreateFaultRecord</del></a><del>(</del><a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_Permission</del></a><del>, ipaddress,  domain, level, acctype, iswrite,
                                     extflag, debugmoe, errortype, secondstage, s2fs1walk);</del></p></div><div class="ps" psname="aarch64.debug.breakpoint.AArch64.BreakpointMatch"><a id="aarch64.debug.breakpoint.AArch64.BreakpointMatch" name="aarch64.debug.breakpoint.AArch64.BreakpointMatch"></a><h3 class="pseudocode">
            Library pseudocode for <ins>aarch64</ins><del>aarch32</del>/<ins>debug</ins><del>translation</del>/<ins>breakpoint</ins><del>faults</del>/<ins>AArch64.BreakpointMatch</ins><del>AArch32.TranslationFault</del></h3><p class="pseudocode"><ins>// AArch64.BreakpointMatch()
// =========================
// Breakpoint matching in an AArch64 translation regime.
</ins><del>// AArch32.TranslationFault()
// ==========================
</del>
<ins>boolean</ins><del>FaultRecord</del> <a id="AArch64.BreakpointMatch.4" name="AArch64.BreakpointMatch.4"></a><ins>AArch64.BreakpointMatch(integer n, bits(64) vaddress,</ins><del>AArch32.TranslationFault(bits(40) ipaddress,  bits(4) domain, integer level,</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType</a> <ins>acctype, integer size)
    assert !</ins><del>acctype, boolean iswrite, boolean secondstage,
                                     boolean s2fs1walk)

    extflag = bit UNKNOWN;
    debugmoe = bits(4) UNKNOWN;
    errortype = bits(2) UNKNOWN;
    return</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><a href="shared_pseudocode.html#AArch32.CreateFaultRecord.11" title="function: FaultRecord AArch32.CreateFaultRecord(Fault type, bits(40) ipaddress,   bits(4) domain, integer level, AccType acctype, boolean write, bit extflag, bits(4) debugmoe, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><del>AArch32.CreateFaultRecord</del></a>(<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_Translation</del></a><ins>());
    assert n &lt;= </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(ID_AA64DFR0_EL1.BRPs);

    enabled = DBGBCR_EL1[n].E == '1';
    ispriv = PSTATE.EL != </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>;
    linked = DBGBCR_EL1[n].BT == '0x01';
    isbreakpnt = TRUE;
    linked_to = FALSE;

    state_match = </ins><a href="shared_pseudocode.html#AArch64.StateMatch.8" title="function: boolean AArch64.StateMatch(bits(2) SSC, bit HMC, bits(2) PxC, boolean linked, bits(4) LBN, boolean isbreakpnt, AccType acctype, boolean ispriv)"><ins>AArch64.StateMatch</ins></a><ins>(DBGBCR_EL1[n].SSC, DBGBCR_EL1[n].HMC, DBGBCR_EL1[n].PMC,
                                     linked, DBGBCR_EL1[n].LBN, isbreakpnt, acctype, ispriv);
    value_match = </ins><a href="shared_pseudocode.html#AArch64.BreakpointValueMatch.3" title="function: boolean AArch64.BreakpointValueMatch(integer n, bits(64) vaddress, boolean linked_to)"><ins>AArch64.BreakpointValueMatch</ins></a><ins>(n, vaddress, linked_to);

    if </ins><a href="shared_pseudocode.html#impl-shared.HaveAnyAArch32.0" title="function: boolean HaveAnyAArch32()"><ins>HaveAnyAArch32</ins></a><ins>() &amp;&amp; size == 4 then                 // Check second halfword
        // If the breakpoint address and BAS of an Address breakpoint match the address of the
        // second halfword of an instruction, but not the address of the first halfword, it is
        // CONSTRAINED UNPREDICTABLE whether or not this breakpoint generates a Breakpoint debug
        // event.
        match_i = </ins><a href="shared_pseudocode.html#AArch64.BreakpointValueMatch.3" title="function: boolean AArch64.BreakpointValueMatch(integer n, bits(64) vaddress, boolean linked_to)"><ins>AArch64.BreakpointValueMatch</ins></a><ins>(n, vaddress + 2, linked_to);
        if !value_match &amp;&amp; match_i then
            value_match = </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><ins>ConstrainUnpredictableBool</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_BPMATCHHALF" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_BPMATCHHALF</ins></a><ins>);

    if vaddress&lt;1> == '1' &amp;&amp; DBGBCR_EL1[n].BAS == '1111' then
        // The above notwithstanding, if DBGBCR_EL1[n].BAS == '1111', then it is CONSTRAINED
        // UNPREDICTABLE whether or not a Breakpoint debug event is generated for an instruction
        // at the address DBGBVR_EL1[n]+2.
        if value_match then value_match = </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><ins>ConstrainUnpredictableBool</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_BPMATCHHALF" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_BPMATCHHALF</ins></a><ins>);

    match = value_match &amp;&amp; state_match &amp;&amp; enabled;

    return match;</ins><del>, ipaddress,  domain, level, acctype, iswrite,
                                     extflag, debugmoe, errortype, secondstage, s2fs1walk);</del></p></div><div class="ps" psname="aarch64.debug.breakpoint.AArch64.BreakpointValueMatch"><a id="aarch64.debug.breakpoint.AArch64.BreakpointValueMatch" name="aarch64.debug.breakpoint.AArch64.BreakpointValueMatch"></a><h3 class="pseudocode">
            Library pseudocode for <ins>aarch64</ins><del>aarch32</del>/<ins>debug</ins><del>translation</del>/<ins>breakpoint</ins><del>translation</del>/<ins>AArch64.BreakpointValueMatch</ins><del>AArch32.FirstStageTranslate</del></h3><p class="pseudocode"><ins>// AArch64.BreakpointValueMatch()
// ==============================
</ins><del>// AArch32.FirstStageTranslate()
// =============================
// Perform a stage 1 translation walk. The function used by Address Translation operations is
// similar except it uses the translation regime specified for the instruction.
</del>
<ins>boolean</ins><del>AddressDescriptor</del> <a id="AArch64.BreakpointValueMatch.3" name="AArch64.BreakpointValueMatch.3"></a><ins>AArch64.BreakpointValueMatch(integer n, bits(64) vaddress, boolean linked_to)

    // "n" is the identity of the breakpoint unit to match against.
    // "vaddress" is the current instruction address, ignored if linked_to is TRUE and for Context
    //   matching breakpoints.
    // "linked_to" is TRUE if this is a call from StateMatch for linking.

    // If a non-existent breakpoint then it is CONSTRAINED UNPREDICTABLE whether this gives
    // no match or the breakpoint is mapped to another UNKNOWN implemented breakpoint.
    if n ></ins><del>AArch32.FirstStageTranslate(bits(32) vaddress,</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><ins>(ID_AA64DFR0_EL1.BRPs) then
        (c, n) =</ins><del>acctype, boolean iswrite,
                                              boolean wasaligned, integer size)

    if PSTATE.EL ==</del> <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableInteger.3" title="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high, Unpredictable which)"><ins>ConstrainUnpredictableInteger</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>(0,</ins><del>then
        s1_enabled = HSCTLR.M == '1';
    elsif</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><ins>(ID_AA64DFR0_EL1.BRPs),</ins><del>() then
        tge = (if</del> <a href="shared_pseudocode.html#Unpredictable_BPNOTIMPL" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_BPNOTIMPL</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><ins>);
        assert c IN {</ins><del>(</del><a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_DISABLED</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>,</ins><del>) then HCR.TGE else HCR_EL2.TGE);
        dc = (if</del> <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_UNKNOWN</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><ins>};
        if c ==</ins><del>(</del> <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_DISABLED</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a> <ins>then return FALSE;
</ins><del>) then HCR.DC else HCR_EL2.DC);
        s1_enabled = tge == '0' &amp;&amp; dc == '0' &amp;&amp; SCTLR.M == '1';
    else
        s1_enabled = SCTLR.M == '1';
</del>
<ins>    // If this breakpoint is not enabled, it cannot generate a match. (This could also happen on a
    // call from StateMatch for linking).
    if DBGBCR_EL1[n].E == '0' then return FALSE;
</ins><del>    ipaddress = bits(40) UNKNOWN;
    secondstage = FALSE;
    s2fs1walk = FALSE;
</del>
<ins>    context_aware = (n >=</ins><del>    if s1_enabled then                         // First stage enabled
        use_long_descriptor_format = PSTATE.EL ==</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>(ID_AA64DFR0_EL1.BRPs) -</ins><del>|| TTBCR.EAE == '1';
        if use_long_descriptor_format then
            S1 =</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#AArch32.TranslationTableWalkLD.7" title="function: TLBRecord AArch32.TranslationTableWalkLD(bits(40) ipaddress, bits(32) vaddress, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk, integer size)"><del>AArch32.TranslationTableWalkLD</del></a><ins>(ID_AA64DFR0_EL1.CTX_CMPs));

    // If BT is set to a reserved type, behaves either as disabled or as a not-reserved type.
    type = DBGBCR_EL1[n].BT;

    if ((type IN {'011x','11xx'} &amp;&amp; !</ins><del>(ipaddress, vaddress, acctype, iswrite, secondstage,
                                                s2fs1walk, size);
            permissioncheck = TRUE;  domaincheck = FALSE;
        else
            S1 =</del><a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><ins>HaveVirtHostExt</ins></a><a href="shared_pseudocode.html#AArch32.TranslationTableWalkSD.4" title="function: TLBRecord AArch32.TranslationTableWalkSD(bits(32) vaddress, AccType acctype, boolean iswrite, integer size)"><del>AArch32.TranslationTableWalkSD</del></a><ins>()) ||              // Context matching
          type == '010x' ||                                             // Reserved
          (type != '0x0x' &amp;&amp; !context_aware) ||                         // Context matching
          (type == '1xxx' &amp;&amp; !</ins><del>(vaddress, acctype, iswrite, size);
            permissioncheck = TRUE;  domaincheck = TRUE;
    else
        S1 =</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#AArch32.TranslateAddressS1Off.3" title="function: TLBRecord AArch32.TranslateAddressS1Off(bits(32) vaddress, AccType acctype, boolean iswrite)"><del>AArch32.TranslateAddressS1Off</del></a><ins>(</ins><del>(vaddress, acctype, iswrite);
        permissioncheck = FALSE;  domaincheck = FALSE;
        if</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><ins>))) then                        // EL2 extension
        (c, type) =</ins><del>() &amp;&amp;</del> <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)"><ins>ConstrainUnpredictableBits</ins></a><a href="shared_pseudocode.html#impl-shared.HaveTrapLoadStoreMultipleDeviceExt.0" title="function: boolean HaveTrapLoadStoreMultipleDeviceExt()"><del>HaveTrapLoadStoreMultipleDeviceExt</del></a><ins>(</ins><del>() &amp;&amp;</del><a href="shared_pseudocode.html#Unpredictable_RESBPTYPE" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESBPTYPE</ins></a><a href="shared_pseudocode.html#AArch32.ExecutingLSMInstr.0" title="function: boolean AArch32.ExecutingLSMInstr()"><del>AArch32.ExecutingLSMInstr</del></a><ins>);
        assert c IN {</ins><del>() then
            if S1.addrdesc.memattrs.type ==</del><a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_DISABLED</ins></a><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Device</del></a><ins>,</ins><del>&amp;&amp; S1.addrdesc.memattrs.device !=</del> <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_UNKNOWN</ins></a><a href="shared_pseudocode.html#DeviceType_GRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType_GRE</del></a><ins>};
        if c ==</ins><del>then
                nTLSMD = if</del> <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_DISABLED</ins></a><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a> <ins>then return FALSE;
        // Otherwise the value returned by ConstrainUnpredictableBits must be a not-reserved value

    // Determine what to compare against.
    match_addr = (type == '0x0x');
    match_vmid = (type == '10xx');
    match_cid  = (type == '001x');
    match_cid1 = (type IN { '101x', 'x11x'});
    match_cid2 = (type == '11xx');
    linked     = (type == 'xxx1');

    // If this is a call from StateMatch, return FALSE if the breakpoint is not programmed for a
    // VMID and/or context ID match, of if not context-aware. The above assertions mean that the
    // code can just test for match_addr == TRUE to confirm all these things.
    if linked_to &amp;&amp; (!linked || match_addr) then return FALSE;

    // If called from BreakpointMatch return FALSE for Linked context ID and/or VMID matches.
    if !linked_to &amp;&amp; linked &amp;&amp; !match_addr then return FALSE;

    // Do the comparison.
    if match_addr then
        byte =</ins><del>() ==</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>(vaddress&lt;1:0>);
        if</ins><del>then HSCTLR.nTLSMD else SCTLR.nTLSMD;
                if nTLSMD == '0' then
                    S1.addrdesc.fault =</del> <a href="shared_pseudocode.html#impl-shared.HaveAnyAArch32.0" title="function: boolean HaveAnyAArch32()"><ins>HaveAnyAArch32</ins></a><a href="shared_pseudocode.html#AArch32.AlignmentFault.3" title="function: FaultRecord AArch32.AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)"><del>AArch32.AlignmentFault</del></a><ins>() then
            // T32 instructions can be executed at EL0 in an AArch64 translation regime.
            assert byte IN {0,2};                 // "vaddress" is halfword aligned
            byte_select_match = (DBGBCR_EL1[n].BAS&lt;byte> == '1');
        else
            assert byte == 0;                     // "vaddress" is word aligned
            byte_select_match = TRUE;             // DBGBCR_EL1[n].BAS&lt;byte> is RES1
        top =</ins><del>(acctype, iswrite, secondstage);

    // Check for unaligned data accesses to Device memory
    if ((!wasaligned &amp;&amp; acctype !=</del> <a href="shared_pseudocode.html#impl-shared.AddrTop.3" title="function: integer AddrTop(bits(64) address, boolean IsInstr, bits(2) el)"><ins>AddrTop</ins></a><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IFETCH</del></a><ins>(vaddress, TRUE, PSTATE.EL);
        BVR_match = vaddress&lt;top:2> == DBGBVR_EL1[n]&lt;top:2> &amp;&amp; byte_select_match;
    elsif match_cid then
        if</ins><del>) || (acctype ==</del> <a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><ins>IsInHost</ins></a><a href="shared_pseudocode.html#AccType_DCZVA" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_DCZVA</del></a><ins>() then
            BVR_match = (CONTEXTIDR_EL2 == DBGBVR_EL1[n]&lt;31:0>);
        else
            BVR_match = (PSTATE.EL IN {</ins><del>))
        &amp;&amp; S1.addrdesc.memattrs.type ==</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Device</del></a><ins>,</ins><del>&amp;&amp; !</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><ins>} &amp;&amp; CONTEXTIDR_EL1 == DBGBVR_EL1[n]&lt;31:0>);
    elsif match_cid1 then
        BVR_match = (PSTATE.EL IN {</ins><del>(S1.addrdesc) then
        S1.addrdesc.fault =</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#AArch32.AlignmentFault.3" title="function: FaultRecord AArch32.AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)"><del>AArch32.AlignmentFault</del></a><ins>,</ins><del>(acctype, iswrite, secondstage);
    if !</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><ins>} &amp;&amp; !</ins><del>(S1.addrdesc) &amp;&amp; domaincheck then
        (permissioncheck, abort) =</del><a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><ins>IsInHost</ins></a><a href="shared_pseudocode.html#AArch32.CheckDomain.5" title="function: (boolean, FaultRecord) AArch32.CheckDomain(bits(4) domain, bits(32) vaddress, integer level, AccType acctype, boolean iswrite)"><del>AArch32.CheckDomain</del></a><ins>() &amp;&amp; CONTEXTIDR_EL1 == DBGBVR_EL1[n]&lt;31:0>);
    if match_vmid then
        if !</ins><del>(S1.domain, vaddress, S1.level, acctype,
                                                       iswrite);
        S1.addrdesc.fault = abort;

    if !</del><a href="shared_pseudocode.html#impl-shared.Have16bitVMID.0" title="function: boolean Have16bitVMID()"><ins>Have16bitVMID</ins></a><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><ins>() || VTCR_EL2.VS == '0' then
            vmid =</ins><del>(S1.addrdesc) &amp;&amp; permissioncheck then
        S1.addrdesc.fault =</del> <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><ins>ZeroExtend</ins></a><a href="shared_pseudocode.html#AArch32.CheckPermission.7" title="function: FaultRecord AArch32.CheckPermission(Permissions perms, bits(32) vaddress, integer level, bits(4) domain, bit NS, AccType acctype, boolean iswrite)"><del>AArch32.CheckPermission</del></a><ins>(VTTBR_EL2.VMID&lt;7:0>, 16);
            bvr_vmid =</ins><del>(S1.perms, vaddress, S1.level,
                                                    S1.domain, S1.addrdesc.paddress.NS,
                                                    acctype, iswrite);

    // Check for instruction fetches from Device memory not marked as execute-never. If there has
    // not been a Permission Fault then the memory is not marked execute-never.
    if (!</del> <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><ins>ZeroExtend</ins></a><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><ins>(DBGBVR_EL1[n]&lt;39:32>, 16);
        else
            vmid = VTTBR_EL2.VMID;
            bvr_vmid = DBGBVR_EL1[n]&lt;47:32>;
        BXVR_match = (</ins><del>(S1.addrdesc) &amp;&amp; S1.addrdesc.memattrs.type ==</del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Device</del></a><ins>() &amp;&amp; PSTATE.EL IN {</ins><del>&amp;&amp;
        acctype ==</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IFETCH</del></a><ins>,</ins><del>) then
        S1.addrdesc =</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#AArch32.InstructionDevice.9" title="function: AddressDescriptor AArch32.InstructionDevice(AddressDescriptor addrdesc, bits(32) vaddress, bits(40) ipaddress, integer level,  bits(4) domain, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><del>AArch32.InstructionDevice</del></a><ins>} &amp;&amp;
                      !</ins><a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><ins>IsInHost</ins></a><ins>() &amp;&amp;
                      vmid == bvr_vmid);
    elsif match_cid2 then
        BXVR_match = (!</ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>() &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><ins>HaveVirtHostExt</ins></a><ins>() &amp;&amp;
                      DBGBVR_EL1[n]&lt;63:32> == CONTEXTIDR_EL2);
</ins><del>(S1.addrdesc, vaddress, ipaddress, S1.level,
                                                S1.domain, acctype, iswrite,
                                                secondstage, s2fs1walk);
</del>
<ins>    bvr_match_valid = (match_addr || match_cid || match_cid1);
    bxvr_match_valid = (match_vmid || match_cid2);

    match = (!bxvr_match_valid || BXVR_match) &amp;&amp; (!bvr_match_valid || BVR_match);

    return match;</ins><del>    return S1.addrdesc;</del></p></div><div class="ps" psname="aarch64.debug.breakpoint.AArch64.StateMatch"><a id="aarch64.debug.breakpoint.AArch64.StateMatch" name="aarch64.debug.breakpoint.AArch64.StateMatch"></a><h3 class="pseudocode">
            Library pseudocode for <ins>aarch64</ins><del>aarch32</del>/<ins>debug</ins><del>translation</del>/<ins>breakpoint</ins><del>translation</del>/<ins>AArch64.StateMatch</ins><del>AArch32.FullTranslate</del></h3><p class="pseudocode"><ins>// AArch64.StateMatch()
// ====================
// Determine whether a breakpoint or watchpoint is enabled in the current mode and state.
</ins><del>// AArch32.FullTranslate()
// =======================
// Perform both stage 1 and stage 2 translation walks for the current translation regime. The
// function used by Address Translation operations is similar except it uses the translation
// regime specified for the instruction.
</del>
<ins>boolean</ins><del>AddressDescriptor</del> <a id="AArch64.StateMatch.8" name="AArch64.StateMatch.8"></a><ins>AArch64.StateMatch(bits(2) SSC, bit HMC, bits(2) PxC, boolean linked, bits(4) LBN,
                           boolean isbreakpnt,</ins><del>AArch32.FullTranslate(bits(32) vaddress,</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType</a> <ins>acctype, boolean ispriv)
    // "SSC", "HMC", "PxC" are the control fields from the DBGBCR[n] or DBGWCR[n] register.
    // "linked" is TRUE if this is a linked breakpoint/watchpoint type.
    // "LBN" is the linked breakpoint number from the DBGBCR[n] or DBGWCR[n] register.
    // "isbreakpnt" is TRUE for breakpoints, FALSE for watchpoints.
    // "ispriv" is valid for watchpoints, and selects between privileged and unprivileged accesses.
</ins><del>acctype, boolean iswrite,
                                        boolean wasaligned, integer size)
</del>
<ins>    // If parameters are set to a reserved type, behaves as either disabled or a defined type
    if ((HMC:SSC:PxC) IN {'011xx','100x0','101x0','11010','11101','1111x'} ||       // Reserved
          (HMC == '0' &amp;&amp; PxC == '00' &amp;&amp; (!isbreakpnt || !</ins><del>    // First Stage Translation
    S1 =</del><a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)"><ins>HaveAArch32EL</ins></a><a href="shared_pseudocode.html#AArch32.FirstStageTranslate.5" title="function: AddressDescriptor AArch32.FirstStageTranslate(bits(32) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><del>AArch32.FirstStageTranslate</del></a><ins>(</ins><del>(vaddress, acctype, iswrite, wasaligned, size);
    if !</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><ins>))) ||    // Usr/Svc/Sys
          (SSC IN {'01','10'} &amp;&amp; !</ins><del>(S1) &amp;&amp; !(</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>)) ||                                   // No EL3
          (HMC:SSC != '000' &amp;&amp; HMC:SSC != '111' &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>)) || // No EL3/EL2
          (HMC:SSC:PxC == '11100' &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>))) then                            // No EL2
        (c, &lt;HMC,SSC,PxC>) = </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)"><ins>ConstrainUnpredictableBits</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_RESBPWPCTRL" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESBPWPCTRL</ins></a><ins>);
        assert c IN {</ins><a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_DISABLED</ins></a><ins>, </ins><a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_UNKNOWN</ins></a><ins>};
        if c == </ins><a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_DISABLED</ins></a><ins> then return FALSE;
        // Otherwise the value returned by ConstrainUnpredictableBits must be a not-reserved value

    EL3_match = </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; HMC == '1' &amp;&amp; SSC&lt;0> == '0';
    EL2_match = </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) &amp;&amp; HMC == '1';
    EL1_match = PxC&lt;0> == '1';
    EL0_match = PxC&lt;1> == '1';

    el = if </ins><a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()">HaveNV2Ext</a>() &amp;&amp; acctype == <a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType_NV2REGISTER</a> <ins>then</ins><del>) &amp;&amp;</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-shared.HasS2Translation.0" title="function: boolean HasS2Translation()"><del>HasS2Translation</del></a> <ins>else PSTATE.EL;
    if !ispriv &amp;&amp; !isbreakpnt then
        priv_match = EL0_match;
    else
        case el of
            when</ins><del>() then
        s2fs1walk = FALSE;
        result =</del> <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#AArch32.SecondStageTranslate.7" title="function: AddressDescriptor AArch32.SecondStageTranslate(AddressDescriptor S1, bits(32) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, boolean s2fs1walk, integer size)"><del>AArch32.SecondStageTranslate</del></a><ins>  priv_match = EL3_match;
            when </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>  priv_match = EL2_match;
            when </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>  priv_match = EL1_match;
            when </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>  priv_match = EL0_match;

    case SSC of
        when '00'  security_state_match = TRUE;         // Both
        when '01'  security_state_match = !</ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>();  // Non-secure only
        when '10'  security_state_match = </ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>();   // Secure only
        when '11'  security_state_match = TRUE;         // Both

    if linked then
        // "LBN" must be an enabled context-aware breakpoint unit. If it is not context-aware then
        // it is CONSTRAINED UNPREDICTABLE whether this gives no match, or LBN is mapped to some
        // UNKNOWN breakpoint that is context-aware.
        lbn = </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(LBN);
        first_ctx_cmp = (</ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(ID_AA64DFR0_EL1.BRPs) - </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(ID_AA64DFR0_EL1.CTX_CMPs));
        last_ctx_cmp = </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(ID_AA64DFR0_EL1.BRPs);
        if (lbn &lt; first_ctx_cmp || lbn > last_ctx_cmp) then
            (c, lbn) = </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableInteger.3" title="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high, Unpredictable which)"><ins>ConstrainUnpredictableInteger</ins></a><ins>(first_ctx_cmp, last_ctx_cmp, </ins><a href="shared_pseudocode.html#Unpredictable_BPNOTCTXCMP" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_BPNOTCTXCMP</ins></a><ins>);
            assert c IN {</ins><a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_DISABLED</ins></a><ins>, </ins><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_NONE</ins></a><ins>, </ins><a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_UNKNOWN</ins></a><ins>};
            case c of
                when </ins><a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_DISABLED</ins></a><ins>  return FALSE;      // Disabled
                when </ins><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_NONE</ins></a><ins>      linked = FALSE;    // No linking
                // Otherwise ConstrainUnpredictableInteger returned a context-aware breakpoint

    if linked then
        vaddress = bits(64) UNKNOWN;
        linked_to = TRUE;
        linked_match = </ins><a href="shared_pseudocode.html#AArch64.BreakpointValueMatch.3" title="function: boolean AArch64.BreakpointValueMatch(integer n, bits(64) vaddress, boolean linked_to)"><ins>AArch64.BreakpointValueMatch</ins></a><ins>(lbn, vaddress, linked_to);
</ins><del>(S1, vaddress, acctype, iswrite, wasaligned, s2fs1walk,
                                              size);
    else
        result = S1;
</del>
<ins>    return priv_match &amp;&amp; security_state_match &amp;&amp; (!linked || linked_match);</ins><del>    return result;</del></p></div><div class="ps" psname="aarch64.debug.enables.AArch64.GenerateDebugExceptions"><a id="aarch64.debug.enables.AArch64.GenerateDebugExceptions" name="aarch64.debug.enables.AArch64.GenerateDebugExceptions"></a><h3 class="pseudocode">
            Library pseudocode for <ins>aarch64</ins><del>aarch32</del>/<ins>debug</ins><del>translation</del>/<ins>enables</ins><del>translation</del>/<ins>AArch64.GenerateDebugExceptions</ins><del>AArch32.SecondStageTranslate</del></h3><p class="pseudocode"><ins>// AArch64.GenerateDebugExceptions()
// =================================
</ins><del>// AArch32.SecondStageTranslate()
// ==============================
// Perform a stage 2 translation walk. The function used by Address Translation operations is
// similar except it uses the translation regime specified for the instruction.
</del>
<ins>boolean</ins><del>AddressDescriptor</del> <a id="AArch64.GenerateDebugExceptions.0" name="AArch64.GenerateDebugExceptions.0"></a><ins>AArch64.GenerateDebugExceptions()
    return</ins><del>AArch32.SecondStageTranslate(</del> <a href="shared_pseudocode.html#AArch64.GenerateDebugExceptionsFrom.3" title="function: boolean AArch64.GenerateDebugExceptionsFrom(bits(2) from, boolean secure, bit mask)"><ins>AArch64.GenerateDebugExceptionsFrom</ins></a><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><del>AddressDescriptor</del></a><ins>(PSTATE.EL,</ins><del>S1, bits(32) vaddress,</del> <del> acctype, boolean iswrite, boolean wasaligned,
                                               boolean s2fs1walk, integer size)
    assert </del><a href="shared_pseudocode.html#impl-shared.HasS2Translation.0" title="function: boolean HasS2Translation()"><del>HasS2Translation</del></a><del>();
    assert </del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(S1.paddress.address&lt;47:40>);
    hwupdatewalk = FALSE;
    if !</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) then
        return </del><a href="shared_pseudocode.html#AArch64.SecondStageTranslate.8" title="function: AddressDescriptor AArch64.SecondStageTranslate(AddressDescriptor S1, bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, boolean s2fs1walk, integer size, boolean hwupdatewalk)"><del>AArch64.SecondStageTranslate</del></a><del>(S1, </del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><del>ZeroExtend</del></a><del>(vaddress, 64), acctype, iswrite,
                                            wasaligned, s2fs1walk, size, hwupdatewalk);

    s2_enabled = HCR.VM == '1' || HCR.DC == '1';
    secondstage = TRUE;

    if s2_enabled then                        // Second stage enabled
        ipaddress = S1.paddress.address&lt;39:0>;
        S2 = </del><a href="shared_pseudocode.html#AArch32.TranslationTableWalkLD.7" title="function: TLBRecord AArch32.TranslationTableWalkLD(bits(40) ipaddress, bits(32) vaddress, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk, integer size)"><del>AArch32.TranslationTableWalkLD</del></a><del>(ipaddress, vaddress, acctype, iswrite, secondstage,
                                            s2fs1walk, size);

        // Check for unaligned data accesses to Device memory
        if ((!wasaligned &amp;&amp; acctype != </del><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IFETCH</del></a><del>) || (acctype == </del><a href="shared_pseudocode.html#AccType_DCZVA" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_DCZVA</del></a><del>))
            &amp;&amp; S2.addrdesc.memattrs.type == </del><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Device</del></a><del> &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><del>(S2.addrdesc) then
            S2.addrdesc.fault = </del><a href="shared_pseudocode.html#AArch32.AlignmentFault.3" title="function: FaultRecord AArch32.AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)"><del>AArch32.AlignmentFault</del></a><del>(acctype, iswrite, secondstage);

        // Check for permissions on Stage2 translations
        if !</del><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><del>(S2.addrdesc) then
            S2.addrdesc.fault = </del><a href="shared_pseudocode.html#AArch32.CheckS2Permission.7" title="function: FaultRecord AArch32.CheckS2Permission(Permissions perms, bits(32) vaddress, bits(40) ipaddress, integer level, AccType acctype, boolean iswrite, boolean s2fs1walk)"><del>AArch32.CheckS2Permission</del></a><del>(S2.perms, vaddress, ipaddress, S2.level,
                                                          acctype, iswrite, s2fs1walk);

        // Check for instruction fetches from Device memory not marked as execute-never. As there
        // has not been a Permission Fault then the memory is not marked execute-never.
        if (!s2fs1walk &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><del>(S2.addrdesc) &amp;&amp; S2.addrdesc.memattrs.type == </del><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Device</del></a><del> &amp;&amp;
            acctype == </del><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IFETCH</del></a><del>) then
            domain = bits(4) UNKNOWN;
            S2.addrdesc = </del><a href="shared_pseudocode.html#AArch32.InstructionDevice.9" title="function: AddressDescriptor AArch32.InstructionDevice(AddressDescriptor addrdesc, bits(32) vaddress, bits(40) ipaddress, integer level,  bits(4) domain, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><del>AArch32.InstructionDevice</del></a><del>(S2.addrdesc, vaddress, ipaddress, S2.level,
                                                    domain, acctype, iswrite,
                                                    secondstage, s2fs1walk);

        // Check for protected table walk
        if (s2fs1walk &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><del>(S2.addrdesc) &amp;&amp; HCR.PTW == '1' &amp;&amp;
            S2.addrdesc.memattrs.type == </del><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Device</del></a><del>) then
            domain = bits(4) UNKNOWN;
            S2.addrdesc.fault = </del><a href="shared_pseudocode.html#AArch32.PermissionFault.7" title="function: FaultRecord AArch32.PermissionFault(bits(40) ipaddress, bits(4) domain, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><del>AArch32.PermissionFault</del></a><del>(ipaddress,   domain, S2.level, acctype,
                                                        iswrite, secondstage, s2fs1walk);

        result = </del><a href="shared_pseudocode.html#impl-shared.CombineS1S2Desc.2" title="function: AddressDescriptor CombineS1S2Desc(AddressDescriptor s1desc, AddressDescriptor s2desc)"><del>CombineS1S2Desc</del></a><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><ins>(), PSTATE.D);</ins><del>(S1, S2.addrdesc);
    else
        result = S1;

    return result;</del></p></div><div class="ps" psname="aarch64.debug.enables.AArch64.GenerateDebugExceptionsFrom"><a id="aarch64.debug.enables.AArch64.GenerateDebugExceptionsFrom" name="aarch64.debug.enables.AArch64.GenerateDebugExceptionsFrom"></a><h3 class="pseudocode">
            Library pseudocode for <ins>aarch64</ins><del>aarch32</del>/<ins>debug</ins><del>translation</del>/<ins>enables</ins><del>translation</del>/<ins>AArch64.GenerateDebugExceptionsFrom</ins><del>AArch32.SecondStageWalk</del></h3><p class="pseudocode"><ins>// AArch64.GenerateDebugExceptionsFrom()
// =====================================
</ins><del>// AArch32.SecondStageWalk()
// =========================
// Perform a stage 2 translation on a stage 1 translation page table walk access.
</del>
<ins>boolean</ins><del>AddressDescriptor</del> <a id="AArch64.GenerateDebugExceptionsFrom.3" name="AArch64.GenerateDebugExceptionsFrom.3"></a><ins>AArch64.GenerateDebugExceptionsFrom(bits(2) from, boolean secure, bit mask)

    if OSLSR_EL1.OSLK == '1' ||</ins><del>AArch32.SecondStageWalk(</del> <a href="shared_pseudocode.html#impl-shared.DoubleLockStatus.0" title="function: boolean DoubleLockStatus()"><ins>DoubleLockStatus</ins></a><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><del>AddressDescriptor</del></a><ins>() ||</ins><del>S1, bits(32) vaddress,</del> <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><ins>Halted</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><ins>() then
        return FALSE;
</ins><del>acctype,
                                          boolean iswrite, integer size)
</del>
<ins>    route_to_el2 =</ins><del>    assert</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-shared.HasS2Translation.0" title="function: boolean HasS2Translation()"><del>HasS2Translation</del></a><ins>(</ins><del>();

    s2fs1walk = TRUE;
    wasaligned = TRUE;
    return</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#AArch32.SecondStageTranslate.7" title="function: AddressDescriptor AArch32.SecondStageTranslate(AddressDescriptor S1, bits(32) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, boolean s2fs1walk, integer size)"><del>AArch32.SecondStageTranslate</del></a><ins>) &amp;&amp; !secure &amp;&amp; (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1');
    target = (if route_to_el2 then </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins> else </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>);

    enabled = !</ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) || !secure || MDCR_EL3.SDD == '0';

    if from == target then
        enabled = enabled &amp;&amp; MDSCR_EL1.KDE == '1' &amp;&amp; mask == '0';
    else
        enabled = enabled &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(target) > </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(from);

    return enabled;</ins><del>(S1, vaddress, acctype, iswrite, wasaligned, s2fs1walk,
                                        size);</del></p></div><div class="ps" psname="aarch64.debug.pmu.AArch64.CheckForPMUOverflow"><a id="aarch64.debug.pmu.AArch64.CheckForPMUOverflow" name="aarch64.debug.pmu.AArch64.CheckForPMUOverflow"></a><h3 class="pseudocode">
            Library pseudocode for <ins>aarch64</ins><del>aarch32</del>/<ins>debug</ins><del>translation</del>/<ins>pmu</ins><del>translation</del>/<ins>AArch64.CheckForPMUOverflow</ins><del>AArch32.TranslateAddress</del></h3><p class="pseudocode"><ins>// AArch64.CheckForPMUOverflow()
// =============================
// Signal Performance Monitors overflow IRQ and CTI overflow events
</ins><del>// AArch32.TranslateAddress()
// ==========================
// Main entry point for translating an address
</del>
<ins>boolean</ins><del>AddressDescriptor</del> <a id="AArch64.CheckForPMUOverflow.0" name="AArch64.CheckForPMUOverflow.0"></a><ins>AArch64.CheckForPMUOverflow()

    pmuirq = PMCR_EL0.E == '1' &amp;&amp; PMINTENSET_EL1&lt;31> == '1' &amp;&amp; PMOVSSET_EL0&lt;31> == '1';
    for n = 0 to</ins><del>AArch32.TranslateAddress(bits(32) vaddress,</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><ins>(PMCR_EL0.N) - 1
        if</ins><del>acctype, boolean iswrite,
                                           boolean wasaligned, integer size)

    if !</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><ins>) then
            E = (if n &lt;</ins><del>()) then
        return</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><del>AArch64.TranslateAddress</del></a><ins>(MDCR_EL2.HPMN) then PMCR_EL0.E else MDCR_EL2.HPME);
        else
            E = PMCR_EL0.E;
        if E == '1' &amp;&amp; PMINTENSET_EL1&lt;n> == '1' &amp;&amp; PMOVSSET_EL0&lt;n> == '1' then pmuirq = TRUE;

    SetInterruptRequestLevel(</ins><del>(</del><a href="shared_pseudocode.html#InterruptID_PMUIRQ" title="enumeration InterruptID {InterruptID_PMUIRQ, InterruptID_COMMIRQ, InterruptID_CTIIRQ, InterruptID_COMMRX, InterruptID_COMMTX}"><ins>InterruptID_PMUIRQ</ins></a><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><del>ZeroExtend</del></a><ins>, if pmuirq then HIGH else LOW);

    CTI_SetEventLevel(</ins><del>(vaddress, 64), acctype, iswrite, wasaligned,
                                        size);
    result =</del><del>(vaddress, acctype, iswrite, wasaligned, size);

    if !(acctype IN {</del><a href="shared_pseudocode.html#AccType_PTW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_PTW</del></a><del>, </del><a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IC</del></a><del>, </del><a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_AT</del></a><del>}) &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><del>(result) then
        result.fault = </del><a href="shared_pseudocode.html#AArch32.CheckDebug.4" title="function: FaultRecord AArch32.CheckDebug(bits(32) vaddress, AccType acctype, boolean iswrite, integer size)"><del>AArch32.CheckDebug</del></a><del>(vaddress, acctype, iswrite, size);

    // Update virtual address for abort functions
    result.vaddress = </del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><a href="shared_pseudocode.html#CrossTriggerIn_PMUOverflow" title="enumeration CrossTriggerIn  {CrossTriggerIn_CrossHalt,     CrossTriggerIn_PMUOverflow, CrossTriggerIn_RSVD2,         CrossTriggerIn_RSVD3, CrossTriggerIn_TraceExtOut0,  CrossTriggerIn_TraceExtOut1, CrossTriggerIn_TraceExtOut2,  CrossTriggerIn_TraceExtOut3}"><ins>CrossTriggerIn_PMUOverflow</ins></a><a href="shared_pseudocode.html#AArch32.FullTranslate.5" title="function: AddressDescriptor AArch32.FullTranslate(bits(32) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><del>AArch32.FullTranslate</del></a><ins>, if pmuirq then HIGH else LOW);
</ins><del>(vaddress);
</del>
<ins>    // The request remains set until the condition is cleared. (For example, an interrupt handler
    // or cross-triggered event handler clears the overflow status flag by writing to PMOVSCLR_EL0.)

    return pmuirq;</ins><del>    return result;</del></p></div><div class="ps" psname="aarch64.debug.pmu.AArch64.CountEvents"><a id="aarch64.debug.pmu.AArch64.CountEvents" name="aarch64.debug.pmu.AArch64.CountEvents"></a><h3 class="pseudocode">
            Library pseudocode for <ins>aarch64</ins><del>aarch32</del>/<ins>debug</ins><del>translation</del>/<ins>pmu</ins><del>walk</del>/<ins>AArch64.CountEvents</ins><del>AArch32.TranslationTableWalkLD</del></h3><p class="pseudocode"><ins>// AArch64.CountEvents()
// =====================
// Return TRUE if counter "n" should count its event. For the cycle counter, n == 31.
</ins><del>// AArch32.TranslationTableWalkLD()
// ================================
// Returns a result of a translation table walk using the Long-descriptor format
//
// Implementations might cache information from memory in any number of non-coherent TLB
// caching structures, and so avoid memory accesses that have been expressed in this
// pseudocode. The use of such TLBs is not expressed in this pseudocode.
</del>
<ins>boolean</ins><del>TLBRecord</del> <a id="AArch64.CountEvents.1" name="AArch64.CountEvents.1"></a><ins>AArch64.CountEvents(integer n)
    assert n == 31 || n &lt;</ins><del>AArch32.TranslationTableWalkLD(bits(40) ipaddress, bits(32) vaddress,</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><ins>(PMCR_EL0.N);

    // Event counting is disabled in Debug state
    debug =</ins><del>acctype, boolean iswrite, boolean secondstage,
                                         boolean s2fs1walk, integer size)
    if !secondstage then
        assert</del> <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><ins>Halted</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><ins>();

    // In Non-secure state, some counters are reserved for EL2
    if</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><del>());
    else
        assert </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a><ins>) then
        E = if n &lt;</ins><del>) &amp;&amp; !</del> <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>() &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.HasS2Translation.0" title="function: boolean HasS2Translation()"><del>HasS2Translation</del></a><del>();

    </del><a href="shared_pseudocode.html#TLBRecord" title="type TLBRecord is ( Permissions perms, bit nG, bits(4) domain, bit GP, boolean contiguous, integer level, integer blocksize, DescriptorUpdate descupdate, bit CnP, AddressDescriptor addrdesc )"><del>TLBRecord</del></a><del> result;
    </del><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><del>AddressDescriptor</del></a><del> descaddr;
    bits(64) baseregister;
    bits(40) inputaddr;        // Input Address is 'vaddress' for stage 1, 'ipaddress' for stage 2

    domain = bits(4) UNKNOWN;

    descaddr.memattrs.type = </del><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Normal</del></a><del>;

    // Fixed parameters for the page table walk:
    //  grainsize = Log2(Size of Table)         - Size of Table is 4KB in AArch32
    //  stride = Log2(Address per Level)        - Bits of address consumed at each level
    constant integer grainsize = 12;                    // Log2(4KB page size)
    constant integer stride = grainsize - 3;            // Log2(page size / 8 bytes)

    // Derived parameters for the page table walk:
    //  inputsize = Log2(Size of Input Address) - Input Address size in bits
    //  level = Level to start walk from
    // This means that the number of levels after start level = 3-level

    if !secondstage then
        // First stage translation
        inputaddr = </del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><del>(vaddress);
        el = </del><a href="shared_pseudocode.html#AArch32.AccessUsesEL.1" title="function: bits(2) AArch32.AccessUsesEL(AccType acctype)"><del>AArch32.AccessUsesEL</del></a><del>(acctype);
        if el == </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del> then
            inputsize = 32 - </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a><ins>(MDCR_EL2.HPMN) || n == 31 then PMCR_EL0.E else MDCR_EL2.HPME;
    else
        E = PMCR_EL0.E;
    enabled = E == '1' &amp;&amp; PMCNTENSET_EL0&lt;n> == '1';

    if !</ins><del>(HTCR.T0SZ);
            basefound = inputsize == 32 ||</del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(inputaddr&lt;31:inputsize>);
            disabled = FALSE;
            baseregister = HTTBR;
            descaddr.memattrs = </del><a href="shared_pseudocode.html#impl-shared.WalkAttrDecode.4" title="function: MemoryAttributes WalkAttrDecode(bits(2) SH, bits(2) ORGN, bits(2) IRGN, boolean secondstage)"><del>WalkAttrDecode</del></a><del>(HTCR.SH0, HTCR.ORGN0, HTCR.IRGN0, secondstage);
            reversedescriptors = HSCTLR.EE == '1';
            lookupsecure = FALSE;
            singlepriv = TRUE;
            hierattrsdisabled = </del><a href="shared_pseudocode.html#AArch32.HaveHPDExt.0" title="function: boolean AArch32.HaveHPDExt()"><del>AArch32.HaveHPDExt</del></a><del>() &amp;&amp; HTCR.HPD == '1';
        else
            basefound = FALSE;
            disabled = FALSE;
            t0size = </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(TTBCR.T0SZ);
            if t0size == 0 || </del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(inputaddr&lt;31:(32-t0size)>) then
                inputsize = 32 - t0size;
                basefound = TRUE;
                baseregister = TTBR0;
                descaddr.memattrs = </del><a href="shared_pseudocode.html#impl-shared.WalkAttrDecode.4" title="function: MemoryAttributes WalkAttrDecode(bits(2) SH, bits(2) ORGN, bits(2) IRGN, boolean secondstage)"><del>WalkAttrDecode</del></a><del>(TTBCR.SH0, TTBCR.ORGN0, TTBCR.IRGN0, secondstage);
                hierattrsdisabled = </del><a href="shared_pseudocode.html#AArch32.HaveHPDExt.0" title="function: boolean AArch32.HaveHPDExt()"><del>AArch32.HaveHPDExt</del></a><del>() &amp;&amp; TTBCR.T2E == '1' &amp;&amp;  TTBCR2.HPD0 == '1';
            t1size = </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(TTBCR.T1SZ);
            if (t1size == 0 &amp;&amp; !basefound) || (t1size > 0 &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)"><del>IsOnes</del></a><del>(inputaddr&lt;31:(32-t1size)>)) then
                inputsize = 32 - t1size;
                basefound = TRUE;
                baseregister = TTBR1;
                descaddr.memattrs = </del><a href="shared_pseudocode.html#impl-shared.WalkAttrDecode.4" title="function: MemoryAttributes WalkAttrDecode(bits(2) SH, bits(2) ORGN, bits(2) IRGN, boolean secondstage)"><del>WalkAttrDecode</del></a><del>(TTBCR.SH1, TTBCR.ORGN1, TTBCR.IRGN1, secondstage);
                hierattrsdisabled = </del><a href="shared_pseudocode.html#AArch32.HaveHPDExt.0" title="function: boolean AArch32.HaveHPDExt()"><del>AArch32.HaveHPDExt</del></a><del>() &amp;&amp; TTBCR.T2E == '1' &amp;&amp;  TTBCR2.HPD1 == '1';
            reversedescriptors = SCTLR.EE == '1';
            lookupsecure = </del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a><ins>() then
        // Event counting in Non-secure state is allowed unless all of:
        // * EL2 and the HPMD Extension are implemented
        // * Executing at EL2
        // * PMNx is not reserved for EL2
        // * MDCR_EL2.HPMD == 1
        if</ins><del>();
            singlepriv = FALSE;
        // The starting level is the number of strides needed to consume the input address
        level = 4 -</del> <a href="shared_pseudocode.html#impl-shared.HaveHPMDExt.0" title="function: boolean HaveHPMDExt()"><ins>HaveHPMDExt</ins></a><a href="shared_pseudocode.html#impl-shared.RoundUp.1" title="function: integer RoundUp(real x)"><del>RoundUp</del></a><ins>() &amp;&amp; PSTATE.EL ==</ins><del>(Real(inputsize - grainsize) / Real(stride));

    else
        // Second stage translation
        inputaddr = ipaddress;
        inputsize = 32 -</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)"><del>SInt</del></a> <ins>&amp;&amp; (n &lt;</ins><del>(VTCR.T0SZ);
        // VTCR.S must match VTCR.T0SZ[3]
        if VTCR.S != VTCR.T0SZ&lt;3> then
            (-, inputsize) =</del> <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableInteger.3" title="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high, Unpredictable which)"><del>ConstrainUnpredictableInteger</del></a><del>(32-7, 32+8, </del><a href="shared_pseudocode.html#Unpredictable_RESVTCRS" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESVTCRS</del></a><del>);
        basefound = inputsize == 40 || </del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(inputaddr&lt;39:inputsize>);
        disabled = FALSE;
        descaddr.memattrs = </del><a href="shared_pseudocode.html#impl-shared.WalkAttrDecode.4" title="function: MemoryAttributes WalkAttrDecode(bits(2) SH, bits(2) ORGN, bits(2) IRGN, boolean secondstage)"><del>WalkAttrDecode</del></a><del>(VTCR.IRGN0, VTCR.ORGN0, VTCR.SH0, secondstage);
        reversedescriptors = HSCTLR.EE == '1';
        singlepriv = TRUE;

        lookupsecure = FALSE;
        baseregister = VTTBR;
        startlevel = </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a><ins>(MDCR_EL2.HPMN) || n == 31) then
            prohibited = (MDCR_EL2.HPMD == '1');
        else
            prohibited = FALSE;
    else
        // Event counting in Secure state is prohibited unless any one of:
        // * EL3 is not implemented
        // * EL3 is using AArch64 and MDCR_EL3.SPME == 1
        prohibited =</ins><del>(VTCR.SL0);
        level = 2 - startlevel;
        if level &lt;= 0 then basefound = FALSE;

        // Number of entries in the starting level table =
        //     (Size of Input Address)/((Address per level)^(Num levels remaining)*(Size of Table))
        startsizecheck = inputsize - ((3 - level)*stride + grainsize); // Log2(Num of entries)

        // Check for starting level table with fewer than 2 entries or longer than 16 pages.
        // Lower bound check is:  startsizecheck &lt; Log2(2 entries)
        //   That is, VTCR.SL0 == '00' and SInt(VTCR.T0SZ) > 1, Size of Input Address &lt; 2^31 bytes
        // Upper bound check is:  startsizecheck > Log2(pagesize/8*16)
        //   That is, VTCR.SL0 == '01' and SInt(VTCR.T0SZ) &lt; -2, Size of Input Address > 2^34 bytes
        if startsizecheck &lt; 1 || startsizecheck > stride + 4 then basefound = FALSE;

    if !basefound || disabled then
        level = 1;           // AArch64 reports this as a level 0 fault
        result.addrdesc.fault =</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#AArch32.TranslationFault.7" title="function: FaultRecord AArch32.TranslationFault(bits(40) ipaddress,  bits(4) domain, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><del>AArch32.TranslationFault</del></a><ins>(</ins><del>(ipaddress,   domain, level, acctype, iswrite,
                                                         secondstage, s2fs1walk);
        return result;

    if !</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><ins>) &amp;&amp; MDCR_EL3.SPME == '0';

    // The IMPLEMENTATION DEFINED authentication interface might override software controls
    if prohibited &amp;&amp; !</ins><del>(baseregister&lt;47:40>) then
        level = 0;
        result.addrdesc.fault =</del><a href="shared_pseudocode.html#impl-shared.HaveNoSecurePMUDisableOverride.0" title="function: boolean HaveNoSecurePMUDisableOverride()"><ins>HaveNoSecurePMUDisableOverride</ins></a><a href="shared_pseudocode.html#AArch32.AddressSizeFault.7" title="function: FaultRecord AArch32.AddressSizeFault(bits(40) ipaddress, bits(4) domain, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><del>AArch32.AddressSizeFault</del></a><ins>() then
        prohibited = !</ins><del>(ipaddress,  domain, level, acctype, iswrite,
                                                         secondstage, s2fs1walk);
        return result;

    // Bottom bound of the Base address is:
    //     Log2(8 bytes per entry)+Log2(Number of entries in starting level table)
    // Number of entries in starting level table =
    //     (Size of Input Address)/((Address per level)^(Num levels remaining)*(Size of Table))
    baselowerbound = 3 + inputsize - ((3-level)*stride + grainsize);  // Log2(Num of entries*8)
    baseaddress = baseregister&lt;39:baselowerbound>:</del><a href="shared_pseudocode.html#impl-shared.ExternalSecureNoninvasiveDebugEnabled.0" title="function: boolean ExternalSecureNoninvasiveDebugEnabled()"><ins>ExternalSecureNoninvasiveDebugEnabled</ins></a><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><ins>();
</ins><del>(baselowerbound);
</del>
<ins>    // For the cycle counter, PMCR_EL0.DP enables counting when otherwise prohibited
    if prohibited &amp;&amp; n == 31 then prohibited = (PMCR_EL0.DP == '1');
</ins><del>    ns_table = if lookupsecure then '0' else '1';
    ap_table = '00';
    xn_table = '0';
    pxn_table = '0';
</del>
<ins>    // Event counting can be filtered by the {P, U, NSK, NSU, NSH, M} bits
    filter = if n == 31 then PMCCFILTR else PMEVTYPER[n];
</ins><del>    addrselecttop = inputsize - 1;
</del>
<ins>    P = filter&lt;31>;
    U = filter&lt;30>;
    NSK = if</ins><del>    repeat
        addrselectbottom = (3-level)*stride + grainsize;

        bits(40) index =</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><ins>(</ins><del>(inputaddr&lt;addrselecttop:addrselectbottom>:'000');
        descaddr.paddress.address =</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><ins>) then filter&lt;29> else '0';
    NSU = if</ins><del>(baseaddress OR index);
        descaddr.paddress.NS = ns_table;

        // If there are two stages of translation, then the first stage table walk addresses
        // are themselves subject to translation
        if secondstage || !</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-shared.HasS2Translation.0" title="function: boolean HasS2Translation()"><del>HasS2Translation</del></a><ins>(</ins><del>() || (</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()"><del>HaveNV2Ext</del></a><ins>) then filter&lt;28> else '0';
    NSH = if</ins><del>() &amp;&amp; acctype ==</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NV2REGISTER</del></a><ins>(</ins><del>) then
            descaddr2 = descaddr;
        else
            descaddr2 =</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#AArch32.SecondStageWalk.5" title="function: AddressDescriptor AArch32.SecondStageWalk(AddressDescriptor S1, bits(32) vaddress, AccType acctype, boolean iswrite, integer size)"><del>AArch32.SecondStageWalk</del></a><ins>) then filter&lt;27> else '0';
    M = if</ins><del>(descaddr, vaddress, acctype, iswrite, 8);
            // Check for a fault on the stage 2 walk
            if</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><ins>(</ins><del>(descaddr2) then
                result.addrdesc.fault = descaddr2.fault;
                return result;

        // Update virtual address for abort functions
        descaddr2.vaddress =</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><ins>) then filter&lt;26> else '0';
</ins><del>(vaddress);
</del>
<ins>    case PSTATE.EL of
        when</ins><del>        accdesc = CreateAccessDescriptorPTW(acctype, secondstage, s2fs1walk, level);
        desc = _Mem[descaddr2, 8, accdesc];

        if reversedescriptors then desc =</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)"><del>BigEndianReverse</del></a>  <ins>filtered = if</ins><del>(desc);

        if desc&lt;0> == '0' || (desc&lt;1:0> == '01' &amp;&amp; level == 3) then
             // Fault (00), Reserved (10), or Block (01) at level 3.
            result.addrdesc.fault =</del> <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><a href="shared_pseudocode.html#AArch32.TranslationFault.7" title="function: FaultRecord AArch32.TranslationFault(bits(40) ipaddress,  bits(4) domain, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><del>AArch32.TranslationFault</del></a><ins>() then U == '1' else U != NSU;
        when</ins><del>(ipaddress,  domain, level, acctype,
                                                             iswrite, secondstage, s2fs1walk);
            return result;

        // Valid Block, Page, or Table entry
        if desc&lt;1:0> == '01' || level == 3 then                 // Block (01) or Page (11)
            blocktranslate = TRUE;
        else                                                    // Table (11)
            if !</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a>  <ins>filtered = if</ins><del>(desc&lt;47:40>) then
                result.addrdesc.fault =</del> <a href="shared_pseudocode.html#AArch32.AddressSizeFault.7" title="function: FaultRecord AArch32.AddressSizeFault(bits(40) ipaddress, bits(4) domain, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><del>AArch32.AddressSizeFault</del></a><del>(ipaddress,  domain, level, acctype,
                                                                 iswrite, secondstage, s2fs1walk);
                return result;

            baseaddress = desc&lt;39:grainsize>:</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(grainsize);
            if !secondstage then
                // Unpack the upper and lower table attributes
                ns_table    = ns_table    OR desc&lt;63>;
            if !secondstage &amp;&amp; !hierattrsdisabled then
                ap_table&lt;1> = ap_table&lt;1> OR desc&lt;62>;       // read-only

                xn_table    = xn_table    OR desc&lt;60>;
                // pxn_table and ap_table[0] apply only in EL1&amp;0 translation regimes
                if !singlepriv then
                    pxn_table   = pxn_table   OR desc&lt;59>;
                    ap_table&lt;0> = ap_table&lt;0> OR desc&lt;61>;   // privileged

            level = level + 1;
            addrselecttop = addrselectbottom - 1;
            blocktranslate = FALSE;
    until blocktranslate;

    // Check the output address is inside the supported range
    if !</del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(desc&lt;47:40>) then
        result.addrdesc.fault = </del><a href="shared_pseudocode.html#AArch32.AddressSizeFault.7" title="function: FaultRecord AArch32.AddressSizeFault(bits(40) ipaddress, bits(4) domain, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><del>AArch32.AddressSizeFault</del></a><del>(ipaddress,  domain, level, acctype,
                                                         iswrite, secondstage, s2fs1walk);
        return result;

    // Unpack the descriptor into address and upper and lower block attributes
    outputaddress = desc&lt;39:addrselectbottom>:inputaddr&lt;addrselectbottom-1:0>;
    // Check the access flag
    if desc&lt;10> == '0' then
        result.addrdesc.fault = </del><a href="shared_pseudocode.html#AArch32.AccessFlagFault.7" title="function: FaultRecord AArch32.AccessFlagFault(bits(40) ipaddress, bits(4) domain, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><del>AArch32.AccessFlagFault</del></a><del>(ipaddress,  domain, level, acctype,
                                                        iswrite, secondstage, s2fs1walk);
        return result;
    xn = desc&lt;54>;                                            // Bit[54] of the block/page descriptor holds UXN
    pxn = desc&lt;53>;                                           // Bit[53] of the block/page descriptor holds PXN
    ap = desc&lt;7:6>:'1';                                       // Bits[7:6] of the block/page descriptor hold AP[2:1]
    contiguousbit = desc&lt;52>;
    nG = desc&lt;11>;
    sh = desc&lt;9:8>;
    memattr = desc&lt;5:2>;                                      // AttrIndx and NS bit in stage 1

    result.domain = bits(4) UNKNOWN;                          // Domains not used
    result.level = level;
    result.blocksize = 2^((3-level)*stride + grainsize);

    // Stage 1 translation regimes also inherit attributes from the tables
    if !secondstage then
        result.perms.xn      = xn OR xn_table;
        result.perms.ap&lt;2>   = ap&lt;2> OR ap_table&lt;1>;          // Force read-only
        // PXN, nG and AP[1] apply only in EL1&amp;0 stage 1 translation regimes
        if !singlepriv then
            result.perms.ap&lt;1> = ap&lt;1> AND NOT(ap_table&lt;0>);  // Force privileged only
            result.perms.pxn   = pxn OR pxn_table;
            // Pages from Non-secure tables are marked non-global in Secure EL1&amp;0
            if </del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a><ins>() then P == '1' else P != NSK;
        when</ins><del>() then
                result.nG = nG OR ns_table;
            else
                result.nG = nG;
        else
            result.perms.ap&lt;1> = '1';
            result.perms.pxn   = '0';
            result.nG          = '0';
        result.GP = desc&lt;50>;                                 // Stage 1 block or pages might be guarded
        result.perms.ap&lt;0>   = '1';
        result.addrdesc.memattrs =</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#AArch32.S1AttrDecode.3" title="function: MemoryAttributes AArch32.S1AttrDecode(bits(2) SH, bits(3) attr, AccType acctype)"><del>AArch32.S1AttrDecode</del></a>  <ins>filtered = (NSH == '0');
        when</ins><del>(sh, memattr&lt;2:0>, acctype);
        result.addrdesc.paddress.NS = memattr&lt;3> OR ns_table;
    else
        result.perms.ap&lt;2:1> = ap&lt;2:1>;
        result.perms.ap&lt;0>   = '1';
        result.perms.xn      = xn;
        if</del> <del>() then result.perms.xxn = desc&lt;53>;
        result.perms.pxn     = '0';
        result.nG            = '0';
        if s2fs1walk then
            result.addrdesc.memattrs = </del><a href="shared_pseudocode.html#impl-shared.S2AttrDecode.3" title="function: MemoryAttributes S2AttrDecode(bits(2) SH, bits(4) attr, AccType acctype)"><del>S2AttrDecode</del></a><del>(sh, memattr, </del><a href="shared_pseudocode.html#AccType_PTW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_PTW</del></a><del>);
        else
            result.addrdesc.memattrs = </del><a href="shared_pseudocode.html#impl-shared.S2AttrDecode.3" title="function: MemoryAttributes S2AttrDecode(bits(2) SH, bits(4) attr, AccType acctype)"><del>S2AttrDecode</del></a><del>(sh, memattr, acctype);
        result.addrdesc.paddress.NS = '1';

    result.addrdesc.paddress.address = </del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><del>(outputaddress);
    result.addrdesc.fault = </del><a href="shared_pseudocode.html#AArch32.NoFault.0" title="function: FaultRecord AArch32.NoFault()"><del>AArch32.NoFault</del></a><del>();
    result.contiguous = contiguousbit == '1';
    if </del><a href="shared_pseudocode.html#impl-shared.HaveCommonNotPrivateTransExt.0" title="function: boolean HaveCommonNotPrivateTransExt()"><del>HaveCommonNotPrivateTransExt</del></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-shared.HaveExtendedExecuteNeverExt.0" title="function: boolean HaveExtendedExecuteNeverExt()"><del>HaveExtendedExecuteNeverExt</del></a>  <ins>filtered = (M != P);
</ins><del>() then result.CnP = baseregister&lt;0>;
</del>
<ins>    return !debug &amp;&amp; enabled &amp;&amp; !prohibited &amp;&amp; !filtered;</ins><del>    return result;</del></p></div><div class="ps" psname="aarch64.debug.statisticalprofiling.CheckProfilingBufferAccess"><a id="aarch64.debug.statisticalprofiling.CheckProfilingBufferAccess" name="aarch64.debug.statisticalprofiling.CheckProfilingBufferAccess"></a><h3 class="pseudocode">
            Library pseudocode for <ins>aarch64</ins><del>aarch32</del>/<ins>debug</ins><del>translation</del>/<ins>statisticalprofiling</ins><del>walk</del>/<ins>CheckProfilingBufferAccess</ins><del>AArch32.TranslationTableWalkSD</del></h3><p class="pseudocode"><ins>// CheckProfilingBufferAccess()
// ============================
</ins><del>// AArch32.TranslationTableWalkSD()
// ================================
// Returns a result of a translation table walk using the Short-descriptor format
//
// Implementations might cache information from memory in any number of non-coherent TLB
// caching structures, and so avoid memory accesses that have been expressed in this
// pseudocode. The use of such TLBs is not expressed in this pseudocode.
</del>
<ins>SysRegAccess</ins><del>TLBRecord</del> <a id="impl-aarch64.CheckProfilingBufferAccess.0" name="impl-aarch64.CheckProfilingBufferAccess.0"></a><ins>CheckProfilingBufferAccess()
    if !</ins><del>AArch32.TranslationTableWalkSD(bits(32) vaddress,</del><a href="shared_pseudocode.html#impl-shared.HaveStatisticalProfiling.0" title="function: boolean HaveStatisticalProfiling()"><ins>HaveStatisticalProfiling</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><ins>() || PSTATE.EL ==</ins><del>acctype, boolean iswrite,
                                         integer size)
    assert</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a> <ins>||</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><ins>() then
        return</ins><del>());

    // This is only called when address translation is enabled</del> <a href="shared_pseudocode.html#SysRegAccess_UNDEFINED" title="enumeration SysRegAccess { SysRegAccess_OK, SysRegAccess_UNDEFINED, SysRegAccess_TrapToEL1, SysRegAccess_TrapToEL2, SysRegAccess_TrapToEL3 }"><ins>SysRegAccess_UNDEFINED</ins></a><a href="shared_pseudocode.html#TLBRecord" title="type TLBRecord is ( Permissions perms, bit nG, bits(4) domain, bit GP, boolean contiguous, integer level, integer blocksize, DescriptorUpdate descupdate, bit CnP, AddressDescriptor addrdesc )"><del>TLBRecord</del></a><ins>;

    if</ins><del>result;</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><del>AddressDescriptor</del></a><ins>() &amp;&amp; PSTATE.EL ==</ins><del>l1descaddr;</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><del>AddressDescriptor</del></a> <ins>&amp;&amp; MDCR_EL2.E2PB&lt;0> != '1' then
        return</ins><del>l2descaddr;
    bits(40)      outputaddress;

    // Variables for Abort functions
    ipaddress = bits(40) UNKNOWN;
    secondstage = FALSE;
    s2fs1walk = FALSE;
    NS = bit UNKNOWN;

    // Default setting of the domain
    domain = bits(4) UNKNOWN;

    // Determine correct Translation Table Base Register to use.
    bits(64) ttbr;
    n =</del> <a href="shared_pseudocode.html#SysRegAccess_TrapToEL2" title="enumeration SysRegAccess { SysRegAccess_OK, SysRegAccess_UNDEFINED, SysRegAccess_TrapToEL1, SysRegAccess_TrapToEL2, SysRegAccess_TrapToEL3 }"><ins>SysRegAccess_TrapToEL2</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>;

    if</ins><del>(TTBCR.N);
    if n == 0 ||</del> <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(vaddress&lt;31:(32-n)>) then
        ttbr = TTBR0;
        disabled = (TTBCR.PD0 == '1');
    else
        ttbr = TTBR1;
        disabled = (TTBCR.PD1 == '1');
        n = 0;  // TTBR1 translation always works like N=0 TTBR0 translation

    // Check this Translation Table Base Register is not disabled.
    if disabled then
        level = 1;
        result.addrdesc.fault = </del><a href="shared_pseudocode.html#AArch32.TranslationFault.7" title="function: FaultRecord AArch32.TranslationFault(bits(40) ipaddress,  bits(4) domain, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><del>AArch32.TranslationFault</del></a><del>(ipaddress, domain, level, acctype, iswrite,
                                                         secondstage, s2fs1walk);
        return result;

    // Obtain descriptor from initial lookup.
    l1descaddr.paddress.address = </del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><del>(ttbr&lt;31:14-n>:vaddress&lt;31-n:20>:'00');
    l1descaddr.paddress.NS = if </del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>() then '0' else '1';
    IRGN = ttbr&lt;0>:ttbr&lt;6>;             // TTBR.IRGN
    RGN = ttbr&lt;4:3>;                    // TTBR.RGN
    SH = ttbr&lt;1>:ttbr&lt;5>;               // TTBR.S:TTBR.NOS
    l1descaddr.memattrs = </del><a href="shared_pseudocode.html#impl-shared.WalkAttrDecode.4" title="function: MemoryAttributes WalkAttrDecode(bits(2) SH, bits(2) ORGN, bits(2) IRGN, boolean secondstage)"><del>WalkAttrDecode</del></a><del>(SH, RGN, IRGN, secondstage);

    if !</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>) &amp;&amp; PSTATE.EL !=</ins><del>) || (</del> <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a> <ins>&amp;&amp; MDCR_EL3.NSPB != SCR_EL3.NS:'1' then
        return</ins><del>() &amp;&amp; !</del> <a href="shared_pseudocode.html#SysRegAccess_TrapToEL3" title="enumeration SysRegAccess { SysRegAccess_OK, SysRegAccess_UNDEFINED, SysRegAccess_TrapToEL1, SysRegAccess_TrapToEL2, SysRegAccess_TrapToEL3 }"><ins>SysRegAccess_TrapToEL3</ins></a><a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()"><del>IsSecureEL2Enabled</del></a><ins>;

    return</ins><del>()) then
        // if only 1 stage of translation
        l1descaddr2 = l1descaddr;
    else
        l1descaddr2 =</del> <del>(l1descaddr, vaddress, acctype, iswrite, 4);
        // Check for a fault on the stage 2 walk
        if </del><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><del>(l1descaddr2) then
            result.addrdesc.fault = l1descaddr2.fault;
            return result;

    // Update virtual address for abort functions
    l1descaddr2.vaddress = </del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><del>(vaddress);

    accdesc = CreateAccessDescriptorPTW(acctype, secondstage, s2fs1walk, level);
    l1desc = _Mem[l1descaddr2, 4,accdesc];

    if SCTLR.EE == '1' then l1desc = </del><a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)"><del>BigEndianReverse</del></a><del>(l1desc);

    // Process descriptor from initial lookup.
    case l1desc&lt;1:0> of
        when '00'                                              // Fault, Reserved
            level = 1;
            result.addrdesc.fault = </del><a href="shared_pseudocode.html#AArch32.TranslationFault.7" title="function: FaultRecord AArch32.TranslationFault(bits(40) ipaddress,  bits(4) domain, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><del>AArch32.TranslationFault</del></a><del>(ipaddress, domain, level, acctype,
                                                             iswrite, secondstage, s2fs1walk);
            return result;

        when '01'                                              // Large page or Small page
            domain = l1desc&lt;8:5>;
            level = 2;
            pxn = l1desc&lt;2>;
            NS = l1desc&lt;3>;

            // Obtain descriptor from level 2 lookup.
            l2descaddr.paddress.address = </del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><del>(l1desc&lt;31:10>:vaddress&lt;19:12>:'00');
            l2descaddr.paddress.NS = if </del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>() then '0' else '1';
            l2descaddr.memattrs = l1descaddr.memattrs;

            if !</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) || (</del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>() &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()"><del>IsSecureEL2Enabled</del></a><del>()) then
                // if only 1 stage of translation
                l2descaddr2 = l2descaddr;
            else
                l2descaddr2 = </del><a href="shared_pseudocode.html#AArch32.SecondStageWalk.5" title="function: AddressDescriptor AArch32.SecondStageWalk(AddressDescriptor S1, bits(32) vaddress, AccType acctype, boolean iswrite, integer size)"><del>AArch32.SecondStageWalk</del></a><del>(l2descaddr, vaddress, acctype, iswrite, 4);
                // Check for a fault on the stage 2 walk
                if </del><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><del>(l2descaddr2) then
                    result.addrdesc.fault = l2descaddr2.fault;
                    return result;

            // Update virtual address for abort functions
            l2descaddr2.vaddress = </del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><del>(vaddress);

            accdesc = CreateAccessDescriptorPTW(acctype, secondstage, s2fs1walk, level);
            l2desc = _Mem[l2descaddr2, 4, accdesc];

            if SCTLR.EE == '1' then l2desc = </del><a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)"><del>BigEndianReverse</del></a><del>(l2desc);

            // Process descriptor from level 2 lookup.
            if l2desc&lt;1:0> == '00' then
                result.addrdesc.fault = </del><a href="shared_pseudocode.html#AArch32.TranslationFault.7" title="function: FaultRecord AArch32.TranslationFault(bits(40) ipaddress,  bits(4) domain, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><del>AArch32.TranslationFault</del></a><del>(ipaddress, domain, level, acctype,
                                                                 iswrite, secondstage, s2fs1walk);
                return result;

            nG = l2desc&lt;11>;
            S = l2desc&lt;10>;
            ap = l2desc&lt;9,5:4>;

            if SCTLR.AFE == '1' &amp;&amp; l2desc&lt;4> == '0' then
                // ARMv8 VMSAv8-32 does not support hardware management of the Access flag.
                result.addrdesc.fault = </del><a href="shared_pseudocode.html#AArch32.AccessFlagFault.7" title="function: FaultRecord AArch32.AccessFlagFault(bits(40) ipaddress, bits(4) domain, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><del>AArch32.AccessFlagFault</del></a><del>(ipaddress, domain, level, acctype,
                                                                iswrite, secondstage, s2fs1walk);
                return result;

            if l2desc&lt;1> == '0' then                           // Large page
                xn = l2desc&lt;15>;
                tex = l2desc&lt;14:12>;
                c = l2desc&lt;3>;
                b = l2desc&lt;2>;
                blocksize = 64;
                outputaddress = </del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><del>(l2desc&lt;31:16>:vaddress&lt;15:0>);
            else                                               // Small page
                tex = l2desc&lt;8:6>;
                c = l2desc&lt;3>;
                b = l2desc&lt;2>;
                xn = l2desc&lt;0>;
                blocksize = 4;
                outputaddress = </del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><del>(l2desc&lt;31:12>:vaddress&lt;11:0>);

        when '1x'                                              // Section or Supersection
            NS = l1desc&lt;19>;
            nG = l1desc&lt;17>;
            S = l1desc&lt;16>;
            ap = l1desc&lt;15,11:10>;
            tex = l1desc&lt;14:12>;
            xn = l1desc&lt;4>;
            c = l1desc&lt;3>;
            b = l1desc&lt;2>;
            pxn = l1desc&lt;0>;
            level = 1;

            if SCTLR.AFE == '1' &amp;&amp; l1desc&lt;10> == '0' then
                // ARMv8 VMSAv8-32 does not support hardware management of the Access flag.
                result.addrdesc.fault = </del><a href="shared_pseudocode.html#AArch32.AccessFlagFault.7" title="function: FaultRecord AArch32.AccessFlagFault(bits(40) ipaddress, bits(4) domain, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><del>AArch32.AccessFlagFault</del></a><del>(ipaddress, domain, level, acctype,
                                                                iswrite, secondstage, s2fs1walk);
                return result;

            if l1desc&lt;18> == '0' then                          // Section
                domain = l1desc&lt;8:5>;
                blocksize = 1024;
                outputaddress = </del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><del>(l1desc&lt;31:20>:vaddress&lt;19:0>);
            else                                               // Supersection
                domain = '0000';
                blocksize = 16384;
                outputaddress = l1desc&lt;8:5>:l1desc&lt;23:20>:l1desc&lt;31:24>:vaddress&lt;23:0>;

    // Decode the TEX, C, B and S bits to produce the TLBRecord's memory attributes
    if SCTLR.TRE == '0' then
        if </del><a href="shared_pseudocode.html#impl-aarch32.RemapRegsHaveResetValues.0" title="function: boolean RemapRegsHaveResetValues()"><del>RemapRegsHaveResetValues</del></a><del>() then
            result.addrdesc.memattrs = </del><a href="shared_pseudocode.html#AArch32.DefaultTEXDecode.5" title="function: MemoryAttributes AArch32.DefaultTEXDecode(bits(3) TEX, bit C, bit B, bit S, AccType acctype)"><del>AArch32.DefaultTEXDecode</del></a><del>(tex, c, b, S, acctype);
        else
            result.addrdesc.memattrs = </del><a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType type, DeviceType device, MemAttrHints inner, MemAttrHints outer, boolean tagged, boolean shareable, boolean outershareable )"><del>MemoryAttributes</del></a><del> IMPLEMENTATION_DEFINED;
    else
        result.addrdesc.memattrs = </del><a href="shared_pseudocode.html#AArch32.RemappedTEXDecode.5" title="function: MemoryAttributes AArch32.RemappedTEXDecode(bits(3) TEX, bit C, bit B, bit S, AccType acctype)"><del>AArch32.RemappedTEXDecode</del></a><del>(tex, c, b, S, acctype);

    // Set the rest of the TLBRecord, try to add it to the TLB, and return it.
    result.perms.ap = ap;
    result.perms.xn = xn;
    result.perms.pxn = pxn;
    result.nG = nG;
    result.domain = domain;
    result.level = level;
    result.blocksize = blocksize;
    result.addrdesc.paddress.address = </del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><del>(outputaddress);
    result.addrdesc.paddress.NS = if </del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>() then NS else '1';
    result.addrdesc.fault = </del><a href="shared_pseudocode.html#AArch32.NoFault.0" title="function: FaultRecord AArch32.NoFault()"><del>AArch32.NoFault</del></a><a href="shared_pseudocode.html#SysRegAccess_OK" title="enumeration SysRegAccess { SysRegAccess_OK, SysRegAccess_UNDEFINED, SysRegAccess_TrapToEL1, SysRegAccess_TrapToEL2, SysRegAccess_TrapToEL3 }"><ins>SysRegAccess_OK</ins></a><a href="shared_pseudocode.html#AArch32.SecondStageWalk.5" title="function: AddressDescriptor AArch32.SecondStageWalk(AddressDescriptor S1, bits(32) vaddress, AccType acctype, boolean iswrite, integer size)"><del>AArch32.SecondStageWalk</del></a><ins>;</ins><del>();

    return result;</del></p></div><div class="ps" psname="aarch64.debug.statisticalprofiling.CheckStatisticalProfilingAccess"><a id="aarch64.debug.statisticalprofiling.CheckStatisticalProfilingAccess" name="aarch64.debug.statisticalprofiling.CheckStatisticalProfilingAccess"></a><h3 class="pseudocode">
            Library pseudocode for <ins>aarch64</ins><del>aarch32</del>/<ins>debug</ins><del>translation</del>/<ins>statisticalprofiling</ins><del>walk</del>/<ins>CheckStatisticalProfilingAccess</ins><del>RemapRegsHaveResetValues</del></h3><p class="pseudocode"><ins>// CheckStatisticalProfilingAccess()
// =================================

SysRegAccess</ins><del>boolean</del> <a id="impl-aarch64.CheckStatisticalProfilingAccess.0" name="impl-aarch64.CheckStatisticalProfilingAccess.0"></a><ins>CheckStatisticalProfilingAccess()
    if !</ins><del>RemapRegsHaveResetValues();</del><a href="shared_pseudocode.html#impl-shared.HaveStatisticalProfiling.0" title="function: boolean HaveStatisticalProfiling()"><ins>HaveStatisticalProfiling</ins></a><ins>() || PSTATE.EL == </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins> || </ins><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>() then
        return </ins><a href="shared_pseudocode.html#SysRegAccess_UNDEFINED" title="enumeration SysRegAccess { SysRegAccess_OK, SysRegAccess_UNDEFINED, SysRegAccess_TrapToEL1, SysRegAccess_TrapToEL2, SysRegAccess_TrapToEL3 }"><ins>SysRegAccess_UNDEFINED</ins></a><ins>;

    if </ins><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>() &amp;&amp; PSTATE.EL == </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins> &amp;&amp; MDCR_EL2.TPMS == '1' then
        return </ins><a href="shared_pseudocode.html#SysRegAccess_TrapToEL2" title="enumeration SysRegAccess { SysRegAccess_OK, SysRegAccess_UNDEFINED, SysRegAccess_TrapToEL1, SysRegAccess_TrapToEL2, SysRegAccess_TrapToEL3 }"><ins>SysRegAccess_TrapToEL2</ins></a><ins>;

    if </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; PSTATE.EL != </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins> &amp;&amp; MDCR_EL3.NSPB != SCR_EL3.NS:'1' then
        return </ins><a href="shared_pseudocode.html#SysRegAccess_TrapToEL3" title="enumeration SysRegAccess { SysRegAccess_OK, SysRegAccess_UNDEFINED, SysRegAccess_TrapToEL1, SysRegAccess_TrapToEL2, SysRegAccess_TrapToEL3 }"><ins>SysRegAccess_TrapToEL3</ins></a><ins>;

    return </ins><a href="shared_pseudocode.html#SysRegAccess_OK" title="enumeration SysRegAccess { SysRegAccess_OK, SysRegAccess_UNDEFINED, SysRegAccess_TrapToEL1, SysRegAccess_TrapToEL2, SysRegAccess_TrapToEL3 }"><ins>SysRegAccess_OK</ins></a><ins>;</ins></p></div><div class="ps" psname="aarch64.debug.statisticalprofiling.CollectContextIDR1"><a id="aarch64.debug.statisticalprofiling.CollectContextIDR1" name="aarch64.debug.statisticalprofiling.CollectContextIDR1"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/<ins>statisticalprofiling</ins><del>breakpoint</del>/<ins>CollectContextIDR1</ins><del>AArch64.BreakpointMatch</del></h3><p class="pseudocode"><ins>// CollectContextIDR1()
// ====================
</ins><del>// AArch64.BreakpointMatch()
// =========================
// Breakpoint matching in an AArch64 translation regime.
</del>
boolean <a id="impl-aarch64.CollectContextIDR1.0" name="impl-aarch64.CollectContextIDR1.0"></a><ins>CollectContextIDR1()
    if !</ins><del>AArch64.BreakpointMatch(integer n, bits(64) vaddress,</del><a href="shared_pseudocode.html#impl-aarch64.StatisticalProfilingEnabled.0" title="function: boolean StatisticalProfilingEnabled()"><ins>StatisticalProfilingEnabled</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><ins>() then return FALSE;
    if  PSTATE.EL ==</ins><del>acctype, integer size)
    assert !</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a> <ins>then return FALSE;
    if</ins><del>(</del> <del>());
    assert n &lt;= </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(ID_AA64DFR0_EL1.BRPs);

    enabled = DBGBCR_EL1[n].E == '1';
    ispriv = PSTATE.EL != </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>;
    linked = DBGBCR_EL1[n].BT == '0x01';
    isbreakpnt = TRUE;
    linked_to = FALSE;

    state_match = </del><a href="shared_pseudocode.html#AArch64.StateMatch.8" title="function: boolean AArch64.StateMatch(bits(2) SSC, bit HMC, bits(2) PxC, boolean linked, bits(4) LBN, boolean isbreakpnt, AccType acctype, boolean ispriv)"><del>AArch64.StateMatch</del></a><del>(DBGBCR_EL1[n].SSC, DBGBCR_EL1[n].HMC, DBGBCR_EL1[n].PMC,
                                     linked, DBGBCR_EL1[n].LBN, isbreakpnt, acctype, ispriv);
    value_match = </del><a href="shared_pseudocode.html#AArch64.BreakpointValueMatch.3" title="function: boolean AArch64.BreakpointValueMatch(integer n, bits(64) vaddress, boolean linked_to)"><del>AArch64.BreakpointValueMatch</del></a><del>(n, vaddress, linked_to);

    if </del><a href="shared_pseudocode.html#impl-shared.HaveAnyAArch32.0" title="function: boolean HaveAnyAArch32()"><del>HaveAnyAArch32</del></a><del>() &amp;&amp; size == 4 then                 // Check second halfword
        // If the breakpoint address and BAS of an Address breakpoint match the address of the
        // second halfword of an instruction, but not the address of the first halfword, it is
        // CONSTRAINED UNPREDICTABLE whether or not this breakpoint generates a Breakpoint debug
        // event.
        match_i = </del><a href="shared_pseudocode.html#AArch64.BreakpointValueMatch.3" title="function: boolean AArch64.BreakpointValueMatch(integer n, bits(64) vaddress, boolean linked_to)"><del>AArch64.BreakpointValueMatch</del></a><del>(n, vaddress + 2, linked_to);
        if !value_match &amp;&amp; match_i then
            value_match = </del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><del>ConstrainUnpredictableBool</del></a><del>(</del><a href="shared_pseudocode.html#Unpredictable_BPMATCHHALF" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_BPMATCHHALF</del></a><del>);

    if vaddress&lt;1> == '1' &amp;&amp; DBGBCR_EL1[n].BAS == '1111' then
        // The above notwithstanding, if DBGBCR_EL1[n].BAS == '1111', then it is CONSTRAINED
        // UNPREDICTABLE whether or not a Breakpoint debug event is generated for an instruction
        // at the address DBGBVR_EL1[n]+2.
        if value_match then value_match = </del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><del>ConstrainUnpredictableBool</del></a><del>(</del><a href="shared_pseudocode.html#Unpredictable_BPMATCHHALF" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_BPMATCHHALF</del></a><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><ins>() &amp;&amp; HCR_EL2.TGE == '1' then return FALSE;
    return PMSCR_EL1.CX == '1';</ins><del>);

    match = value_match &amp;&amp; state_match &amp;&amp; enabled;

    return match;</del></p></div><div class="ps" psname="aarch64.debug.statisticalprofiling.CollectContextIDR2"><a id="aarch64.debug.statisticalprofiling.CollectContextIDR2" name="aarch64.debug.statisticalprofiling.CollectContextIDR2"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/<ins>statisticalprofiling</ins><del>breakpoint</del>/<ins>CollectContextIDR2</ins><del>AArch64.BreakpointValueMatch</del></h3><p class="pseudocode"><ins>// CollectContextIDR2()
// ====================
</ins><del>// AArch64.BreakpointValueMatch()
// ==============================
</del>
boolean <a id="impl-aarch64.CollectContextIDR2.0" name="impl-aarch64.CollectContextIDR2.0"></a><ins>CollectContextIDR2()
    if !</ins><del>AArch64.BreakpointValueMatch(integer n, bits(64) vaddress, boolean linked_to)

    // "n" is the identity of the breakpoint unit to match against.
    // "vaddress" is the current instruction address, ignored if linked_to is TRUE and for Context
    //   matching breakpoints.
    // "linked_to" is TRUE if this is a call from StateMatch for linking.

    // If a non-existent breakpoint then it is CONSTRAINED UNPREDICTABLE whether this gives
    // no match or the breakpoint is mapped to another UNKNOWN implemented breakpoint.
    if n ></del><a href="shared_pseudocode.html#impl-aarch64.StatisticalProfilingEnabled.0" title="function: boolean StatisticalProfilingEnabled()"><ins>StatisticalProfilingEnabled</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>() then return FALSE;
    if</ins><del>(ID_AA64DFR0_EL1.BRPs) then
        (c, n) =</del>  <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableInteger.3" title="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high, Unpredictable which)"><del>ConstrainUnpredictableInteger</del></a><del>(0, </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(ID_AA64DFR0_EL1.BRPs), </del><a href="shared_pseudocode.html#Unpredictable_BPNOTIMPL" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_BPNOTIMPL</del></a><del>);
        assert c IN {</del><a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_DISABLED</del></a><del>, </del><a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_UNKNOWN</del></a><del>};
        if c == </del><a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_DISABLED</del></a><del> then return FALSE;

    // If this breakpoint is not enabled, it cannot generate a match. (This could also happen on a
    // call from StateMatch for linking).
    if DBGBCR_EL1[n].E == '0' then return FALSE;

    context_aware = (n >= </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(ID_AA64DFR0_EL1.BRPs) - </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(ID_AA64DFR0_EL1.CTX_CMPs));

    // If BT is set to a reserved type, behaves either as disabled or as a not-reserved type.
    type = DBGBCR_EL1[n].BT;

    if ((type IN {'011x','11xx'} &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><del>HaveVirtHostExt</del></a><del>()) ||              // Context matching
          type == '010x' ||                                             // Reserved
          (type != '0x0x' &amp;&amp; !context_aware) ||                         // Context matching
          (type == '1xxx' &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>))) then                        // EL2 extension
        (c, type) = </del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)"><del>ConstrainUnpredictableBits</del></a><del>(</del><a href="shared_pseudocode.html#Unpredictable_RESBPTYPE" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESBPTYPE</del></a><del>);
        assert c IN {</del><a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_DISABLED</del></a><del>, </del><a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_UNKNOWN</del></a><del>};
        if c == </del><a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_DISABLED</del></a><del> then return FALSE;
        // Otherwise the value returned by ConstrainUnpredictableBits must be a not-reserved value

    // Determine what to compare against.
    match_addr = (type == '0x0x');
    match_vmid = (type == '10xx');
    match_cid  = (type == '001x');
    match_cid1 = (type IN { '101x', 'x11x'});
    match_cid2 = (type == '11xx');
    linked     = (type == 'xxx1');

    // If this is a call from StateMatch, return FALSE if the breakpoint is not programmed for a
    // VMID and/or context ID match, of if not context-aware. The above assertions mean that the
    // code can just test for match_addr == TRUE to confirm all these things.
    if linked_to &amp;&amp; (!linked || match_addr) then return FALSE;

    // If called from BreakpointMatch return FALSE for Linked context ID and/or VMID matches.
    if !linked_to &amp;&amp; linked &amp;&amp; !match_addr then return FALSE;

    // Do the comparison.
    if match_addr then
        byte = </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(vaddress&lt;1:0>);
        if </del><a href="shared_pseudocode.html#impl-shared.HaveAnyAArch32.0" title="function: boolean HaveAnyAArch32()"><del>HaveAnyAArch32</del></a><del>() then
            // T32 instructions can be executed at EL0 in an AArch64 translation regime.
            assert byte IN {0,2};                 // "vaddress" is halfword aligned
            byte_select_match = (DBGBCR_EL1[n].BAS&lt;byte> == '1');
        else
            assert byte == 0;                     // "vaddress" is word aligned
            byte_select_match = TRUE;             // DBGBCR_EL1[n].BAS&lt;byte> is RES1
        top = </del><a href="shared_pseudocode.html#impl-shared.AddrTop.3" title="function: integer AddrTop(bits(64) address, boolean IsInstr, bits(2) el)"><del>AddrTop</del></a><del>(vaddress, TRUE, PSTATE.EL);
        BVR_match = vaddress&lt;top:2> == DBGBVR_EL1[n]&lt;top:2> &amp;&amp; byte_select_match;
    elsif match_cid then
        if </del><a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><del>IsInHost</del></a><del>() then
            BVR_match = (CONTEXTIDR_EL2 == DBGBVR_EL1[n]&lt;31:0>);
        else
            BVR_match = (PSTATE.EL IN {</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>,</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>} &amp;&amp; CONTEXTIDR_EL1 == DBGBVR_EL1[n]&lt;31:0>);
    elsif match_cid1 then
        BVR_match = (PSTATE.EL IN {</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>,</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>} &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><del>IsInHost</del></a><del>() &amp;&amp; CONTEXTIDR_EL1 == DBGBVR_EL1[n]&lt;31:0>);
    if match_vmid then
        if !</del><a href="shared_pseudocode.html#impl-shared.Have16bitVMID.0" title="function: boolean Have16bitVMID()"><del>Have16bitVMID</del></a><del>() || VTCR_EL2.VS == '0' then
            vmid = </del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><del>ZeroExtend</del></a><del>(VTTBR_EL2.VMID&lt;7:0>, 16);
            bvr_vmid = </del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><del>ZeroExtend</del></a><del>(DBGBVR_EL1[n]&lt;39:32>, 16);
        else
            vmid = VTTBR_EL2.VMID;
            bvr_vmid = DBGBVR_EL1[n]&lt;47:32>;
        BXVR_match = (</del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a><del>() &amp;&amp; PSTATE.EL IN {</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>,</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>} &amp;&amp;
                      !</del><a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><del>IsInHost</del></a><del>() &amp;&amp;
                      vmid == bvr_vmid);
    elsif match_cid2 then
        BXVR_match = (!</del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>() &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><del>HaveVirtHostExt</del></a><ins>() then return FALSE;
    return PMSCR_EL2.CX == '1';</ins><del>() &amp;&amp;
                      DBGBVR_EL1[n]&lt;63:32> == CONTEXTIDR_EL2);

    bvr_match_valid = (match_addr || match_cid || match_cid1);
    bxvr_match_valid = (match_vmid || match_cid2);

    match = (!bxvr_match_valid || BXVR_match) &amp;&amp; (!bvr_match_valid || BVR_match);

    return match;</del></p></div><div class="ps" psname="aarch64.debug.statisticalprofiling.CollectPhysicalAddress"><a id="aarch64.debug.statisticalprofiling.CollectPhysicalAddress" name="aarch64.debug.statisticalprofiling.CollectPhysicalAddress"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/<ins>statisticalprofiling</ins><del>breakpoint</del>/<ins>CollectPhysicalAddress</ins><del>AArch64.StateMatch</del></h3><p class="pseudocode"><ins>// CollectPhysicalAddress()
// ========================
</ins><del>// AArch64.StateMatch()
// ====================
// Determine whether a breakpoint or watchpoint is enabled in the current mode and state.
</del>
boolean <a id="impl-aarch64.CollectPhysicalAddress.0" name="impl-aarch64.CollectPhysicalAddress.0"></a><ins>CollectPhysicalAddress()
    if !</ins><del>AArch64.StateMatch(bits(2) SSC, bit HMC, bits(2) PxC, boolean linked, bits(4) LBN,
                           boolean isbreakpnt,</del><a href="shared_pseudocode.html#impl-aarch64.StatisticalProfilingEnabled.0" title="function: boolean StatisticalProfilingEnabled()"><ins>StatisticalProfilingEnabled</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><ins>() then return FALSE;
    (secure, el) =</ins><del>acctype, boolean ispriv)
    // "SSC", "HMC", "PxC" are the control fields from the DBGBCR[n] or DBGWCR[n] register.
    // "linked" is TRUE if this is a linked breakpoint/watchpoint type.
    // "LBN" is the linked breakpoint number from the DBGBCR[n] or DBGWCR[n] register.
    // "isbreakpnt" is TRUE for breakpoints, FALSE for watchpoints.
    // "ispriv" is valid for watchpoints, and selects between privileged and unprivileged accesses.

    // If parameters are set to a reserved type, behaves as either disabled or a defined type
    if ((HMC:SSC:PxC) IN {'011xx','100x0','101x0','11010','11101','1111x'} ||       // Reserved
          (HMC == '0' &amp;&amp; PxC == '00' &amp;&amp; (!isbreakpnt || !</del> <a href="shared_pseudocode.html#impl-aarch64.ProfilingBufferOwner.0" title="function: (boolean, bits(2)) ProfilingBufferOwner()"><ins>ProfilingBufferOwner</ins></a><a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)"><del>HaveAArch32EL</del></a><ins>();
    if !secure &amp;&amp;</ins><del>(</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>))) ||    // Usr/Svc/Sys
          (SSC IN {'01','10'} &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>)) ||                                   // No EL3
          (HMC:SSC != '000' &amp;&amp; HMC:SSC != '111' &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a><ins>) then
        return PMSCR_EL2.PA == '1' &amp;&amp; (el ==</ins><del>)) || // No EL3/EL2
          (HMC:SSC:PxC == '11100' &amp;&amp; !</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a><del>))) then                            // No EL2
        (c, &lt;HMC,SSC,PxC>) = </del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)"><del>ConstrainUnpredictableBits</del></a><del>(</del><a href="shared_pseudocode.html#Unpredictable_RESBPWPCTRL" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESBPWPCTRL</del></a><del>);
        assert c IN {</del><a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_DISABLED</del></a><del>, </del><a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_UNKNOWN</del></a><del>};
        if c == </del><a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_DISABLED</del></a><del> then return FALSE;
        // Otherwise the value returned by ConstrainUnpredictableBits must be a not-reserved value

    EL3_match = </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; HMC == '1' &amp;&amp; SSC&lt;0> == '0';
    EL2_match = </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) &amp;&amp; HMC == '1';
    EL1_match = PxC&lt;0> == '1';
    EL0_match = PxC&lt;1> == '1';

    el = if </del><a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()"><del>HaveNV2Ext</del></a><del>() &amp;&amp; acctype == </del><a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NV2REGISTER</del></a><del> then </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del> else PSTATE.EL;
    if !ispriv &amp;&amp; !isbreakpnt then
        priv_match = EL0_match;
    else
        case el of
            when </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>  priv_match = EL3_match;
            when </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>  priv_match = EL2_match;
            when </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>  priv_match = EL1_match;
            when </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>  priv_match = EL0_match;

    case SSC of
        when '00'  security_state_match = TRUE;         // Both
        when '01'  security_state_match = !</del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>();  // Non-secure only
        when '10'  security_state_match = </del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>();   // Secure only
        when '11'  security_state_match = TRUE;         // Both

    if linked then
        // "LBN" must be an enabled context-aware breakpoint unit. If it is not context-aware then
        // it is CONSTRAINED UNPREDICTABLE whether this gives no match, or LBN is mapped to some
        // UNKNOWN breakpoint that is context-aware.
        lbn = </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(LBN);
        first_ctx_cmp = (</del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(ID_AA64DFR0_EL1.BRPs) - </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(ID_AA64DFR0_EL1.CTX_CMPs));
        last_ctx_cmp = </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(ID_AA64DFR0_EL1.BRPs);
        if (lbn &lt; first_ctx_cmp || lbn > last_ctx_cmp) then
            (c, lbn) = </del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableInteger.3" title="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high, Unpredictable which)"><del>ConstrainUnpredictableInteger</del></a><del>(first_ctx_cmp, last_ctx_cmp, </del><a href="shared_pseudocode.html#Unpredictable_BPNOTCTXCMP" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_BPNOTCTXCMP</del></a><del>);
            assert c IN {</del><a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_DISABLED</del></a><del>, </del><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_NONE</del></a><del>, </del><a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_UNKNOWN</del></a><del>};
            case c of
                when </del><a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_DISABLED</del></a><del>  return FALSE;      // Disabled
                when </del><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_NONE</del></a><del>      linked = FALSE;    // No linking
                // Otherwise ConstrainUnpredictableInteger returned a context-aware breakpoint

    if linked then
        vaddress = bits(64) UNKNOWN;
        linked_to = TRUE;
        linked_match = </del><a href="shared_pseudocode.html#AArch64.BreakpointValueMatch.3" title="function: boolean AArch64.BreakpointValueMatch(integer n, bits(64) vaddress, boolean linked_to)"><del>AArch64.BreakpointValueMatch</del></a> <ins>|| PMSCR_EL1.PA == '1');
    else
        return PMSCR_EL1.PA == '1';</ins><del>(lbn, vaddress, linked_to);

    return priv_match &amp;&amp; security_state_match &amp;&amp; (!linked || linked_match);</del></p></div><div class="ps" psname="aarch64.debug.statisticalprofiling.CollectRecord"><a id="aarch64.debug.statisticalprofiling.CollectRecord" name="aarch64.debug.statisticalprofiling.CollectRecord"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/<ins>statisticalprofiling</ins><del>enables</del>/<ins>CollectRecord</ins><del>AArch64.GenerateDebugExceptions</del></h3><p class="pseudocode"><ins>// CollectRecord()
// ===============
</ins><del>// AArch64.GenerateDebugExceptions()
// =================================
</del>
boolean <a id="impl-aarch64.CollectRecord.3" name="impl-aarch64.CollectRecord.3"></a><ins>CollectRecord(bits(64) events, integer total_latency,</ins><del>AArch64.GenerateDebugExceptions()
    return</del> <a href="shared_pseudocode.html#OpType" title="enumeration OpType { OpType_Load, OpType_Store, OpType_LoadAtomic, OpType_Branch, OpType_Other }"><ins>OpType</ins></a><a href="shared_pseudocode.html#AArch64.GenerateDebugExceptionsFrom.3" title="function: boolean AArch64.GenerateDebugExceptionsFrom(bits(2) from, boolean secure, bit mask)"><del>AArch64.GenerateDebugExceptionsFrom</del></a> <ins>optype)
    assert</ins><del>(PSTATE.EL,</del> <a href="shared_pseudocode.html#impl-aarch64.StatisticalProfilingEnabled.0" title="function: boolean StatisticalProfilingEnabled()"><ins>StatisticalProfilingEnabled</ins></a><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><ins>();
    if PMSFCR_EL1.FE == '1' then
        e = events&lt;63:48,31:24,15:12,7,5,3,1>;
        m = PMSEVFR_EL1&lt;63:48,31:24,15:12,7,5,3,1>;
        // Check for UNPREDICTABLE case
        if </ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(PMSEVFR_EL1) &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><ins>ConstrainUnpredictableBool</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_ZEROPMSEVFR" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_ZEROPMSEVFR</ins></a><ins>) then return FALSE;
        if !</ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(NOT(e) AND m) then return FALSE;
    if PMSFCR_EL1.FT == '1' then
        // Check for UNPREDICTABLE case
        if </ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(PMSFCR_EL1.&lt;B,LD,ST>) &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><ins>ConstrainUnpredictableBool</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_NOOPTYPES" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_NOOPTYPES</ins></a><ins>) then
            return FALSE;
        case optype of
            when </ins><a href="shared_pseudocode.html#OpType_Branch" title="enumeration OpType { OpType_Load, OpType_Store, OpType_LoadAtomic, OpType_Branch, OpType_Other }"><ins>OpType_Branch</ins></a><ins> if PMSFCR_EL1.B == '0' then return FALSE;
            when </ins><a href="shared_pseudocode.html#OpType_Load" title="enumeration OpType { OpType_Load, OpType_Store, OpType_LoadAtomic, OpType_Branch, OpType_Other }"><ins>OpType_Load</ins></a><ins> if PMSFCR_EL1.LD == '0' then return FALSE;
            when </ins><a href="shared_pseudocode.html#OpType_Store" title="enumeration OpType { OpType_Load, OpType_Store, OpType_LoadAtomic, OpType_Branch, OpType_Other }"><ins>OpType_Store</ins></a><ins> if PMSFCR_EL1.ST == '0' then return FALSE;
            when </ins><a href="shared_pseudocode.html#OpType_LoadAtomic" title="enumeration OpType { OpType_Load, OpType_Store, OpType_LoadAtomic, OpType_Branch, OpType_Other }"><ins>OpType_LoadAtomic</ins></a><ins> if PMSFCR_EL1.&lt;LD,ST> == '00' then return FALSE;
            otherwise return FALSE;
    if PMSFCR_EL1.FL == '1' then
        if </ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(PMSLATFR_EL1.MINLAT) &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><ins>ConstrainUnpredictableBool</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_ZEROMINLATENCY" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_ZEROMINLATENCY</ins></a><ins>) then // UNPREDICTABLE case
            return FALSE;
        if total_latency &lt; </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(PMSLATFR_EL1.MINLAT) then return FALSE;
    return TRUE;</ins><del>(), PSTATE.D);</del></p></div><div class="ps" psname="aarch64.debug.statisticalprofiling.CollectTimeStamp"><a id="aarch64.debug.statisticalprofiling.CollectTimeStamp" name="aarch64.debug.statisticalprofiling.CollectTimeStamp"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/<ins>statisticalprofiling</ins><del>enables</del>/<ins>CollectTimeStamp</ins><del>AArch64.GenerateDebugExceptionsFrom</del></h3><p class="pseudocode"><ins>// CollectTimeStamp()
// ==================
</ins><del>// AArch64.GenerateDebugExceptionsFrom()
// =====================================
</del>
<ins>TimeStamp</ins><del>boolean</del> <a id="impl-aarch64.CollectTimeStamp.0" name="impl-aarch64.CollectTimeStamp.0"></a><ins>CollectTimeStamp()
    if !</ins><del>AArch64.GenerateDebugExceptionsFrom(bits(2) from, boolean secure, bit mask)

    if OSLSR_EL1.OSLK == '1' ||</del><a href="shared_pseudocode.html#impl-aarch64.StatisticalProfilingEnabled.0" title="function: boolean StatisticalProfilingEnabled()"><ins>StatisticalProfilingEnabled</ins></a><a href="shared_pseudocode.html#impl-shared.DoubleLockStatus.0" title="function: boolean DoubleLockStatus()"><del>DoubleLockStatus</del></a><ins>() then return</ins><del>() ||</del> <a href="shared_pseudocode.html#TimeStamp_None" title="enumeration TimeStamp { TimeStamp_None, TimeStamp_Virtual, TimeStamp_Physical }"><ins>TimeStamp_None</ins></a><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><del>Halted</del></a><ins>;
    (secure, el) =</ins><del>() then
        return FALSE;

    route_to_el2 =</del> <a href="shared_pseudocode.html#impl-aarch64.ProfilingBufferOwner.0" title="function: (boolean, bits(2)) ProfilingBufferOwner()"><ins>ProfilingBufferOwner</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>();
    if el ==</ins><del>(</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> <ins>then
        if PMSCR_EL2.TS == '0' then return</ins><del>) &amp;&amp; !secure &amp;&amp; (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1');
    target = (if route_to_el2 then</del> <a href="shared_pseudocode.html#TimeStamp_None" title="enumeration TimeStamp { TimeStamp_None, TimeStamp_Virtual, TimeStamp_Physical }"><ins>TimeStamp_None</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>;
    else
        if PMSCR_EL1.TS == '0' then return</ins><del>else</del> <a href="shared_pseudocode.html#TimeStamp_None" title="enumeration TimeStamp { TimeStamp_None, TimeStamp_Virtual, TimeStamp_Physical }"><ins>TimeStamp_None</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>;
    if</ins><del>);

    enabled = !</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>() then
        pct = PMSCR_EL2.PCT == '1' &amp;&amp; (el ==</ins><del>(</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a> <ins>|| PMSCR_EL1.PCT == '1');
</ins><del>) || !secure || MDCR_EL3.SDD == '0';

    if from == target then
        enabled = enabled &amp;&amp; MDSCR_EL1.KDE == '1' &amp;&amp; mask == '0';
</del>    else
<ins>        pct = PMSCR_EL1.PCT == '1';
    return (if pct then</ins><del>        enabled = enabled &amp;&amp;</del> <a href="shared_pseudocode.html#TimeStamp_Physical" title="enumeration TimeStamp { TimeStamp_None, TimeStamp_Virtual, TimeStamp_Physical }"><ins>TimeStamp_Physical</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a> <ins>else</ins><del>(target) ></del> <a href="shared_pseudocode.html#TimeStamp_Virtual" title="enumeration TimeStamp { TimeStamp_None, TimeStamp_Virtual, TimeStamp_Physical }"><ins>TimeStamp_Virtual</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>);</ins><del>(from);

    return enabled;</del></p></div><div class="ps" psname="aarch64.debug.statisticalprofiling.OpType"><a id="aarch64.debug.statisticalprofiling.OpType" name="aarch64.debug.statisticalprofiling.OpType"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/<ins>statisticalprofiling</ins><del>pmu</del>/<ins>OpType</ins><del>AArch64.CheckForPMUOverflow</del></h3><p class="pseudocode"><ins>enumeration</ins><del>// AArch64.CheckForPMUOverflow()
// =============================
// Signal Performance Monitors overflow IRQ and CTI overflow events

boolean</del> <a id="OpType" name="OpType"></a><ins>OpType {</ins><del>AArch64.CheckForPMUOverflow()

    pmuirq = PMCR_EL0.E == '1' &amp;&amp; PMINTENSET_EL1&lt;31> == '1' &amp;&amp; PMOVSSET_EL0&lt;31> == '1';
    for n = 0 to</del>
 <a id="OpType_Load" name="OpType_Load"></a><ins>OpType_Load,                 // Any memory-read operation other than atomics, compare-and-swap, and swap</ins><del>(PMCR_EL0.N) - 1
        if</del>
 <a id="OpType_Store" name="OpType_Store"></a><ins>OpType_Store,                // Any memory-write operation, including atomics without return</ins><del>(</del>
 <a id="OpType_LoadAtomic" name="OpType_LoadAtomic"></a><ins>OpType_LoadAtomic,           // Atomics with return, compare-and-swap and swap</ins><del>) then
            E = (if n &lt;</del>
 <a id="OpType_Branch" name="OpType_Branch"></a><ins>OpType_Branch,               // Software write to the PC</ins><del>(MDCR_EL2.HPMN) then PMCR_EL0.E else MDCR_EL2.HPME);
        else
            E = PMCR_EL0.E;
        if E == '1' &amp;&amp; PMINTENSET_EL1&lt;n> == '1' &amp;&amp; PMOVSSET_EL0&lt;n> == '1' then pmuirq = TRUE;

    SetInterruptRequestLevel(</del>
 <del>, if pmuirq then HIGH else LOW);

    CTI_SetEventLevel(</del><a href="shared_pseudocode.html#CrossTriggerIn_PMUOverflow" title="enumeration CrossTriggerIn  {CrossTriggerIn_CrossHalt,     CrossTriggerIn_PMUOverflow, CrossTriggerIn_RSVD2,         CrossTriggerIn_RSVD3, CrossTriggerIn_TraceExtOut0,  CrossTriggerIn_TraceExtOut1, CrossTriggerIn_TraceExtOut2,  CrossTriggerIn_TraceExtOut3}"><del>CrossTriggerIn_PMUOverflow</del></a><a id="OpType_Other" name="OpType_Other"></a><ins>OpType_Other                 // Any other class of operation
 };</ins><del>, if pmuirq then HIGH else LOW);

    // The request remains set until the condition is cleared. (For example, an interrupt handler
    // or cross-triggered event handler clears the overflow status flag by writing to PMOVSCLR_EL0.)

    return pmuirq;</del></p></div><div class="ps" psname="aarch64.debug.statisticalprofiling.ProfilingBufferEnabled"><a id="aarch64.debug.statisticalprofiling.ProfilingBufferEnabled" name="aarch64.debug.statisticalprofiling.ProfilingBufferEnabled"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/<ins>statisticalprofiling</ins><del>pmu</del>/<ins>ProfilingBufferEnabled</ins><del>AArch64.CountEvents</del></h3><p class="pseudocode"><ins>// ProfilingBufferEnabled()
// ========================
</ins><del>// AArch64.CountEvents()
// =====================
// Return TRUE if counter "n" should count its event. For the cycle counter, n == 31.
</del>
boolean <a id="impl-aarch64.ProfilingBufferEnabled.0" name="impl-aarch64.ProfilingBufferEnabled.0"></a><ins>ProfilingBufferEnabled()
    if !</ins><del>AArch64.CountEvents(integer n)
    assert n == 31 || n &lt;</del><a href="shared_pseudocode.html#impl-shared.HaveStatisticalProfiling.0" title="function: boolean HaveStatisticalProfiling()"><ins>HaveStatisticalProfiling</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>() then return FALSE;
    (secure, el) =</ins><del>(PMCR_EL0.N);

    // Event counting is disabled in Debug state
    debug =</del> <a href="shared_pseudocode.html#impl-aarch64.ProfilingBufferOwner.0" title="function: (boolean, bits(2)) ProfilingBufferOwner()"><ins>ProfilingBufferOwner</ins></a><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><del>Halted</del></a>();
<ins>    non_secure_bit = if secure then '0' else '1';
    return (!</ins><del>
    // In Non-secure state, some counters are reserved for EL2
    if</del><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) then
        E = if n &lt; </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(MDCR_EL2.HPMN) || n == 31 then PMCR_EL0.E else MDCR_EL2.HPME;
    else
        E = PMCR_EL0.E;
    enabled = E == '1' &amp;&amp; PMCNTENSET_EL0&lt;n> == '1';

    if !</del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>() then
        // Event counting in Non-secure state is allowed unless all of:
        // * EL2 and the HPMD Extension are implemented
        // * Executing at EL2
        // * PMNx is not reserved for EL2
        // * MDCR_EL2.HPMD == 1
        if </del><a href="shared_pseudocode.html#impl-shared.HaveHPMDExt.0" title="function: boolean HaveHPMDExt()"><del>HaveHPMDExt</del></a><del>() &amp;&amp; PSTATE.EL == </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del> &amp;&amp; (n &lt; </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(MDCR_EL2.HPMN) || n == 31) then
            prohibited = (MDCR_EL2.HPMD == '1');
        else
            prohibited = FALSE;
    else
        // Event counting in Secure state is prohibited unless any one of:
        // * EL3 is not implemented
        // * EL3 is using AArch64 and MDCR_EL3.SPME == 1
        prohibited = </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; MDCR_EL3.SPME == '0';

    // The IMPLEMENTATION DEFINED authentication interface might override software controls
    if prohibited &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.HaveNoSecurePMUDisableOverride.0" title="function: boolean HaveNoSecurePMUDisableOverride()"><del>HaveNoSecurePMUDisableOverride</del></a><del>() then
        prohibited = !</del><a href="shared_pseudocode.html#impl-shared.ExternalSecureNoninvasiveDebugEnabled.0" title="function: boolean ExternalSecureNoninvasiveDebugEnabled()"><del>ExternalSecureNoninvasiveDebugEnabled</del></a><del>();

    // For the cycle counter, PMCR_EL0.DP enables counting when otherwise prohibited
    if prohibited &amp;&amp; n == 31 then prohibited = (PMCR_EL0.DP == '1');

    // Event counting can be filtered by the {P, U, NSK, NSU, NSH, M} bits
    filter = if n == 31 then PMCCFILTR else PMEVTYPER[n];

    P = filter&lt;31>;
    U = filter&lt;30>;
    NSK = if </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) then filter&lt;29> else '0';
    NSU = if </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) then filter&lt;28> else '0';
    NSH = if </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) then filter&lt;27> else '0';
    M = if </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) then filter&lt;26> else '0';

    case PSTATE.EL of
        when </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>  filtered = if </del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>() then U == '1' else U != NSU;
        when </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>  filtered = if </del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>() then P == '1' else P != NSK;
        when </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>  filtered = (NSH == '0');
        when </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>(el) &amp;&amp; non_secure_bit == SCR_EL3.NS &amp;&amp;
            PMBLIMITR_EL1.E == '1' &amp;&amp; PMBSR_EL1.S == '0');</ins><del>filtered = (M != P);

    return !debug &amp;&amp; enabled &amp;&amp; !prohibited &amp;&amp; !filtered;</del></p></div><div class="ps" psname="aarch64.debug.statisticalprofiling.ProfilingBufferOwner"><a id="aarch64.debug.statisticalprofiling.ProfilingBufferOwner" name="aarch64.debug.statisticalprofiling.ProfilingBufferOwner"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/<ins>ProfilingBufferOwner</ins><del>CheckProfilingBufferAccess</del></h3><p class="pseudocode"><ins>// ProfilingBufferOwner()
// ======================
</ins><del>// CheckProfilingBufferAccess()
// ============================
</del>
<ins>(boolean, bits(2))</ins><del>SysRegAccess</del> <a id="impl-aarch64.ProfilingBufferOwner.0" name="impl-aarch64.ProfilingBufferOwner.0"></a><ins>ProfilingBufferOwner()
    secure = if</ins><del>CheckProfilingBufferAccess()
    if !</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-shared.HaveStatisticalProfiling.0" title="function: boolean HaveStatisticalProfiling()"><del>HaveStatisticalProfiling</del></a><ins>(</ins><del>() || PSTATE.EL ==</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>) then (MDCR_EL3.NSPB&lt;1> == '0') else</ins><del>||</del> <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><ins>();
    el = if !secure &amp;&amp;</ins><del>() then
        return</del> <a href="shared_pseudocode.html#SysRegAccess_UNDEFINED" title="enumeration SysRegAccess { SysRegAccess_OK, SysRegAccess_UNDEFINED, SysRegAccess_TrapToEL1, SysRegAccess_TrapToEL2, SysRegAccess_TrapToEL3 }"><del>SysRegAccess_UNDEFINED</del></a><del>;

    if </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; PSTATE.EL == </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del> &amp;&amp; MDCR_EL2.E2PB&lt;0> != '1' then
        return </del><a href="shared_pseudocode.html#SysRegAccess_TrapToEL2" title="enumeration SysRegAccess { SysRegAccess_OK, SysRegAccess_UNDEFINED, SysRegAccess_TrapToEL1, SysRegAccess_TrapToEL2, SysRegAccess_TrapToEL3 }"><del>SysRegAccess_TrapToEL2</del></a><del>;

    if </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><ins>) &amp;&amp; MDCR_EL2.E2PB == '00' then</ins><del>) &amp;&amp; PSTATE.EL !=</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a> <ins>else</ins><del>&amp;&amp; MDCR_EL3.NSPB != SCR_EL3.NS:'1' then
        return</del> <del>;

    return </del><a href="shared_pseudocode.html#SysRegAccess_OK" title="enumeration SysRegAccess { SysRegAccess_OK, SysRegAccess_UNDEFINED, SysRegAccess_TrapToEL1, SysRegAccess_TrapToEL2, SysRegAccess_TrapToEL3 }"><del>SysRegAccess_OK</del></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#SysRegAccess_TrapToEL3" title="enumeration SysRegAccess { SysRegAccess_OK, SysRegAccess_UNDEFINED, SysRegAccess_TrapToEL1, SysRegAccess_TrapToEL2, SysRegAccess_TrapToEL3 }"><del>SysRegAccess_TrapToEL3</del></a><ins>;
    return (secure, el);</ins><del>;</del></p></div><div class="ps" psname="aarch64.debug.statisticalprofiling.ProfilingSynchronizationBarrier"><a id="aarch64.debug.statisticalprofiling.ProfilingSynchronizationBarrier" name="aarch64.debug.statisticalprofiling.ProfilingSynchronizationBarrier"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/<ins>ProfilingSynchronizationBarrier</ins><del>CheckStatisticalProfilingAccess</del></h3><p class="pseudocode"><ins>// Barrier to ensure that all existing profiling data has been formatted, and profiling buffer
// addresses have been translated such that writes to the profiling buffer have been initiated.
// A following DSB completes when writes to the profiling buffer have completed.</ins><del>// CheckStatisticalProfilingAccess()
// =================================

SysRegAccess</del>
<a id="impl-aarch64.ProfilingSynchronizationBarrier.0" name="impl-aarch64.ProfilingSynchronizationBarrier.0"></a><ins>ProfilingSynchronizationBarrier();</ins><del>CheckStatisticalProfilingAccess()
    if !</del><a href="shared_pseudocode.html#impl-shared.HaveStatisticalProfiling.0" title="function: boolean HaveStatisticalProfiling()"><del>HaveStatisticalProfiling</del></a><del>() || PSTATE.EL == </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del> || </del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>() then
        return </del><a href="shared_pseudocode.html#SysRegAccess_UNDEFINED" title="enumeration SysRegAccess { SysRegAccess_OK, SysRegAccess_UNDEFINED, SysRegAccess_TrapToEL1, SysRegAccess_TrapToEL2, SysRegAccess_TrapToEL3 }"><del>SysRegAccess_UNDEFINED</del></a><del>;

    if </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; PSTATE.EL == </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del> &amp;&amp; MDCR_EL2.TPMS == '1' then
        return </del><a href="shared_pseudocode.html#SysRegAccess_TrapToEL2" title="enumeration SysRegAccess { SysRegAccess_OK, SysRegAccess_UNDEFINED, SysRegAccess_TrapToEL1, SysRegAccess_TrapToEL2, SysRegAccess_TrapToEL3 }"><del>SysRegAccess_TrapToEL2</del></a><del>;

    if </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; PSTATE.EL != </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del> &amp;&amp; MDCR_EL3.NSPB != SCR_EL3.NS:'1' then
        return </del><a href="shared_pseudocode.html#SysRegAccess_TrapToEL3" title="enumeration SysRegAccess { SysRegAccess_OK, SysRegAccess_UNDEFINED, SysRegAccess_TrapToEL1, SysRegAccess_TrapToEL2, SysRegAccess_TrapToEL3 }"><del>SysRegAccess_TrapToEL3</del></a><del>;

    return </del><a href="shared_pseudocode.html#SysRegAccess_OK" title="enumeration SysRegAccess { SysRegAccess_OK, SysRegAccess_UNDEFINED, SysRegAccess_TrapToEL1, SysRegAccess_TrapToEL2, SysRegAccess_TrapToEL3 }"><del>SysRegAccess_OK</del></a><del>;</del></p></div><div class="ps" psname="aarch64.debug.statisticalprofiling.StatisticalProfilingEnabled"><a id="aarch64.debug.statisticalprofiling.StatisticalProfilingEnabled" name="aarch64.debug.statisticalprofiling.StatisticalProfilingEnabled"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/<ins>StatisticalProfilingEnabled</ins><del>CollectContextIDR1</del></h3><p class="pseudocode"><ins>// StatisticalProfilingEnabled()
// =============================
</ins><del>// CollectContextIDR1()
// ====================
</del>
boolean <a id="impl-aarch64.StatisticalProfilingEnabled.0" name="impl-aarch64.StatisticalProfilingEnabled.0"></a><ins>StatisticalProfilingEnabled()
</ins><del>CollectContextIDR1()
</del>    if !<a href="shared_pseudocode.html#impl-shared.HaveStatisticalProfiling.0" title="function: boolean HaveStatisticalProfiling()"><ins>HaveStatisticalProfiling</ins></a><a href="shared_pseudocode.html#impl-aarch64.StatisticalProfilingEnabled.0" title="function: boolean StatisticalProfilingEnabled()"><del>StatisticalProfilingEnabled</del></a><ins>() ||</ins><del>() then return FALSE;
    if  PSTATE.EL ==</del> <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>() || !</ins><del>then return FALSE;
    if</del><a href="shared_pseudocode.html#impl-aarch64.ProfilingBufferEnabled.0" title="function: boolean ProfilingBufferEnabled()"><ins>ProfilingBufferEnabled</ins></a><ins>() then
        return FALSE;

    in_host = </ins><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a><ins>() &amp;&amp; HCR_EL2.TGE == '1';
    (secure, el) = </ins><a href="shared_pseudocode.html#impl-aarch64.ProfilingBufferOwner.0" title="function: (boolean, bits(2)) ProfilingBufferOwner()"><ins>ProfilingBufferOwner</ins></a><ins>();
    if </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(el) &lt;  </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(PSTATE.EL) || secure != </ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>() || (in_host &amp;&amp; el == </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>)  then
        return FALSE;

    case PSTATE.EL of
        when </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>  </ins><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><ins>Unreachable</ins></a><ins>();
        when </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>  spe_bit = PMSCR_EL2.E2SPE;
        when </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>  spe_bit = PMSCR_EL1.E1SPE;
        when </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a>  <ins>spe_bit = (if in_host then PMSCR_EL2.E0HSPE else PMSCR_EL1.E0SPE);

    return spe_bit == '1';</ins><del>() &amp;&amp; HCR_EL2.TGE == '1' then return FALSE;
    return PMSCR_EL1.CX == '1';</del></p></div><div class="ps" psname="aarch64.debug.statisticalprofiling.SysRegAccess"><a id="aarch64.debug.statisticalprofiling.SysRegAccess" name="aarch64.debug.statisticalprofiling.SysRegAccess"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/<ins>SysRegAccess</ins><del>CollectContextIDR2</del></h3><p class="pseudocode"><ins>enumeration</ins><del>// CollectContextIDR2()
// ====================

boolean</del> <a id="SysRegAccess" name="SysRegAccess"></a><ins>SysRegAccess {</ins><del>CollectContextIDR2()
    if !</del> <a id="SysRegAccess_OK" name="SysRegAccess_OK"></a><ins>SysRegAccess_OK,</ins><del>() then return FALSE;
    if</del>
                           <a id="SysRegAccess_UNDEFINED" name="SysRegAccess_UNDEFINED"></a><ins>SysRegAccess_UNDEFINED,
                           </ins><a id="SysRegAccess_TrapToEL1" name="SysRegAccess_TrapToEL1"></a><ins>SysRegAccess_TrapToEL1,
                           </ins><a id="SysRegAccess_TrapToEL2" name="SysRegAccess_TrapToEL2"></a><ins>SysRegAccess_TrapToEL2,
                           </ins><a id="SysRegAccess_TrapToEL3" name="SysRegAccess_TrapToEL3"></a><ins>SysRegAccess_TrapToEL3 };</ins><del>() then return FALSE;
    return PMSCR_EL2.CX == '1';</del></p></div><div class="ps" psname="aarch64.debug.statisticalprofiling.TimeStamp"><a id="aarch64.debug.statisticalprofiling.TimeStamp" name="aarch64.debug.statisticalprofiling.TimeStamp"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/<ins>TimeStamp</ins><del>CollectPhysicalAddress</del></h3><p class="pseudocode"><ins>enumeration</ins><del>// CollectPhysicalAddress()
// ========================

boolean</del> <a id="TimeStamp" name="TimeStamp"></a><ins>TimeStamp {</ins><del>CollectPhysicalAddress()
    if !</del> <a id="TimeStamp_None" name="TimeStamp_None"></a><ins>TimeStamp_None,</ins><del>() then return FALSE;
    (secure, el) =</del>
                        <a id="TimeStamp_Virtual" name="TimeStamp_Virtual"></a><ins>TimeStamp_Virtual,</ins><del>();
    if !secure &amp;&amp;</del>
                        <del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) then
        return PMSCR_EL2.PA == '1' &amp;&amp; (el == </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><a id="TimeStamp_Physical" name="TimeStamp_Physical"></a><ins>TimeStamp_Physical };</ins><del>|| PMSCR_EL1.PA == '1');
    else
        return PMSCR_EL1.PA == '1';</del></p></div><div class="ps" psname="aarch64.debug.takeexceptiondbg.AArch64.TakeExceptionInDebugState"><a id="aarch64.debug.takeexceptiondbg.AArch64.TakeExceptionInDebugState" name="aarch64.debug.takeexceptiondbg.AArch64.TakeExceptionInDebugState"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/<ins>takeexceptiondbg</ins><del>statisticalprofiling</del>/<ins>AArch64.TakeExceptionInDebugState</ins><del>CollectRecord</del></h3><p class="pseudocode"><ins>// AArch64.TakeExceptionInDebugState()
// ===================================
// Take an exception in Debug state to an Exception Level using AArch64.</ins><del>// CollectRecord()
// ===============

boolean</del>

<a id="AArch64.TakeExceptionInDebugState.2" name="AArch64.TakeExceptionInDebugState.2"></a><ins>AArch64.TakeExceptionInDebugState(bits(2) target_el,</ins><del>CollectRecord(bits(64) events, integer total_latency,</del> <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is (Exception type, bits(25) syndrome, bits(64) vaddress, boolean ipavalid, bits(1) NS, bits(52) ipaddress)"><ins>ExceptionRecord</ins></a><a href="shared_pseudocode.html#OpType" title="enumeration OpType { OpType_Load, OpType_Store, OpType_LoadAtomic, OpType_Branch, OpType_Other }"><del>OpType</del></a> <ins>exception)
</ins><del>optype)
</del>    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-aarch64.StatisticalProfilingEnabled.0" title="function: boolean StatisticalProfilingEnabled()"><del>StatisticalProfilingEnabled</del></a><ins>(target_el) &amp;&amp; !</ins><del>();
    if PMSFCR_EL1.FE == '1' then
        e = events&lt;63:48,31:24,15:12,7,5,3,1>;
        m = PMSEVFR_EL1&lt;63:48,31:24,15:12,7,5,3,1>;
        // Check for UNPREDICTABLE case
        if</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><ins>(target_el) &amp;&amp;</ins><del>(PMSEVFR_EL1) &amp;&amp;</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><del>ConstrainUnpredictableBool</del></a><ins>(target_el) >=</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#Unpredictable_ZEROPMSEVFR" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_ZEROPMSEVFR</del></a><ins>(PSTATE.EL);

    sync_errors =</ins><del>) then return FALSE;
        if !</del> <a href="shared_pseudocode.html#impl-shared.HaveIESB.0" title="function: boolean HaveIESB()"><ins>HaveIESB</ins></a><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><ins>() &amp;&amp;</ins><del>(NOT(e) AND m) then return FALSE;
    if PMSFCR_EL1.FT == '1' then
        // Check for UNPREDICTABLE case
        if</del> <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><ins>SCTLR</ins></a><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><ins>[].IESB == '1';
    if</ins><del>(PMSFCR_EL1.&lt;B,LD,ST>) &amp;&amp;</del> <a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()"><ins>HaveDoubleFaultExt</ins></a><ins>() then
        sync_errors = sync_errors || (SCR_EL3.EA == '1' &amp;&amp; SCR_EL3.NMEA == '1' &amp;&amp; PSTATE.EL == </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>);
    // SCTLR[].IESB might be ignored in Debug state.
    if !</ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_IESBinDebug" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_IESBinDebug</ins></a><a href="shared_pseudocode.html#Unpredictable_NOOPTYPES" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_NOOPTYPES</del></a>) then
<ins>        sync_errors = FALSE;
    if sync_errors &amp;&amp;</ins><del>            return FALSE;
        case optype of
            when</del> <a href="shared_pseudocode.html#impl-shared.InsertIESBBeforeException.1" title="function: boolean InsertIESBBeforeException(bits(2) el)"><ins>InsertIESBBeforeException</ins></a><a href="shared_pseudocode.html#OpType_Branch" title="enumeration OpType { OpType_Load, OpType_Store, OpType_LoadAtomic, OpType_Branch, OpType_Other }"><del>OpType_Branch</del></a><ins>(target_el) then</ins><del>if PMSFCR_EL1.B == '0' then return FALSE;
            when</del>
        <a href="shared_pseudocode.html#impl-shared.SynchronizeErrors.0" title="function: SynchronizeErrors()"><ins>SynchronizeErrors</ins></a><a href="shared_pseudocode.html#OpType_Load" title="enumeration OpType { OpType_Load, OpType_Store, OpType_LoadAtomic, OpType_Branch, OpType_Other }"><del>OpType_Load</del></a><ins>();</ins><del>if PMSFCR_EL1.LD == '0' then return FALSE;
            when</del>

    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()"><ins>SynchronizeContext</ins></a><a href="shared_pseudocode.html#OpType_Store" title="enumeration OpType { OpType_Load, OpType_Store, OpType_LoadAtomic, OpType_Branch, OpType_Other }"><del>OpType_Store</del></a><ins>();

    // If coming from AArch32 state, the top parts of the X[] registers might be set to zero
    from_32 =</ins><del>if PMSFCR_EL1.ST == '0' then return FALSE;
            when</del> <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><a href="shared_pseudocode.html#OpType_LoadAtomic" title="enumeration OpType { OpType_Load, OpType_Store, OpType_LoadAtomic, OpType_Branch, OpType_Other }"><del>OpType_LoadAtomic</del></a><ins>();
    if from_32 then</ins><del>if PMSFCR_EL1.&lt;LD,ST> == '00' then return FALSE;
            otherwise return FALSE;
    if PMSFCR_EL1.FL == '1' then
        if</del> <a href="shared_pseudocode.html#AArch64.MaybeZeroRegisterUppers.0" title="function: AArch64.MaybeZeroRegisterUppers()"><ins>AArch64.MaybeZeroRegisterUppers</ins></a><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><ins>();</ins><del>(PMSLATFR_EL1.MINLAT) &amp;&amp;</del>
    <a href="shared_pseudocode.html#impl-aarch64.MaybeZeroSVEUppers.1" title="function: MaybeZeroSVEUppers(bits(2) target_el)"><ins>MaybeZeroSVEUppers</ins></a><ins>(target_el);

    </ins><a href="shared_pseudocode.html#AArch64.ReportException.2" title="function: AArch64.ReportException(ExceptionRecord exception, bits(2) target_el)"><ins>AArch64.ReportException</ins></a><ins>(exception, target_el);

    PSTATE.EL = target_el;  PSTATE.nRW = '0';  PSTATE.SP = '1';

    </ins><a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(32) value"><ins>SPSR</ins></a><ins>[] = bits(32) UNKNOWN;
    </ins><a href="shared_pseudocode.html#impl-aarch64.ELR.write.0" title="accessor: ELR[] = bits(64) value"><ins>ELR</ins></a><ins>[] = bits(64) UNKNOWN;

    PSTATE.SSBS = bits(1) UNKNOWN;
    // PSTATE.{SS,D,A,I,F} are not observable and ignored in Debug state, so behave as if UNKNOWN.
    PSTATE.&lt;SS,D,A,I,F> = bits(5) UNKNOWN;
    DLR_EL0 = bits(64) UNKNOWN;
    DSPSR_EL0 = bits(32) UNKNOWN;

    if </ins><a href="shared_pseudocode.html#impl-shared.HaveBTIExt.0" title="function: boolean HaveBTIExt()"><ins>HaveBTIExt</ins></a><ins>() then
        if exception.type == </ins><a href="shared_pseudocode.html#Exception_Breakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_Breakpoint</ins></a><ins> then
            DSPSR_EL0&lt;11:10> = PSTATE.BTYPE;
        else
            DSPSR_EL0&lt;11:10> = if </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_ZEROBTYPE" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_ZEROBTYPE</ins></a><a href="shared_pseudocode.html#Unpredictable_ZEROMINLATENCY" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_ZEROMINLATENCY</del></a><ins>) then '00' else PSTATE.BTYPE;
        PSTATE.BTYPE = '00';

    PSTATE.IL = '0';
    if from_32 then                                 // Coming from AArch32
        PSTATE.IT = '00000000';  PSTATE.T = '0';    // PSTATE.J is RES0
    if</ins><del>) then // UNPREDICTABLE case
            return FALSE;
        if total_latency &lt;</del> <a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()"><ins>HavePANExt</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>() &amp;&amp; (PSTATE.EL == </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins> || (PSTATE.EL == </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins> &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)"><ins>ELIsInHost</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>)))
        &amp;&amp; </ins><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><ins>SCTLR</ins></a><ins>[].SPAN == '0' then
        PSTATE.PAN = '1';
    if </ins><a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()"><ins>HaveMTEExt</ins></a><ins>() then PSTATE.TCO = '1';

    EDSCR.ERR = '1';
    </ins><a href="shared_pseudocode.html#impl-shared.UpdateEDSCRFields.0" title="function: UpdateEDSCRFields()"><ins>UpdateEDSCRFields</ins></a><ins>();                        // Update EDSCR processor state flags.

    if sync_errors then
        </ins><a href="shared_pseudocode.html#impl-shared.SynchronizeErrors.0" title="function: SynchronizeErrors()"><ins>SynchronizeErrors</ins></a><ins>();

    </ins><a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()"><ins>EndOfInstruction</ins></a><ins>();</ins><del>(PMSLATFR_EL1.MINLAT) then return FALSE;
    return TRUE;</del></p></div><div class="ps" psname="aarch64.debug.watchpoint.AArch64.WatchpointByteMatch"><a id="aarch64.debug.watchpoint.AArch64.WatchpointByteMatch" name="aarch64.debug.watchpoint.AArch64.WatchpointByteMatch"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/<ins>watchpoint</ins><del>statisticalprofiling</del>/<ins>AArch64.WatchpointByteMatch</ins><del>CollectTimeStamp</del></h3><p class="pseudocode"><ins>// AArch64.WatchpointByteMatch()
// =============================
</ins><del>// CollectTimeStamp()
// ==================
</del>
<ins>boolean</ins><del>TimeStamp</del> <a id="AArch64.WatchpointByteMatch.3" name="AArch64.WatchpointByteMatch.3"></a><ins>AArch64.WatchpointByteMatch(integer n,</ins><del>CollectTimeStamp()
    if !</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><a href="shared_pseudocode.html#impl-aarch64.StatisticalProfilingEnabled.0" title="function: boolean StatisticalProfilingEnabled()"><del>StatisticalProfilingEnabled</del></a> <ins>acctype, bits(64) vaddress)

    el = if</ins><del>() then return</del> <a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()"><ins>HaveNV2Ext</ins></a><a href="shared_pseudocode.html#TimeStamp_None" title="enumeration TimeStamp { TimeStamp_None, TimeStamp_Virtual, TimeStamp_Physical }"><del>TimeStamp_None</del></a><ins>() &amp;&amp; acctype ==</ins><del>;
    (secure, el) =</del> <a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NV2REGISTER</ins></a><a href="shared_pseudocode.html#impl-aarch64.ProfilingBufferOwner.0" title="function: (boolean, bits(2)) ProfilingBufferOwner()"><del>ProfilingBufferOwner</del></a> <ins>then</ins><del>();
    if el ==</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> <ins>else PSTATE.EL;
    top =</ins><del>then
        if PMSCR_EL2.TS == '0' then return</del> <a href="shared_pseudocode.html#impl-shared.AddrTop.3" title="function: integer AddrTop(bits(64) address, boolean IsInstr, bits(2) el)"><ins>AddrTop</ins></a><a href="shared_pseudocode.html#TimeStamp_None" title="enumeration TimeStamp { TimeStamp_None, TimeStamp_Virtual, TimeStamp_Physical }"><del>TimeStamp_None</del></a><ins>(vaddress, FALSE, el);
    bottom = if DBGWVR_EL1[n]&lt;2> == '1' then 2 else 3;            // Word or doubleword
    byte_select_match = (DBGWCR_EL1[n].BAS&lt;</ins><del>;
    else
        if PMSCR_EL1.TS == '0' then return</del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#TimeStamp_None" title="enumeration TimeStamp { TimeStamp_None, TimeStamp_Virtual, TimeStamp_Physical }"><del>TimeStamp_None</del></a><ins>(vaddress&lt;bottom-1:0>)> != '0');
    mask =</ins><del>;
    if</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><ins>(DBGWCR_EL1[n].MASK);

    // If DBGWCR_EL1[n].MASK is non-zero value and DBGWCR_EL1[n].BAS is not set to '11111111', or
    // DBGWCR_EL1[n].BAS specifies a non-contiguous set of bytes behavior is CONSTRAINED
    // UNPREDICTABLE.
    if mask > 0 &amp;&amp; !</ins><del>() then
        pct = PMSCR_EL2.PCT == '1' &amp;&amp; (el ==</del><a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)"><ins>IsOnes</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>(DBGWCR_EL1[n].BAS) then
        byte_select_match =</ins><del>|| PMSCR_EL1.PCT == '1');
    else
        pct = PMSCR_EL1.PCT == '1';
    return (if pct then</del> <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><ins>ConstrainUnpredictableBool</ins></a><a href="shared_pseudocode.html#TimeStamp_Physical" title="enumeration TimeStamp { TimeStamp_None, TimeStamp_Virtual, TimeStamp_Physical }"><del>TimeStamp_Physical</del></a><ins>(</ins><del>else</del><a href="shared_pseudocode.html#Unpredictable_WPMASKANDBAS" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_WPMASKANDBAS</ins></a><a href="shared_pseudocode.html#TimeStamp_Virtual" title="enumeration TimeStamp { TimeStamp_None, TimeStamp_Virtual, TimeStamp_Physical }"><del>TimeStamp_Virtual</del></a><ins>);
    else
        LSB = (DBGWCR_EL1[n].BAS AND NOT(DBGWCR_EL1[n].BAS - 1));  MSB = (DBGWCR_EL1[n].BAS + LSB);
        if !</ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(MSB AND (MSB - 1)) then                     // Not contiguous
            byte_select_match = </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><ins>ConstrainUnpredictableBool</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_WPBASCONTIGUOUS" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_WPBASCONTIGUOUS</ins></a><ins>);
            bottom = 3;                                        // For the whole doubleword

    // If the address mask is set to a reserved value, the behavior is CONSTRAINED UNPREDICTABLE.
    if mask > 0 &amp;&amp; mask &lt;= 2 then
        (c, mask) = </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableInteger.3" title="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high, Unpredictable which)"><ins>ConstrainUnpredictableInteger</ins></a><ins>(3, 31, </ins><a href="shared_pseudocode.html#Unpredictable_RESWPMASK" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESWPMASK</ins></a><ins>);
        assert c IN {</ins><a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_DISABLED</ins></a><ins>, </ins><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_NONE</ins></a><ins>, </ins><a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_UNKNOWN</ins></a><ins>};
        case c of
            when </ins><a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_DISABLED</ins></a><ins>  return FALSE;            // Disabled
            when </ins><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_NONE</ins></a><ins>      mask = 0;                // No masking
            // Otherwise the value returned by ConstrainUnpredictableInteger is a not-reserved value

    if mask > bottom then
        WVR_match = (vaddress&lt;top:mask> == DBGWVR_EL1[n]&lt;top:mask>);
        // If masked bits of DBGWVR_EL1[n] are not zero, the behavior is CONSTRAINED UNPREDICTABLE.
        if WVR_match &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(DBGWVR_EL1[n]&lt;mask-1:bottom>) then
            WVR_match = </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><ins>ConstrainUnpredictableBool</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_WPMASKEDBITS" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_WPMASKEDBITS</ins></a><ins>);
    else
        WVR_match = vaddress&lt;top:bottom> == DBGWVR_EL1[n]&lt;top:bottom>;

    return WVR_match &amp;&amp; byte_select_match;</ins><del>);</del></p></div><div class="ps" psname="aarch64.debug.watchpoint.AArch64.WatchpointMatch"><a id="aarch64.debug.watchpoint.AArch64.WatchpointMatch" name="aarch64.debug.watchpoint.AArch64.WatchpointMatch"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/<ins>watchpoint</ins><del>statisticalprofiling</del>/<ins>AArch64.WatchpointMatch</ins><del>OpType</del></h3><p class="pseudocode"><ins>// AArch64.WatchpointMatch()
// =========================
// Watchpoint matching in an AArch64 translation regime.

boolean</ins><del>enumeration</del> <a id="AArch64.WatchpointMatch.6" name="AArch64.WatchpointMatch.6"></a><ins>AArch64.WatchpointMatch(integer n, bits(64) vaddress, integer size, boolean ispriv,</ins><del>OpType {</del>
                                <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a> <ins>acctype, boolean iswrite)
    assert !</ins><del>OpType_Load,                 // Any memory-read operation other than atomics, compare-and-swap, and swap</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><del>OpType_Store,                // Any memory-write operation, including atomics without return</del><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><ins>());
    assert n &lt;=</ins><del>OpType_LoadAtomic,           // Atomics with return, compare-and-swap and swap</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(ID_AA64DFR0_EL1.WRPs);

    // "ispriv" is FALSE for LDTR/STTR instructions executed at EL1 and all
    // load/stores at EL0, TRUE for all other load/stores. "iswrite" is TRUE for stores, FALSE for
    // loads.
    enabled = DBGWCR_EL1[n].E == '1';
    linked = DBGWCR_EL1[n].WT == '1';
    isbreakpnt = FALSE;

    state_match =</ins><del>OpType_Branch,               // Software write to the PC</del> <a href="shared_pseudocode.html#AArch64.StateMatch.8" title="function: boolean AArch64.StateMatch(bits(2) SSC, bit HMC, bits(2) PxC, boolean linked, bits(4) LBN, boolean isbreakpnt, AccType acctype, boolean ispriv)"><ins>AArch64.StateMatch</ins></a><ins>(DBGWCR_EL1[n].SSC, DBGWCR_EL1[n].HMC, DBGWCR_EL1[n].PAC,
                                     linked, DBGWCR_EL1[n].LBN, isbreakpnt, acctype, ispriv);

    ls_match = (DBGWCR_EL1[n].LSC&lt;(if iswrite then 1 else 0)> == '1');

    value_match = FALSE;
    for byte = 0 to size - 1
        value_match = value_match || </ins><a href="shared_pseudocode.html#AArch64.WatchpointByteMatch.3" title="function: boolean AArch64.WatchpointByteMatch(integer n, AccType acctype, bits(64) vaddress)"><ins>AArch64.WatchpointByteMatch</ins></a><ins>(n, acctype, vaddress + byte);

    return value_match &amp;&amp; state_match &amp;&amp; ls_match &amp;&amp; enabled;</ins><del>OpType_Other                 // Any other class of operation
 };</del></p></div><div class="ps" psname="aarch64.exceptions.aborts.AArch64.Abort"><a id="aarch64.exceptions.aborts.AArch64.Abort" name="aarch64.exceptions.aborts.AArch64.Abort"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>exceptions</ins><del>debug</del>/<ins>aborts</ins><del>statisticalprofiling</del>/<ins>AArch64.Abort</ins><del>ProfilingBufferEnabled</del></h3><p class="pseudocode"><ins>// AArch64.Abort()
// ===============
// Abort and Debug exception handling in an AArch64 translation regime.</ins><del>// ProfilingBufferEnabled()
// ========================

boolean</del>

<a id="AArch64.Abort.2" name="AArch64.Abort.2"></a><ins>AArch64.Abort(bits(64) vaddress,</ins><del>ProfilingBufferEnabled()
    if !</del> <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><ins>FaultRecord</ins></a><a href="shared_pseudocode.html#impl-shared.HaveStatisticalProfiling.0" title="function: boolean HaveStatisticalProfiling()"><del>HaveStatisticalProfiling</del></a> <ins>fault)

    if</ins><del>() then return FALSE;
    (secure, el) =</del> <a href="shared_pseudocode.html#impl-shared.IsDebugException.1" title="function: boolean IsDebugException(FaultRecord fault)"><ins>IsDebugException</ins></a><a href="shared_pseudocode.html#impl-aarch64.ProfilingBufferOwner.0" title="function: (boolean, bits(2)) ProfilingBufferOwner()"><del>ProfilingBufferOwner</del></a><ins>(fault) then
        if fault.acctype ==</ins><del>();
    non_secure_bit = if secure then '0' else '1';
    return (!</del> <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><ins> then
            if </ins><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>() &amp;&amp; fault.debugmoe == </ins><a href="shared_pseudocode.html#DebugException_VectorCatch" title="constant bits(4) DebugException_VectorCatch = '0101'"><ins>DebugException_VectorCatch</ins></a><ins> then
                </ins><a href="shared_pseudocode.html#AArch64.VectorCatchException.1" title="function: AArch64.VectorCatchException(FaultRecord fault)"><ins>AArch64.VectorCatchException</ins></a><ins>(fault);
            else
                </ins><a href="shared_pseudocode.html#AArch64.BreakpointException.1" title="function: AArch64.BreakpointException(FaultRecord fault)"><ins>AArch64.BreakpointException</ins></a><ins>(fault);
        else
            </ins><a href="shared_pseudocode.html#AArch64.WatchpointException.2" title="function: AArch64.WatchpointException(bits(64) vaddress, FaultRecord fault)"><ins>AArch64.WatchpointException</ins></a><ins>(vaddress, fault);
    elsif fault.acctype == </ins><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><ins> then
        </ins><a href="shared_pseudocode.html#AArch64.InstructionAbort.2" title="function: AArch64.InstructionAbort(bits(64) vaddress, FaultRecord fault)"><ins>AArch64.InstructionAbort</ins></a><ins>(vaddress, fault);
    else
        </ins><a href="shared_pseudocode.html#AArch64.DataAbort.2" title="function: AArch64.DataAbort(bits(64) vaddress, FaultRecord fault)"><ins>AArch64.DataAbort</ins></a><ins>(vaddress, fault);</ins><del>(el) &amp;&amp; non_secure_bit == SCR_EL3.NS &amp;&amp;
            PMBLIMITR_EL1.E == '1' &amp;&amp; PMBSR_EL1.S == '0');</del></p></div><div class="ps" psname="aarch64.exceptions.aborts.AArch64.AbortSyndrome"><a id="aarch64.exceptions.aborts.AArch64.AbortSyndrome" name="aarch64.exceptions.aborts.AArch64.AbortSyndrome"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>exceptions</ins><del>debug</del>/<ins>aborts</ins><del>statisticalprofiling</del>/<ins>AArch64.AbortSyndrome</ins><del>ProfilingBufferOwner</del></h3><p class="pseudocode"><ins>// AArch64.AbortSyndrome()
// =======================
// Creates an exception syndrome record for Abort and Watchpoint exceptions
// from an AArch64 translation regime.
</ins><del>// ProfilingBufferOwner()
// ======================
</del>
<ins>ExceptionRecord</ins><del>(boolean, bits(2))</del> <a id="AArch64.AbortSyndrome.3" name="AArch64.AbortSyndrome.3"></a><ins>AArch64.AbortSyndrome(</ins><del>ProfilingBufferOwner()
    secure = if</del><a href="shared_pseudocode.html#Exception" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a> <ins>type,</ins><del>(</del> <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><ins>FaultRecord</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a> <ins>fault, bits(64) vaddress)

    exception =</ins><del>) then (MDCR_EL3.NSPB&lt;1> == '0') else</del> <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><ins>(type);

    d_side = type IN {</ins><del>();
    el = if !secure &amp;&amp;</del><a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_DataAbort</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>,</ins><del>(</del> <a href="shared_pseudocode.html#Exception_NV2DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_NV2DataAbort</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>,</ins><del>) &amp;&amp; MDCR_EL2.E2PB == '00' then</del> <a href="shared_pseudocode.html#Exception_Watchpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_Watchpoint</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>};

    exception.syndrome =</ins><del>else</del> <a href="shared_pseudocode.html#AArch64.FaultSyndrome.2" title="function: bits(25) AArch64.FaultSyndrome(boolean d_side, FaultRecord fault)"><ins>AArch64.FaultSyndrome</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>(d_side, fault);
    exception.vaddress = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(vaddress);
    if </ins><a href="shared_pseudocode.html#impl-shared.IPAValid.1" title="function: boolean IPAValid(FaultRecord fault)"><ins>IPAValid</ins></a><ins>(fault) then
        exception.ipavalid = TRUE;
        exception.NS = fault.ipaddress.NS;
        exception.ipaddress = fault.ipaddress.address;
    else
        exception.ipavalid = FALSE;

    return exception;</ins><del>;
    return (secure, el);</del></p></div><div class="ps" psname="aarch64.exceptions.aborts.AArch64.CheckPCAlignment"><a id="aarch64.exceptions.aborts.AArch64.CheckPCAlignment" name="aarch64.exceptions.aborts.AArch64.CheckPCAlignment"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>exceptions</ins><del>debug</del>/<ins>aborts</ins><del>statisticalprofiling</del>/<ins>AArch64.CheckPCAlignment</ins><del>ProfilingSynchronizationBarrier</del></h3><p class="pseudocode"><ins>// AArch64.CheckPCAlignment()
// ==========================</ins><del>// Barrier to ensure that all existing profiling data has been formatted, and profiling buffer
// addresses have been translated such that writes to the profiling buffer have been initiated.
// A following DSB completes when writes to the profiling buffer have completed.</del>

<a id="AArch64.CheckPCAlignment.0" name="AArch64.CheckPCAlignment.0"></a><ins>AArch64.CheckPCAlignment()

    bits(64) pc =</ins><del>ProfilingSynchronizationBarrier();</del> <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><ins>ThisInstrAddr</ins></a><ins>();
    if pc&lt;1:0> != '00' then
        </ins><a href="shared_pseudocode.html#AArch64.PCAlignmentFault.0" title="function: AArch64.PCAlignmentFault()"><ins>AArch64.PCAlignmentFault</ins></a><ins>();</ins></p></div><div class="ps" psname="aarch64.exceptions.aborts.AArch64.DataAbort"><a id="aarch64.exceptions.aborts.AArch64.DataAbort" name="aarch64.exceptions.aborts.AArch64.DataAbort"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>exceptions</ins><del>debug</del>/<ins>aborts</ins><del>statisticalprofiling</del>/<ins>AArch64.DataAbort</ins><del>StatisticalProfilingEnabled</del></h3><p class="pseudocode"><ins>// AArch64.DataAbort()
// ===================</ins><del>// StatisticalProfilingEnabled()
// =============================

boolean</del>

<a id="AArch64.DataAbort.2" name="AArch64.DataAbort.2"></a><ins>AArch64.DataAbort(bits(64) vaddress,</ins><del>StatisticalProfilingEnabled()
    if !</del> <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><ins>FaultRecord</ins></a><a href="shared_pseudocode.html#impl-shared.HaveStatisticalProfiling.0" title="function: boolean HaveStatisticalProfiling()"><del>HaveStatisticalProfiling</del></a> <ins>fault)
    route_to_el3 =</ins><del>() ||</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><ins>(</ins><del>() || !</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-aarch64.ProfilingBufferEnabled.0" title="function: boolean ProfilingBufferEnabled()"><del>ProfilingBufferEnabled</del></a><ins>) &amp;&amp; SCR_EL3.EA == '1' &amp;&amp;</ins><del>() then
        return FALSE;

    in_host =</del> <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault type)"><ins>IsExternalAbort</ins></a><ins>(fault);
    route_to_el2 = (</ins><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a><ins>() &amp;&amp; PSTATE.EL IN {</ins><del>() &amp;&amp; HCR_EL2.TGE == '1';
    (secure, el) =</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#impl-aarch64.ProfilingBufferOwner.0" title="function: (boolean, bits(2)) ProfilingBufferOwner()"><del>ProfilingBufferOwner</del></a><ins>,</ins><del>();
    if</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>} &amp;&amp; (HCR_EL2.TGE == '1' ||
                    (</ins><del>(el) &lt;</del><a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()"><ins>HaveRASExt</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>() &amp;&amp; HCR_EL2.TEA == '1' &amp;&amp;</ins><del>(PSTATE.EL) || secure !=</del> <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault type)"><ins>IsExternalAbort</ins></a><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><ins>(fault)) ||
                    (</ins><del>() || (in_host &amp;&amp; el ==</del><a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()"><ins>HaveNV2Ext</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>() &amp;&amp; fault.acctype ==</ins><del>)  then
        return FALSE;

    case PSTATE.EL of
        when</del> <a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NV2REGISTER</ins></a><ins>) ||
                    </ins><a href="shared_pseudocode.html#impl-shared.IsSecondStage.1" title="function: boolean IsSecondStage(FaultRecord fault)"><ins>IsSecondStage</ins></a><ins>(fault)));

    bits(64) preferred_exception_return = </ins><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><ins>ThisInstrAddr</ins></a><ins>();
    if (</ins><a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()"><ins>HaveDoubleFaultExt</ins></a><ins>() &amp;&amp; (PSTATE.EL == </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> <ins>|| route_to_el3) &amp;&amp;</ins>
        <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault type)"><ins>IsExternalAbort</ins></a><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><del>Unreachable</del></a><ins>(fault) &amp;&amp; SCR_EL3.EASE == '1') then
        vect_offset = 0x180;
    else
        vect_offset = 0x0;
    if</ins><del>();
        when</del> <a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()"><ins>HaveNV2Ext</ins></a><ins>() &amp;&amp; fault.acctype == </ins><a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NV2REGISTER</ins></a><ins> then
        exception = </ins><a href="shared_pseudocode.html#AArch64.AbortSyndrome.3" title="function: ExceptionRecord AArch64.AbortSyndrome(Exception type, FaultRecord fault, bits(64) vaddress)"><ins>AArch64.AbortSyndrome</ins></a><ins>(</ins><a href="shared_pseudocode.html#Exception_NV2DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_NV2DataAbort</ins></a><ins>, fault, vaddress);
    else
        exception = </ins><a href="shared_pseudocode.html#AArch64.AbortSyndrome.3" title="function: ExceptionRecord AArch64.AbortSyndrome(Exception type, FaultRecord fault, bits(64) vaddress)"><ins>AArch64.AbortSyndrome</ins></a><ins>(</ins><a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_DataAbort</ins></a><ins>, fault, vaddress);
    if PSTATE.EL == </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins> || route_to_el3 then
        </ins><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>, exception, preferred_exception_return, vect_offset);
    elsif PSTATE.EL == </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> <ins>|| route_to_el2 then</ins><del>spe_bit = PMSCR_EL2.E2SPE;
        when</del>
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>(</ins><del>spe_bit = PMSCR_EL1.E1SPE;
        when</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>, exception, preferred_exception_return, vect_offset);
    else
        </ins><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>, exception, preferred_exception_return, vect_offset);</ins><del>spe_bit = (if in_host then PMSCR_EL2.E0HSPE else PMSCR_EL1.E0SPE);

    return spe_bit == '1';</del></p></div><div class="ps" psname="aarch64.exceptions.aborts.AArch64.InstructionAbort"><a id="aarch64.exceptions.aborts.AArch64.InstructionAbort" name="aarch64.exceptions.aborts.AArch64.InstructionAbort"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>exceptions</ins><del>debug</del>/<ins>aborts</ins><del>statisticalprofiling</del>/<ins>AArch64.InstructionAbort</ins><del>SysRegAccess</del></h3><p class="pseudocode"><ins>// AArch64.InstructionAbort()
// ==========================</ins><del>enumeration</del>

<a id="AArch64.InstructionAbort.2" name="AArch64.InstructionAbort.2"></a><ins>AArch64.InstructionAbort(bits(64) vaddress,</ins><del>SysRegAccess {</del> <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><ins>FaultRecord</ins></a> <ins>fault)
    // External aborts on instruction fetch must be taken synchronously
    if</ins><del>SysRegAccess_OK,</del> <a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()"><ins>HaveDoubleFaultExt</ins></a><ins>() then assert fault.type !=</ins><del>SysRegAccess_UNDEFINED,</del> <a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_AsyncExternal</ins></a><ins>;
    route_to_el3 =</ins><del>SysRegAccess_TrapToEL1,</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><del>SysRegAccess_TrapToEL2,</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; SCR_EL3.EA == '1' &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault type)"><ins>IsExternalAbort</ins></a><ins>(fault);
    route_to_el2 = (</ins><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>() &amp;&amp; PSTATE.EL IN {</ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>,</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>} &amp;&amp;
                    (HCR_EL2.TGE == '1' || </ins><a href="shared_pseudocode.html#impl-shared.IsSecondStage.1" title="function: boolean IsSecondStage(FaultRecord fault)"><ins>IsSecondStage</ins></a><ins>(fault) ||
                    (</ins><a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()"><ins>HaveRASExt</ins></a><ins>() &amp;&amp; HCR_EL2.TEA == '1' &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault type)"><ins>IsExternalAbort</ins></a><ins>(fault))));

    bits(64) preferred_exception_return = </ins><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><ins>ThisInstrAddr</ins></a><ins>();
    vect_offset = 0x0;

    exception = </ins><a href="shared_pseudocode.html#AArch64.AbortSyndrome.3" title="function: ExceptionRecord AArch64.AbortSyndrome(Exception type, FaultRecord fault, bits(64) vaddress)"><ins>AArch64.AbortSyndrome</ins></a><ins>(</ins><a href="shared_pseudocode.html#Exception_InstructionAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_InstructionAbort</ins></a><ins>, fault, vaddress);

    if PSTATE.EL == </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins> || route_to_el3 then
        </ins><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>, exception, preferred_exception_return, vect_offset);
    elsif PSTATE.EL == </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins> || route_to_el2 then
        </ins><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>, exception, preferred_exception_return, vect_offset);
    else
        </ins><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>, exception, preferred_exception_return, vect_offset);</ins><del>SysRegAccess_TrapToEL3 };</del></p></div><div class="ps" psname="aarch64.exceptions.aborts.AArch64.PCAlignmentFault"><a id="aarch64.exceptions.aborts.AArch64.PCAlignmentFault" name="aarch64.exceptions.aborts.AArch64.PCAlignmentFault"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>exceptions</ins><del>debug</del>/<ins>aborts</ins><del>statisticalprofiling</del>/<ins>AArch64.PCAlignmentFault</ins><del>TimeStamp</del></h3><p class="pseudocode"><ins>// AArch64.PCAlignmentFault()
// ==========================
// Called on unaligned program counter in AArch64 state.</ins><del>enumeration</del>

<a id="AArch64.PCAlignmentFault.0" name="AArch64.PCAlignmentFault.0"></a><ins>AArch64.PCAlignmentFault()

    bits(64) preferred_exception_return =</ins><del>TimeStamp {</del> <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><ins>ThisInstrAddr</ins></a><ins>();
    vect_offset = 0x0;

    exception =</ins><del>TimeStamp_None,</del> <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><ins>(</ins><del>TimeStamp_Virtual,</del><a href="shared_pseudocode.html#Exception_PCAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_PCAlignment</ins></a><ins>);
    exception.vaddress = </ins><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><ins>ThisInstrAddr</ins></a><ins>();

    if </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(PSTATE.EL) > </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>) then
        </ins><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><ins>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
    elsif </ins><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>() &amp;&amp; HCR_EL2.TGE == '1' then
        </ins><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>, exception, preferred_exception_return, vect_offset);
    else
        </ins><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>, exception, preferred_exception_return, vect_offset);</ins><del>TimeStamp_Physical };</del></p></div><div class="ps" psname="aarch64.exceptions.aborts.AArch64.SPAlignmentFault"><a id="aarch64.exceptions.aborts.AArch64.SPAlignmentFault" name="aarch64.exceptions.aborts.AArch64.SPAlignmentFault"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>exceptions</ins><del>debug</del>/<ins>aborts</ins><del>takeexceptiondbg</del>/<ins>AArch64.SPAlignmentFault</ins><del>AArch64.TakeExceptionInDebugState</del></h3><p class="pseudocode"><ins>// AArch64.SPAlignmentFault()
// ==========================
// Called on an unaligned stack pointer in AArch64 state.</ins><del>// AArch64.TakeExceptionInDebugState()
// ===================================
// Take an exception in Debug state to an Exception Level using AArch64.</del>

<a id="AArch64.SPAlignmentFault.0" name="AArch64.SPAlignmentFault.0"></a><ins>AArch64.SPAlignmentFault()

    bits(64) preferred_exception_return =</ins><del>AArch64.TakeExceptionInDebugState(bits(2) target_el,</del> <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><ins>ThisInstrAddr</ins></a><a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is (Exception type, bits(25) syndrome, bits(64) vaddress, boolean ipavalid, bits(1) NS, bits(52) ipaddress)"><del>ExceptionRecord</del></a><ins>();
    vect_offset = 0x0;

    exception =</ins><del>exception)
    assert</del> <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>(</ins><del>(target_el) &amp;&amp; !</del><a href="shared_pseudocode.html#Exception_SPAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_SPAlignment</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><ins>);

    if</ins><del>(target_el) &amp;&amp;</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a><ins>(PSTATE.EL) ></ins><del>(target_el) >=</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a><ins>(</ins><del>(PSTATE.EL);

    sync_errors =</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#impl-shared.HaveIESB.0" title="function: boolean HaveIESB()"><del>HaveIESB</del></a><ins>) then</ins><del>() &amp;&amp;</del>
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><del>SCTLR</del></a><ins>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
    elsif</ins><del>[].IESB == '1';
    if</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()"><del>HaveDoubleFaultExt</del></a><ins>() &amp;&amp; HCR_EL2.TGE == '1' then</ins><del>() then
        sync_errors = sync_errors || (SCR_EL3.EA == '1' &amp;&amp; SCR_EL3.NMEA == '1' &amp;&amp; PSTATE.EL ==</del>
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><ins>(</ins><del>);
    // SCTLR[].IESB might be ignored in Debug state.
    if !</del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><del>ConstrainUnpredictableBool</del></a><del>(</del><a href="shared_pseudocode.html#Unpredictable_IESBinDebug" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_IESBinDebug</del></a><del>) then
        sync_errors = FALSE;
    if sync_errors &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.InsertIESBBeforeException.1" title="function: boolean InsertIESBBeforeException(bits(2) el)"><del>InsertIESBBeforeException</del></a><del>(target_el) then
        </del><a href="shared_pseudocode.html#impl-shared.SynchronizeErrors.0" title="function: SynchronizeErrors()"><del>SynchronizeErrors</del></a><del>();

    </del><a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()"><del>SynchronizeContext</del></a><del>();

    // If coming from AArch32 state, the top parts of the X[] registers might be set to zero
    from_32 = </del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>();
    if from_32 then </del><a href="shared_pseudocode.html#AArch64.MaybeZeroRegisterUppers.0" title="function: AArch64.MaybeZeroRegisterUppers()"><del>AArch64.MaybeZeroRegisterUppers</del></a><del>();
    </del><a href="shared_pseudocode.html#impl-aarch64.MaybeZeroSVEUppers.1" title="function: MaybeZeroSVEUppers(bits(2) target_el)"><del>MaybeZeroSVEUppers</del></a><del>(target_el);

    </del><a href="shared_pseudocode.html#AArch64.ReportException.2" title="function: AArch64.ReportException(ExceptionRecord exception, bits(2) target_el)"><del>AArch64.ReportException</del></a><del>(exception, target_el);

    PSTATE.EL = target_el;  PSTATE.nRW = '0';  PSTATE.SP = '1';

    </del><a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(32) value"><del>SPSR</del></a><del>[] = bits(32) UNKNOWN;
    </del><a href="shared_pseudocode.html#impl-aarch64.ELR.write.0" title="accessor: ELR[] = bits(64) value"><del>ELR</del></a><del>[] = bits(64) UNKNOWN;

    if </del><a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()"><del>HaveSSBSExt</del></a><del>() then PSTATE.SSBS = bits(1) UNKNOWN;
    // PSTATE.{SS,D,A,I,F} are not observable and ignored in Debug state, so behave as if UNKNOWN.
    PSTATE.&lt;SS,D,A,I,F> = bits(5) UNKNOWN;
    DLR_EL0 = bits(64) UNKNOWN;
    DSPSR_EL0 = bits(32) UNKNOWN;

    if </del><a href="shared_pseudocode.html#impl-shared.HaveBTIExt.0" title="function: boolean HaveBTIExt()"><del>HaveBTIExt</del></a><del>() then
        if exception.type == </del><a href="shared_pseudocode.html#Exception_Breakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_Breakpoint</del></a><del> then
            DSPSR_EL0&lt;11:10> = PSTATE.BTYPE;
        else
            DSPSR_EL0&lt;11:10> = if </del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><del>ConstrainUnpredictableBool</del></a><del>(</del><a href="shared_pseudocode.html#Unpredictable_ZEROBTYPE" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_ZEROBTYPE</del></a><del>) then '00' else PSTATE.BTYPE;
        PSTATE.BTYPE = '00';

    PSTATE.IL = '0';
    if from_32 then                                 // Coming from AArch32
        PSTATE.IT = '00000000';  PSTATE.T = '0';    // PSTATE.J is RES0
    if </del><a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()"><del>HavePANExt</del></a><del>() &amp;&amp; (PSTATE.EL == </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del> || (PSTATE.EL == </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a><ins>, exception, preferred_exception_return, vect_offset);
    else</ins><del>&amp;&amp;</del>
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)"><del>ELIsInHost</del></a>(<del>))) &amp;&amp; </del><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><del>SCTLR</del></a><del>[].SPAN == '0' then
        PSTATE.PAN = '1';
    if </del><a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()"><del>HaveMTEExt</del></a><del>() then PSTATE.TCO = '1';

    EDSCR.ERR = '1';
    </del><a href="shared_pseudocode.html#impl-shared.UpdateEDSCRFields.0" title="function: UpdateEDSCRFields()"><del>UpdateEDSCRFields</del></a><del>();                        // Update EDSCR processor state flags.

    if sync_errors then
        </del><a href="shared_pseudocode.html#impl-shared.SynchronizeErrors.0" title="function: SynchronizeErrors()"><del>SynchronizeErrors</del></a><del>();

    </del><a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()"><del>EndOfInstruction</del></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>, exception, preferred_exception_return, vect_offset);</ins><del>();</del></p></div><div class="ps" psname="aarch64.exceptions.aborts.BranchTargetException"><a id="aarch64.exceptions.aborts.BranchTargetException" name="aarch64.exceptions.aborts.BranchTargetException"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>exceptions</ins><del>debug</del>/<ins>aborts</ins><del>watchpoint</del>/<ins>BranchTargetException</ins><del>AArch64.WatchpointByteMatch</del></h3><p class="pseudocode"><ins>// BranchTargetException
// =====================
// Raise branch target exception.</ins><del>// AArch64.WatchpointByteMatch()
// =============================

boolean</del>

<a id="AArch64.BranchTargetException.1_2" name="AArch64.BranchTargetException.1_2"></a><ins>AArch64.BranchTargetException(bits(52) vaddress)

    route_to_el2 =</ins><del>AArch64.WatchpointByteMatch(integer n,</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><ins>() &amp;&amp; PSTATE.EL ==</ins><del>acctype, bits(64) vaddress)

    el = if</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()"><del>HaveNV2Ext</del></a> <ins>&amp;&amp; HCR_EL2.TGE == '1';
    bits(64) preferred_exception_return =</ins><del>() &amp;&amp; acctype ==</del> <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><ins>ThisInstrAddr</ins></a><a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NV2REGISTER</del></a><ins>();
    vect_offset = 0x0;

    exception =</ins><del>then</del> <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>(</ins><del>else PSTATE.EL;
    top =</del><a href="shared_pseudocode.html#Exception_BranchTarget" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_BranchTarget</ins></a><a href="shared_pseudocode.html#impl-shared.AddrTop.3" title="function: integer AddrTop(bits(64) address, boolean IsInstr, bits(2) el)"><del>AddrTop</del></a><ins>);
    exception.syndrome&lt;1:0>   = PSTATE.BTYPE;
    exception.syndrome&lt;24:2>  =</ins><del>(vaddress, FALSE, el);
    bottom = if DBGWVR_EL1[n]&lt;2> == '1' then 2 else 3;            // Word or doubleword
    byte_select_match = (DBGWCR_EL1[n].BAS&lt;</del> <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><ins>Zeros</ins></a><ins>();         // RES0

    if </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a><ins>(PSTATE.EL) ></ins><del>(vaddress&lt;bottom-1:0>)> != '0');
    mask =</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a><ins>(</ins><del>(DBGWCR_EL1[n].MASK);

    // If DBGWCR_EL1[n].MASK is non-zero value and DBGWCR_EL1[n].BAS is not set to '11111111', or
    // DBGWCR_EL1[n].BAS specifies a non-contiguous set of bytes behavior is CONSTRAINED
    // UNPREDICTABLE.
    if mask > 0 &amp;&amp; !</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)"><del>IsOnes</del></a><ins>) then</ins><del>(DBGWCR_EL1[n].BAS) then
        byte_select_match =</del>
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><del>ConstrainUnpredictableBool</del></a><ins>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
    elsif route_to_el2 then</ins><del>(</del>
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><a href="shared_pseudocode.html#Unpredictable_WPMASKANDBAS" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_WPMASKANDBAS</del></a><ins>(</ins><del>);
    else
        LSB = (DBGWCR_EL1[n].BAS AND NOT(DBGWCR_EL1[n].BAS - 1));  MSB = (DBGWCR_EL1[n].BAS + LSB);
        if !</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><ins>, exception, preferred_exception_return, vect_offset);
    else</ins><del>(MSB AND (MSB - 1)) then                     // Not contiguous
            byte_select_match =</del>
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><del>ConstrainUnpredictableBool</del></a>(<del>);
            bottom = 3;                                        // For the whole doubleword

    // If the address mask is set to a reserved value, the behavior is CONSTRAINED UNPREDICTABLE.
    if mask > 0 &amp;&amp; mask &lt;= 2 then
        (c, mask) = </del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableInteger.3" title="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high, Unpredictable which)"><del>ConstrainUnpredictableInteger</del></a><del>(3, 31, </del><a href="shared_pseudocode.html#Unpredictable_RESWPMASK" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESWPMASK</del></a><del>);
        assert c IN {</del><a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_DISABLED</del></a><del>, </del><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_NONE</del></a><del>, </del><a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_UNKNOWN</del></a><del>};
        case c of
            when </del><a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_DISABLED</del></a><del>  return FALSE;            // Disabled
            when </del><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_NONE</del></a><del>      mask = 0;                // No masking
            // Otherwise the value returned by ConstrainUnpredictableInteger is a not-reserved value

    if mask > bottom then
        WVR_match = (vaddress&lt;top:mask> == DBGWVR_EL1[n]&lt;top:mask>);
        // If masked bits of DBGWVR_EL1[n] are not zero, the behavior is CONSTRAINED UNPREDICTABLE.
        if WVR_match &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(DBGWVR_EL1[n]&lt;mask-1:bottom>) then
            WVR_match = </del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><del>ConstrainUnpredictableBool</del></a><del>(</del><a href="shared_pseudocode.html#Unpredictable_WPMASKEDBITS" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_WPMASKEDBITS</del></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#Unpredictable_WPBASCONTIGUOUS" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_WPBASCONTIGUOUS</del></a><ins>, exception, preferred_exception_return, vect_offset);</ins><del>);
    else
        WVR_match = vaddress&lt;top:bottom> == DBGWVR_EL1[n]&lt;top:bottom>;

    return WVR_match &amp;&amp; byte_select_match;</del></p></div><div class="ps" psname="aarch64.exceptions.aborts.EffectiveTCF"><a id="aarch64.exceptions.aborts.EffectiveTCF" name="aarch64.exceptions.aborts.EffectiveTCF"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>exceptions</ins><del>debug</del>/<ins>aborts</ins><del>watchpoint</del>/<ins>EffectiveTCF</ins><del>AArch64.WatchpointMatch</del></h3><p class="pseudocode"><ins>// EffectiveTCF()
// ==============
// Returns the TCF field applied to Tag Check Fails in the given Exception Level
</ins><del>// AArch64.WatchpointMatch()
// =========================
// Watchpoint matching in an AArch64 translation regime.
</del>
<ins>bits(2)</ins><del>boolean</del> <a id="impl-aarch64.EffectiveTCF.1_2" name="impl-aarch64.EffectiveTCF.1_2"></a><ins>EffectiveTCF(bits(2) el)
    if el ==</ins><del>AArch64.WatchpointMatch(integer n, bits(64) vaddress, integer size, boolean ispriv,</del> <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a> <ins>then
        tcf = SCTLR_EL3.TCF;
    elsif el ==</ins><del>acctype, boolean iswrite)
    assert !</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a> <ins>then
        tcf = SCTLR_EL2.TCF;
    elsif el ==</ins><del>(</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a> <ins>then
        tcf = SCTLR_EL1.TCF;
    elsif el ==</ins><del>());
    assert n &lt;=</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a> <ins>&amp;&amp; HCR_EL2.&lt;E2H,TGE> == '11' then
        tcf = SCTLR_EL2.TCF0;
    elsif el ==</ins><del>(ID_AA64DFR0_EL1.WRPs);

    // "ispriv" is FALSE for LDTR/STTR instructions executed at EL1 and all
    // load/stores at EL0, TRUE for all other load/stores. "iswrite" is TRUE for stores, FALSE for
    // loads.
    enabled = DBGWCR_EL1[n].E == '1';
    linked = DBGWCR_EL1[n].WT == '1';
    isbreakpnt = FALSE;

    state_match =</del> <del>(DBGWCR_EL1[n].SSC, DBGWCR_EL1[n].HMC, DBGWCR_EL1[n].PAC,
                                     linked, DBGWCR_EL1[n].LBN, isbreakpnt, acctype, ispriv);

    ls_match = (DBGWCR_EL1[n].LSC&lt;(if iswrite then 1 else 0)> == '1');

    value_match = FALSE;
    for byte = 0 to size - 1
        value_match = value_match || </del><a href="shared_pseudocode.html#AArch64.WatchpointByteMatch.3" title="function: boolean AArch64.WatchpointByteMatch(integer n, AccType acctype, bits(64) vaddress)"><del>AArch64.WatchpointByteMatch</del></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#AArch64.StateMatch.8" title="function: boolean AArch64.StateMatch(bits(2) SSC, bit HMC, bits(2) PxC, boolean linked, bits(4) LBN, boolean isbreakpnt, AccType acctype, boolean ispriv)"><del>AArch64.StateMatch</del></a> <ins>&amp;&amp; HCR_EL2.&lt;E2H,TGE> != '11' then
        tcf = SCTLR_EL1.TCF0;
</ins><del>(n, acctype, vaddress + byte);
</del>
<ins>    return tcf;</ins><del>    return value_match &amp;&amp; state_match &amp;&amp; ls_match &amp;&amp; enabled;</del></p></div><div class="ps" psname="aarch64.exceptions.aborts.RecordTagCheckFail"><a id="aarch64.exceptions.aborts.RecordTagCheckFail" name="aarch64.exceptions.aborts.RecordTagCheckFail"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/<ins>RecordTagCheckFail</ins><del>AArch64.Abort</del></h3><p class="pseudocode"><ins>// RecordTagCheckFail()
// ====================
// Records a tag fail exception into the appropriate TCFR_ELx</ins><del>// AArch64.Abort()
// ===============
// Abort and Debug exception handling in an AArch64 translation regime.</del>

<a id="impl-aarch64.ReportTagCheckFail.2_2" name="impl-aarch64.ReportTagCheckFail.2_2"></a><ins>ReportTagCheckFail(bits(2) el, bit ttbr)
    if el ==</ins><del>AArch64.Abort(bits(64) vaddress,</del> <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><del>FaultRecord</del></a> <ins>then
        assert ttbr == '0';
        TFSR_EL3.TF0 = '1';
    elsif el ==</ins><del>fault)

    if</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-shared.IsDebugException.1" title="function: boolean IsDebugException(FaultRecord fault)"><del>IsDebugException</del></a> <ins>then
        if ttbr == '0' then
            TFSR_EL2.TF0 = '1';
        else
            TFSR_EL2.TF1 = '1';
    elsif el ==</ins><del>(fault) then
        if fault.acctype ==</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IFETCH</del></a> then
<ins>        if ttbr == '0' then
            TFSR_EL1.TF0 = '1';
        else
            TFSR_EL1.TF1 = '1';
    elsif el ==</ins><del>            if</del> <del>() &amp;&amp; fault.debugmoe == </del><a href="shared_pseudocode.html#DebugException_VectorCatch" title="constant bits(4) DebugException_VectorCatch = '0101'"><del>DebugException_VectorCatch</del></a><del> then
                </del><a href="shared_pseudocode.html#AArch64.VectorCatchException.1" title="function: AArch64.VectorCatchException(FaultRecord fault)"><del>AArch64.VectorCatchException</del></a><del>(fault);
            else
                </del><a href="shared_pseudocode.html#AArch64.BreakpointException.1" title="function: AArch64.BreakpointException(FaultRecord fault)"><del>AArch64.BreakpointException</del></a><del>(fault);
        else
            </del><a href="shared_pseudocode.html#AArch64.WatchpointException.2" title="function: AArch64.WatchpointException(bits(64) vaddress, FaultRecord fault)"><del>AArch64.WatchpointException</del></a><del>(vaddress, fault);
    elsif fault.acctype == </del><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IFETCH</del></a><del> then
        </del><a href="shared_pseudocode.html#AArch64.InstructionAbort.2" title="function: AArch64.InstructionAbort(bits(64) vaddress, FaultRecord fault)"><del>AArch64.InstructionAbort</del></a><del>(vaddress, fault);
    else
        </del><a href="shared_pseudocode.html#AArch64.DataAbort.2" title="function: AArch64.DataAbort(bits(64) vaddress, FaultRecord fault)"><del>AArch64.DataAbort</del></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a> <ins>then
        if ttbr == '0' then
            TFSRE0_EL1.TF0 = '1';
        else
            TFSRE0_EL1.TF1 = '1';</ins><del>(vaddress, fault);</del></p></div><div class="ps" psname="aarch64.exceptions.aborts.TagCheckFail"><a id="aarch64.exceptions.aborts.TagCheckFail" name="aarch64.exceptions.aborts.TagCheckFail"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/<ins>TagCheckFail</ins><del>AArch64.AbortSyndrome</del></h3><p class="pseudocode"><ins>// TagCheckFail()
// ==============
// Handle a tag check fail condition</ins><del>// AArch64.AbortSyndrome()
// =======================
// Creates an exception syndrome record for Abort and Watchpoint exceptions
// from an AArch64 translation regime.

ExceptionRecord</del>

<a id="impl-aarch64.TagCheckFail.2_2" name="impl-aarch64.TagCheckFail.2_2"></a><ins>TagCheckFail(bits(64) vaddress, boolean iswrite)
    bits(2) tcf =</ins><del>AArch64.AbortSyndrome(</del> <a href="shared_pseudocode.html#impl-aarch64.EffectiveTCF.1" title="function: bits(2) EffectiveTCF(bits(2) el)"><ins>EffectiveTCF</ins></a><a href="shared_pseudocode.html#Exception" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception</del></a><ins>(PSTATE.EL);
    if tcf == '01' then</ins><del>type,</del>
        <a href="shared_pseudocode.html#impl-aarch64.TagCheckFault.2" title="function: TagCheckFault(bits(64) va, boolean write)"><ins>TagCheckFault</ins></a><a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><del>FaultRecord</del></a><ins>(vaddress, iswrite);
    elsif tcf == '10' then</ins><del>fault, bits(64) vaddress)

    exception =</del>
        <del>(type);

    d_side = type IN {</del><a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_DataAbort</del></a><del>, </del><a href="shared_pseudocode.html#Exception_NV2DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_NV2DataAbort</del></a><del>, </del><a href="shared_pseudocode.html#Exception_Watchpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_Watchpoint</del></a><del>};

    exception.syndrome = </del><a href="shared_pseudocode.html#AArch64.FaultSyndrome.2" title="function: bits(25) AArch64.FaultSyndrome(boolean d_side, FaultRecord fault)"><del>AArch64.FaultSyndrome</del></a><del>(d_side, fault);
    exception.vaddress = </del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><del>(vaddress);
    if </del><a href="shared_pseudocode.html#impl-shared.IPAValid.1" title="function: boolean IPAValid(FaultRecord fault)"><del>IPAValid</del></a><a href="shared_pseudocode.html#impl-aarch64.ReportTagCheckFail.2" title="function: ReportTagCheckFail(bits(2) el, bit ttbr)"><ins>ReportTagCheckFail</ins></a><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a><ins>(PSTATE.EL, vaddress&lt;55>);</ins><del>(fault) then
        exception.ipavalid = TRUE;
        exception.NS = fault.ipaddress.NS;
        exception.ipaddress = fault.ipaddress.address;
    else
        exception.ipavalid = FALSE;

    return exception;</del></p></div><div class="ps" psname="aarch64.exceptions.aborts.TagCheckFault"><a id="aarch64.exceptions.aborts.TagCheckFault" name="aarch64.exceptions.aborts.TagCheckFault"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/<ins>TagCheckFault</ins><del>AArch64.CheckPCAlignment</del></h3><p class="pseudocode"><ins>// TagCheckFault()
// ===============
// Raise a tag check fail exception.</ins><del>// AArch64.CheckPCAlignment()
// ==========================</del>

<a id="impl-aarch64.TagCheckFault.2_2" name="impl-aarch64.TagCheckFault.2_2"></a><ins>TagCheckFault(bits(64) va, boolean write)
    bits(2) target_el;
    bits(64) preferred_exception_return =</ins><del>AArch64.CheckPCAlignment()

    bits(64) pc =</del> <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
<ins>    integer vect_offset = 0x0;

    if PSTATE.EL ==</ins><del>    if pc&lt;1:0> != '00' then</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#AArch64.PCAlignmentFault.0" title="function: AArch64.PCAlignmentFault()"><del>AArch64.PCAlignmentFault</del></a><ins> then
        target_el = if HCR_EL2.TGE == 0 then </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins> else </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>;
    else
        target_el = PSTATE.EL;

    exception = </ins><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><ins>(</ins><a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_DataAbort</ins></a><ins>);
    exception.syndrome&lt;5:0> = '010001';
    if write then
        exception.syndrome&lt;6> = '1';
    exception.vaddress = va;

    </ins><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><ins>(target_el, exception, preferred_exception_return, vect_offset);</ins><del>();</del></p></div><div class="ps" psname="aarch64.exceptions.asynch.AArch64.TakePhysicalFIQException"><a id="aarch64.exceptions.asynch.AArch64.TakePhysicalFIQException" name="aarch64.exceptions.asynch.AArch64.TakePhysicalFIQException"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/<ins>asynch</ins><del>aborts</del>/<ins>AArch64.TakePhysicalFIQException</ins><del>AArch64.DataAbort</del></h3><p class="pseudocode"><ins>// AArch64.TakePhysicalFIQException()
// ==================================</ins><del>// AArch64.DataAbort()
// ===================</del>

<a id="AArch64.TakePhysicalFIQException.0" name="AArch64.TakePhysicalFIQException.0"></a><ins>AArch64.TakePhysicalFIQException()

    route_to_el3 =</ins><del>AArch64.DataAbort(bits(64) vaddress,</del> <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><del>FaultRecord</del></a><del> fault)
    route_to_el3 = </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a><ins>) &amp;&amp; SCR_EL3.FIQ == '1';
    route_to_el2 = (</ins><del>) &amp;&amp; SCR_EL3.EA == '1' &amp;&amp;</del><a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault type)"><del>IsExternalAbort</del></a><del>(fault);
    route_to_el2 = (</del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>,<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a><ins>} &amp;&amp;
                    (HCR_EL2.TGE == '1' || HCR_EL2.FMO == '1'));
    bits(64) preferred_exception_return =</ins><del>} &amp;&amp; (HCR_EL2.TGE == '1' ||
                    (</del> <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><ins>ThisInstrAddr</ins></a><a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()"><del>HaveRASExt</del></a><ins>();
    vect_offset = 0x100;
    exception =</ins><del>() &amp;&amp; HCR_EL2.TEA == '1' &amp;&amp;</del> <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault type)"><del>IsExternalAbort</del></a><ins>(</ins><del>(fault)) ||
                    (</del><a href="shared_pseudocode.html#Exception_FIQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_FIQ</ins></a><a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()"><del>HaveNV2Ext</del></a><ins>);

    if route_to_el3 then</ins><del>() &amp;&amp; fault.acctype ==</del>
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NV2REGISTER</del></a><ins>(</ins><del>) ||</del><a href="shared_pseudocode.html#impl-shared.IsSecondStage.1" title="function: boolean IsSecondStage(FaultRecord fault)"><del>IsSecondStage</del></a><del>(fault)));

    bits(64) preferred_exception_return = </del><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><del>ThisInstrAddr</del></a><del>();
    if (</del><a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()"><del>HaveDoubleFaultExt</del></a><del>() &amp;&amp; (PSTATE.EL == </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a><ins>, exception, preferred_exception_return, vect_offset);
    elsif PSTATE.EL ==</ins><del>|| route_to_el3) &amp;&amp;</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault type)"><del>IsExternalAbort</del></a> <ins>|| route_to_el2 then
        assert PSTATE.EL !=</ins><del>(fault) &amp;&amp; SCR_EL3.EASE == '1') then
        vect_offset = 0x180;
    else
        vect_offset = 0x0;
    if</del> <a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()"><del>HaveNV2Ext</del></a><del>() &amp;&amp; fault.acctype == </del><a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NV2REGISTER</del></a><del> then
        exception = </del><a href="shared_pseudocode.html#AArch64.AbortSyndrome.3" title="function: ExceptionRecord AArch64.AbortSyndrome(Exception type, FaultRecord fault, bits(64) vaddress)"><del>AArch64.AbortSyndrome</del></a><del>(</del><a href="shared_pseudocode.html#Exception_NV2DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_NV2DataAbort</del></a><del>, fault, vaddress);
    else
        exception = </del><a href="shared_pseudocode.html#AArch64.AbortSyndrome.3" title="function: ExceptionRecord AArch64.AbortSyndrome(Exception type, FaultRecord fault, bits(64) vaddress)"><del>AArch64.AbortSyndrome</del></a><del>(</del><a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_DataAbort</del></a><del>, fault, vaddress);
    if PSTATE.EL == </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a><ins>;</ins><del>|| route_to_el3 then</del>
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>, exception, preferred_exception_return, vect_offset);
    elsif PSTATE.EL == </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a><ins>, exception, preferred_exception_return, vect_offset);
    else
        assert PSTATE.EL IN {</ins><del>|| route_to_el2 then</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a><ins>,</ins><del>(</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>};</ins><del>, exception, preferred_exception_return, vect_offset);
    else</del>
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p></div><div class="ps" psname="aarch64.exceptions.asynch.AArch64.TakePhysicalIRQException"><a id="aarch64.exceptions.asynch.AArch64.TakePhysicalIRQException" name="aarch64.exceptions.asynch.AArch64.TakePhysicalIRQException"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/<ins>asynch</ins><del>aborts</del>/<ins>AArch64.TakePhysicalIRQException</ins><del>AArch64.InstructionAbort</del></h3><p class="pseudocode"><ins>// AArch64.TakePhysicalIRQException()
// ==================================
// Take an enabled physical IRQ exception.</ins><del>// AArch64.InstructionAbort()
// ==========================</del>

<a id="AArch64.TakePhysicalIRQException.0" name="AArch64.TakePhysicalIRQException.0"></a><ins>AArch64.TakePhysicalIRQException()

    route_to_el3 =</ins><del>AArch64.InstructionAbort(bits(64) vaddress,</del> <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><del>FaultRecord</del></a><del> fault)
    // External aborts on instruction fetch must be taken synchronously
    if </del><a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()"><del>HaveDoubleFaultExt</del></a><del>() then assert fault.type != </del><a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_AsyncExternal</del></a><del>;
    route_to_el3 = </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a><ins>) &amp;&amp; SCR_EL3.IRQ == '1';
    route_to_el2 = (</ins><del>) &amp;&amp; SCR_EL3.EA == '1' &amp;&amp;</del><a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault type)"><del>IsExternalAbort</del></a><del>(fault);
    route_to_el2 = (</del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>,<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp;
<ins>                    (HCR_EL2.TGE == '1' || HCR_EL2.IMO == '1'));
    bits(64) preferred_exception_return =</ins><del>                    (HCR_EL2.TGE == '1' ||</del> <a href="shared_pseudocode.html#impl-shared.IsSecondStage.1" title="function: boolean IsSecondStage(FaultRecord fault)"><del>IsSecondStage</del></a><del>(fault) ||
                    (</del><a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()"><del>HaveRASExt</del></a><del>() &amp;&amp; HCR_EL2.TEA == '1' &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault type)"><del>IsExternalAbort</del></a><del>(fault))));

    bits(64) preferred_exception_return = </del><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
<ins>    vect_offset = 0x80;
</ins><del>    vect_offset = 0x0;
</del>
    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><a href="shared_pseudocode.html#AArch64.AbortSyndrome.3" title="function: ExceptionRecord AArch64.AbortSyndrome(Exception type, FaultRecord fault, bits(64) vaddress)"><del>AArch64.AbortSyndrome</del></a>(<a href="shared_pseudocode.html#Exception_IRQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_IRQ</ins></a><a href="shared_pseudocode.html#Exception_InstructionAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_InstructionAbort</del></a><ins>);
</ins><del>, fault, vaddress);
</del>
<ins>    if route_to_el3 then</ins><del>    if PSTATE.EL ==</del>
        <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del> || route_to_el3 then
        </del><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, exception, preferred_exception_return, vect_offset);
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> <ins>|| route_to_el2 then
        assert PSTATE.EL !=</ins><del>|| route_to_el2 then</del> <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>;
        </ins><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a><ins>, exception, preferred_exception_return, vect_offset);
    else
        assert PSTATE.EL IN {</ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>,</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>};</ins><del>, exception, preferred_exception_return, vect_offset);
    else</del>
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p></div><div class="ps" psname="aarch64.exceptions.asynch.AArch64.TakePhysicalSErrorException"><a id="aarch64.exceptions.asynch.AArch64.TakePhysicalSErrorException" name="aarch64.exceptions.asynch.AArch64.TakePhysicalSErrorException"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/<ins>asynch</ins><del>aborts</del>/<ins>AArch64.TakePhysicalSErrorException</ins><del>AArch64.PCAlignmentFault</del></h3><p class="pseudocode"><ins>// AArch64.TakePhysicalSErrorException()
// =====================================</ins><del>// AArch64.PCAlignmentFault()
// ==========================
// Called on unaligned program counter in AArch64 state.</del>

<a id="AArch64.TakePhysicalSErrorException.2" name="AArch64.TakePhysicalSErrorException.2"></a><ins>AArch64.TakePhysicalSErrorException(boolean impdef_syndrome, bits(24) syndrome)
</ins><del>AArch64.PCAlignmentFault()
</del>
<ins>    route_to_el3 =</ins><del>    bits(64) preferred_exception_return =</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><del>ThisInstrAddr</del></a><ins>(</ins><del>();
    vect_offset = 0x0;

    exception =</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a><ins>) &amp;&amp; SCR_EL3.EA == '1';
    route_to_el2 = (</ins><del>(</del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#Exception_PCAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_PCAlignment</del></a><ins>() &amp;&amp; PSTATE.EL IN {</ins><del>);
    exception.vaddress =</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>,</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>} &amp;&amp;
                    (HCR_EL2.TGE == '1' || (!</ins><a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><ins>IsInHost</ins></a><ins>() &amp;&amp; HCR_EL2.AMO == '1')));
    bits(64) preferred_exception_return = </ins><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
<ins>    vect_offset = 0x180;
</ins>
<ins>    exception =</ins><del>    if</del> <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>(</ins><del>(PSTATE.EL) ></del><a href="shared_pseudocode.html#Exception_SError" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_SError</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>);
    exception.syndrome&lt;24> = if impdef_syndrome then '1' else '0';
    exception.syndrome&lt;23:0> = syndrome;</ins><del>(</del>

    <a href="shared_pseudocode.html#impl-shared.ClearPendingPhysicalSError.0" title="function: ClearPendingPhysicalSError()"><ins>ClearPendingPhysicalSError</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>();

    if PSTATE.EL ==</ins><del>) then</del> <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins> || route_to_el3 then
        </ins><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a><ins>(</ins><del>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
    elsif</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><ins>, exception, preferred_exception_return, vect_offset);
    elsif PSTATE.EL == </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a> <ins>|| route_to_el2 then</ins><del>() &amp;&amp; HCR_EL2.TGE == '1' then</del>
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p></div><div class="ps" psname="aarch64.exceptions.asynch.AArch64.TakeVirtualFIQException"><a id="aarch64.exceptions.asynch.AArch64.TakeVirtualFIQException" name="aarch64.exceptions.asynch.AArch64.TakeVirtualFIQException"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/<ins>asynch</ins><del>aborts</del>/<ins>AArch64.TakeVirtualFIQException</ins><del>AArch64.SPAlignmentFault</del></h3><p class="pseudocode"><ins>// AArch64.TakeVirtualFIQException()
// =================================</ins><del>// AArch64.SPAlignmentFault()
// ==========================
// Called on an unaligned stack pointer in AArch64 state.</del>

<a id="AArch64.TakeVirtualFIQException.0" name="AArch64.TakeVirtualFIQException.0"></a><ins>AArch64.TakeVirtualFIQException()
    assert</ins><del>AArch64.SPAlignmentFault()

    bits(64) preferred_exception_return =</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><del>ThisInstrAddr</del></a><ins>() &amp;&amp; PSTATE.EL IN {</ins><del>();
    vect_offset = 0x0;

    exception =</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a><ins>,</ins><del>(</del><a href="shared_pseudocode.html#Exception_SPAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_SPAlignment</del></a><del>);

    if </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(PSTATE.EL) > </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a><ins>};
    assert HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.FMO == '1';  // Virtual IRQ enabled if TGE==0 and FMO==1

    bits(64) preferred_exception_return =</ins><del>) then</del> <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><ins>ThisInstrAddr</ins></a><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a><ins>();
    vect_offset = 0x100;

    exception =</ins><del>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
    elsif</del> <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><ins>(</ins><del>() &amp;&amp; HCR_EL2.TGE == '1' then</del><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><a href="shared_pseudocode.html#Exception_FIQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_FIQ</ins></a><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a><ins>);</ins><del>, exception, preferred_exception_return, vect_offset);
    else</del>

    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p></div><div class="ps" psname="aarch64.exceptions.asynch.AArch64.TakeVirtualIRQException"><a id="aarch64.exceptions.asynch.AArch64.TakeVirtualIRQException" name="aarch64.exceptions.asynch.AArch64.TakeVirtualIRQException"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/<ins>asynch</ins><del>aborts</del>/<ins>AArch64.TakeVirtualIRQException</ins><del>BranchTargetException</del></h3><p class="pseudocode"><ins>// AArch64.TakeVirtualIRQException()
// =================================</ins><del>// BranchTargetException
// =====================
// Raise branch target exception.</del>

<a id="AArch64.TakeVirtualIRQException.0" name="AArch64.TakeVirtualIRQException.0"></a><ins>AArch64.TakeVirtualIRQException()
    assert</ins><del>AArch64.BranchTargetException(bits(52) vaddress)

    route_to_el2 =</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a><ins>() &amp;&amp; PSTATE.EL IN {</ins><del>() &amp;&amp; PSTATE.EL ==</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a><ins>,</ins><del>&amp;&amp; HCR_EL2.TGE == '1';
    bits(64) preferred_exception_return =</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>};
    assert HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.IMO == '1';  // Virtual IRQ enabled if TGE==0 and IMO==1

    bits(64) preferred_exception_return = </ins><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
<ins>    vect_offset = 0x80;
</ins><del>    vect_offset = 0x0;
</del>
    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)">ExceptionSyndrome</a>(<del>);
    exception.syndrome&lt;1:0>   = PSTATE.BTYPE;
    exception.syndrome&lt;24:2>  = </del><a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><del>Zeros</del></a><del>();         // RES0

    if </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(PSTATE.EL) > </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>) then
        </del><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a><del>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
    elsif route_to_el2 then
        </del><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><a href="shared_pseudocode.html#Exception_IRQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_IRQ</ins></a><a href="shared_pseudocode.html#Exception_BranchTarget" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_BranchTarget</del></a><ins>);</ins><del>, exception, preferred_exception_return, vect_offset);
    else</del>

    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p></div><div class="ps" psname="aarch64.exceptions.asynch.AArch64.TakeVirtualSErrorException"><a id="aarch64.exceptions.asynch.AArch64.TakeVirtualSErrorException" name="aarch64.exceptions.asynch.AArch64.TakeVirtualSErrorException"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/<ins>asynch</ins><del>aborts</del>/<ins>AArch64.TakeVirtualSErrorException</ins><del>EffectiveTCF</del></h3><p class="pseudocode"><ins>// AArch64.TakeVirtualSErrorException()
// ====================================</ins><del>// EffectiveTCF()
// ==============
// Returns the TCF field applied to Tag Check Fails in the given Exception Level

bits(2)</del>

<a id="AArch64.TakeVirtualSErrorException.2" name="AArch64.TakeVirtualSErrorException.2"></a><ins>AArch64.TakeVirtualSErrorException(boolean impdef_syndrome, bits(24) syndrome)

    assert</ins><del>EffectiveTCF(bits(2) el)
    if el ==</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><ins>() &amp;&amp; PSTATE.EL IN {</ins><del>then
        tcf = SCTLR_EL3.TCF;
    elsif el ==</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>,</ins><del>then
        tcf = SCTLR_EL2.TCF;
    elsif el ==</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a><ins>};
    assert HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.AMO == '1';  // Virtual SError enabled if TGE==0 and AMO==1

    bits(64) preferred_exception_return =</ins><del>then
        tcf = SCTLR_EL1.TCF;
    elsif el ==</del> <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><ins>ThisInstrAddr</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>();
    vect_offset = 0x180;

    exception =</ins><del>&amp;&amp; HCR_EL2.&lt;E2H,TGE> == '11' then
        tcf = SCTLR_EL2.TCF0;
    elsif el ==</del> <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>(</ins><a href="shared_pseudocode.html#Exception_SError" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_SError</ins></a><ins>);
    if </ins><a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()"><ins>HaveRASExt</ins></a><ins>() then
        exception.syndrome&lt;24>   = VSESR_EL2.IDS;
        exception.syndrome&lt;23:0> = VSESR_EL2.ISS;
    else
        exception.syndrome&lt;24> = if impdef_syndrome then '1' else '0';
        if impdef_syndrome then exception.syndrome&lt;23:0> = syndrome;

    </ins><a href="shared_pseudocode.html#impl-shared.ClearPendingVirtualSError.0" title="function: ClearPendingVirtualSError()"><ins>ClearPendingVirtualSError</ins></a><ins>();
    </ins><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>, exception, preferred_exception_return, vect_offset);</ins><del>&amp;&amp; HCR_EL2.&lt;E2H,TGE> != '11' then
        tcf = SCTLR_EL1.TCF0;

    return tcf;</del></p></div><div class="ps" psname="aarch64.exceptions.debug.AArch64.BreakpointException"><a id="aarch64.exceptions.debug.AArch64.BreakpointException" name="aarch64.exceptions.debug.AArch64.BreakpointException"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/<ins>debug</ins><del>aborts</del>/<ins>AArch64.BreakpointException</ins><del>RecordTagCheckFail</del></h3><p class="pseudocode"><ins>// AArch64.BreakpointException()
// =============================</ins><del>// RecordTagCheckFail()
// ====================
// Records a tag fail exception into the appropriate TCFR_ELx</del>

<a id="AArch64.BreakpointException.1" name="AArch64.BreakpointException.1"></a><ins>AArch64.BreakpointException(</ins><del>ReportTagCheckFail(bits(2) el, bit ttbr)
    if el ==</del><a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><ins>FaultRecord</ins></a><ins> fault)
    assert PSTATE.EL != </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a><ins>;

    route_to_el2 = (</ins><del>then
        assert ttbr == '0';
        TFSR_EL3.TF0 = '1';
    elsif el ==</del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>() &amp;&amp; PSTATE.EL IN {</ins><del>then
        if ttbr == '0' then
            TFSR_EL2.TF0 = '1';
        else
            TFSR_EL2.TF1 = '1';
    elsif el ==</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>,</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a><ins>} &amp;&amp;
                    (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1'));

    bits(64) preferred_exception_return =</ins><del>then
        if ttbr == '0' then
            TFSR_EL1.TF0 = '1';
        else
            TFSR_EL1.TF1 = '1';
    elsif el ==</del> <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><ins>ThisInstrAddr</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>();
    vect_offset = 0x0;

    vaddress = bits(64) UNKNOWN;
    exception = </ins><a href="shared_pseudocode.html#AArch64.AbortSyndrome.3" title="function: ExceptionRecord AArch64.AbortSyndrome(Exception type, FaultRecord fault, bits(64) vaddress)"><ins>AArch64.AbortSyndrome</ins></a><ins>(</ins><a href="shared_pseudocode.html#Exception_Breakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_Breakpoint</ins></a><ins>, fault, vaddress);

    if PSTATE.EL == </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins> || route_to_el2 then
        </ins><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>, exception, preferred_exception_return, vect_offset);
    else
        </ins><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>, exception, preferred_exception_return, vect_offset);</ins><del>then
        if ttbr == '0' then
            TFSRE0_EL1.TF0 = '1';
        else
            TFSRE0_EL1.TF1 = '1';</del></p></div><div class="ps" psname="aarch64.exceptions.debug.AArch64.SoftwareBreakpoint"><a id="aarch64.exceptions.debug.AArch64.SoftwareBreakpoint" name="aarch64.exceptions.debug.AArch64.SoftwareBreakpoint"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/<ins>debug</ins><del>aborts</del>/<ins>AArch64.SoftwareBreakpoint</ins><del>TagCheckFail</del></h3><p class="pseudocode"><ins>// AArch64.SoftwareBreakpoint()
// ============================</ins><del>// TagCheckFail()
// ==============
// Handle a tag check fail condition</del>

<a id="AArch64.SoftwareBreakpoint.1" name="AArch64.SoftwareBreakpoint.1"></a><ins>AArch64.SoftwareBreakpoint(bits(16) immediate)

    route_to_el2 = (</ins><del>TagCheckFail(bits(64) vaddress, boolean iswrite)
    bits(2) tcf =</del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#impl-aarch64.EffectiveTCF.1" title="function: bits(2) EffectiveTCF(bits(2) el)"><del>EffectiveTCF</del></a><ins>() &amp;&amp; PSTATE.EL IN {</ins><del>(PSTATE.EL);
    if tcf == '01' then</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#impl-aarch64.TagCheckFault.2" title="function: TagCheckFault(bits(64) va, boolean write)"><del>TagCheckFault</del></a><ins>,</ins><del>(vaddress, iswrite);
    elsif tcf == '10' then</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#impl-aarch64.ReportTagCheckFail.2" title="function: ReportTagCheckFail(bits(2) el, bit ttbr)"><del>ReportTagCheckFail</del></a><ins>} &amp;&amp;
                    (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1'));

    bits(64) preferred_exception_return = </ins><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><ins>ThisInstrAddr</ins></a><ins>();
    vect_offset = 0x0;

    exception = </ins><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><ins>(</ins><a href="shared_pseudocode.html#Exception_SoftwareBreakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_SoftwareBreakpoint</ins></a><ins>);
    exception.syndrome&lt;15:0> = immediate;

    if </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(PSTATE.EL) > </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>) then
        </ins><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><ins>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
    elsif route_to_el2 then
        </ins><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>, exception, preferred_exception_return, vect_offset);
    else
        </ins><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>, exception, preferred_exception_return, vect_offset);</ins><del>(PSTATE.EL, vaddress&lt;55>);</del></p></div><div class="ps" psname="aarch64.exceptions.debug.AArch64.SoftwareStepException"><a id="aarch64.exceptions.debug.AArch64.SoftwareStepException" name="aarch64.exceptions.debug.AArch64.SoftwareStepException"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/<ins>debug</ins><del>aborts</del>/<ins>AArch64.SoftwareStepException</ins><del>TagCheckFault</del></h3><p class="pseudocode"><ins>// AArch64.SoftwareStepException()
// ===============================</ins><del>// TagCheckFault()
// ===============
// Raise a tag check fail exception.</del>

<a id="AArch64.SoftwareStepException.0" name="AArch64.SoftwareStepException.0"></a><ins>AArch64.SoftwareStepException()
    assert PSTATE.EL !=</ins><del>TagCheckFault(bits(64) va, boolean write)
    bits(2) target_el;
    bits(64) preferred_exception_return =</del> <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><del>ThisInstrAddr</del></a><ins>;
</ins><del>();
    integer vect_offset = 0x0;
</del>
<ins>    route_to_el2 = (</ins><del>    if PSTATE.EL ==</del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>() &amp;&amp; PSTATE.EL IN {</ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a><ins>,</ins><del>then
        target_el = if HCR_EL2.TGE == 0 then</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a><ins>} &amp;&amp;
                    (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1'));

    bits(64) preferred_exception_return =</ins><del>else</del> <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><ins>ThisInstrAddr</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>();
    vect_offset = 0x0;
</ins><del>;
    else
        target_el = PSTATE.EL;
</del>
    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_SoftwareStep" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_SoftwareStep</ins></a><a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_DataAbort</del></a>);
<ins>    if</ins><del>    exception.syndrome&lt;5:0> = '010001';
    if write then
        exception.syndrome&lt;6> = '1';
    exception.vaddress = va;</del> <a href="shared_pseudocode.html#impl-shared.SoftwareStep_DidNotStep.0" title="function: boolean SoftwareStep_DidNotStep()"><ins>SoftwareStep_DidNotStep</ins></a><ins>() then
        exception.syndrome&lt;24> = '0';
    else
        exception.syndrome&lt;24> = '1';
        exception.syndrome&lt;6> = if </ins><a href="shared_pseudocode.html#impl-shared.SoftwareStep_SteppedEX.0" title="function: boolean SoftwareStep_SteppedEX()"><ins>SoftwareStep_SteppedEX</ins></a><ins>() then '1' else '0';

    if PSTATE.EL == </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins> || route_to_el2 then
        </ins><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>, exception, preferred_exception_return, vect_offset);
    else
        </ins><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>, exception, preferred_exception_return, vect_offset);</ins><del>(target_el, exception, preferred_exception_return, vect_offset);</del></p></div><div class="ps" psname="aarch64.exceptions.debug.AArch64.VectorCatchException"><a id="aarch64.exceptions.debug.AArch64.VectorCatchException" name="aarch64.exceptions.debug.AArch64.VectorCatchException"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/<ins>debug</ins><del>asynch</del>/<ins>AArch64.VectorCatchException</ins><del>AArch64.TakePhysicalFIQException</del></h3><p class="pseudocode"><ins>// AArch64.VectorCatchException()
// ==============================
// Vector Catch taken from EL0 or EL1 to EL2. This can only be called when debug exceptions are
// being routed to EL2, as Vector Catch is a legacy debug event.</ins><del>// AArch64.TakePhysicalFIQException()
// ==================================</del>

<a id="AArch64.VectorCatchException.1" name="AArch64.VectorCatchException.1"></a><ins>AArch64.VectorCatchException(</ins><del>AArch64.TakePhysicalFIQException()

    route_to_el3 =</del><a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><ins>FaultRecord</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a> <ins>fault)
    assert PSTATE.EL !=</ins><del>(</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><ins>;
    assert</ins><del>) &amp;&amp; SCR_EL3.FIQ == '1';
    route_to_el2 = (</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a><ins>() &amp;&amp; (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1');

    bits(64) preferred_exception_return =</ins><del>() &amp;&amp; PSTATE.EL IN {</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>,</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>} &amp;&amp;
                    (HCR_EL2.TGE == '1' || HCR_EL2.FMO == '1'));
    bits(64) preferred_exception_return = </del><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
<ins>    vect_offset = 0x0;

    vaddress = bits(64) UNKNOWN;
</ins><del>    vect_offset = 0x100;
</del>    exception = <a href="shared_pseudocode.html#AArch64.AbortSyndrome.3" title="function: ExceptionRecord AArch64.AbortSyndrome(Exception type, FaultRecord fault, bits(64) vaddress)"><ins>AArch64.AbortSyndrome</ins></a><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a>(<a href="shared_pseudocode.html#Exception_VectorCatch" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_VectorCatch</ins></a><a href="shared_pseudocode.html#Exception_FIQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_FIQ</del></a><ins>, fault, vaddress);</ins><del>);

    if route_to_el3 then</del>

    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>, exception, preferred_exception_return, vect_offset);
    elsif PSTATE.EL == </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a><del> || route_to_el2 then
        assert PSTATE.EL != </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>;
        </del><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>, exception, preferred_exception_return, vect_offset);
    else
        assert PSTATE.EL IN {</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>,</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>};
        </del><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a><del>(</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a>, exception, preferred_exception_return, vect_offset);</p></div><div class="ps" psname="aarch64.exceptions.debug.AArch64.WatchpointException"><a id="aarch64.exceptions.debug.AArch64.WatchpointException" name="aarch64.exceptions.debug.AArch64.WatchpointException"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/<ins>debug</ins><del>asynch</del>/<ins>AArch64.WatchpointException</ins><del>AArch64.TakePhysicalIRQException</del></h3><p class="pseudocode"><ins>// AArch64.WatchpointException()
// =============================</ins><del>// AArch64.TakePhysicalIRQException()
// ==================================
// Take an enabled physical IRQ exception.</del>

<a id="AArch64.WatchpointException.2" name="AArch64.WatchpointException.2"></a><ins>AArch64.WatchpointException(bits(64) vaddress,</ins><del>AArch64.TakePhysicalIRQException()

    route_to_el3 =</del> <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><ins>FaultRecord</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a> <ins>fault)
    assert PSTATE.EL !=</ins><del>(</del> <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a><ins>;

</ins><del>) &amp;&amp; SCR_EL3.IRQ == '1';
</del>    route_to_el2 = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>,<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp;
<ins>                    (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1'));

</ins><del>                    (HCR_EL2.TGE == '1' || HCR_EL2.IMO == '1'));
</del>    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
<ins>    vect_offset = 0x0;
</ins><del>    vect_offset = 0x80;
</del>
    exception = <a href="shared_pseudocode.html#AArch64.AbortSyndrome.3" title="function: ExceptionRecord AArch64.AbortSyndrome(Exception type, FaultRecord fault, bits(64) vaddress)"><ins>AArch64.AbortSyndrome</ins></a><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a>(<a href="shared_pseudocode.html#Exception_Watchpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_Watchpoint</ins></a><a href="shared_pseudocode.html#Exception_IRQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_IRQ</del></a><ins>, fault, vaddress);
</ins><del>);
</del>
<ins>    if PSTATE.EL ==</ins><del>    if route_to_el3 then</del> <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>, exception, preferred_exception_return, vect_offset);
    elsif PSTATE.EL == </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> <ins>|| route_to_el2 then</ins><del>|| route_to_el2 then
        assert PSTATE.EL !=</del>
        <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>;
        </del><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a><del>, exception, preferred_exception_return, vect_offset);
    else
        assert PSTATE.EL IN {</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>,</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>, exception, preferred_exception_return, vect_offset);
    else</ins><del>};</del>
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p></div><div class="ps" psname="aarch64.exceptions.exceptions.AArch64.ExceptionClass"><a id="aarch64.exceptions.exceptions.AArch64.ExceptionClass" name="aarch64.exceptions.exceptions.AArch64.ExceptionClass"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/<ins>exceptions</ins><del>asynch</del>/<ins>AArch64.ExceptionClass</ins><del>AArch64.TakePhysicalSErrorException</del></h3><p class="pseudocode"><ins>// AArch64.ExceptionClass()
// ========================
// Returns the Exception Class and Instruction Length fields to be reported in ESR

(integer,bit)</ins><del>// AArch64.TakePhysicalSErrorException()
// =====================================</del> <a id="AArch64.ExceptionClass.2" name="AArch64.ExceptionClass.2"></a><ins>AArch64.ExceptionClass(</ins><del>AArch64.TakePhysicalSErrorException(boolean impdef_syndrome, bits(24) syndrome)

    route_to_el3 =</del><a href="shared_pseudocode.html#Exception" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a> <ins>type, bits(2) target_el)

    il = if</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.ThisInstrLength.0" title="function: integer ThisInstrLength()"><ins>ThisInstrLength</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><ins>() == 32 then '1' else '0';
    from_32 =</ins><del>) &amp;&amp; SCR_EL3.EA == '1';
    route_to_el2 = (</del> <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><ins>();
    assert from_32 || il == '1';            // AArch64 instructions always 32-bit

    case type of
        when</ins><del>() &amp;&amp; PSTATE.EL IN {</del> <a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_Uncategorized</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a>        <ins>ec = 0x00; il = '1';
        when</ins><del>,</del> <a href="shared_pseudocode.html#Exception_WFxTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_WFxTrap</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a>              <ins>ec = 0x01;
        when</ins><del>} &amp;&amp;
                    (HCR_EL2.TGE == '1' || (!</del> <a href="shared_pseudocode.html#Exception_CP15RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_CP15RTTrap</ins></a><a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><del>IsInHost</del></a>           <ins>ec = 0x03;           assert from_32;
        when</ins><del>() &amp;&amp; HCR_EL2.AMO == '1')));
    bits(64) preferred_exception_return =</del> <a href="shared_pseudocode.html#Exception_CP15RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_CP15RRTTrap</ins></a><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><del>ThisInstrAddr</del></a>          <ins>ec = 0x04;           assert from_32;
        when</ins><del>();
    vect_offset = 0x180;

    exception =</del> <a href="shared_pseudocode.html#Exception_CP14RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_CP14RTTrap</ins></a><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a>           <ins>ec = 0x05;           assert from_32;
        when</ins><del>(</del> <a href="shared_pseudocode.html#Exception_CP14DTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_CP14DTTrap</ins></a><a href="shared_pseudocode.html#Exception_SError" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_SError</del></a>           <ins>ec = 0x06;           assert from_32;
        when</ins><del>);
    exception.syndrome&lt;24> = if impdef_syndrome then '1' else '0';
    exception.syndrome&lt;23:0> = syndrome;</del> <a href="shared_pseudocode.html#Exception_AdvSIMDFPAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_AdvSIMDFPAccessTrap</ins></a><a href="shared_pseudocode.html#impl-shared.ClearPendingPhysicalSError.0" title="function: ClearPendingPhysicalSError()"><del>ClearPendingPhysicalSError</del></a>  <ins>ec = 0x07;
        when</ins><del>();

    if PSTATE.EL ==</del> <a href="shared_pseudocode.html#Exception_FPIDTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_FPIDTrap</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a>             <ins>ec = 0x08;
        when</ins><del>|| route_to_el3 then</del> <a href="shared_pseudocode.html#Exception_PACTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_PACTrap</ins></a><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a>              <ins>ec = 0x09;
        when</ins><del>(</del> <a href="shared_pseudocode.html#Exception_CP14RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_CP14RRTTrap</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a>          <ins>ec = 0x0C;           assert from_32;
        when</ins><del>, exception, preferred_exception_return, vect_offset);
    elsif PSTATE.EL ==</del> <a href="shared_pseudocode.html#Exception_BranchTarget" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_BranchTarget</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a>         <ins>ec = 0x0D;
        when</ins><del>|| route_to_el2 then</del> <a href="shared_pseudocode.html#Exception_IllegalState" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_IllegalState</ins></a><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a>         <ins>ec = 0x0E; il = '1';
        when</ins><del>(</del> <a href="shared_pseudocode.html#Exception_SupervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_SupervisorCall</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a>       <ins>ec = 0x11;
        when</ins><del>, exception, preferred_exception_return, vect_offset);
    else</del> <a href="shared_pseudocode.html#Exception_HypervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_HypervisorCall</ins></a><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a>       <ins>ec = 0x12;
        when</ins><del>(</del> <a href="shared_pseudocode.html#Exception_MonitorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_MonitorCall</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>          ec = 0x13;
        when </ins><a href="shared_pseudocode.html#Exception_SystemRegisterTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_SystemRegisterTrap</ins></a><ins>   ec = 0x18;           assert !from_32;
        when </ins><a href="shared_pseudocode.html#Exception_SVEAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_SVEAccessTrap</ins></a><ins>        ec = 0x19;           assert !from_32;
        when </ins><a href="shared_pseudocode.html#Exception_ERetTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_ERetTrap</ins></a><ins>             ec = 0x1A;
        when </ins><a href="shared_pseudocode.html#Exception_InstructionAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_InstructionAbort</ins></a><ins>     ec = 0x20; il = '1';
        when </ins><a href="shared_pseudocode.html#Exception_PCAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_PCAlignment</ins></a><ins>          ec = 0x22; il = '1';
        when </ins><a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_DataAbort</ins></a><ins>            ec = 0x24;
        when </ins><a href="shared_pseudocode.html#Exception_NV2DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_NV2DataAbort</ins></a><ins>         ec = 0x25;
        when </ins><a href="shared_pseudocode.html#Exception_SPAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_SPAlignment</ins></a><ins>          ec = 0x26; il = '1'; assert !from_32;
        when </ins><a href="shared_pseudocode.html#Exception_FPTrappedException" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_FPTrappedException</ins></a><ins>   ec = 0x28;
        when </ins><a href="shared_pseudocode.html#Exception_SError" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_SError</ins></a><ins>               ec = 0x2F; il = '1';
        when </ins><a href="shared_pseudocode.html#Exception_Breakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_Breakpoint</ins></a><ins>           ec = 0x30; il = '1';
        when </ins><a href="shared_pseudocode.html#Exception_SoftwareStep" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_SoftwareStep</ins></a><ins>         ec = 0x32; il = '1';
        when </ins><a href="shared_pseudocode.html#Exception_Watchpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_Watchpoint</ins></a><ins>           ec = 0x34; il = '1';
        when </ins><a href="shared_pseudocode.html#Exception_SoftwareBreakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_SoftwareBreakpoint</ins></a><ins>   ec = 0x38;
        when </ins><a href="shared_pseudocode.html#Exception_VectorCatch" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_VectorCatch</ins></a><ins>          ec = 0x3A; il = '1'; assert from_32;
        otherwise                           </ins><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><ins>Unreachable</ins></a><ins>();

    if ec IN {0x20,0x24,0x30,0x32,0x34} &amp;&amp; target_el == PSTATE.EL then
        ec = ec + 1;

    if ec IN {0x11,0x12,0x13,0x28,0x38} &amp;&amp; !from_32 then
        ec = ec + 4;

    return (ec,il);</ins><del>, exception, preferred_exception_return, vect_offset);</del></p></div><div class="ps" psname="aarch64.exceptions.exceptions.AArch64.ReportException"><a id="aarch64.exceptions.exceptions.AArch64.ReportException" name="aarch64.exceptions.exceptions.AArch64.ReportException"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/<ins>exceptions</ins><del>asynch</del>/<ins>AArch64.ReportException</ins><del>AArch64.TakeVirtualFIQException</del></h3><p class="pseudocode"><ins>// AArch64.ReportException()
// =========================
// Report syndrome information for exception taken to AArch64 state.</ins><del>// AArch64.TakeVirtualFIQException()
// =================================</del>

<a id="AArch64.ReportException.2" name="AArch64.ReportException.2"></a><ins>AArch64.ReportException(</ins><del>AArch64.TakeVirtualFIQException()
    assert</del><a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is (Exception type, bits(25) syndrome, bits(64) vaddress, boolean ipavalid, bits(1) NS, bits(52) ipaddress)"><ins>ExceptionRecord</ins></a><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a> <ins>exception, bits(2) target_el)</ins><del>() &amp;&amp; PSTATE.EL IN {</del>

    <a href="shared_pseudocode.html#Exception" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a> <ins>type = exception.type;

    (ec,il) =</ins><del>,</del> <a href="shared_pseudocode.html#AArch64.ExceptionClass.2" title="function: (integer,bit) AArch64.ExceptionClass(Exception type, bits(2) target_el)"><ins>AArch64.ExceptionClass</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>(type, target_el);
    iss = exception.syndrome;
</ins><del>};
    assert HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.FMO == '1';  // Virtual IRQ enabled if TGE==0 and FMO==1
</del>
<ins>    // IL is not valid for Data Abort exceptions without valid instruction syndrome information
    if ec IN {0x24,0x25} &amp;&amp; iss&lt;24> == '0' then
        il = '1';</ins><del>    bits(64) preferred_exception_return =</del>

    <a href="shared_pseudocode.html#impl-aarch64.ESR.write.1" title="accessor: ESR[bits(2) regime] = ESRType value"><ins>ESR</ins></a><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><del>ThisInstrAddr</del></a><ins>[target_el] = ec&lt;5:0>:il:iss;
</ins><del>();
    vect_offset = 0x100;
</del>
<ins>    if type IN {</ins><del>    exception =</del><a href="shared_pseudocode.html#Exception_InstructionAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_InstructionAbort</ins></a><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a><ins>,</ins><del>(</del> <a href="shared_pseudocode.html#Exception_PCAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_PCAlignment</ins></a><a href="shared_pseudocode.html#Exception_FIQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_FIQ</del></a><ins>,</ins><del>);</del> <a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_DataAbort</ins></a><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a><ins>,</ins><del>(</del>
                <a href="shared_pseudocode.html#Exception_NV2DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_NV2DataAbort</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>,
                </ins><a href="shared_pseudocode.html#Exception_Watchpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_Watchpoint</ins></a><ins>} then
        </ins><a href="shared_pseudocode.html#impl-aarch64.FAR.write.1" title="accessor: FAR[bits(2) regime] = bits(64) value"><ins>FAR</ins></a><ins>[target_el] = exception.vaddress;
    else
        </ins><a href="shared_pseudocode.html#impl-aarch64.FAR.write.1" title="accessor: FAR[bits(2) regime] = bits(64) value"><ins>FAR</ins></a><ins>[target_el] = bits(64) UNKNOWN;

    if target_el == </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins> then
        if exception.ipavalid then
            HPFAR_EL2&lt;43:4> = exception.ipaddress&lt;51:12>;
            if </ins><a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()"><ins>HaveSecureEL2Ext</ins></a><ins>() then
                if </ins><a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()"><ins>IsSecureEL2Enabled</ins></a><ins>() then
                    HPFAR_EL2.NS = exception.NS;
                else
                    HPFAR_EL2.NS = '0';
        else
            HPFAR_EL2&lt;43:4> = bits(40) UNKNOWN;

    return;</ins><del>, exception, preferred_exception_return, vect_offset);</del></p></div><div class="ps" psname="aarch64.exceptions.exceptions.AArch64.ResetControlRegisters"><a id="aarch64.exceptions.exceptions.AArch64.ResetControlRegisters" name="aarch64.exceptions.exceptions.AArch64.ResetControlRegisters"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/<ins>exceptions</ins><del>asynch</del>/<ins>AArch64.ResetControlRegisters</ins><del>AArch64.TakeVirtualIRQException</del></h3><p class="pseudocode"><ins>// Resets System registers and memory-mapped control registers that have architecturally-defined
// reset values to those values.</ins><del>// AArch64.TakeVirtualIRQException()
// =================================</del>
<a id="AArch64.ResetControlRegisters.1" name="AArch64.ResetControlRegisters.1"></a><ins>AArch64.ResetControlRegisters(boolean cold_reset);</ins><del>AArch64.TakeVirtualIRQException()
    assert</del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; PSTATE.EL IN {</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>,</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>};
    assert HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.IMO == '1';  // Virtual IRQ enabled if TGE==0 and IMO==1

    bits(64) preferred_exception_return = </del><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><del>ThisInstrAddr</del></a><del>();
    vect_offset = 0x80;

    exception = </del><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a><del>(</del><a href="shared_pseudocode.html#Exception_IRQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_IRQ</del></a><del>);

    </del><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a><del>(</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>, exception, preferred_exception_return, vect_offset);</del></p></div><div class="ps" psname="aarch64.exceptions.exceptions.AArch64.TakeReset"><a id="aarch64.exceptions.exceptions.AArch64.TakeReset" name="aarch64.exceptions.exceptions.AArch64.TakeReset"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/<ins>exceptions</ins><del>asynch</del>/<ins>AArch64.TakeReset</ins><del>AArch64.TakeVirtualSErrorException</del></h3><p class="pseudocode"><ins>// AArch64.TakeReset()
// ===================
// Reset into AArch64 state</ins><del>// AArch64.TakeVirtualSErrorException()
// ====================================</del>

<a id="AArch64.TakeReset.1" name="AArch64.TakeReset.1"></a><ins>AArch64.TakeReset(boolean cold_reset)
    assert !</ins><del>AArch64.TakeVirtualSErrorException(boolean impdef_syndrome, bits(24) syndrome)

    assert</del><a href="shared_pseudocode.html#impl-shared.HighestELUsingAArch32.0" title="function: boolean HighestELUsingAArch32()"><ins>HighestELUsingAArch32</ins></a><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><ins>();

    // Enter the highest implemented Exception level in AArch64 state
    PSTATE.nRW = '0';
    if</ins><del>() &amp;&amp; PSTATE.EL IN {</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>(</ins><del>,</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) then
        PSTATE.EL = </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>;
    elsif </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) then
        PSTATE.EL = </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>;
    else
        PSTATE.EL = </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a><ins>;
</ins><del>};
    assert HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.AMO == '1';  // Virtual SError enabled if TGE==0 and AMO==1
</del>
<ins>    // Reset the system registers and other system components</ins><del>    bits(64) preferred_exception_return =</del>
    <a href="shared_pseudocode.html#AArch64.ResetControlRegisters.1" title="function: AArch64.ResetControlRegisters(boolean cold_reset)"><ins>AArch64.ResetControlRegisters</ins></a><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><del>ThisInstrAddr</del></a><ins>(cold_reset);
</ins><del>();
    vect_offset = 0x180;
</del>
<ins>    // Reset all other PSTATE fields
    PSTATE.SP = '1';              // Select stack pointer
    PSTATE.&lt;D,A,I,F>  = '1111';   // All asynchronous exceptions masked
    PSTATE.SS = '0';              // Clear software step bit
    PSTATE.DIT = '0';             // PSTATE.DIT is reset to 0 when resetting into AArch64
    PSTATE.IL = '0';              // Clear Illegal Execution state bit

    // All registers, bits and fields not reset by the above pseudocode or by the BranchTo() call
    // below are UNKNOWN bitstrings after reset. In particular, the return information registers
    // ELR_ELx and SPSR_ELx have UNKNOWN values, so that it
    // is impossible to return from a reset in an architecturally defined way.</ins><del>    exception =</del>
    <a href="shared_pseudocode.html#AArch64.ResetGeneralRegisters.0" title="function: AArch64.ResetGeneralRegisters()"><ins>AArch64.ResetGeneralRegisters</ins></a><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a><ins>();</ins><del>(</del>
    <a href="shared_pseudocode.html#AArch64.ResetSIMDFPRegisters.0" title="function: AArch64.ResetSIMDFPRegisters()"><ins>AArch64.ResetSIMDFPRegisters</ins></a><a href="shared_pseudocode.html#Exception_SError" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_SError</del></a><ins>();</ins><del>);
    if</del>
    <a href="shared_pseudocode.html#AArch64.ResetSpecialRegisters.0" title="function: AArch64.ResetSpecialRegisters()"><ins>AArch64.ResetSpecialRegisters</ins></a><a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()"><del>HaveRASExt</del></a><ins>();</ins><del>() then
        exception.syndrome&lt;24>   = VSESR_EL2.IDS;
        exception.syndrome&lt;23:0> = VSESR_EL2.ISS;
    else
        exception.syndrome&lt;24> = if impdef_syndrome then '1' else '0';
        if impdef_syndrome then exception.syndrome&lt;23:0> = syndrome;</del>
    <a href="shared_pseudocode.html#impl-shared.ResetExternalDebugRegisters.1" title="function: ResetExternalDebugRegisters(boolean cold_reset)"><ins>ResetExternalDebugRegisters</ins></a><a href="shared_pseudocode.html#impl-shared.ClearPendingVirtualSError.0" title="function: ClearPendingVirtualSError()"><del>ClearPendingVirtualSError</del></a><ins>(cold_reset);

    bits(64) rv;                      // IMPLEMENTATION DEFINED reset vector

    if</ins><del>();</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>) then
        rv = RVBAR_EL3;
    elsif </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) then
        rv = RVBAR_EL2;
    else
        rv = RVBAR_EL1;

    // The reset vector must be correctly aligned
    assert </ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(rv&lt;63:</ins><a href="shared_pseudocode.html#impl-shared.PAMax.0" title="function: integer PAMax()"><ins>PAMax</ins></a><ins>()>) &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(rv&lt;1:0>);

    </ins><a href="shared_pseudocode.html#impl-shared.BranchTo.2" title="function: BranchTo(bits(N) target, BranchType branch_type)"><ins>BranchTo</ins></a><ins>(rv, </ins><a href="shared_pseudocode.html#BranchType_RESET" title="enumeration BranchType { BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}"><ins>BranchType_RESET</ins></a><ins>);</ins><del>, exception, preferred_exception_return, vect_offset);</del></p></div><div class="ps" psname="aarch64.exceptions.ieeefp.AArch64.FPTrappedException"><a id="aarch64.exceptions.ieeefp.AArch64.FPTrappedException" name="aarch64.exceptions.ieeefp.AArch64.FPTrappedException"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/<ins>ieeefp</ins><del>debug</del>/<ins>AArch64.FPTrappedException</ins><del>AArch64.BreakpointException</del></h3><p class="pseudocode"><ins>// AArch64.FPTrappedException()
// ============================</ins><del>// AArch64.BreakpointException()
// =============================</del>

<a id="AArch64.FPTrappedException.3" name="AArch64.FPTrappedException.3"></a><ins>AArch64.FPTrappedException(boolean is_ase, integer element, bits(8) accumulated_exceptions)
    exception =</ins><del>AArch64.BreakpointException(</del> <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><del>FaultRecord</del></a><ins>(</ins><del>fault)
    assert PSTATE.EL !=</del><a href="shared_pseudocode.html#Exception_FPTrappedException" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_FPTrappedException</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><ins>);
    if is_ase then
        if boolean IMPLEMENTATION_DEFINED "vector instructions set TFV to 1" then
            exception.syndrome&lt;23> = '1';                          // TFV
        else
            exception.syndrome&lt;23> = '0';                          // TFV
    else
        exception.syndrome&lt;23> = '1';                              // TFV
    exception.syndrome&lt;10:8> = bits(3) UNKNOWN;                    // VECITR
    if exception.syndrome&lt;23> == '1' then
        exception.syndrome&lt;7,4:0> = accumulated_exceptions&lt;7,4:0>; // IDF,IXF,UFF,OFF,DZF,IOF
    else
        exception.syndrome&lt;7,4:0> = bits(6) UNKNOWN;
</ins><del>;
</del>
<ins>    route_to_el2 =</ins><del>    route_to_el2 = (</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a><ins>() &amp;&amp; HCR_EL2.TGE == '1';

    bits(64) preferred_exception_return =</ins><del>() &amp;&amp; PSTATE.EL IN {</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>,</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>} &amp;&amp;
                    (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1'));

    bits(64) preferred_exception_return = </del><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

<ins>    if</ins><del>    vaddress = bits(64) UNKNOWN;
    exception =</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#AArch64.AbortSyndrome.3" title="function: ExceptionRecord AArch64.AbortSyndrome(Exception type, FaultRecord fault, bits(64) vaddress)"><del>AArch64.AbortSyndrome</del></a><ins>(PSTATE.EL) ></ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#Exception_Breakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_Breakpoint</del></a><ins>(</ins><del>, fault, vaddress);

    if PSTATE.EL ==</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>) then
        </ins><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><ins>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
    elsif route_to_el2 then</ins><del>|| route_to_el2 then</del>
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p></div><div class="ps" psname="aarch64.exceptions.syscalls.AArch64.CallHypervisor"><a id="aarch64.exceptions.syscalls.AArch64.CallHypervisor" name="aarch64.exceptions.syscalls.AArch64.CallHypervisor"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/<ins>syscalls</ins><del>debug</del>/<ins>AArch64.CallHypervisor</ins><del>AArch64.SoftwareBreakpoint</del></h3><p class="pseudocode"><ins>// AArch64.CallHypervisor()
// ========================
// Performs a HVC call</ins><del>// AArch64.SoftwareBreakpoint()
// ============================</del>

<a id="AArch64.CallHypervisor.1" name="AArch64.CallHypervisor.1"></a><ins>AArch64.CallHypervisor(bits(16) immediate)
    assert</ins><del>AArch64.SoftwareBreakpoint(bits(16) immediate)

    route_to_el2 = (</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><ins>(</ins><del>() &amp;&amp; PSTATE.EL IN {</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>);

    if</ins><del>,</del> <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>() then</ins><del>} &amp;&amp;
                    (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1'));

    bits(64) preferred_exception_return =</del> <a href="shared_pseudocode.html#AArch32.ITAdvance.0" title="function: AArch32.ITAdvance()"><ins>AArch32.ITAdvance</ins></a><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><del>ThisInstrAddr</del></a><ins>();</ins><del>();
    vect_offset = 0x0;

    exception =</del>
    <a href="shared_pseudocode.html#impl-shared.SSAdvance.0" title="function: SSAdvance()"><ins>SSAdvance</ins></a><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a><ins>();
    bits(64) preferred_exception_return =</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.NextInstrAddr.0" title="function: bits(N) NextInstrAddr()"><ins>NextInstrAddr</ins></a><a href="shared_pseudocode.html#Exception_SoftwareBreakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_SoftwareBreakpoint</del></a><ins>();
    vect_offset = 0x0;
</ins><del>);
    exception.syndrome&lt;15:0> = immediate;
</del>
<ins>    exception =</ins><del>    if</del> <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>(</ins><del>(PSTATE.EL) ></del><a href="shared_pseudocode.html#Exception_HypervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_HypervisorCall</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>);
    exception.syndrome&lt;15:0> = immediate;

    if PSTATE.EL ==</ins><del>(</del> <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a> <ins>then</ins><del>) then</del>
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a><ins>(</ins><del>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
    elsif route_to_el2 then</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a><ins>, exception, preferred_exception_return, vect_offset);
    else</ins><del>(</del>
        <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>, exception, preferred_exception_return, vect_offset);
    else
        </del><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a>, exception, preferred_exception_return, vect_offset);</p></div><div class="ps" psname="aarch64.exceptions.syscalls.AArch64.CallSecureMonitor"><a id="aarch64.exceptions.syscalls.AArch64.CallSecureMonitor" name="aarch64.exceptions.syscalls.AArch64.CallSecureMonitor"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/<ins>syscalls</ins><del>debug</del>/<ins>AArch64.CallSecureMonitor</ins><del>AArch64.SoftwareStepException</del></h3><p class="pseudocode"><ins>// AArch64.CallSecureMonitor()
// ===========================</ins><del>// AArch64.SoftwareStepException()
// ===============================</del>

<a id="AArch64.CallSecureMonitor.1" name="AArch64.CallSecureMonitor.1"></a><ins>AArch64.CallSecureMonitor(bits(16) immediate)
    assert</ins><del>AArch64.SoftwareStepException()
    assert PSTATE.EL !=</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a><ins>) &amp;&amp; !</ins><del>;

    route_to_el2 = (</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><ins>(</ins><del>() &amp;&amp; PSTATE.EL IN {</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>);
    if</ins><del>,</del> <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>() then</ins><del>} &amp;&amp;
                    (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1'));

    bits(64) preferred_exception_return =</del> <a href="shared_pseudocode.html#AArch32.ITAdvance.0" title="function: AArch32.ITAdvance()"><ins>AArch32.ITAdvance</ins></a><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><del>ThisInstrAddr</del></a><ins>();</ins><del>();
    vect_offset = 0x0;

    exception =</del>
    <a href="shared_pseudocode.html#impl-shared.SSAdvance.0" title="function: SSAdvance()"><ins>SSAdvance</ins></a><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a><ins>();
    bits(64) preferred_exception_return =</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.NextInstrAddr.0" title="function: bits(N) NextInstrAddr()"><ins>NextInstrAddr</ins></a><a href="shared_pseudocode.html#Exception_SoftwareStep" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_SoftwareStep</del></a><ins>();
    vect_offset = 0x0;

    exception =</ins><del>);
    if</del> <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><a href="shared_pseudocode.html#impl-shared.SoftwareStep_DidNotStep.0" title="function: boolean SoftwareStep_DidNotStep()"><del>SoftwareStep_DidNotStep</del></a><ins>(</ins><del>() then
        exception.syndrome&lt;24> = '0';
    else
        exception.syndrome&lt;24> = '1';
        exception.syndrome&lt;6> = if</del><a href="shared_pseudocode.html#Exception_MonitorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_MonitorCall</ins></a><a href="shared_pseudocode.html#impl-shared.SoftwareStep_SteppedEX.0" title="function: boolean SoftwareStep_SteppedEX()"><del>SoftwareStep_SteppedEX</del></a><ins>);
    exception.syndrome&lt;15:0> = immediate;</ins><del>() then '1' else '0';

    if PSTATE.EL ==</del>

    <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del> || route_to_el2 then
        </del><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<del>, exception, preferred_exception_return, vect_offset);
    else
        </del><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a><del>(</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a>, exception, preferred_exception_return, vect_offset);</p></div><div class="ps" psname="aarch64.exceptions.syscalls.AArch64.CallSupervisor"><a id="aarch64.exceptions.syscalls.AArch64.CallSupervisor" name="aarch64.exceptions.syscalls.AArch64.CallSupervisor"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/<ins>syscalls</ins><del>debug</del>/<ins>AArch64.CallSupervisor</ins><del>AArch64.VectorCatchException</del></h3><p class="pseudocode"><ins>// AArch64.CallSupervisor()
// ========================
// Calls the Supervisor</ins><del>// AArch64.VectorCatchException()
// ==============================
// Vector Catch taken from EL0 or EL1 to EL2. This can only be called when debug exceptions are
// being routed to EL2, as Vector Catch is a legacy debug event.</del>

<a id="AArch64.CallSupervisor.1" name="AArch64.CallSupervisor.1"></a><ins>AArch64.CallSupervisor(bits(16) immediate)

    if</ins><del>AArch64.VectorCatchException(</del> <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><del>FaultRecord</del></a><ins>() then</ins><del>fault)
    assert PSTATE.EL !=</del> <a href="shared_pseudocode.html#AArch32.ITAdvance.0" title="function: AArch32.ITAdvance()"><ins>AArch32.ITAdvance</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>();</ins><del>;
    assert</del>
    <a href="shared_pseudocode.html#impl-shared.SSAdvance.0" title="function: SSAdvance()"><ins>SSAdvance</ins></a><ins>();
    route_to_el2 = </ins><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a><ins>() &amp;&amp; PSTATE.EL ==</ins><del>() &amp;&amp; (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1');

    bits(64) preferred_exception_return =</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><del>ThisInstrAddr</del></a> <ins>&amp;&amp; HCR_EL2.TGE == '1';
</ins><del>();
    vect_offset = 0x0;
</del>
<ins>    bits(64) preferred_exception_return =</ins><del>    vaddress = bits(64) UNKNOWN;
    exception =</del> <a href="shared_pseudocode.html#impl-shared.NextInstrAddr.0" title="function: bits(N) NextInstrAddr()"><ins>NextInstrAddr</ins></a><a href="shared_pseudocode.html#AArch64.AbortSyndrome.3" title="function: ExceptionRecord AArch64.AbortSyndrome(Exception type, FaultRecord fault, bits(64) vaddress)"><del>AArch64.AbortSyndrome</del></a><ins>();
    vect_offset = 0x0;

    exception =</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><a href="shared_pseudocode.html#Exception_VectorCatch" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_VectorCatch</del></a><ins>(</ins><del>, fault, vaddress);</del><a href="shared_pseudocode.html#Exception_SupervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_SupervisorCall</ins></a><ins>);
    exception.syndrome&lt;15:0> = immediate;

    if </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(PSTATE.EL) > </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>) then
        </ins><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a><ins>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
    elsif route_to_el2 then</ins><del>(</del>
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a><ins>, exception, preferred_exception_return, vect_offset);
    else
        </ins><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a>, exception, preferred_exception_return, vect_offset);</p></div><div class="ps" psname="aarch64.exceptions.takeexception.AArch64.TakeException"><a id="aarch64.exceptions.takeexception.AArch64.TakeException" name="aarch64.exceptions.takeexception.AArch64.TakeException"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/<ins>takeexception</ins><del>debug</del>/<ins>AArch64.TakeException</ins><del>AArch64.WatchpointException</del></h3><p class="pseudocode"><ins>// AArch64.TakeException()
// =======================
// Take an exception to an Exception Level using AArch64.</ins><del>// AArch64.WatchpointException()
// =============================</del>

<a id="AArch64.TakeException.4" name="AArch64.TakeException.4"></a><ins>AArch64.TakeException(bits(2) target_el,</ins><del>AArch64.WatchpointException(bits(64) vaddress,</del> <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is (Exception type, bits(25) syndrome, bits(64) vaddress, boolean ipavalid, bits(1) NS, bits(52) ipaddress)"><ins>ExceptionRecord</ins></a><a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><del>FaultRecord</del></a> <ins>exception,
                      bits(64) preferred_exception_return, integer vect_offset)
    assert</ins><del>fault)
    assert PSTATE.EL !=</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(target_el) &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(target_el) &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(target_el) >= </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(PSTATE.EL);

    sync_errors = </ins><a href="shared_pseudocode.html#impl-shared.HaveIESB.0" title="function: boolean HaveIESB()"><ins>HaveIESB</ins></a><ins>() &amp;&amp; </ins><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><ins>SCTLR</ins></a><ins>[].IESB == '1';
    if </ins><a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()"><ins>HaveDoubleFaultExt</ins></a><ins>() then
        sync_errors = sync_errors || (SCR_EL3.EA == '1' &amp;&amp; SCR_EL3.NMEA == '1' &amp;&amp; PSTATE.EL == </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a><ins>);
    if sync_errors &amp;&amp;</ins><del>;

    route_to_el2 = (</del> <a href="shared_pseudocode.html#impl-shared.InsertIESBBeforeException.1" title="function: boolean InsertIESBBeforeException(bits(2) el)"><ins>InsertIESBBeforeException</ins></a><ins>(target_el) then
        </ins><a href="shared_pseudocode.html#impl-shared.SynchronizeErrors.0" title="function: SynchronizeErrors()"><ins>SynchronizeErrors</ins></a><ins>();
        iesb_req = FALSE;
        sync_errors = FALSE;
        </ins><a href="shared_pseudocode.html#impl-shared.TakeUnmaskedPhysicalSErrorInterrupts.1" title="function: TakeUnmaskedPhysicalSErrorInterrupts(boolean iesb_req)"><ins>TakeUnmaskedPhysicalSErrorInterrupts</ins></a><ins>(iesb_req);

    </ins><a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()"><ins>SynchronizeContext</ins></a><ins>();

    // If coming from AArch32 state, the top parts of the X[] registers might be set to zero
    from_32 = </ins><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>();
    if from_32 then </ins><a href="shared_pseudocode.html#AArch64.MaybeZeroRegisterUppers.0" title="function: AArch64.MaybeZeroRegisterUppers()"><ins>AArch64.MaybeZeroRegisterUppers</ins></a><ins>();
    </ins><a href="shared_pseudocode.html#impl-aarch64.MaybeZeroSVEUppers.1" title="function: MaybeZeroSVEUppers(bits(2) target_el)"><ins>MaybeZeroSVEUppers</ins></a><ins>(target_el);

    if </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(target_el) > </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(PSTATE.EL) then
        boolean lower_32;
        if target_el == </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins> then
            if </ins><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a><ins>() then
                lower_32 =</ins><del>() &amp;&amp; PSTATE.EL IN {</del> <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>);
            else
                lower_32 = </ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>);
        elsif </ins><a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><ins>IsInHost</ins></a><ins>() &amp;&amp; PSTATE.EL == </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> <ins>&amp;&amp; target_el ==</ins><del>,</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins> then
            lower_32 = </ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>);
        else
            lower_32 = </ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(target_el - 1);
        vect_offset = vect_offset + (if lower_32 then 0x600 else 0x400);

    elsif PSTATE.SP == '1' then
        vect_offset = vect_offset + 0x200;

    spsr = </ins><a href="shared_pseudocode.html#impl-shared.GetPSRFromPSTATE.0" title="function: bits(32) GetPSRFromPSTATE()"><ins>GetPSRFromPSTATE</ins></a><ins>();

    if PSTATE.EL == </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> <ins>&amp;&amp; target_el ==</ins><del>} &amp;&amp;
                    (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1'));

    bits(64) preferred_exception_return =</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><del>ThisInstrAddr</del></a> <ins>&amp;&amp;</ins><del>();
    vect_offset = 0x0;

    exception =</del> <a href="shared_pseudocode.html#impl-shared.HaveNVExt.0" title="function: boolean HaveNVExt()"><ins>HaveNVExt</ins></a><a href="shared_pseudocode.html#AArch64.AbortSyndrome.3" title="function: ExceptionRecord AArch64.AbortSyndrome(Exception type, FaultRecord fault, bits(64) vaddress)"><del>AArch64.AbortSyndrome</del></a><ins>() &amp;&amp;</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#Exception_Watchpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_Watchpoint</del></a><ins>() &amp;&amp; HCR_EL2.&lt;NV, NV1> == '10' then
        spsr&lt;3:2> = '10';
</ins><del>, fault, vaddress);
</del>
<ins>    if</ins><del>    if PSTATE.EL ==</del> <a href="shared_pseudocode.html#impl-shared.HaveUAOExt.0" title="function: boolean HaveUAOExt()"><ins>HaveUAOExt</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>() then PSTATE.UAO = '0';
    if !(exception.type IN {</ins><del>|| route_to_el2 then</del><a href="shared_pseudocode.html#Exception_IRQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_IRQ</ins></a><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a><ins>,</ins><del>(</del> <a href="shared_pseudocode.html#Exception_FIQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_FIQ</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>}) then</ins><del>, exception, preferred_exception_return, vect_offset);
    else</del>
        <a href="shared_pseudocode.html#AArch64.ReportException.2" title="function: AArch64.ReportException(ExceptionRecord exception, bits(2) target_el)"><ins>AArch64.ReportException</ins></a><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a><ins>(exception, target_el);

    PSTATE.EL = target_el;  PSTATE.nRW = '0';  PSTATE.SP = '1';

    if</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.HaveBTIExt.0" title="function: boolean HaveBTIExt()"><ins>HaveBTIExt</ins></a><ins>() then
        if ( exception.type IN {</ins><a href="shared_pseudocode.html#Exception_SError" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_SError</ins></a><ins>, </ins><a href="shared_pseudocode.html#Exception_IRQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_IRQ</ins></a><ins>, </ins><a href="shared_pseudocode.html#Exception_FIQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_FIQ</ins></a><ins>,
                                </ins><a href="shared_pseudocode.html#Exception_SoftwareStep" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_SoftwareStep</ins></a><ins>, </ins><a href="shared_pseudocode.html#Exception_PCAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_PCAlignment</ins></a><ins>, </ins><a href="shared_pseudocode.html#Exception_InstructionAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_InstructionAbort</ins></a><ins>,
                                </ins><a href="shared_pseudocode.html#Exception_SoftwareBreakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_SoftwareBreakpoint</ins></a><ins>, </ins><a href="shared_pseudocode.html#Exception_IllegalState" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_IllegalState</ins></a><ins>, </ins><a href="shared_pseudocode.html#Exception_BranchTarget" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_BranchTarget</ins></a><ins>} ) then
            spsr_btype = PSTATE.BTYPE;
        else
            spsr_btype = if </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><ins>ConstrainUnpredictableBool</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_ZEROBTYPE" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_ZEROBTYPE</ins></a><ins>) then '00' else PSTATE.BTYPE;

        spsr&lt;11:10> = spsr_btype;

    </ins><a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(32) value"><ins>SPSR</ins></a><ins>[] = spsr;
    </ins><a href="shared_pseudocode.html#impl-aarch64.ELR.write.0" title="accessor: ELR[] = bits(64) value"><ins>ELR</ins></a><ins>[] = preferred_exception_return;

    if </ins><a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()"><ins>HaveSSBSExt</ins></a><ins>() then PSTATE.SSBS = </ins><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><ins>SCTLR</ins></a><ins>[].DSSBS;
    if </ins><a href="shared_pseudocode.html#impl-shared.HaveBTIExt.0" title="function: boolean HaveBTIExt()"><ins>HaveBTIExt</ins></a><ins>() then PSTATE.BTYPE = '00';
    PSTATE.SS = '0';
    PSTATE.&lt;D,A,I,F> = '1111';
    PSTATE.IL = '0';
    if from_32 then                                 // Coming from AArch32
        PSTATE.IT = '00000000';  PSTATE.T = '0';    // PSTATE.J is RES0
    if </ins><a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()"><ins>HavePANExt</ins></a><ins>() &amp;&amp; (PSTATE.EL == </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a><ins> || (PSTATE.EL == </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins> &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)"><ins>ELIsInHost</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>)))
        &amp;&amp; </ins><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><ins>SCTLR</ins></a><ins>[].SPAN == '0' then
        PSTATE.PAN = '1';
    if </ins><a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()"><ins>HaveMTEExt</ins></a><ins>() then PSTATE.TCO = '1';

    </ins><a href="shared_pseudocode.html#impl-shared.BranchTo.2" title="function: BranchTo(bits(N) target, BranchType branch_type)"><ins>BranchTo</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-aarch64.VBAR.read.0" title="accessor: bits(64) VBAR[]"><ins>VBAR</ins></a><ins>[]&lt;63:11>:vect_offset&lt;10:0>, </ins><a href="shared_pseudocode.html#BranchType_EXCEPTION" title="enumeration BranchType { BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}"><ins>BranchType_EXCEPTION</ins></a><ins>);

    if sync_errors then
        </ins><a href="shared_pseudocode.html#impl-shared.SynchronizeErrors.0" title="function: SynchronizeErrors()"><ins>SynchronizeErrors</ins></a><ins>();
        iesb_req = TRUE;
        </ins><a href="shared_pseudocode.html#impl-shared.TakeUnmaskedPhysicalSErrorInterrupts.1" title="function: TakeUnmaskedPhysicalSErrorInterrupts(boolean iesb_req)"><ins>TakeUnmaskedPhysicalSErrorInterrupts</ins></a><ins>(iesb_req);

    </ins><a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()"><ins>EndOfInstruction</ins></a><ins>();</ins><del>, exception, preferred_exception_return, vect_offset);</del></p></div><div class="ps" psname="aarch64.exceptions.traps.AArch64.AArch32SystemAccessTrap"><a id="aarch64.exceptions.traps.AArch64.AArch32SystemAccessTrap" name="aarch64.exceptions.traps.AArch64.AArch32SystemAccessTrap"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/<ins>traps</ins><del>exceptions</del>/<ins>AArch64.AArch32SystemAccessTrap</ins><del>AArch64.ExceptionClass</del></h3><p class="pseudocode"><ins>// AArch64.AArch32SystemAccessTrap()
// =================================
// Trapped AARCH32 system register access.</ins><del>// AArch64.ExceptionClass()
// ========================
// Return the Exception Class and Instruction Length fields for reported in ESR

(integer,bit)</del>

<a id="AArch64.AArch32SystemAccessTrap.2" name="AArch64.AArch32SystemAccessTrap.2"></a><ins>AArch64.AArch32SystemAccessTrap(bits(2) target_el, integer ec)
    assert</ins><del>AArch64.ExceptionClass(</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#Exception" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception</del></a><ins>(target_el) &amp;&amp; target_el !=</ins><del>type, bits(2) target_el)

    il = if</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#impl-shared.ThisInstrLength.0" title="function: integer ThisInstrLength()"><del>ThisInstrLength</del></a> <ins>&amp;&amp;</ins><del>() == 32 then '1' else '0';
    from_32 =</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><ins>(target_el) >=</ins><del>();
    assert from_32 || il == '1';            // AArch64 instructions always 32-bit

    case type of
        when</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_Uncategorized</del></a><ins>(PSTATE.EL);

    bits(64) preferred_exception_return =</ins><del>ec = 0x00; il = '1';
        when</del> <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><ins>ThisInstrAddr</ins></a><a href="shared_pseudocode.html#Exception_WFxTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_WFxTrap</del></a><ins>();
    vect_offset = 0x0;

    exception =</ins><del>ec = 0x01;
        when</del> <a href="shared_pseudocode.html#AArch64.AArch32SystemAccessTrapSyndrome.2" title="function: ExceptionRecord AArch64.AArch32SystemAccessTrapSyndrome(bits(32) instr, integer ec)"><ins>AArch64.AArch32SystemAccessTrapSyndrome</ins></a><a href="shared_pseudocode.html#Exception_CP15RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_CP15RTTrap</del></a><ins>(</ins><del>ec = 0x03;           assert from_32;
        when</del><a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()"><ins>ThisInstr</ins></a><a href="shared_pseudocode.html#Exception_CP15RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_CP15RRTTrap</del></a><ins>(), ec);</ins><del>ec = 0x04;           assert from_32;
        when</del>
    <del>           ec = 0x05;           assert from_32;
        when </del><a href="shared_pseudocode.html#Exception_CP14DTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_CP14DTTrap</del></a><del>           ec = 0x06;           assert from_32;
        when </del><a href="shared_pseudocode.html#Exception_AdvSIMDFPAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_AdvSIMDFPAccessTrap</del></a><del>  ec = 0x07;
        when </del><a href="shared_pseudocode.html#Exception_FPIDTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_FPIDTrap</del></a><del>             ec = 0x08;
        when </del><a href="shared_pseudocode.html#Exception_PACTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_PACTrap</del></a><del>              ec = 0x09;
        when </del><a href="shared_pseudocode.html#Exception_CP14RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_CP14RRTTrap</del></a><del>          ec = 0x0C;           assert from_32;
        when </del><a href="shared_pseudocode.html#Exception_BranchTarget" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_BranchTarget</del></a><del>         ec = 0x0D;
        when </del><a href="shared_pseudocode.html#Exception_IllegalState" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_IllegalState</del></a><del>         ec = 0x0E; il = '1';
        when </del><a href="shared_pseudocode.html#Exception_SupervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_SupervisorCall</del></a><del>       ec = 0x11;
        when </del><a href="shared_pseudocode.html#Exception_HypervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_HypervisorCall</del></a><del>       ec = 0x12;
        when </del><a href="shared_pseudocode.html#Exception_MonitorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_MonitorCall</del></a><del>          ec = 0x13;
        when </del><a href="shared_pseudocode.html#Exception_SystemRegisterTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_SystemRegisterTrap</del></a><del>   ec = 0x18;           assert !from_32;
        when </del><a href="shared_pseudocode.html#Exception_SVEAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_SVEAccessTrap</del></a><del>        ec = 0x19;           assert !from_32;
        when </del><a href="shared_pseudocode.html#Exception_ERetTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_ERetTrap</del></a><del>             ec = 0x1A;
        when </del><a href="shared_pseudocode.html#Exception_InstructionAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_InstructionAbort</del></a><del>     ec = 0x20; il = '1';
        when </del><a href="shared_pseudocode.html#Exception_PCAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_PCAlignment</del></a><del>          ec = 0x22; il = '1';
        when </del><a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_DataAbort</del></a><del>            ec = 0x24;
        when </del><a href="shared_pseudocode.html#Exception_NV2DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_NV2DataAbort</del></a><del>         ec = 0x25;
        when </del><a href="shared_pseudocode.html#Exception_SPAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_SPAlignment</del></a><del>          ec = 0x26; il = '1'; assert !from_32;
        when </del><a href="shared_pseudocode.html#Exception_FPTrappedException" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_FPTrappedException</del></a><del>   ec = 0x28;
        when </del><a href="shared_pseudocode.html#Exception_SError" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_SError</del></a><del>               ec = 0x2F; il = '1';
        when </del><a href="shared_pseudocode.html#Exception_Breakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_Breakpoint</del></a><del>           ec = 0x30; il = '1';
        when </del><a href="shared_pseudocode.html#Exception_SoftwareStep" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_SoftwareStep</del></a><del>         ec = 0x32; il = '1';
        when </del><a href="shared_pseudocode.html#Exception_Watchpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_Watchpoint</del></a><del>           ec = 0x34; il = '1';
        when </del><a href="shared_pseudocode.html#Exception_SoftwareBreakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_SoftwareBreakpoint</del></a><del>   ec = 0x38;
        when </del><a href="shared_pseudocode.html#Exception_VectorCatch" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_VectorCatch</del></a><del>          ec = 0x3A; il = '1'; assert from_32;
        otherwise                           </del><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><del>Unreachable</del></a><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><a href="shared_pseudocode.html#Exception_CP14RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_CP14RTTrap</del></a><ins>(target_el, exception, preferred_exception_return, vect_offset);</ins><del>();

    if ec IN {0x20,0x24,0x30,0x32,0x34} &amp;&amp; target_el == PSTATE.EL then
        ec = ec + 1;

    if ec IN {0x11,0x12,0x13,0x28,0x38} &amp;&amp; !from_32 then
        ec = ec + 4;

    return (ec,il);</del></p></div><div class="ps" psname="aarch64.exceptions.traps.AArch64.AArch32SystemAccessTrapSyndrome"><a id="aarch64.exceptions.traps.AArch64.AArch32SystemAccessTrapSyndrome" name="aarch64.exceptions.traps.AArch64.AArch32SystemAccessTrapSyndrome"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/<ins>traps</ins><del>exceptions</del>/<ins>AArch64.AArch32SystemAccessTrapSyndrome</ins><del>AArch64.ReportException</del></h3><p class="pseudocode"><ins>// AArch64.AArch32SystemAccessTrapSyndrome()
// =========================================
// Returns the syndrome information for traps on AArch32 MCR, MCRR, MRC, MRRC, and VMRS, VMSR instructions,
// other than traps that are due to HCPTR or CPACR.

ExceptionRecord</ins><del>// AArch64.ReportException()
// =========================
// Report syndrome information for exception taken to AArch64 state.</del> <a id="AArch64.AArch32SystemAccessTrapSyndrome.2" name="AArch64.AArch32SystemAccessTrapSyndrome.2"></a><ins>AArch64.AArch32SystemAccessTrapSyndrome(bits(32) instr, integer ec)</ins><del>AArch64.ReportException(</del>
    <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is (Exception type, bits(25) syndrome, bits(64) vaddress, boolean ipavalid, bits(1) NS, bits(52) ipaddress)">ExceptionRecord</a> <ins>exception;

    case ec of
        when 0x0    exception =</ins><del>exception, bits(2) target_el)</del> <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><a href="shared_pseudocode.html#Exception" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception</del></a><ins>(</ins><del>type = exception.type;

    (ec,il) =</del><a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_Uncategorized</ins></a><a href="shared_pseudocode.html#AArch64.ExceptionClass.2" title="function: (integer,bit) AArch64.ExceptionClass(Exception type, bits(2) target_el)"><del>AArch64.ExceptionClass</del></a><ins>);
        when 0x3    exception =</ins><del>(type, target_el);
    iss = exception.syndrome;

    // IL is not valid for Data Abort exceptions without valid instruction syndrome information
    if ec IN {0x24,0x25} &amp;&amp; iss&lt;24> == '0' then
        il = '1';</del> <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><a href="shared_pseudocode.html#impl-aarch64.ESR.write.1" title="accessor: ESR[bits(2) regime] = ESRType value"><del>ESR</del></a><ins>(</ins><del>[target_el] = ec&lt;5:0>:il:iss;

    if type IN {</del><a href="shared_pseudocode.html#Exception_CP15RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_CP15RTTrap</ins></a><a href="shared_pseudocode.html#Exception_InstructionAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_InstructionAbort</del></a><ins>);
        when 0x4    exception =</ins><del>,</del> <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><a href="shared_pseudocode.html#Exception_PCAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_PCAlignment</del></a><ins>(</ins><del>,</del><a href="shared_pseudocode.html#Exception_CP15RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_CP15RRTTrap</ins></a><a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_DataAbort</del></a><ins>);
        when 0x5    exception =</ins><del>,</del> <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><a href="shared_pseudocode.html#Exception_NV2DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_NV2DataAbort</del></a><ins>(</ins><del>,</del><a href="shared_pseudocode.html#Exception_CP14RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_CP14RTTrap</ins></a><a href="shared_pseudocode.html#Exception_Watchpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_Watchpoint</del></a><ins>);
        when 0x6    exception =</ins><del>} then</del> <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><a href="shared_pseudocode.html#impl-aarch64.FAR.write.1" title="accessor: FAR[bits(2) regime] = bits(64) value"><del>FAR</del></a><ins>(</ins><del>[target_el] = exception.vaddress;
    else</del><a href="shared_pseudocode.html#Exception_CP14DTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_CP14DTTrap</ins></a><a href="shared_pseudocode.html#impl-aarch64.FAR.write.1" title="accessor: FAR[bits(2) regime] = bits(64) value"><del>FAR</del></a><ins>);
        when 0x7    exception =</ins><del>[target_el] = bits(64) UNKNOWN;

    if target_el ==</del> <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>(</ins><del>then
        if exception.ipavalid then
            HPFAR_EL2&lt;43:4> = exception.ipaddress&lt;51:12>;
            if</del><a href="shared_pseudocode.html#Exception_AdvSIMDFPAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_AdvSIMDFPAccessTrap</ins></a><a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()"><del>HaveSecureEL2Ext</del></a><ins>);
        when 0x8    exception =</ins><del>() then
                if</del> <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()"><del>IsSecureEL2Enabled</del></a><ins>(</ins><a href="shared_pseudocode.html#Exception_FPIDTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_FPIDTrap</ins></a><ins>);
        when 0xC    exception = </ins><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><ins>(</ins><a href="shared_pseudocode.html#Exception_CP14RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_CP14RRTTrap</ins></a><ins>);
        otherwise   </ins><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><ins>Unreachable</ins></a><ins>();

    bits(20) iss = </ins><a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><ins>Zeros</ins></a><ins>();

    if exception.type IN {</ins><a href="shared_pseudocode.html#Exception_FPIDTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_FPIDTrap</ins></a><ins>, </ins><a href="shared_pseudocode.html#Exception_CP14RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_CP14RTTrap</ins></a><ins>, </ins><a href="shared_pseudocode.html#Exception_CP15RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_CP15RTTrap</ins></a><ins>} then
        // Trapped MRC/MCR, VMRS on FPSID
        if exception.type != </ins><a href="shared_pseudocode.html#Exception_FPIDTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_FPIDTrap</ins></a><ins> then    // When trap is not for VMRS
            iss&lt;19:17> = instr&lt;7:5>;           // opc2
            iss&lt;16:14> = instr&lt;23:21>;         // opc1
            iss&lt;13:10> = instr&lt;19:16>;         // CRn
            iss&lt;4:1>   = instr&lt;3:0>;           // CRm
        else
            iss&lt;19:17> = '000';
            iss&lt;16:14> = '111';
            iss&lt;13:10> = instr&lt;19:16>;         // reg
            iss&lt;4:1>   = '0000';

        if instr&lt;20> == '1' &amp;&amp; instr&lt;15:12> == '1111' then    // MRC, Rt==15
            iss&lt;9:5> = '11111';
        elsif instr&lt;20> == '0' &amp;&amp; instr&lt;15:12> == '1111' then // MCR, Rt==15
            iss&lt;9:5> = bits(5) UNKNOWN;
        else
            iss&lt;9:5> = LookUpRIndex(UInt(instr&lt;15:12>), PSTATE.M)&lt;4:0>;
    elsif exception.type IN {</ins><a href="shared_pseudocode.html#Exception_CP14RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_CP14RRTTrap</ins></a><ins>, </ins><a href="shared_pseudocode.html#Exception_AdvSIMDFPAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_AdvSIMDFPAccessTrap</ins></a><ins>, </ins><a href="shared_pseudocode.html#Exception_CP15RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_CP15RRTTrap</ins></a><ins>} then
        // Trapped MRRC/MCRR, VMRS/VMSR
        iss&lt;19:16> = instr&lt;7:4>;          // opc1
        if instr&lt;19:16> == '1111' then    // Rt2==15
            iss&lt;14:10> = bits(5) UNKNOWN;
        else
            iss&lt;14:10> = LookUpRIndex(UInt(instr&lt;19:16>), PSTATE.M)&lt;4:0>;

        if instr&lt;15:12> == '1111' then    // Rt==15
            iss&lt;9:5> = bits(5) UNKNOWN;
        else
            iss&lt;9:5> = LookUpRIndex(UInt(instr&lt;15:12>), PSTATE.M)&lt;4:0>;
        iss&lt;4:1>   = instr&lt;3:0>;         // CRm
    elsif exception.type == </ins><a href="shared_pseudocode.html#Exception_CP14DTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_CP14DTTrap</ins></a><ins> then
        // Trapped LDC/STC
        iss&lt;19:12> = instr&lt;7:0>;         // imm8
        iss&lt;4>     = instr&lt;23>;          // U
        iss&lt;2:1>   = instr&lt;24,21>;       // P,W
        if instr&lt;19:16> == '1111' then   // Rn==15, LDC(Literal addressing)/STC
            iss&lt;9:5> = bits(5) UNKNOWN;
            iss&lt;3>   = '1';
    elsif exception.type == </ins><a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_Uncategorized</ins></a><ins> then
        // Trapped for unknown reason
        iss&lt;9:5> = LookUpRIndex(UInt(instr&lt;19:16>), PSTATE.M)&lt;4:0>; // Rn
        iss&lt;3>   = '0';

    iss&lt;0> = instr&lt;20>;                  // Direction

    exception.syndrome&lt;24:20> = </ins><a href="shared_pseudocode.html#impl-shared.ConditionSyndrome.0" title="function: bits(5) ConditionSyndrome()"><ins>ConditionSyndrome</ins></a><ins>();
    exception.syndrome&lt;19:0>  = iss;
</ins><del>() then
                    HPFAR_EL2.NS = exception.NS;
                else
                    HPFAR_EL2.NS = '0';
        else
            HPFAR_EL2&lt;43:4> = bits(40) UNKNOWN;
</del>
<ins>    return exception;</ins><del>    return;</del></p></div><div class="ps" psname="aarch64.exceptions.traps.AArch64.AdvSIMDFPAccessTrap"><a id="aarch64.exceptions.traps.AArch64.AdvSIMDFPAccessTrap" name="aarch64.exceptions.traps.AArch64.AdvSIMDFPAccessTrap"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/<ins>traps</ins><del>exceptions</del>/<ins>AArch64.AdvSIMDFPAccessTrap</ins><del>AArch64.ResetControlRegisters</del></h3><p class="pseudocode"><ins>// AArch64.AdvSIMDFPAccessTrap()
// =============================
// Trapped access to Advanced SIMD or FP registers due to CPACR[].</ins><del>// Resets System registers and memory-mapped control registers that have architecturally-defined
// reset values to those values.</del>

<a id="AArch64.AdvSIMDFPAccessTrap.1" name="AArch64.AdvSIMDFPAccessTrap.1"></a><ins>AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)
    bits(64) preferred_exception_return =</ins><del>AArch64.ResetControlRegisters(boolean cold_reset);</del> <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><ins>ThisInstrAddr</ins></a><ins>();
    vect_offset = 0x0;

    route_to_el2 = (target_el == </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins> &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>() &amp;&amp; HCR_EL2.TGE == '1');

    if route_to_el2 then
        exception = </ins><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><ins>(</ins><a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_Uncategorized</ins></a><ins>);
        </ins><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>, exception, preferred_exception_return, vect_offset);
    else
        exception = </ins><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><ins>(</ins><a href="shared_pseudocode.html#Exception_AdvSIMDFPAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_AdvSIMDFPAccessTrap</ins></a><ins>);
        exception.syndrome&lt;24:20> = </ins><a href="shared_pseudocode.html#impl-shared.ConditionSyndrome.0" title="function: bits(5) ConditionSyndrome()"><ins>ConditionSyndrome</ins></a><ins>();
        </ins><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><ins>(target_el, exception, preferred_exception_return, vect_offset);

    return;</ins></p></div><div class="ps" psname="aarch64.exceptions.traps.AArch64.CheckCP15InstrCoarseTraps"><a id="aarch64.exceptions.traps.AArch64.CheckCP15InstrCoarseTraps" name="aarch64.exceptions.traps.AArch64.CheckCP15InstrCoarseTraps"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/<ins>traps</ins><del>exceptions</del>/<ins>AArch64.CheckCP15InstrCoarseTraps</ins><del>AArch64.TakeReset</del></h3><p class="pseudocode"><ins>// AArch64.CheckCP15InstrCoarseTraps()
// ===================================
// Check for coarse-grained AArch32 CP15 traps in HSTR_EL2 and HCR_EL2.

boolean</ins><del>// AArch64.TakeReset()
// ===================
// Reset into AArch64 state</del> <a id="AArch64.CheckCP15InstrCoarseTraps.3" name="AArch64.CheckCP15InstrCoarseTraps.3"></a><ins>AArch64.CheckCP15InstrCoarseTraps(integer CRn, integer nreg, integer CRm)

    // Check for coarse-grained Hyp traps
    if</ins><del>AArch64.TakeReset(boolean cold_reset)
    assert !</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#impl-shared.HighestELUsingAArch32.0" title="function: boolean HighestELUsingAArch32()"><del>HighestELUsingAArch32</del></a><ins>() &amp;&amp; PSTATE.EL IN {</ins><del>();

    // Enter the highest implemented Exception level in AArch64 state
    PSTATE.nRW = '0';
    if</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>,</ins><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) then
        PSTATE.EL = </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>;
    elsif </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) then
        PSTATE.EL = </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>;
    else
        PSTATE.EL = </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a><ins>} then
        // Check for MCR, MRC, MCRR and MRRC disabled by HSTR_EL2&lt;CRn/CRm>
        major = if nreg == 1 then CRn else CRm;
        if !</ins><del>;

    // Reset the system registers and other system components</del><del>(cold_reset);

    // Reset all other PSTATE fields
    PSTATE.SP = '1';              // Select stack pointer
    PSTATE.&lt;D,A,I,F>  = '1111';   // All asynchronous exceptions masked
    PSTATE.SS = '0';              // Clear software step bit
    PSTATE.DIT = '0';             // PSTATE.DIT is reset to 0 when resetting into AArch64
    PSTATE.IL = '0';              // Clear Illegal Execution state bit

    // All registers, bits and fields not reset by the above pseudocode or by the BranchTo() call
    // below are UNKNOWN bitstrings after reset. In particular, the return information registers
    // ELR_ELx and SPSR_ELx have UNKNOWN values, so that it
    // is impossible to return from a reset in an architecturally defined way.
    </del><a href="shared_pseudocode.html#AArch64.ResetGeneralRegisters.0" title="function: AArch64.ResetGeneralRegisters()"><del>AArch64.ResetGeneralRegisters</del></a><del>();
    </del><a href="shared_pseudocode.html#AArch64.ResetSIMDFPRegisters.0" title="function: AArch64.ResetSIMDFPRegisters()"><del>AArch64.ResetSIMDFPRegisters</del></a><del>();
    </del><a href="shared_pseudocode.html#AArch64.ResetSpecialRegisters.0" title="function: AArch64.ResetSpecialRegisters()"><del>AArch64.ResetSpecialRegisters</del></a><del>();
    </del><a href="shared_pseudocode.html#impl-shared.ResetExternalDebugRegisters.1" title="function: ResetExternalDebugRegisters(boolean cold_reset)"><del>ResetExternalDebugRegisters</del></a><del>(cold_reset);

    bits(64) rv;                      // IMPLEMENTATION DEFINED reset vector

    if </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) then
        rv = RVBAR_EL3;
    elsif </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) then
        rv = RVBAR_EL2;
    else
        rv = RVBAR_EL1;
    // The reset vector must be correctly aligned
    assert </del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(rv&lt;63:</del><a href="shared_pseudocode.html#impl-shared.PAMax.0" title="function: integer PAMax()"><del>PAMax</del></a><del>()>) &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(rv&lt;1:0>);

    </del><a href="shared_pseudocode.html#impl-shared.BranchTo.2" title="function: BranchTo(bits(N) target, BranchType branch_type)"><del>BranchTo</del></a><del>(rv, </del><a href="shared_pseudocode.html#BranchType_RESET" title="enumeration BranchType { BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}"><del>BranchType_RESET</del></a><a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><ins>IsInHost</ins></a><a href="shared_pseudocode.html#AArch64.ResetControlRegisters.1" title="function: AArch64.ResetControlRegisters(boolean cold_reset)"><del>AArch64.ResetControlRegisters</del></a><ins>() &amp;&amp; !(major IN {4,14}) &amp;&amp; HSTR_EL2&lt;major> == '1' then
            return TRUE;

        // Check for MRC and MCR disabled by HCR_EL2.TIDCP
        if (HCR_EL2.TIDCP == '1' &amp;&amp; nreg == 1 &amp;&amp;
            ((CRn == 9  &amp;&amp; CRm IN {0,1,2,    5,6,7,8   }) ||
             (CRn == 10 &amp;&amp; CRm IN {0,1,    4,      8   }) ||
             (CRn == 11 &amp;&amp; CRm IN {0,1,2,3,4,5,6,7,8,15}))) then
            return TRUE;

    return FALSE;</ins><del>);</del></p></div><div class="ps" psname="aarch64.exceptions.traps.AArch64.CheckFPAdvSIMDEnabled"><a id="aarch64.exceptions.traps.AArch64.CheckFPAdvSIMDEnabled" name="aarch64.exceptions.traps.AArch64.CheckFPAdvSIMDEnabled"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/<ins>traps</ins><del>ieeefp</del>/<ins>AArch64.CheckFPAdvSIMDEnabled</ins><del>AArch64.FPTrappedException</del></h3><p class="pseudocode"><ins>// AArch64.CheckFPAdvSIMDEnabled()
// ===============================
// Check against CPACR[]</ins><del>// AArch64.FPTrappedException()
// ============================</del>

<a id="AArch64.CheckFPAdvSIMDEnabled.0" name="AArch64.CheckFPAdvSIMDEnabled.0"></a><ins>AArch64.CheckFPAdvSIMDEnabled()
    if PSTATE.EL IN {</ins><del>AArch64.FPTrappedException(boolean is_ase, integer element, bits(8) accumulated_exceptions)
    exception =</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a><ins>,</ins><del>(</del> <a href="shared_pseudocode.html#Exception_FPTrappedException" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_FPTrappedException</del></a><del>);
    if is_ase then
        if boolean IMPLEMENTATION_DEFINED "vector instructions set TFV to 1" then
            exception.syndrome&lt;23> = '1';                          // TFV
        else
            exception.syndrome&lt;23> = '0';                          // TFV
    else
        exception.syndrome&lt;23> = '1';                              // TFV
    exception.syndrome&lt;10:8> = bits(3) UNKNOWN;                    // VECITR
    if exception.syndrome&lt;23> == '1' then
        exception.syndrome&lt;7,4:0> = accumulated_exceptions&lt;7,4:0>; // IDF,IXF,UFF,OFF,DZF,IOF
    else
        exception.syndrome&lt;7,4:0> = bits(6) UNKNOWN;

    route_to_el2 = </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; HCR_EL2.TGE == '1';

    bits(64) preferred_exception_return = </del><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><del>ThisInstrAddr</del></a><del>();
    vect_offset = 0x0;

    if </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(PSTATE.EL) > </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a><ins>} &amp;&amp; !</ins><del>) then</del><a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><ins>IsInHost</ins></a><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a><ins>() then
        // Check if access disabled in CPACR_EL1
        case</ins><del>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
    elsif route_to_el2 then</del> <a href="shared_pseudocode.html#impl-aarch64.CPACR.read.0" title="accessor: CPACRType CPACR[]"><ins>CPACR</ins></a><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a><ins>[].FPEN of
            when 'x0'  disabled = TRUE;
            when '01'  disabled = PSTATE.EL ==</ins><del>(</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>;
            when '11'  disabled = FALSE;
        if disabled then</ins><del>, exception, preferred_exception_return, vect_offset);
    else</del> <a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)"><ins>AArch64.AdvSIMDFPAccessTrap</ins></a><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a><ins>);

    </ins><a href="shared_pseudocode.html#AArch64.CheckFPAdvSIMDTrap.0" title="function: AArch64.CheckFPAdvSIMDTrap()"><ins>AArch64.CheckFPAdvSIMDTrap</ins></a><ins>();               // Also check against CPTR_EL2 and CPTR_EL3</ins><del>, exception, preferred_exception_return, vect_offset);</del></p></div><div class="ps" psname="aarch64.exceptions.traps.AArch64.CheckFPAdvSIMDTrap"><a id="aarch64.exceptions.traps.AArch64.CheckFPAdvSIMDTrap" name="aarch64.exceptions.traps.AArch64.CheckFPAdvSIMDTrap"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/<ins>traps</ins><del>syscalls</del>/<ins>AArch64.CheckFPAdvSIMDTrap</ins><del>AArch64.CallHypervisor</del></h3><p class="pseudocode"><ins>// AArch64.CheckFPAdvSIMDTrap()
// ============================
// Check against CPTR_EL2 and CPTR_EL3.</ins><del>// AArch64.CallHypervisor()
// ========================
// Performs a HVC call</del>

<a id="AArch64.CheckFPAdvSIMDTrap.0" name="AArch64.CheckFPAdvSIMDTrap.0"></a><ins>AArch64.CheckFPAdvSIMDTrap()

    if PSTATE.EL IN {</ins><del>AArch64.CallHypervisor(bits(16) immediate)
    assert</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>,</ins><del>(</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>, </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a><ins>} &amp;&amp;</ins><del>);

    if</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><ins>() then
        // Check if access disabled in CPTR_EL2
        if</ins><del>() then</del> <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><ins>HaveVirtHostExt</ins></a><a href="shared_pseudocode.html#AArch32.ITAdvance.0" title="function: AArch32.ITAdvance()"><del>AArch32.ITAdvance</del></a><ins>() &amp;&amp; HCR_EL2.E2H == '1' then
            case CPTR_EL2.FPEN of
                when 'x0'  disabled = !(PSTATE.EL ==</ins><del>();</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#impl-shared.SSAdvance.0" title="function: SSAdvance()"><del>SSAdvance</del></a> <ins>&amp;&amp; HCR_EL2.TGE == '1');
                when '01'  disabled = (PSTATE.EL ==</ins><del>();
    bits(64) preferred_exception_return =</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#impl-shared.NextInstrAddr.0" title="function: bits(N) NextInstrAddr()"><del>NextInstrAddr</del></a> <ins>&amp;&amp; HCR_EL2.TGE == '1');
                when '11'  disabled = FALSE;
            if disabled then</ins><del>();
    vect_offset = 0x0;

    exception =</del> <a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)"><ins>AArch64.AdvSIMDFPAccessTrap</ins></a><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#Exception_HypervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_HypervisorCall</del></a>);
<ins>        else
            if CPTR_EL2.TFP == '1' then</ins><del>    exception.syndrome&lt;15:0> = immediate;

    if PSTATE.EL ==</del> <a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)"><ins>AArch64.AdvSIMDFPAccessTrap</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><ins>(</ins><del>then</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a><ins>);

    if</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a><ins>) then
        // Check if access disabled in CPTR_EL3
        if CPTR_EL3.TFP == '1' then</ins><del>, exception, preferred_exception_return, vect_offset);
    else</del> <a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)"><ins>AArch64.AdvSIMDFPAccessTrap</ins></a><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>);

    return;</ins><del>, exception, preferred_exception_return, vect_offset);</del></p></div><div class="ps" psname="aarch64.exceptions.traps.AArch64.CheckForERetTrap"><a id="aarch64.exceptions.traps.AArch64.CheckForERetTrap" name="aarch64.exceptions.traps.AArch64.CheckForERetTrap"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/<ins>traps</ins><del>syscalls</del>/<ins>AArch64.CheckForERetTrap</ins><del>AArch64.CallSecureMonitor</del></h3><p class="pseudocode"><ins>// AArch64.CheckForERetTrap()
// ==========================
// Check for trap on ERET, ERETAA, ERETAB instruction</ins><del>// AArch64.CallSecureMonitor()
// ===========================</del>

<a id="AArch64.CheckForERetTrap.2" name="AArch64.CheckForERetTrap.2"></a><ins>AArch64.CheckForERetTrap(boolean eret_with_pac, boolean pac_uses_key_a)

    // Non-secure EL1 execution of ERET, ERETAA, ERETAB when HCR_EL2.NV bit is set, is trapped to EL2
    route_to_el2 =</ins><del>AArch64.CallSecureMonitor(bits(16) immediate)
    assert</del> <a href="shared_pseudocode.html#impl-shared.HaveNVExt.0" title="function: boolean HaveNVExt()"><ins>HaveNVExt</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>() &amp;&amp;</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><ins>() &amp;&amp; PSTATE.EL ==</ins><del>) &amp;&amp; !</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a> <ins>&amp;&amp; HCR_EL2.NV == '1';

    if route_to_el2 then</ins><del>(</del>
        <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is (Exception type, bits(25) syndrome, bits(64) vaddress, boolean ipavalid, bits(1) NS, bits(52) ipaddress)"><ins>ExceptionRecord</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a> <ins>exception;
        bits(64) preferred_exception_return =</ins><del>);
    if</del> <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><ins>ThisInstrAddr</ins></a><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><ins>();
        vect_offset = 0x0;
        exception =</ins><del>() then</del> <a href="shared_pseudocode.html#AArch32.ITAdvance.0" title="function: AArch32.ITAdvance()"><del>AArch32.ITAdvance</del></a><del>();
    </del><a href="shared_pseudocode.html#impl-shared.SSAdvance.0" title="function: SSAdvance()"><del>SSAdvance</del></a><del>();
    bits(64) preferred_exception_return = </del><a href="shared_pseudocode.html#impl-shared.NextInstrAddr.0" title="function: bits(N) NextInstrAddr()"><del>NextInstrAddr</del></a><del>();
    vect_offset = 0x0;

    exception = </del><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_ERetTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_ERetTrap</ins></a><a href="shared_pseudocode.html#Exception_MonitorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_MonitorCall</del></a>);
<ins>        if !eret_with_pac then                             // ERET
            exception.syndrome&lt;1> = '0';
            exception.syndrome&lt;0> = '0';                   // RES0
        else
            exception.syndrome&lt;1> = '1';
            if pac_uses_key_a then                         // ERETAA
                exception.syndrome&lt;0> = '0';
            else    // ERETAB
                exception.syndrome&lt;0> = '1';</ins><del>    exception.syndrome&lt;15:0> = immediate;</del>
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a>, exception, preferred_exception_return, vect_offset);</p></div><div class="ps" psname="aarch64.exceptions.traps.AArch64.CheckForSMCUndefOrTrap"><a id="aarch64.exceptions.traps.AArch64.CheckForSMCUndefOrTrap" name="aarch64.exceptions.traps.AArch64.CheckForSMCUndefOrTrap"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/<ins>traps</ins><del>syscalls</del>/<ins>AArch64.CheckForSMCUndefOrTrap</ins><del>AArch64.CallSupervisor</del></h3><p class="pseudocode"><ins>// AArch64.CheckForSMCUndefOrTrap()
// ================================
// Check for UNDEFINED or trap on SMC instruction</ins><del>// AArch64.CallSupervisor()
// ========================
// Calls the Supervisor</del>

<a id="AArch64.CheckForSMCUndefOrTrap.1" name="AArch64.CheckForSMCUndefOrTrap.1"></a><ins>AArch64.CheckForSMCUndefOrTrap(bits(16) imm)
    route_to_el2 =</ins><del>AArch64.CallSupervisor(bits(16) immediate)

    if</del> <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>() then </del><a href="shared_pseudocode.html#AArch32.ITAdvance.0" title="function: AArch32.ITAdvance()"><del>AArch32.ITAdvance</del></a><del>();
    </del><a href="shared_pseudocode.html#impl-shared.SSAdvance.0" title="function: SSAdvance()"><del>SSAdvance</del></a><del>();
    route_to_el2 = </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins> &amp;&amp; HCR_EL2.TSC == '1';
    if PSTATE.EL == </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> <ins>then UNDEFINED;
    if !</ins><del>&amp;&amp; HCR_EL2.TGE == '1';

    bits(64) preferred_exception_return =</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-shared.NextInstrAddr.0" title="function: bits(N) NextInstrAddr()"><del>NextInstrAddr</del></a><ins>(</ins><del>();
    vect_offset = 0x0;

    exception =</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a><ins>) then
        if</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#Exception_SupervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_SupervisorCall</del></a><ins>() &amp;&amp; PSTATE.EL ==</ins><del>);
    exception.syndrome&lt;15:0> = immediate;

    if</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a> <ins>then
            if</ins><del>(PSTATE.EL) ></del> <a href="shared_pseudocode.html#impl-shared.HaveNVExt.0" title="function: boolean HaveNVExt()"><ins>HaveNVExt</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>() &amp;&amp; HCR_EL2.NV == '1' &amp;&amp; HCR_EL2.TSC == '1' then
                route_to_el2 = TRUE;
            else
                UNDEFINED;
        else
            UNDEFINED;
    else
        route_to_el2 =</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>() &amp;&amp; PSTATE.EL == </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> <ins>&amp;&amp; HCR_EL2.TSC == '1';
    if route_to_el2 then
        bits(64) preferred_exception_return =</ins><del>) then</del> <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><ins>ThisInstrAddr</ins></a><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a><ins>();
        vect_offset = 0x0;
        exception =</ins><del>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
    elsif route_to_el2 then</del> <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a>(<a href="shared_pseudocode.html#Exception_MonitorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_MonitorCall</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>);
        exception.syndrome&lt;15:0> = imm;</ins><del>, exception, preferred_exception_return, vect_offset);
    else</del>
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a>, exception, preferred_exception_return, vect_offset);</p></div><div class="ps" psname="aarch64.exceptions.traps.AArch64.CheckForWFxTrap"><a id="aarch64.exceptions.traps.AArch64.CheckForWFxTrap" name="aarch64.exceptions.traps.AArch64.CheckForWFxTrap"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/<ins>traps</ins><del>takeexception</del>/<ins>AArch64.CheckForWFxTrap</ins><del>AArch64.TakeException</del></h3><p class="pseudocode"><ins>// AArch64.CheckForWFxTrap()
// =========================
// Check for trap on WFE or WFI instruction</ins><del>// AArch64.TakeException()
// =======================
// Take an exception to an Exception Level using AArch64.</del>

<a id="AArch64.CheckForWFxTrap.2" name="AArch64.CheckForWFxTrap.2"></a><ins>AArch64.CheckForWFxTrap(bits(2) target_el, boolean is_wfe)
    assert</ins><del>AArch64.TakeException(bits(2) target_el,</del> <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is (Exception type, bits(25) syndrome, bits(64) vaddress, boolean ipavalid, bits(1) NS, bits(52) ipaddress)"><del>ExceptionRecord</del></a><del> exception,
                      bits(64) preferred_exception_return, integer vect_offset)
    assert </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a><ins>(target_el);

    case target_el of
        when</ins><del>(target_el) &amp;&amp; !</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a> <ins>trap = (if is_wfe then</ins><del>(target_el) &amp;&amp;</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(target_el) >= </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(PSTATE.EL);

    sync_errors = </del><a href="shared_pseudocode.html#impl-shared.HaveIESB.0" title="function: boolean HaveIESB()"><del>HaveIESB</del></a><del>() &amp;&amp; </del><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a><ins>[].nTWE else</ins><del>[].IESB == '1';
    if</del> <a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()"><del>HaveDoubleFaultExt</del></a><del>() then
        sync_errors = sync_errors || (SCR_EL3.EA == '1' &amp;&amp; SCR_EL3.NMEA == '1' &amp;&amp; PSTATE.EL == </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>);
    if sync_errors &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.InsertIESBBeforeException.1" title="function: boolean InsertIESBBeforeException(bits(2) el)"><del>InsertIESBBeforeException</del></a><del>(target_el) then
        </del><a href="shared_pseudocode.html#impl-shared.SynchronizeErrors.0" title="function: SynchronizeErrors()"><del>SynchronizeErrors</del></a><del>();
        iesb_req = FALSE;
        sync_errors = FALSE;
        </del><a href="shared_pseudocode.html#impl-shared.TakeUnmaskedPhysicalSErrorInterrupts.1" title="function: TakeUnmaskedPhysicalSErrorInterrupts(boolean iesb_req)"><del>TakeUnmaskedPhysicalSErrorInterrupts</del></a><del>(iesb_req);

    </del><a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()"><del>SynchronizeContext</del></a><del>();

    // If coming from AArch32 state, the top parts of the X[] registers might be set to zero
    from_32 = </del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>();
    if from_32 then </del><a href="shared_pseudocode.html#AArch64.MaybeZeroRegisterUppers.0" title="function: AArch64.MaybeZeroRegisterUppers()"><del>AArch64.MaybeZeroRegisterUppers</del></a><del>();
    </del><a href="shared_pseudocode.html#impl-aarch64.MaybeZeroSVEUppers.1" title="function: MaybeZeroSVEUppers(bits(2) target_el)"><del>MaybeZeroSVEUppers</del></a><del>(target_el);

    if </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(target_el) > </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(PSTATE.EL) then
        boolean lower_32;
        if target_el == </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del> then
            if </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() then
                lower_32 = </del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>);
            else
                lower_32 = </del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>);
        elsif </del><a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><del>IsInHost</del></a><del>() &amp;&amp; PSTATE.EL == </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del> &amp;&amp; target_el == </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del> then
            lower_32 = </del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>);
        else
            lower_32 = </del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(target_el - 1);
        vect_offset = vect_offset + (if lower_32 then 0x600 else 0x400);

    elsif PSTATE.SP == '1' then
        vect_offset = vect_offset + 0x200;

    spsr = </del><a href="shared_pseudocode.html#impl-shared.GetPSRFromPSTATE.0" title="function: bits(32) GetPSRFromPSTATE()"><del>GetPSRFromPSTATE</del></a><del>();

    if PSTATE.EL == </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del> &amp;&amp; target_el == </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del> &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.HaveNVExt.0" title="function: boolean HaveNVExt()"><del>HaveNVExt</del></a><del>() &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; HCR_EL2.&lt;NV, NV1> == '10' then
        spsr&lt;3:2> = '10';

    if </del><a href="shared_pseudocode.html#impl-shared.HaveUAOExt.0" title="function: boolean HaveUAOExt()"><del>HaveUAOExt</del></a><del>() then PSTATE.UAO = '0';
    if !(exception.type IN {</del><a href="shared_pseudocode.html#Exception_IRQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_IRQ</del></a><del>, </del><a href="shared_pseudocode.html#Exception_FIQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_FIQ</del></a><del>}) then
        </del><a href="shared_pseudocode.html#AArch64.ReportException.2" title="function: AArch64.ReportException(ExceptionRecord exception, bits(2) target_el)"><del>AArch64.ReportException</del></a><del>(exception, target_el);

    PSTATE.EL = target_el;  PSTATE.nRW = '0';  PSTATE.SP = '1';

    if </del><a href="shared_pseudocode.html#impl-shared.HaveBTIExt.0" title="function: boolean HaveBTIExt()"><del>HaveBTIExt</del></a><del>() then
        if ( exception.type IN {</del><a href="shared_pseudocode.html#Exception_SError" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_SError</del></a><del>, </del><a href="shared_pseudocode.html#Exception_IRQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_IRQ</del></a><del>, </del><a href="shared_pseudocode.html#Exception_FIQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_FIQ</del></a><del>,
                                </del><a href="shared_pseudocode.html#Exception_SoftwareStep" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_SoftwareStep</del></a><del>, </del><a href="shared_pseudocode.html#Exception_PCAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_PCAlignment</del></a><del>, </del><a href="shared_pseudocode.html#Exception_InstructionAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_InstructionAbort</del></a><del>,
                                </del><a href="shared_pseudocode.html#Exception_SoftwareBreakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_SoftwareBreakpoint</del></a><del>, </del><a href="shared_pseudocode.html#Exception_IllegalState" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_IllegalState</del></a><del>, </del><a href="shared_pseudocode.html#Exception_BranchTarget" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_BranchTarget</del></a><del>} ) then
            spsr_btype = PSTATE.BTYPE;
        else
            spsr_btype = if </del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><del>ConstrainUnpredictableBool</del></a><del>(</del><a href="shared_pseudocode.html#Unpredictable_ZEROBTYPE" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_ZEROBTYPE</del></a><del>) then '00' else PSTATE.BTYPE;

        spsr&lt;11:10> = spsr_btype;

    </del><a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(32) value"><del>SPSR</del></a><del>[] = spsr;
    </del><a href="shared_pseudocode.html#impl-aarch64.ELR.write.0" title="accessor: ELR[] = bits(64) value"><del>ELR</del></a><del>[] = preferred_exception_return;

    if </del><a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()"><del>HaveSSBSExt</del></a><del>() then PSTATE.SSBS = </del><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a><ins>[].nTWI) == '0';
        when</ins><del>[].DSSBS;
    if</del> <a href="shared_pseudocode.html#impl-shared.HaveBTIExt.0" title="function: boolean HaveBTIExt()"><del>HaveBTIExt</del></a><del>() then PSTATE.BTYPE = '00';
    PSTATE.SS = '0';
    PSTATE.&lt;D,A,I,F> = '1111';
    PSTATE.IL = '0';
    if from_32 then                                 // Coming from AArch32
        PSTATE.IT = '00000000';  PSTATE.T = '0';    // PSTATE.J is RES0
    if </del><a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()"><del>HavePANExt</del></a><del>() &amp;&amp; (PSTATE.EL == </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del> || (PSTATE.EL == </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> <ins>trap = (if is_wfe then HCR_EL2.TWE else HCR_EL2.TWI) == '1';
        when</ins><del>&amp;&amp;</del> <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)"><del>ELIsInHost</del></a> <ins>trap = (if is_wfe then SCR_EL3.TWE else SCR_EL3.TWI) == '1';
    if trap then</ins><del>(</del>
        <del>))) &amp;&amp; </del><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><del>SCTLR</del></a><del>[].SPAN == '0' then
        PSTATE.PAN = '1';
    if </del><a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()"><del>HaveMTEExt</del></a><del>() then PSTATE.TCO = '1';

    </del><a href="shared_pseudocode.html#impl-shared.BranchTo.2" title="function: BranchTo(bits(N) target, BranchType branch_type)"><del>BranchTo</del></a><del>(</del><a href="shared_pseudocode.html#impl-aarch64.VBAR.read.0" title="accessor: bits(64) VBAR[]"><del>VBAR</del></a><del>[]&lt;63:11>:vect_offset&lt;10:0>, </del><a href="shared_pseudocode.html#BranchType_EXCEPTION" title="enumeration BranchType { BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}"><del>BranchType_EXCEPTION</del></a><del>);

    if sync_errors then
        </del><a href="shared_pseudocode.html#impl-shared.SynchronizeErrors.0" title="function: SynchronizeErrors()"><del>SynchronizeErrors</del></a><del>();
        iesb_req = TRUE;
        </del><a href="shared_pseudocode.html#impl-shared.TakeUnmaskedPhysicalSErrorInterrupts.1" title="function: TakeUnmaskedPhysicalSErrorInterrupts(boolean iesb_req)"><del>TakeUnmaskedPhysicalSErrorInterrupts</del></a><del>(iesb_req);

    </del><a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()"><del>EndOfInstruction</del></a><a href="shared_pseudocode.html#AArch64.WFxTrap.2" title="function: AArch64.WFxTrap(bits(2) target_el, boolean is_wfe)"><ins>AArch64.WFxTrap</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>(target_el, is_wfe);</ins><del>();</del></p></div><div class="ps" psname="aarch64.exceptions.traps.AArch64.CheckIllegalState"><a id="aarch64.exceptions.traps.AArch64.CheckIllegalState" name="aarch64.exceptions.traps.AArch64.CheckIllegalState"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/<ins>AArch64.CheckIllegalState</ins><del>AArch64.AArch32SystemAccessTrap</del></h3><p class="pseudocode"><ins>// AArch64.CheckIllegalState()
// ===========================
// Check PSTATE.IL bit and generate Illegal Execution state exception if set.</ins><del>// AArch64.AArch32SystemAccessTrap()
// =================================
// Trapped AArch32 System register access other than due to CPTR_EL2 or CPACR_EL1.</del>

<a id="AArch64.CheckIllegalState.0" name="AArch64.CheckIllegalState.0"></a><ins>AArch64.CheckIllegalState()
    if PSTATE.IL == '1' then
        route_to_el2 =</ins><del>AArch64.AArch32SystemAccessTrap(bits(2) target_el, bits(32) aarch32_instr)
    assert</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>() &amp;&amp; PSTATE.EL ==</ins><del>(target_el) &amp;&amp; target_el !=</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> <ins>&amp;&amp; HCR_EL2.TGE == '1';

        bits(64) preferred_exception_return =</ins><del>&amp;&amp;</del> <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><ins>ThisInstrAddr</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>();
        vect_offset = 0x0;

        exception =</ins><del>(target_el) >=</del> <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>(</ins><del>(PSTATE.EL);

    bits(64) preferred_exception_return =</del><a href="shared_pseudocode.html#Exception_IllegalState" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_IllegalState</ins></a><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><del>ThisInstrAddr</del></a><ins>);
</ins><del>();
    vect_offset = 0x0;
</del>
<ins>        if</ins><del>    exception =</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#AArch64.AArch32SystemAccessTrapSyndrome.1" title="function: ExceptionRecord AArch64.AArch32SystemAccessTrapSyndrome(bits(32) instr)"><del>AArch64.AArch32SystemAccessTrapSyndrome</del></a><ins>(PSTATE.EL) ></ins><del>(aarch32_instr);

    if target_el ==</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a><ins>) then</ins><del>&amp;&amp;</del>
            <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><ins>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
        elsif route_to_el2 then</ins><del>() &amp;&amp; HCR_EL2.TGE == '1' then</del>
            <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
        else
            <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a><ins>(</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>, exception, preferred_exception_return, vect_offset);</ins><del>(target_el, exception, preferred_exception_return, vect_offset);</del></p></div><div class="ps" psname="aarch64.exceptions.traps.AArch64.MonitorModeTrap"><a id="aarch64.exceptions.traps.AArch64.MonitorModeTrap" name="aarch64.exceptions.traps.AArch64.MonitorModeTrap"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/<ins>AArch64.MonitorModeTrap</ins><del>AArch64.AArch32SystemAccessTrapSyndrome</del></h3><p class="pseudocode"><ins>// AArch64.MonitorModeTrap()
// =========================
// Trapped use of Monitor mode features in a Secure EL1 AArch32 mode</ins><del>// AArch64.AArch32SystemAccessTrapSyndrome()
// =========================================
// Return the syndrome information for traps on AArch32 MCR, MCRR, MRC, MRRC, and VMRS instructions,
// other than traps that are due to HCPTR or CPACR.

ExceptionRecord</del>

<a id="AArch64.MonitorModeTrap.0" name="AArch64.MonitorModeTrap.0"></a><ins>AArch64.MonitorModeTrap()
    bits(64) preferred_exception_return =</ins><del>AArch64.AArch32SystemAccessTrapSyndrome(bits(32) instr)</del> <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><ins>ThisInstrAddr</ins></a><a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is (Exception type, bits(25) syndrome, bits(64) vaddress, boolean ipavalid, bits(1) NS, bits(52) ipaddress)"><del>ExceptionRecord</del></a><ins>();
    vect_offset = 0x0;

    exception =</ins><del>exception;
    cpnum =</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(instr&lt;11:8>);

    bits(20) iss = </del><a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><del>Zeros</del></a><del>();
    if instr&lt;27:24> == '1110' &amp;&amp; instr&lt;4> == '1' &amp;&amp; instr&lt;31:28> != '1111' then
        // MRC/MCR
        case cpnum of
            when 10    exception = </del><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_Uncategorized</ins></a><a href="shared_pseudocode.html#Exception_FPIDTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_FPIDTrap</del></a>);
<ins>
    if</ins><del>            when 14    exception =</del> <a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()"><ins>IsSecureEL2Enabled</ins></a><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a><ins>() then</ins><del>(</del>
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><a href="shared_pseudocode.html#Exception_CP14RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_CP14RTTrap</del></a><ins>(</ins><del>);
            when 15    exception =</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a><ins>, exception, preferred_exception_return, vect_offset);</ins><del>(</del>
    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><a href="shared_pseudocode.html#Exception_CP15RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_CP15RTTrap</del></a><ins>(</ins><del>);
            otherwise</del><del>();
        iss&lt;19:17> = instr&lt;7:5>;      // opc2
        iss&lt;16:14> = instr&lt;23:21>;    // opc1
        iss&lt;13:10> = instr&lt;19:16>;    // CRn
        if instr&lt;20> == '1' &amp;&amp; instr&lt;15:12> == '1111' then // MRC, Rt==15
            iss&lt;9:5> = '11111';
        elsif instr&lt;20> == '0' &amp;&amp; instr&lt;15:12> == '1111' then // MCR, Rt==15
            iss&lt;9:5> = bits(5) UNKNOWN;
        else
            iss&lt;9:5> = LookUpRIndex(UInt(instr&lt;15:12>), PSTATE.M)&lt;4:0>;
        iss&lt;4:1>   = instr&lt;3:0>;      // CRm
    elsif instr&lt;27:21> == '1100010' &amp;&amp; instr&lt;31:28> != '1111' then
        // MRRC/MCRR
        case cpnum of
            when 14    exception = </del><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a><del>(</del><a href="shared_pseudocode.html#Exception_CP14RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_CP14RRTTrap</del></a><del>);
            when 15    exception = </del><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a><del>(</del><a href="shared_pseudocode.html#Exception_CP15RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_CP15RRTTrap</del></a><del>);
            otherwise  </del><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><del>Unreachable</del></a><del>();
        iss&lt;19:16> = instr&lt;7:4>;      // opc1
        if instr&lt;19:16> == '1111' then    // Rt2==15
            iss&lt;14:10> = bits(5) UNKNOWN;
        else
            iss&lt;14:10> = LookUpRIndex(UInt(instr&lt;19:16>), PSTATE.M)&lt;4:0>;

        if instr&lt;15:12> == '1111' then    // Rt==15
            iss&lt;9:5> = bits(5) UNKNOWN;
        else
            iss&lt;9:5> = LookUpRIndex(UInt(instr&lt;15:12>), PSTATE.M)&lt;4:0>;
        iss&lt;4:1>   = instr&lt;3:0>;      // CRm
    elsif instr&lt;27:25> == '110' &amp;&amp; instr&lt;31:28> != '1111' then
        // LDC/STC
        assert cpnum == 14;
        exception = </del><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a><del>(</del><a href="shared_pseudocode.html#Exception_CP14DTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_CP14DTTrap</del></a><del>);
        iss&lt;19:12> = instr&lt;7:0>;      // imm8
        iss&lt;4>     = instr&lt;23>;       // U
        iss&lt;2:1>   = instr&lt;24,21>;    // P,W
        if instr&lt;19:16> == '1111' then    // Rn==15, LDC(Literal addressing)/STC
            iss&lt;9:5> = bits(5) UNKNOWN;
            iss&lt;3>   = '1';
        else
            iss&lt;9:5> = LookUpRIndex(UInt(instr&lt;19:16>), PSTATE.M)&lt;4:0>; // Rn
            iss&lt;3>   = '0';
    else
        </del><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><del>Unreachable</del></a><del>();
    iss&lt;0> = instr&lt;20>;               // Direction

    exception.syndrome&lt;24:20> = </del><a href="shared_pseudocode.html#impl-shared.ConditionSyndrome.0" title="function: bits(5) ConditionSyndrome()"><del>ConditionSyndrome</del></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><del>Unreachable</del></a><ins>, exception, preferred_exception_return, vect_offset);</ins><del>();
    exception.syndrome&lt;19:0>  = iss;

    return exception;</del></p></div><div class="ps" psname="aarch64.exceptions.traps.AArch64.SystemAccessTrap"><a id="aarch64.exceptions.traps.AArch64.SystemAccessTrap" name="aarch64.exceptions.traps.AArch64.SystemAccessTrap"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/<ins>AArch64.SystemAccessTrap</ins><del>AArch64.AdvSIMDFPAccessTrap</del></h3><p class="pseudocode"><ins>// AArch64.SystemAccessTrap()
// ==========================
// Trapped access to AArch64 system register or system instruction.</ins><del>// AArch64.AdvSIMDFPAccessTrap()
// =============================
// Trapped access to Advanced SIMD or FP registers due to CPACR[].</del>

<a id="AArch64.SystemAccessTrap.2" name="AArch64.SystemAccessTrap.2"></a><ins>AArch64.SystemAccessTrap(bits(2) target_el, integer ec)
    assert</ins><del>AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)
    bits(64) preferred_exception_return =</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><del>ThisInstrAddr</del></a><ins>(target_el) &amp;&amp; target_el !=</ins><del>();
    vect_offset = 0x0;

    route_to_el2 = (target_el ==</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><ins>(target_el) >=</ins><del>() &amp;&amp; HCR_EL2.TGE == '1');

    if route_to_el2 then
        exception =</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a><ins>(PSTATE.EL);

    bits(64) preferred_exception_return =</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><ins>ThisInstrAddr</ins></a><a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_Uncategorized</del></a><ins>();
    vect_offset = 0x0;

    exception =</ins><del>);</del> <a href="shared_pseudocode.html#AArch64.SystemAccessTrapSyndrome.2" title="function: ExceptionRecord AArch64.SystemAccessTrapSyndrome(bits(32) instr, integer ec)"><ins>AArch64.SystemAccessTrapSyndrome</ins></a><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a>(<del>, exception, preferred_exception_return, vect_offset);
    else
        exception = </del><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a><del>(</del><a href="shared_pseudocode.html#Exception_AdvSIMDFPAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_AdvSIMDFPAccessTrap</del></a><del>);
        exception.syndrome&lt;24:20> = </del><a href="shared_pseudocode.html#impl-shared.ConditionSyndrome.0" title="function: bits(5) ConditionSyndrome()"><del>ConditionSyndrome</del></a><a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()"><ins>ThisInstr</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>(), ec);</ins><del>();</del>
    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a><ins>(target_el, exception, preferred_exception_return, vect_offset);</ins><del>(target_el, exception, preferred_exception_return, vect_offset);

    return;</del></p></div><div class="ps" psname="aarch64.exceptions.traps.AArch64.SystemAccessTrapSyndrome"><a id="aarch64.exceptions.traps.AArch64.SystemAccessTrapSyndrome" name="aarch64.exceptions.traps.AArch64.SystemAccessTrapSyndrome"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/<ins>AArch64.SystemAccessTrapSyndrome</ins><del>AArch64.CheckAArch32SystemAccess</del></h3><p class="pseudocode"><ins>// AArch64.SystemAccessTrapSyndrome()
</ins><del>// AArch64.CheckAArch32SystemAccess()
</del>// ==================================
<ins>// Returns the syndrome information for traps on AArch64 MSR/MRS instructions.

ExceptionRecord</ins><del>// Check AArch32 System register access instruction for enables and disables</del> <a id="AArch64.SystemAccessTrapSyndrome.2" name="AArch64.SystemAccessTrapSyndrome.2"></a><ins>AArch64.SystemAccessTrapSyndrome(bits(32) instr, integer ec)</ins><del>AArch64.CheckAArch32SystemAccess(bits(32) instr)
    cp_num =</del>
    <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is (Exception type, bits(25) syndrome, bits(64) vaddress, boolean ipavalid, bits(1) NS, bits(52) ipaddress)"><ins>ExceptionRecord</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a> <ins>exception;
    case ec of
        when 0x0                                                     // Trapped access due to unknown reason.
            exception =</ins><del>(instr&lt;11:8>);
    assert cp_num IN {14,15};
    // Decode the AArch32 System register access instruction
    if instr&lt;31:28> != '1111' &amp;&amp; instr&lt;27:24> == '1110' &amp;&amp; instr&lt;4> == '1' then      // MRC/MCR
        cprt = TRUE;  cpdt = FALSE;  nreg = 1;
        opc1 =</del> <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>(</ins><del>(instr&lt;23:21>);
        opc2 =</del><a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_Uncategorized</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>);
        when 0x7                                                     // Trapped access to SVE, Advance SIMD&amp;FP system register.
            exception =</ins><del>(instr&lt;7:5>);
        CRn  =</del> <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>(</ins><del>(instr&lt;19:16>);
        CRm  =</del><a href="shared_pseudocode.html#Exception_AdvSIMDFPAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_AdvSIMDFPAccessTrap</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>);
            exception.syndrome&lt;24:20> =</ins><del>(instr&lt;3:0>);
    elsif instr&lt;31:28> != '1111' &amp;&amp; instr&lt;27:21> == '1100010' then                   // MRRC/MCRR
        cprt = TRUE;  cpdt = FALSE;  nreg = 2;
        opc1 =</del> <a href="shared_pseudocode.html#impl-shared.ConditionSyndrome.0" title="function: bits(5) ConditionSyndrome()"><ins>ConditionSyndrome</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>();
        when 0x18                                                    // Trapped access to system register or system instruction.
            exception =</ins><del>(instr&lt;7:4>);
        CRm  =</del> <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>(</ins><del>(instr&lt;3:0>);
    elsif instr&lt;31:28> != '1111' &amp;&amp; instr&lt;27:25> == '110' &amp;&amp; instr&lt;22> == '0' then   // LDC/STC
        cprt = FALSE;  cpdt = TRUE;  nreg = 0;
        opc1 = 0;
        CRn  =</del><a href="shared_pseudocode.html#Exception_SystemRegisterTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_SystemRegisterTrap</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>);
            instr =</ins><del>(instr&lt;15:12>);
    else
        allocated = FALSE;

    //
    // Coarse-grain decode into CP14 or CP15 encoding space. Each of the CPxxxInstrDecode functions
    // returns TRUE if the instruction is allocated at the current Exception level, FALSE otherwise.
    if cp_num == 14 then
        // LDC and STC only supported for c5 in CP14 encoding space
        if cpdt &amp;&amp; CRn != 5 then
            allocated = FALSE;
        else
            // Coarse-grained decode of CP14 based on opc1 field
            case opc1 of
                when 0     allocated = CP14DebugInstrDecode(instr);
                when 1     allocated = CP14TraceInstrDecode(instr);
                when 7     allocated = CP14JazelleInstrDecode(instr);    // JIDR only
                otherwise  allocated = FALSE;          // All other values are unallocated

    elsif cp_num == 15 then
        // LDC and STC not supported in CP15 encoding space
        if !cprt then
            allocated = FALSE;
        else
            allocated = CP15InstrDecode(instr);

            // Coarse-grain traps to EL2 have a higher priority than exceptions generated because
            // the access instruction is UNDEFINED
            if</del> <a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()"><ins>ThisInstr</ins></a><a href="shared_pseudocode.html#AArch64.CheckCP15InstrCoarseTraps.3" title="function: boolean AArch64.CheckCP15InstrCoarseTraps(integer CRn, integer nreg, integer CRm)"><del>AArch64.CheckCP15InstrCoarseTraps</del></a><ins>();
            exception.syndrome&lt;21:20> = instr&lt;20:19>;          // Op0
            exception.syndrome&lt;19:17> = instr&lt;7:5>;            // Op2
            exception.syndrome&lt;16:14> = instr&lt;18:16>;          // Op1
            exception.syndrome&lt;13:10> = instr&lt;15:12>;          // CRn
            exception.syndrome&lt;9:5>   = instr&lt;4:0>;            // Rt
            exception.syndrome&lt;4:1>   = instr&lt;11:8>;           // CRm
            exception.syndrome&lt;0>     = instr&lt;21>;             // Direction
        otherwise</ins><del>(CRn, nreg, CRm) then
                // For a coarse-grain trap, if it is IMPLEMENTATION DEFINED whether an access from
                // User mode is UNDEFINED when the trap is disabled, then it is
                // IMPLEMENTATION DEFINED whether the same access is UNDEFINED or generates a trap
                // when the trap is enabled.
                if PSTATE.EL ==</del>
            <del> &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; !allocated then
                    if boolean IMPLEMENTATION_DEFINED "UNDEF unallocated CP15 access at </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>" then
                        UNDEFINED;
                </del><a href="shared_pseudocode.html#AArch64.AArch32SystemAccessTrap.2" title="function: AArch64.AArch32SystemAccessTrap(bits(2) target_el, bits(32) aarch32_instr)"><del>AArch64.AArch32SystemAccessTrap</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>, instr);

    else
        allocated = FALSE;

    if !allocated then
        UNDEFINED;

    // If the instruction is not UNDEFINED, it might be disabled or trapped to a higher EL.
    </del><a href="shared_pseudocode.html#AArch64.CheckAArch32SystemAccessTraps.1" title="function: AArch64.CheckAArch32SystemAccessTraps(bits(32) instr)"><del>AArch64.CheckAArch32SystemAccessTraps</del></a><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><ins>Unreachable</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>();
</ins><del>(instr);
</del>
<ins>    return exception;</ins><del>    return;</del></p></div><div class="ps" psname="aarch64.exceptions.traps.AArch64.UndefinedFault"><a id="aarch64.exceptions.traps.AArch64.UndefinedFault" name="aarch64.exceptions.traps.AArch64.UndefinedFault"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/<ins>AArch64.UndefinedFault</ins><del>AArch64.CheckAArch32SystemAccessEL1Traps</del></h3><p class="pseudocode"><ins>// AArch64.UndefinedFault()
// ========================</ins><del>// AArch64.CheckAArch32SystemAccessEL1Traps()
// ==========================================
// Check for configurable disables or traps to EL1 or EL2 of an AArch32 System register
// access instruction.</del>

<a id="AArch64.UndefinedFault.0" name="AArch64.UndefinedFault.0"></a><ins>AArch64.UndefinedFault()

    route_to_el2 =</ins><del>AArch64.CheckAArch32SystemAccessEL1Traps(bits(32) instr)
    assert PSTATE.EL ==</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>() &amp;&amp; PSTATE.EL == </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> <ins>&amp;&amp; HCR_EL2.TGE == '1';
    bits(64) preferred_exception_return =</ins><del>;

    trap = FALSE;

    // Decode the AArch32 System register access instruction
    (op, cp_num, opc1, CRn, CRm, opc2, write) =</del> <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><ins>ThisInstrAddr</ins></a><a href="shared_pseudocode.html#AArch32.DecodeSysRegAccess.1" title="function: (SystemAccessType, integer, integer, integer, integer, integer, boolean) AArch32.DecodeSysRegAccess(bits(32) instr)"><del>AArch32.DecodeSysRegAccess</del></a><ins>();
    vect_offset = 0x0;
</ins><del>(instr);
</del>
<ins>    exception =</ins><del>    if cp_num == 14 then
        if ((op ==</del> <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><ins>(</ins><del>&amp;&amp; opc1 == 0 &amp;&amp; CRn == 0 &amp;&amp; CRm == 5 &amp;&amp; opc2 == 0) || // DBGDTRRXint/DBGDTRTXint
            (op ==</del><a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_Uncategorized</ins></a><a href="shared_pseudocode.html#SystemAccessType_DT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_DT</del></a><ins>);

    if</ins><del>&amp;&amp; CRn == 5 &amp;&amp; opc2 == 0)) then                       // DBGDTRRXint/DBGDTRTXint (STC/LDC)
            trap = !</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><del>Halted</del></a><ins>(PSTATE.EL) ></ins><del>() &amp;&amp; MDSCR_EL1.TDCC == '1';

        elsif opc1 == 0 then
            trap = MDSCR_EL1.TDCC == '1';

        elsif opc1 == 1 then
            trap =</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#impl-aarch64.CPACR.read.0" title="accessor: CPACRType CPACR[]"><del>CPACR</del></a><ins>(</ins><del>[].TTA == '1';

    elsif cp_num == 15 then
        if ((op ==</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><ins>) then</ins><del>&amp;&amp; opc1 == 0 &amp;&amp; CRn == 9 &amp;&amp; CRm == 12 &amp;&amp; opc2 == 0) || // PMCR
            (op ==</del>
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><ins>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
    elsif route_to_el2 then</ins><del>&amp;&amp; opc1 == 0 &amp;&amp; CRn == 9 &amp;&amp; CRm == 12 &amp;&amp; opc2 == 1) || // PMCNTENSET
            (op ==</del>
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><ins>(</ins><del>&amp;&amp; opc1 == 0 &amp;&amp; CRn == 9 &amp;&amp; CRm == 12 &amp;&amp; opc2 == 2) || // PMCNTENCLR
            (op ==</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><ins>, exception, preferred_exception_return, vect_offset);
    else</ins><del>&amp;&amp; opc1 == 0 &amp;&amp; CRn == 9 &amp;&amp; CRm == 12 &amp;&amp; opc2 == 3) || // PMOVSR
            (op ==</del>
        <del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 9 &amp;&amp; CRm == 12 &amp;&amp; opc2 == 6) || // PMCEID0
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 9 &amp;&amp; CRm == 12 &amp;&amp; opc2 == 7) || // PMCEID1
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 9 &amp;&amp; CRm == 13 &amp;&amp; opc2 == 1) || // PMXEVTYPER
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 9 &amp;&amp; CRm == 14 &amp;&amp; opc2 == 3) || // PMOVSSET
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 14 &amp;&amp; CRm >= 12)) then          // PMEVTYPER&lt;n>
            trap = PMUSERENR_EL0.EN == '0';

        elsif op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 9 &amp;&amp; CRm == 14 &amp;&amp; opc2 == 4 then // PMSWINC
            trap = PMUSERENR_EL0.EN == '0' &amp;&amp; PMUSERENR_EL0.SW == '0';

        elsif ((op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 9 &amp;&amp; CRm == 13 &amp;&amp; opc2 == 0) || // PMCCNTR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RRT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RRT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRm == 9)) then                          // PMCCNTR (MRRC/MCRR)
            trap = PMUSERENR_EL0.EN == '0' &amp;&amp; (write || PMUSERENR_EL0.CR == '0');

        elsif ((op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 9 &amp;&amp; CRm == 13 &amp;&amp; opc2 == 2) || // PMXEVCNTR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 14 &amp;&amp; CRm >= 8 &amp;&amp; CRm &lt;= 11)) then  // PMEVCNTR&lt;n>
            trap = PMUSERENR_EL0.EN == '0' &amp;&amp; (write || PMUSERENR_EL0.ER == '0');

        elsif op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 9 &amp;&amp; CRm == 12 &amp;&amp; opc2 == 5 then    // PMSELR
            trap = PMUSERENR_EL0.EN == '0' &amp;&amp; PMUSERENR_EL0.ER == '0';

        elsif op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 14 &amp;&amp; CRm == 2 &amp;&amp; opc2 IN {0,1,2} then // CNTP_TVAL CNTP_CTL CNTP_CVAL
            trap = </del><a href="shared_pseudocode.html#impl-aarch64.CNTKCTL.read.0" title="accessor: CNTKCTLType CNTKCTL[]"><del>CNTKCTL</del></a><del>[].EL0PTEN == '0';

        elsif op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 14 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 0 then       // CNTFRQ
            trap = </del><a href="shared_pseudocode.html#impl-aarch64.CNTKCTL.read.0" title="accessor: CNTKCTLType CNTKCTL[]"><del>CNTKCTL</del></a><del>[].EL0PTEN == '0' &amp;&amp; </del><a href="shared_pseudocode.html#impl-aarch64.CNTKCTL.read.0" title="accessor: CNTKCTLType CNTKCTL[]"><del>CNTKCTL</del></a><del>[].EL0VCTEN == '0';

        elsif op == </del><a href="shared_pseudocode.html#SystemAccessType_RRT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RRT</del></a><del> &amp;&amp; opc1 == 1 &amp;&amp; CRm == 14 then                               // CNTVCT
            trap = </del><a href="shared_pseudocode.html#impl-aarch64.CNTKCTL.read.0" title="accessor: CNTKCTLType CNTKCTL[]"><del>CNTKCTL</del></a><del>[].EL0VCTEN == '0';

    if trap then
        </del><a href="shared_pseudocode.html#AArch64.AArch32SystemAccessTrap.2" title="function: AArch64.AArch32SystemAccessTrap(bits(2) target_el, bits(32) aarch32_instr)"><del>AArch64.AArch32SystemAccessTrap</del></a><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a><ins>, exception, preferred_exception_return, vect_offset);</ins><del>, instr);</del></p></div><div class="ps" psname="aarch64.exceptions.traps.AArch64.WFxTrap"><a id="aarch64.exceptions.traps.AArch64.WFxTrap" name="aarch64.exceptions.traps.AArch64.WFxTrap"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/<ins>AArch64.WFxTrap</ins><del>AArch64.CheckAArch32SystemAccessEL2Traps</del></h3><p class="pseudocode"><ins>// AArch64.WFxTrap()
// =================</ins><del>// AArch64.CheckAArch32SystemAccessEL2Traps()
// ==========================================
// Check for configurable traps to EL2 of an AArch32 System register access instruction.</del>

<a id="AArch64.WFxTrap.2" name="AArch64.WFxTrap.2"></a><ins>AArch64.WFxTrap(bits(2) target_el, boolean is_wfe)
</ins><del>AArch64.CheckAArch32SystemAccessEL2Traps(bits(32) instr)
</del>    assert <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><ins>(target_el) ></ins><del>() &amp;&amp; PSTATE.EL IN {</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>(PSTATE.EL);

    bits(64) preferred_exception_return =</ins><del>,</del> <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><ins>ThisInstrAddr</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>();
    vect_offset = 0x0;

    exception =</ins><del>,</del> <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>(</ins><del>};

    trap = FALSE;

    // Decode the AArch32 System register access instruction
    (op, cp_num, opc1, CRn, CRm, opc2, write) =</del><a href="shared_pseudocode.html#Exception_WFxTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_WFxTrap</ins></a><a href="shared_pseudocode.html#AArch32.DecodeSysRegAccess.1" title="function: (SystemAccessType, integer, integer, integer, integer, integer, boolean) AArch32.DecodeSysRegAccess(bits(32) instr)"><del>AArch32.DecodeSysRegAccess</del></a><ins>);
    exception.syndrome&lt;24:20> =</ins><del>(instr);

    if cp_num == 14 &amp;&amp; PSTATE.EL IN {</del> <a href="shared_pseudocode.html#impl-shared.ConditionSyndrome.0" title="function: bits(5) ConditionSyndrome()"><ins>ConditionSyndrome</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>();
    exception.syndrome&lt;0> = if is_wfe then '1' else '0';

    if target_el ==</ins><del>,</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> <ins>&amp;&amp;</ins><del>} then
        if ((op ==</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><ins>() &amp;&amp; HCR_EL2.TGE == '1' then</ins><del>&amp;&amp; opc1 == 0 &amp;&amp; CRn == 1 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 0) || // DBGDRAR
            (op ==</del>
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><a href="shared_pseudocode.html#SystemAccessType_RRT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RRT</del></a><ins>(</ins><del>&amp;&amp; opc1 == 0 &amp;&amp; CRm == 1) ||                         // DBGDRAR (MRRC)
            (op ==</del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 2 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 0) || // DBGDSAR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RRT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RRT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRm == 2)) then                      // DBGDSAR (MRRC)
            trap = MDCR_EL2.TDRA == '1' || MDCR_EL2.TDE == '1' || HCR_EL2.TGE == '1';

        elsif ((op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 1 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 4) || // DBGOSLAR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 1 &amp;&amp; CRm == 1 &amp;&amp; opc2 == 4) ||    // DBGOSLSR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 1 &amp;&amp; CRm == 3 &amp;&amp; opc2 == 4) ||    // DBGOSDLR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 1 &amp;&amp; CRm == 4 &amp;&amp; opc2 == 4)) then // DBGPRCR
            trap = MDCR_EL2.TDOSA == '1' || MDCR_EL2.TDE == '1' || HCR_EL2.TGE == '1';

        elsif opc1 == 0 &amp;&amp; (!</del><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><del>Halted</del></a><del>() || !(op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; CRn == 0 &amp;&amp; CRm == 5 &amp;&amp; opc2 == 0)) then
            trap = MDCR_EL2.TDA == '1' || MDCR_EL2.TDE == '1' || HCR_EL2.TGE == '1';

        elsif opc1 == 1 then
            trap = CPTR_EL2.TTA == '1';

        elsif op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 7 &amp;&amp; CRn == 0 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 0 then  // JIDR
            trap = HCR_EL2.TID0 == '1';

    elsif cp_num == 14 &amp;&amp; PSTATE.EL == </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a><ins>, exception, preferred_exception_return, vect_offset);
    else</ins><del>then
        if opc1 == 1 then
            trap = CPTR_EL2.TTA == '1';

    elsif cp_num == 15 &amp;&amp; PSTATE.EL IN {</del>
        <del>, </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>} then
        if ((op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 1 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 0) ||  // SCTLR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 2 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 0) ||  // TTBR0
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RRT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RRT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRm == 2) ||                          // TTBR0 (MRRC/MCCR)
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 2 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 1) ||  // TTBR1
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RRT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RRT</del></a><del> &amp;&amp; opc1 == 1 &amp;&amp; CRm == 2) ||                          // TTBR1 (MRRC/MCCR)
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 2 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 2) ||  // TTBCR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 2 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 3) ||  // TTBCR2
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 3 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 0) ||  // DACR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 5 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 0) ||  // DFSR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 5 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 1) ||  // IFSR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 6 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 0) ||  // DFAR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 6 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 2) ||  // IFAR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 5 &amp;&amp; CRm == 1 &amp;&amp; opc2 == 0) ||  // ADFSR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 5 &amp;&amp; CRm == 1 &amp;&amp; opc2 == 1) ||  // AIFSR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 10 &amp;&amp; CRm == 2 &amp;&amp; opc2 == 0) || // PRRR/MAIR0
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 10 &amp;&amp; CRm == 2 &amp;&amp; opc2 == 1) || // NMRR/MAIR1
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 10 &amp;&amp; CRm == 3 &amp;&amp; opc2 == 0) || // AMAIR0
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 10 &amp;&amp; CRm == 3 &amp;&amp; opc2 == 1) || // AMAIR1
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 13 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 1)) then // CONTEXTIDR
            trap = if write then HCR_EL2.TVM == '1' else HCR_EL2.TRVM == '1';
        elsif op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 8 then                         // TLBI
            trap = write &amp;&amp; HCR_EL2.TTLB == '1';
        elsif ((op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 7 &amp;&amp; CRm == 6 &amp;&amp; opc2 == 2) ||  // DCISW
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 7 &amp;&amp; CRm == 10 &amp;&amp; opc2 == 2) ||    // DCCSW
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 7 &amp;&amp; CRm == 14 &amp;&amp; opc2 == 2)) then // DCCISW
            trap = write &amp;&amp; HCR_EL2.TSW == '1';

        elsif ((op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 7 &amp;&amp; CRm == 6 &amp;&amp; opc2 == 1) ||  // DCIMVAC
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 7 &amp;&amp; CRm == 10 &amp;&amp; opc2 == 1) ||    // DCCMVAC
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 7 &amp;&amp; CRm == 14 &amp;&amp; opc2 == 1)) then // DCCIMVAC
            trap = write &amp;&amp; HCR_EL2.TPCP == '1';

        elsif ((op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 7 &amp;&amp; CRm == 5 &amp;&amp; opc2 == 1) ||  // ICIMVAU
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 7 &amp;&amp; CRm == 5 &amp;&amp; opc2 == 0) ||     // ICIALLU
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 7 &amp;&amp; CRm == 1 &amp;&amp; opc2 == 0) ||     // ICIALLUIS
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 7 &amp;&amp; CRm == 11 &amp;&amp; opc2 == 1)) then // DCCMVAU
            trap = write &amp;&amp; HCR_EL2.TPU == '1';

        elsif ((op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 1 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 1) ||   // ACTLR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 1 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 3)) then   // ACTLR2
            trap = HCR_EL2.TACR == '1';

        elsif ((op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 0 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 2) ||  // TCMTR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 0 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 3) ||     // TLBTR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 0 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 6) ||     // REVIDR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 1 &amp;&amp; CRn == 0 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 7)) then  // AIDR
            trap = HCR_EL2.TID1 == '1';

        elsif ((op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 0 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 1) ||  // CTR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 1 &amp;&amp; CRn == 0 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 0) ||     // CCSIDR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 1 &amp;&amp; CRn == 0 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 2) ||     // CCSIDR2
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 1 &amp;&amp; CRn == 0 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 1) ||     // CLIDR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 2 &amp;&amp; CRn == 0 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 0)) then  // CSSELR
            trap = HCR_EL2.TID2 == '1';

        elsif ((op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 0 &amp;&amp; CRm == 1) ||               // ID_*
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 0 &amp;&amp; CRm == 2 &amp;&amp; opc2 &lt;= 7) ||     // ID_*
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 0 &amp;&amp; CRm >= 3 &amp;&amp; opc2 &lt;= 1) ||     // Reserved
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 0 &amp;&amp; CRm == 3 &amp;&amp; opc2 == 2) ||     // Reserved
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 0 &amp;&amp; CRm == 5 &amp;&amp; opc2 IN {4,5})) then  // Reserved
            trap = HCR_EL2.TID3 == '1';

        elsif op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 1 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 2 then   // CPACR
            trap = CPTR_EL2.TCPAC == '1';

        elsif op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 9 &amp;&amp; CRm == 12 &amp;&amp; opc2 == 0 then  // PMCR
            trap = MDCR_EL2.TPMCR == '1' || MDCR_EL2.TPM == '1';

        elsif ((op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 14 &amp;&amp; CRm >= 8) ||      // PMEVCNTR&lt;n>/PMEVTYPER&lt;n>
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 9 &amp;&amp; CRm IN {12,13,14}) || // PM*
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RRT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RRT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRm == 9)) then                  // PMCCNTR (MRRC/MCCR)
            trap = MDCR_EL2.TPM == '1';

        elsif op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 14 &amp;&amp; CRm == 2 &amp;&amp; opc2 IN {0,1,2} then      // CNTP_TVAL CNTP_CTL CNTP_CVAL
            if !</del><a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><del>HaveVirtHostExt</del></a><del>() || HCR_EL2.E2H == '0' then
                trap = CNTHCTL_EL2.EL1PCEN == '0';
            else
                trap = CNTHCTL_EL2.EL1PTEN == '0';
        elsif op == </del><a href="shared_pseudocode.html#SystemAccessType_RRT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RRT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRm == 14 then                                    // CNTPCT
            trap = CNTHCTL_EL2.EL1PCTEN == '0';

        elsif ((op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 1 &amp;&amp; CRm == 1 &amp;&amp; opc2 == 0) ||    // SCR
               (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 1 &amp;&amp; CRm == 1 &amp;&amp; opc2 == 2) ||    // NSACR
               (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 12 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 1) ||   // MVBAR
               (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 1 &amp;&amp; CRm == 3 &amp;&amp; opc2 == 1) ||    // SDCR
               (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 7 &amp;&amp; CRm == 8 &amp;&amp; opc2 >= 4)) then // ATS12NSOxx
            trap = </del><a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()"><del>IsSecureEL2Enabled</del></a><del>() &amp;&amp; PSTATE.EL == </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del> &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>() &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>);

    if trap then
        </del><a href="shared_pseudocode.html#AArch64.AArch32SystemAccessTrap.2" title="function: AArch64.AArch32SystemAccessTrap(bits(2) target_el, bits(32) aarch32_instr)"><del>AArch64.AArch32SystemAccessTrap</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>(target_el, exception, preferred_exception_return, vect_offset);</ins><del>, instr);</del></p></div><div class="ps" psname="aarch64.exceptions.traps.CheckFPAdvSIMDEnabled64"><a id="aarch64.exceptions.traps.CheckFPAdvSIMDEnabled64" name="aarch64.exceptions.traps.CheckFPAdvSIMDEnabled64"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/<ins>CheckFPAdvSIMDEnabled64</ins><del>AArch64.CheckAArch32SystemAccessEL3Traps</del></h3><p class="pseudocode"><ins>// CheckFPAdvSIMDEnabled64()
// =========================
// AArch64 instruction wrapper</ins><del>// AArch64.CheckAArch32SystemAccessEL3Traps()
// ==========================================
// Check for configurable traps to EL3 of an AArch32 System register access instruction.</del>

<a id="impl-aarch64.CheckFPAdvSIMDEnabled64.0" name="impl-aarch64.CheckFPAdvSIMDEnabled64.0"></a><ins>CheckFPAdvSIMDEnabled64()</ins><del>AArch64.CheckAArch32SystemAccessEL3Traps(bits(32) instr)
    assert</del>
    <del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; PSTATE.EL != </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>;

    // Decode the AArch32 System register access instruction
    (op, cp_num, opc1, CRn, CRm, opc2, write) = </del><a href="shared_pseudocode.html#AArch32.DecodeSysRegAccess.1" title="function: (SystemAccessType, integer, integer, integer, integer, integer, boolean) AArch32.DecodeSysRegAccess(bits(32) instr)"><del>AArch32.DecodeSysRegAccess</del></a><del>(instr);

    trap = FALSE;

    if cp_num == 14 then
        if ((op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 1 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 4 &amp;&amp; !write) || // DBGOSLAR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 1 &amp;&amp; CRm == 1 &amp;&amp; opc2 == 4 &amp;&amp; write) ||  // DBGOSLSR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 1 &amp;&amp; CRm == 3 &amp;&amp; opc2 == 4) ||           // DBGOSDLR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 1 &amp;&amp; CRm == 4 &amp;&amp; opc2 == 4)) then        // DBGPRCR
            trap = MDCR_EL3.TDOSA == '1';

        elsif opc1 == 0 &amp;&amp; (!</del><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><del>Halted</del></a><del>() || !(op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; CRn == 0 &amp;&amp; CRm == 5 &amp;&amp; opc2 == 0)) then
            trap = MDCR_EL3.TDA == '1';

        elsif opc1 == 1 then
            trap = CPTR_EL3.TTA == '1';

    elsif cp_num == 15 then
        if ((op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 1 &amp;&amp; CRm == 1 &amp;&amp; opc2 == 0) ||    // SCR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 1 &amp;&amp; CRm == 1 &amp;&amp; opc2 == 2) ||    // NSACR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 12 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 1) ||   // MVBAR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 1 &amp;&amp; CRm == 3 &amp;&amp; opc2 == 1) ||    // SDCR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 7 &amp;&amp; CRm == 8 &amp;&amp; opc2 >= 4)) then // ATS12NSOxx
            trap = PSTATE.EL == </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del> &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>();

        elsif ((op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 1 &amp;&amp; CRm == 0 &amp;&amp; opc2 == 2) || // CPACR
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 4 &amp;&amp; CRn == 1 &amp;&amp; CRm == 1 &amp;&amp; opc2 == 2)) then // HCPTR
            trap = CPTR_EL3.TCPAC == '1';

        elsif ((op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 14 &amp;&amp; CRm >= 8) ||             // PMEVCNTR&lt;n>/PMEVTYPER&lt;n>
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRn == 9 &amp;&amp; CRm IN {12,13,14}) ||        // PM*
            (op == </del><a href="shared_pseudocode.html#SystemAccessType_RRT" title="enumeration SystemAccessType { SystemAccessType_RT,  SystemAccessType_RRT,  SystemAccessType_DT }"><del>SystemAccessType_RRT</del></a><del> &amp;&amp; opc1 == 0 &amp;&amp; CRm == 9)) then                         // PMCCNTR (MRRC/MCCR)
            trap = MDCR_EL3.TPM == '1';

    if trap then
        </del><a href="shared_pseudocode.html#AArch64.AArch32SystemAccessTrap.2" title="function: AArch64.AArch32SystemAccessTrap(bits(2) target_el, bits(32) aarch32_instr)"><del>AArch64.AArch32SystemAccessTrap</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><a href="shared_pseudocode.html#AArch64.CheckFPAdvSIMDEnabled.0" title="function: AArch64.CheckFPAdvSIMDEnabled()"><ins>AArch64.CheckFPAdvSIMDEnabled</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>();</ins><del>, instr);</del></p></div><div class="ps" psname="aarch64.functions.aborts.AArch64.CreateFaultRecord"><a id="aarch64.functions.aborts.AArch64.CreateFaultRecord" name="aarch64.functions.aborts.AArch64.CreateFaultRecord"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>functions</ins><del>exceptions</del>/<ins>aborts</ins><del>traps</del>/<ins>AArch64.CreateFaultRecord</ins><del>AArch64.CheckAArch32SystemAccessTraps</del></h3><p class="pseudocode"><ins>// AArch64.CreateFaultRecord()
// ===========================

FaultRecord</ins><del>// AArch64.CheckAArch32SystemAccessTraps()
// =======================================
// Check for configurable disables or traps to a higher EL of an AArch32 System register access.</del> <a id="AArch64.CreateFaultRecord.10" name="AArch64.CreateFaultRecord.10"></a><ins>AArch64.CreateFaultRecord(</ins><del>AArch64.CheckAArch32SystemAccessTraps(bits(32) instr)

    if PSTATE.EL ==</del><a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a> <ins>type, bits(52) ipaddress, bit NS,
                                      integer level,</ins><del>then</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><a href="shared_pseudocode.html#AArch64.CheckAArch32SystemAccessEL1Traps.1" title="function: AArch64.CheckAArch32SystemAccessEL1Traps(bits(32) instr)"><del>AArch64.CheckAArch32SystemAccessEL1Traps</del></a> <ins>acctype, boolean write, bit extflag,
                                      bits(2) errortype, boolean secondstage, boolean s2fs1walk)</ins><del>(instr);
    if</del>

    <del>() &amp;&amp; PSTATE.EL IN {</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>, </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>, </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>} &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><del>IsInHost</del></a><del>() then
        </del><a href="shared_pseudocode.html#AArch64.CheckAArch32SystemAccessEL2Traps.1" title="function: AArch64.CheckAArch32SystemAccessEL2Traps(bits(32) instr)"><del>AArch64.CheckAArch32SystemAccessEL2Traps</del></a><del>(instr);
    </del><a href="shared_pseudocode.html#AArch64.CheckAArch32SystemAccessEL3Traps.1" title="function: AArch64.CheckAArch32SystemAccessEL3Traps(bits(32) instr)"><del>AArch64.CheckAArch32SystemAccessEL3Traps</del></a><a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><ins>FaultRecord</ins></a><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a> <ins>fault;
    fault.type = type;
    fault.domain = bits(4) UNKNOWN;         // Not used from AArch64
    fault.debugmoe = bits(4) UNKNOWN;       // Not used from AArch64
    fault.errortype = errortype;
    fault.ipaddress.NS = NS;
    fault.ipaddress.address = ipaddress;
    fault.level = level;
    fault.acctype = acctype;
    fault.write = write;
    fault.extflag = extflag;
    fault.secondstage = secondstage;
    fault.s2fs1walk = s2fs1walk;

    return fault;</ins><del>(instr);</del></p></div><div class="ps" psname="aarch64.functions.aborts.AArch64.FaultSyndrome"><a id="aarch64.functions.aborts.AArch64.FaultSyndrome" name="aarch64.functions.aborts.AArch64.FaultSyndrome"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>functions</ins><del>exceptions</del>/<ins>aborts</ins><del>traps</del>/<ins>AArch64.FaultSyndrome</ins><del>AArch64.CheckCP15InstrCoarseTraps</del></h3><p class="pseudocode"><ins>// AArch64.FaultSyndrome()
// =======================
// Creates an exception syndrome value for Abort and Watchpoint exceptions taken to
// an Exception Level using AArch64.
</ins><del>// AArch64.CheckCP15InstrCoarseTraps()
// ===================================
// Check for coarse-grained AArch32 CP15 traps in HSTR_EL2 and HCR_EL2.
</del>
<ins>bits(25)</ins><del>boolean</del> <a id="AArch64.FaultSyndrome.2" name="AArch64.FaultSyndrome.2"></a><ins>AArch64.FaultSyndrome(boolean d_side,</ins><del>AArch64.CheckCP15InstrCoarseTraps(integer CRn, integer nreg, integer CRm)

    // Check for coarse-grained Hyp traps
    if</del> <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><ins>FaultRecord</ins></a><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a> <ins>fault)
    assert fault.type !=</ins><del>() &amp;&amp; PSTATE.EL IN {</del> <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_None</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>;

    bits(25) iss =</ins><del>,</del> <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><ins>Zeros</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>();
    if</ins><del>} then
        // Check for MCR, MRC, MCRR and MRRC disabled by HSTR_EL2&lt;CRn/CRm>
        major = if nreg == 1 then CRn else CRm;
        if !</del> <a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()"><ins>HaveRASExt</ins></a><a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><del>IsInHost</del></a><ins>() &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.IsExternalSyncAbort.1" title="function: boolean IsExternalSyncAbort(Fault type)"><ins>IsExternalSyncAbort</ins></a><ins>(fault) then iss&lt;12:11> = fault.errortype; // SET
    if d_side then
        if </ins><a href="shared_pseudocode.html#impl-shared.IsSecondStage.1" title="function: boolean IsSecondStage(FaultRecord fault)"><ins>IsSecondStage</ins></a><ins>(fault) &amp;&amp; !fault.s2fs1walk then iss&lt;24:14> = </ins><a href="shared_pseudocode.html#impl-shared.LSInstructionSyndrome.0" title="function: bits(11) LSInstructionSyndrome()"><ins>LSInstructionSyndrome</ins></a><ins>();
        if </ins><a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()"><ins>HaveNV2Ext</ins></a><ins>() &amp;&amp; fault.acctype == </ins><a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NV2REGISTER</ins></a><ins> then
            iss&lt;13> = '1';   // Value of '1' indicates fault is generated by use of VNCR_EL2
        if fault.acctype IN {</ins><a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_DC</ins></a><ins>, </ins><a href="shared_pseudocode.html#AccType_DC_UNPRIV" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_DC_UNPRIV</ins></a><ins>, </ins><a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IC</ins></a><ins>, </ins><a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_AT</ins></a><ins>} then
            iss&lt;8> = '1';  iss&lt;6> = '1';
        else
            iss&lt;6> = if fault.write then '1' else '0';
    if </ins><a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault type)"><ins>IsExternalAbort</ins></a><ins>(fault) then iss&lt;9> = fault.extflag;
    iss&lt;7> = if fault.s2fs1walk then '1' else '0';
    iss&lt;5:0> = </ins><a href="shared_pseudocode.html#impl-shared.EncodeLDFSC.2" title="function: bits(6) EncodeLDFSC(Fault type, integer level)"><ins>EncodeLDFSC</ins></a><ins>(fault.type, fault.level);
</ins><del>() &amp;&amp; !(major IN {4,14}) &amp;&amp; HSTR_EL2&lt;major> == '1' then
            return TRUE;
</del>
<ins>    return iss;</ins><del>        // Check for MRC and MCR disabled by HCR_EL2.TIDCP
        if (HCR_EL2.TIDCP == '1' &amp;&amp; nreg == 1 &amp;&amp;
            ((CRn == 9  &amp;&amp; CRm IN {0,1,2,    5,6,7,8   }) ||
             (CRn == 10 &amp;&amp; CRm IN {0,1,    4,      8   }) ||
             (CRn == 11 &amp;&amp; CRm IN {0,1,2,3,4,5,6,7,8,15}))) then
            return TRUE;

    return FALSE;</del></p></div><div class="ps" psname="aarch64.functions.exclusive.AArch64.ExclusiveMonitorsPass"><a id="aarch64.functions.exclusive.AArch64.ExclusiveMonitorsPass" name="aarch64.functions.exclusive.AArch64.ExclusiveMonitorsPass"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>functions</ins><del>exceptions</del>/<ins>exclusive</ins><del>traps</del>/<ins>AArch64.ExclusiveMonitorsPass</ins><del>AArch64.CheckFPAdvSIMDEnabled</del></h3><p class="pseudocode"><ins>// AArch64.ExclusiveMonitorsPass()
</ins><del>// AArch64.CheckFPAdvSIMDEnabled()
</del>// ===============================
<ins>
// Return TRUE if the Exclusives monitors for the current PE include all of the addresses
// associated with the virtual address region of size bytes starting at address.
// The immediately following memory write must be to the same addresses.

boolean</ins><del>// Check against CPACR[]</del> <a id="AArch64.ExclusiveMonitorsPass.2" name="AArch64.ExclusiveMonitorsPass.2"></a><ins>AArch64.ExclusiveMonitorsPass(bits(64) address, integer size)

    // It is IMPLEMENTATION DEFINED whether the detection of memory aborts happens
    // before or after the check on the local Exclusives monitor. As a result a failure
    // of the local monitor can occur on some implementations even if the memory
    // access would give an memory abort.

    acctype =</ins><del>AArch64.CheckFPAdvSIMDEnabled()
    if PSTATE.EL IN {</del> <a href="shared_pseudocode.html#AccType_ATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ATOMIC</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>;
    iswrite = TRUE;
    aligned = (address ==</ins><del>,</del> <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)"><ins>Align</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>(address, size));

    if !aligned then
        secondstage = FALSE;</ins><del>} &amp;&amp; !</del>
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)"><ins>AArch64.Abort</ins></a><a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><del>IsInHost</del></a><ins>(address,</ins><del>() then
        // Check if access disabled in CPACR_EL1
        case</del> <a href="shared_pseudocode.html#AArch64.AlignmentFault.3" title="function: FaultRecord AArch64.AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)"><ins>AArch64.AlignmentFault</ins></a><a href="shared_pseudocode.html#impl-aarch64.CPACR.read.0" title="accessor: CPACRType CPACR[]"><del>CPACR</del></a><ins>(acctype, iswrite, secondstage));

    passed =</ins><del>[].FPEN of
            when 'x0'  disabled = TRUE;
            when '01'  disabled = PSTATE.EL ==</del> <a href="shared_pseudocode.html#AArch64.IsExclusiveVA.3" title="function: boolean AArch64.IsExclusiveVA(bits(64) address, integer processorid, integer size)"><ins>AArch64.IsExclusiveVA</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>(address,</ins><del>;
            when '11'  disabled = FALSE;
        if disabled then</del> <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><ins>ProcessorID</ins></a><a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)"><del>AArch64.AdvSIMDFPAccessTrap</del></a><ins>(), size);
    if !passed then
        return FALSE;
    memaddrdesc =</ins><del>(</del> <a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><ins>AArch64.TranslateAddress</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>(address, acctype, iswrite, aligned, size);

    // Check for aborts or debug exceptions
    if</ins><del>);</del> <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><a href="shared_pseudocode.html#AArch64.CheckFPAdvSIMDTrap.0" title="function: AArch64.CheckFPAdvSIMDTrap()"><del>AArch64.CheckFPAdvSIMDTrap</del></a><ins>(memaddrdesc) then
        </ins><a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)"><ins>AArch64.Abort</ins></a><ins>(address, memaddrdesc.fault);

    passed = </ins><a href="shared_pseudocode.html#impl-shared.IsExclusiveLocal.3" title="function: boolean IsExclusiveLocal(FullAddress paddress, integer processorid, integer size)"><ins>IsExclusiveLocal</ins></a><ins>(memaddrdesc.paddress, </ins><a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><ins>ProcessorID</ins></a><ins>(), size);

    if passed then
        </ins><a href="shared_pseudocode.html#impl-shared.ClearExclusiveLocal.1" title="function: ClearExclusiveLocal(integer processorid)"><ins>ClearExclusiveLocal</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><ins>ProcessorID</ins></a><ins>());
        if memaddrdesc.memattrs.shareable then
            passed = </ins><a href="shared_pseudocode.html#impl-shared.IsExclusiveGlobal.3" title="function: boolean IsExclusiveGlobal(FullAddress paddress, integer processorid, integer size)"><ins>IsExclusiveGlobal</ins></a><ins>(memaddrdesc.paddress, </ins><a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><ins>ProcessorID</ins></a><ins>(), size);

    return passed;</ins><del>();               // Also check against CPTR_EL2 and CPTR_EL3</del></p></div><div class="ps" psname="aarch64.functions.exclusive.AArch64.IsExclusiveVA"><a id="aarch64.functions.exclusive.AArch64.IsExclusiveVA" name="aarch64.functions.exclusive.AArch64.IsExclusiveVA"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>functions</ins><del>exceptions</del>/<ins>exclusive</ins><del>traps</del>/<ins>AArch64.IsExclusiveVA</ins><del>AArch64.CheckFPAdvSIMDTrap</del></h3><p class="pseudocode"><ins>// An optional IMPLEMENTATION DEFINED test for an exclusive access to a virtual
// address region of size bytes starting at address.
//
// It is permitted (but not required) for this function to return FALSE and
// cause a store exclusive to fail if the virtual address region is not
// totally included within the region recorded by MarkExclusiveVA().
//
// It is always safe to return TRUE which will check the physical address only.
boolean</ins><del>// AArch64.CheckFPAdvSIMDTrap()
// ============================
// Check against CPTR_EL2 and CPTR_EL3.</del> <a id="AArch64.IsExclusiveVA.3" name="AArch64.IsExclusiveVA.3"></a><ins>AArch64.IsExclusiveVA(bits(64) address, integer processorid, integer size);</ins><del>AArch64.CheckFPAdvSIMDTrap()

    if</del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() then
        // Check if access disabled in CPTR_EL2
        if </del><a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><del>HaveVirtHostExt</del></a><del>() &amp;&amp; HCR_EL2.E2H == '1' then
            case CPTR_EL2.FPEN of
                when 'x0'  disabled = !(PSTATE.EL == </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del> &amp;&amp; HCR_EL2.TGE == '1');
                when '01'  disabled = (PSTATE.EL == </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del> &amp;&amp; HCR_EL2.TGE == '1');
                when '11'  disabled = FALSE;
            if disabled then </del><a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)"><del>AArch64.AdvSIMDFPAccessTrap</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>);
        else
            if CPTR_EL2.TFP == '1' then </del><a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)"><del>AArch64.AdvSIMDFPAccessTrap</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>);

    if </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) then
        // Check if access disabled in CPTR_EL3
        if CPTR_EL3.TFP == '1' then </del><a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)"><del>AArch64.AdvSIMDFPAccessTrap</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>);

    return;</del></p></div><div class="ps" psname="aarch64.functions.exclusive.AArch64.MarkExclusiveVA"><a id="aarch64.functions.exclusive.AArch64.MarkExclusiveVA" name="aarch64.functions.exclusive.AArch64.MarkExclusiveVA"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>functions</ins><del>exceptions</del>/<ins>exclusive</ins><del>traps</del>/<ins>AArch64.MarkExclusiveVA</ins><del>AArch64.CheckForERetTrap</del></h3><p class="pseudocode"><ins>// Optionally record an exclusive access to the virtual address region of size bytes
// starting at address for processorid.</ins><del>// AArch64.CheckForERetTrap()
// ==========================
// Check for trap on ERET, ERETAA, ERETAB instruction</del>
<a id="AArch64.MarkExclusiveVA.3" name="AArch64.MarkExclusiveVA.3"></a><ins>AArch64.MarkExclusiveVA(bits(64) address, integer processorid, integer size);</ins><del>AArch64.CheckForERetTrap(boolean eret_with_pac, boolean pac_uses_key_a)

    // Non-secure EL1 execution of ERET, ERETAA, ERETAB when HCR_EL2.NV bit is set, is trapped to EL2
    route_to_el2 =</del><a href="shared_pseudocode.html#impl-shared.HaveNVExt.0" title="function: boolean HaveNVExt()"><del>HaveNVExt</del></a><del>() &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; PSTATE.EL == </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del> &amp;&amp; HCR_EL2.NV == '1';

    if route_to_el2 then
        </del><a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is (Exception type, bits(25) syndrome, bits(64) vaddress, boolean ipavalid, bits(1) NS, bits(52) ipaddress)"><del>ExceptionRecord</del></a><del> exception;
        bits(64) preferred_exception_return = </del><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><del>ThisInstrAddr</del></a><del>();
        vect_offset = 0x0;
        exception = </del><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a><del>(</del><a href="shared_pseudocode.html#Exception_ERetTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_ERetTrap</del></a><del>);
        if !eret_with_pac then                             // ERET
            exception.syndrome&lt;1> = '0';
            exception.syndrome&lt;0> = '0';                   // RES0
        else
            exception.syndrome&lt;1> = '1';
            if pac_uses_key_a then                         // ERETAA
                exception.syndrome&lt;0> = '0';
            else    // ERETAB
                exception.syndrome&lt;0> = '1';
        </del><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>, exception, preferred_exception_return, vect_offset);</del></p></div><div class="ps" psname="aarch64.functions.exclusive.AArch64.SetExclusiveMonitors"><a id="aarch64.functions.exclusive.AArch64.SetExclusiveMonitors" name="aarch64.functions.exclusive.AArch64.SetExclusiveMonitors"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>functions</ins><del>exceptions</del>/<ins>exclusive</ins><del>traps</del>/<ins>AArch64.SetExclusiveMonitors</ins><del>AArch64.CheckForSMCUndefOrTrap</del></h3><p class="pseudocode"><ins>// AArch64.SetExclusiveMonitors()
// ==============================

// Sets the Exclusives monitors for the current PE to record the addresses associated
// with the virtual address region of size bytes starting at address.</ins><del>// AArch64.CheckForSMCUndefOrTrap()
// ================================
// Check for UNDEFINED or trap on SMC instruction</del>

<a id="AArch64.SetExclusiveMonitors.2" name="AArch64.SetExclusiveMonitors.2"></a><ins>AArch64.SetExclusiveMonitors(bits(64) address, integer size)

    acctype =</ins><del>AArch64.CheckForSMCUndefOrTrap(bits(16) imm)
    route_to_el2 =</del> <a href="shared_pseudocode.html#AccType_ATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ATOMIC</ins></a><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><ins>;
    iswrite = FALSE;
    aligned = (address ==</ins><del>() &amp;&amp; PSTATE.EL ==</del> <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)"><ins>Align</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>(address, size));
    memaddrdesc =</ins><del>&amp;&amp; HCR_EL2.TSC == '1';
    if PSTATE.EL ==</del> <a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><ins>AArch64.TranslateAddress</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>(address, acctype, iswrite, aligned, size);

    // Check for aborts or debug exceptions
    if</ins><del>then UNDEFINED;
    if !</del> <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>(memaddrdesc) then
        return;

    if memaddrdesc.memattrs.shareable then</ins><del>(</del>
        <a href="shared_pseudocode.html#impl-shared.MarkExclusiveGlobal.3" title="function: MarkExclusiveGlobal(FullAddress paddress, integer processorid, integer size)"><ins>MarkExclusiveGlobal</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><ins>(memaddrdesc.paddress,</ins><del>) then
        if</del> <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><ins>ProcessorID</ins></a><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><ins>(), size);</ins><del>() &amp;&amp; PSTATE.EL ==</del>

    <a href="shared_pseudocode.html#impl-shared.MarkExclusiveLocal.3" title="function: MarkExclusiveLocal(FullAddress paddress, integer processorid, integer size)"><ins>MarkExclusiveLocal</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>(memaddrdesc.paddress,</ins><del>then
            if</del> <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><ins>ProcessorID</ins></a><a href="shared_pseudocode.html#impl-shared.HaveNVExt.0" title="function: boolean HaveNVExt()"><del>HaveNVExt</del></a><ins>(), size);</ins><del>() &amp;&amp; HCR_EL2.NV == '1' &amp;&amp; HCR_EL2.TSC == '1' then
                route_to_el2 = TRUE;
            else
                UNDEFINED;
        else
            UNDEFINED;
    else
        route_to_el2 =</del>

    <a href="shared_pseudocode.html#AArch64.MarkExclusiveVA.3" title="function: AArch64.MarkExclusiveVA(bits(64) address, integer processorid, integer size)"><ins>AArch64.MarkExclusiveVA</ins></a><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><ins>(address,</ins><del>() &amp;&amp; PSTATE.EL ==</del> <del> &amp;&amp; HCR_EL2.TSC == '1';
    if route_to_el2 then
        bits(64) preferred_exception_return = </del><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><del>ThisInstrAddr</del></a><del>();
        vect_offset = 0x0;
        exception = </del><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a><del>(</del><a href="shared_pseudocode.html#Exception_MonitorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_MonitorCall</del></a><del>);
        exception.syndrome&lt;15:0> = imm;
        </del><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><ins>ProcessorID</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>(), size);</ins><del>, exception, preferred_exception_return, vect_offset);</del></p></div><div class="ps" psname="aarch64.functions.fusedrstep.FPRSqrtStepFused"><a id="aarch64.functions.fusedrstep.FPRSqrtStepFused" name="aarch64.functions.fusedrstep.FPRSqrtStepFused"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>functions</ins><del>exceptions</del>/<ins>fusedrstep</ins><del>traps</del>/<ins>FPRSqrtStepFused</ins><del>AArch64.CheckForWFxTrap</del></h3><p class="pseudocode"><ins>// FPRSqrtStepFused()
// ==================

bits(N)</ins><del>// AArch64.CheckForWFxTrap()
// =========================
// Check for trap on WFE or WFI instruction</del> <a id="impl-aarch64.FPRSqrtStepFused.2" name="impl-aarch64.FPRSqrtStepFused.2"></a><ins>FPRSqrtStepFused(bits(N) op1, bits(N) op2)
    assert N IN {16, 32, 64};
    bits(N) result;
    op1 =</ins><del>AArch64.CheckForWFxTrap(bits(2) target_el, boolean is_wfe)
    assert</del> <a href="shared_pseudocode.html#impl-shared.FPNeg.1" title="function: bits(N) FPNeg(bits(N) op)"><ins>FPNeg</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>(op1);
    (type1,sign1,value1) =</ins><del>(target_el);

    case target_el of
        when</del> <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>(op1, FPCR);
    (type2,sign2,value2) =</ins><del>trap = (if is_wfe then</del> <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><del>SCTLR</del></a><ins>(op2, FPCR);
    (done,result) =</ins><del>[].nTWE else</del> <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2, FPCRType fpcr)"><ins>FPProcessNaNs</ins></a><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><del>SCTLR</del></a><ins>(type1, type2, op1, op2, FPCR);
    if !done then
        inf1 = (type1 ==</ins><del>[].nTWI) == '0';
        when</del> <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>);
        inf2 = (type2 ==</ins><del>trap = (if is_wfe then HCR_EL2.TWE else HCR_EL2.TWI) == '1';
        when</del> <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><ins>);
        zero1 = (type1 ==</ins><del>trap = (if is_wfe then SCR_EL3.TWE else SCR_EL3.TWI) == '1';
    if trap then</del> <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><a href="shared_pseudocode.html#AArch64.WFxTrap.2" title="function: AArch64.WFxTrap(bits(2) target_el, boolean is_wfe)"><del>AArch64.WFxTrap</del></a><ins>);
        zero2 = (type2 == </ins><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><ins>);
        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPOnePointFive.1" title="function: bits(N) FPOnePointFive(bit sign)"><ins>FPOnePointFive</ins></a><ins>('0');
        elsif inf1 || inf2 then
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><ins>FPInfinity</ins></a><ins>(sign1 EOR sign2);
        else
            // Fully fused multiply-add and halve
            result_value = (3.0 + (value1 * value2)) / 2.0;
            if result_value == 0.0 then
                // Sign of exact zero result depends on rounding mode
                sign = if </ins><a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)"><ins>FPRoundingMode</ins></a><ins>(FPCR) == </ins><a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_NEGINF</ins></a><ins> then '1' else '0';
                result = </ins><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><ins>FPZero</ins></a><ins>(sign);
            else
                result = </ins><a href="shared_pseudocode.html#impl-shared.FPRound.2" title="function: bits(N) FPRound(real op, FPCRType fpcr)"><ins>FPRound</ins></a><ins>(result_value, FPCR);
    return result;</ins><del>(target_el, is_wfe);</del></p></div><div class="ps" psname="aarch64.functions.fusedrstep.FPRecipStepFused"><a id="aarch64.functions.fusedrstep.FPRecipStepFused" name="aarch64.functions.fusedrstep.FPRecipStepFused"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>functions</ins><del>exceptions</del>/<ins>fusedrstep</ins><del>traps</del>/<ins>FPRecipStepFused</ins><del>AArch64.CheckIllegalState</del></h3><p class="pseudocode"><ins>// FPRecipStepFused()
// ==================

bits(N)</ins><del>// AArch64.CheckIllegalState()
// ===========================
// Check PSTATE.IL bit and generate Illegal Execution state exception if set.</del> <a id="impl-aarch64.FPRecipStepFused.2" name="impl-aarch64.FPRecipStepFused.2"></a><ins>FPRecipStepFused(bits(N) op1, bits(N) op2)
    assert N IN {16, 32, 64};
    bits(N) result;
    op1 =</ins><del>AArch64.CheckIllegalState()
    if PSTATE.IL == '1' then
        route_to_el2 =</del> <a href="shared_pseudocode.html#impl-shared.FPNeg.1" title="function: bits(N) FPNeg(bits(N) op)"><ins>FPNeg</ins></a><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><ins>(op1);
    (type1,sign1,value1) =</ins><del>() &amp;&amp; PSTATE.EL ==</del> <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>(op1, FPCR);
    (type2,sign2,value2) =</ins><del>&amp;&amp; HCR_EL2.TGE == '1';

        bits(64) preferred_exception_return =</del> <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><del>ThisInstrAddr</del></a><ins>(op2, FPCR);
    (done,result) =</ins><del>();
        vect_offset = 0x0;

        exception =</del> <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2, FPCRType fpcr)"><ins>FPProcessNaNs</ins></a><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a><ins>(type1, type2, op1, op2, FPCR);
    if !done then
        inf1 = (type1 ==</ins><del>(</del> <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><a href="shared_pseudocode.html#Exception_IllegalState" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_IllegalState</del></a>);
<ins>        inf2 = (type2 ==</ins><del>
        if</del> <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>);
        zero1 = (type1 ==</ins><del>(PSTATE.EL) ></del> <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>);
        zero2 = (type2 ==</ins><del>(</del> <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>);
        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            result =</ins><del>) then</del> <a href="shared_pseudocode.html#impl-shared.FPTwo.1" title="function: bits(N) FPTwo(bit sign)"><ins>FPTwo</ins></a><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a><ins>('0');
        elsif inf1 || inf2 then
            result =</ins><del>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
        elsif route_to_el2 then</del> <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><ins>FPInfinity</ins></a><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a><ins>(sign1 EOR sign2);
        else
            // Fully fused multiply-add
            result_value = 2.0 + (value1 * value2);
            if result_value == 0.0 then
                // Sign of exact zero result depends on rounding mode
                sign = if</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)"><ins>FPRoundingMode</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>(FPCR) ==</ins><del>, exception, preferred_exception_return, vect_offset);
        else</del> <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_NEGINF</ins></a><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a> <ins>then '1' else '0';
                result =</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><ins>FPZero</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>(sign);
            else
                result = </ins><a href="shared_pseudocode.html#impl-shared.FPRound.2" title="function: bits(N) FPRound(real op, FPCRType fpcr)"><ins>FPRound</ins></a><ins>(result_value, FPCR);
    return result;</ins><del>, exception, preferred_exception_return, vect_offset);</del></p></div><div class="ps" psname="aarch64.functions.memory.AArch64.CheckAlignment"><a id="aarch64.functions.memory.AArch64.CheckAlignment" name="aarch64.functions.memory.AArch64.CheckAlignment"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>functions</ins><del>exceptions</del>/<ins>memory</ins><del>traps</del>/<ins>AArch64.CheckAlignment</ins><del>AArch64.MonitorModeTrap</del></h3><p class="pseudocode"><ins>// AArch64.CheckAlignment()
// ========================

boolean</ins><del>// AArch64.MonitorModeTrap()
// =========================
// Trapped use of Monitor mode features in a Secure EL1 AArch32 mode</del> <a id="AArch64.CheckAlignment.4" name="AArch64.CheckAlignment.4"></a><ins>AArch64.CheckAlignment(bits(64) address, integer alignment,</ins><del>AArch64.MonitorModeTrap()
    bits(64) preferred_exception_return =</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><del>ThisInstrAddr</del></a> <ins>acctype,
                               boolean iswrite)
</ins><del>();
    vect_offset = 0x0;
</del>
<ins>    aligned = (address ==</ins><del>    exception =</del> <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)"><ins>Align</ins></a><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a><ins>(address, alignment));
    atomic  = acctype IN {</ins><del>(</del> <a href="shared_pseudocode.html#AccType_ATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ATOMIC</ins></a><a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_Uncategorized</del></a><ins>,</ins><del>);

    if</del> <a href="shared_pseudocode.html#AccType_ATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ATOMICRW</ins></a><a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()"><del>IsSecureEL2Enabled</del></a><ins>,</ins><del>() then</del> <a href="shared_pseudocode.html#AccType_ORDEREDATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ORDEREDATOMIC</ins></a><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a><ins>,</ins><del>(</del> <a href="shared_pseudocode.html#AccType_ORDEREDATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ORDEREDATOMICRW</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a> <ins>};
    ordered = acctype IN {</ins><del>, exception, preferred_exception_return, vect_offset);</del> <a href="shared_pseudocode.html#AccType_ORDERED" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ORDERED</ins></a><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a><ins>,</ins><del>(</del> <a href="shared_pseudocode.html#AccType_ORDEREDRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ORDEREDRW</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><ins>, </ins><a href="shared_pseudocode.html#AccType_LIMITEDORDERED" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_LIMITEDORDERED</ins></a><ins>, </ins><a href="shared_pseudocode.html#AccType_ORDEREDATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ORDEREDATOMIC</ins></a><ins>, </ins><a href="shared_pseudocode.html#AccType_ORDEREDATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ORDEREDATOMICRW</ins></a><ins> };
    vector  = acctype == </ins><a href="shared_pseudocode.html#AccType_VEC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_VEC</ins></a><ins>;
    if </ins><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><ins>SCTLR</ins></a><ins>[].A == '1' then check = TRUE;
    elsif </ins><a href="shared_pseudocode.html#impl-shared.HaveUA16Ext.0" title="function: boolean HaveUA16Ext()"><ins>HaveUA16Ext</ins></a><ins>() then
        check = (</ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(address&lt;0+:4>) + alignment > 16) &amp;&amp; ((ordered &amp;&amp; </ins><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><ins>SCTLR</ins></a><ins>[].nAA == '0') || atomic);
    else check = atomic || ordered;

    if check &amp;&amp; !aligned then
        secondstage = FALSE;
        </ins><a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)"><ins>AArch64.Abort</ins></a><ins>(address, </ins><a href="shared_pseudocode.html#AArch64.AlignmentFault.3" title="function: FaultRecord AArch64.AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)"><ins>AArch64.AlignmentFault</ins></a><ins>(acctype, iswrite, secondstage));

    return aligned;</ins><del>, exception, preferred_exception_return, vect_offset);</del></p></div><div class="ps" psname="aarch64.functions.memory.AArch64.MemSingle"><a id="aarch64.functions.memory.AArch64.MemSingle" name="aarch64.functions.memory.AArch64.MemSingle"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>functions</ins><del>exceptions</del>/<ins>memory</ins><del>traps</del>/<ins>AArch64.MemSingle</ins><del>AArch64.SystemRegisterTrap</del></h3><p class="pseudocode"><ins>// AArch64.MemSingle[] - non-assignment (read) form
// ================================================
// Perform an atomic, little-endian read of 'size' bytes.

bits(size*8)</ins><del>// AArch64.SystemRegisterTrap()
// ============================
// Trapped system register access other than due to CPTR_EL2 and CPACR_EL1</del> <a id="AArch64.MemSingle.read.4" name="AArch64.MemSingle.read.4"></a><ins>AArch64.MemSingle[bits(64) address, integer size,</ins><del>AArch64.SystemRegisterTrap(bits(2) target_el, bits(2) op0, bits(3) op2, bits(3) op1, bits(4) crn,
                           bits(5) rt, bits(4) crm, bit dir)
    assert</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a> <ins>acctype, boolean wasaligned]
    assert size IN {1, 2, 4, 8, 16};
    assert address ==</ins><del>(target_el) >=</del> <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)"><ins>Align</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>(address, size);</ins><del>(PSTATE.EL);

    bits(64) preferred_exception_return =</del>

    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><ins>AddressDescriptor</ins></a><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><del>ThisInstrAddr</del></a> <ins>memaddrdesc;
    bits(size*8) value;
    iswrite = FALSE;
</ins><del>();
    vect_offset = 0x0;
</del>
<ins>    // MMU or MPU
    memaddrdesc =</ins><del>    exception =</del> <a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><ins>AArch64.TranslateAddress</ins></a><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a><ins>(address, acctype, iswrite, wasaligned, size);
    // Check for aborts or debug exceptions
    if</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><a href="shared_pseudocode.html#Exception_SystemRegisterTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_SystemRegisterTrap</del></a><ins>(memaddrdesc) then</ins><del>);
    exception.syndrome&lt;21:20> = op0;
    exception.syndrome&lt;19:17> = op2;
    exception.syndrome&lt;16:14> = op1;
    exception.syndrome&lt;13:10> = crn;
    exception.syndrome&lt;9:5>   = rt;
    exception.syndrome&lt;4:1>   = crm;
    exception.syndrome&lt;0>     = dir;

    if target_el ==</del>
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)"><ins>AArch64.Abort</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>(address, memaddrdesc.fault);

    // Memory array access
    accdesc = CreateAccessDescriptor(acctype);
    if</ins><del>&amp;&amp;</del> <a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()"><ins>HaveMTEExt</ins></a><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><ins>() then
        if</ins><del>() &amp;&amp; HCR_EL2.TGE == '1' then</del> <a href="shared_pseudocode.html#impl-aarch64.AccessIsTagChecked.2" title="function: boolean AccessIsTagChecked(bits(64) vaddr, AccType acctype)"><ins>AccessIsTagChecked</ins></a><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a>(<a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><ins>ZeroExtend</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>(address, 64), acctype) then
            bits(4) ptag =</ins><del>, exception, preferred_exception_return, vect_offset);
    else</del> <a href="shared_pseudocode.html#impl-aarch64.TransformTag.1" title="function: bits(4) TransformTag(bits(64) vaddr)"><ins>TransformTag</ins></a><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><ins>ZeroExtend</ins></a><ins>(address, 64));
            if !</ins><a href="shared_pseudocode.html#impl-aarch64.CheckTag.3" title="function: boolean CheckTag(AddressDescriptor memaddrdesc, bits(4) ptag, boolean write)"><ins>CheckTag</ins></a><ins>(memaddrdesc, ptag, iswrite) then
                </ins><a href="shared_pseudocode.html#impl-aarch64.TagCheckFail.2" title="function: TagCheckFail(bits(64) vaddress, boolean iswrite)"><ins>TagCheckFail</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><ins>ZeroExtend</ins></a><ins>(address, 64), iswrite);
    value = _Mem[memaddrdesc, size, accdesc];
    return value;

// AArch64.MemSingle[] - assignment (write) form
// =============================================
// Perform an atomic, little-endian write of 'size' bytes.

</ins><a id="AArch64.MemSingle.write.4" name="AArch64.MemSingle.write.4"></a><ins>AArch64.MemSingle[bits(64) address, integer size, </ins><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><ins> acctype, boolean wasaligned] = bits(size*8) value
    assert size IN {1, 2, 4, 8, 16};
    assert address == </ins><a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)"><ins>Align</ins></a><ins>(address, size);

    </ins><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><ins>AddressDescriptor</ins></a><ins> memaddrdesc;
    iswrite = TRUE;

    // MMU or MPU
    memaddrdesc = </ins><a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><ins>AArch64.TranslateAddress</ins></a><ins>(address, acctype, iswrite, wasaligned, size);

    // Check for aborts or debug exceptions
    if </ins><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><ins>(memaddrdesc) then
        </ins><a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)"><ins>AArch64.Abort</ins></a><ins>(address, memaddrdesc.fault);

    // Effect on exclusives
    if memaddrdesc.memattrs.shareable then
        </ins><a href="shared_pseudocode.html#impl-shared.ClearExclusiveByAddress.3" title="function: ClearExclusiveByAddress(FullAddress paddress, integer processorid, integer size)"><ins>ClearExclusiveByAddress</ins></a><ins>(memaddrdesc.paddress, </ins><a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><ins>ProcessorID</ins></a><ins>(), size);

    // Memory array access
    accdesc = CreateAccessDescriptor(acctype);
    if </ins><a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()"><ins>HaveMTEExt</ins></a><ins>() then
        if </ins><a href="shared_pseudocode.html#impl-aarch64.AccessIsTagChecked.2" title="function: boolean AccessIsTagChecked(bits(64) vaddr, AccType acctype)"><ins>AccessIsTagChecked</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><ins>ZeroExtend</ins></a><ins>(address, 64), acctype) then
            bits(4) ptag = </ins><a href="shared_pseudocode.html#impl-aarch64.TransformTag.1" title="function: bits(4) TransformTag(bits(64) vaddr)"><ins>TransformTag</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><ins>ZeroExtend</ins></a><ins>(address, 64));
            if !</ins><a href="shared_pseudocode.html#impl-aarch64.CheckTag.3" title="function: boolean CheckTag(AddressDescriptor memaddrdesc, bits(4) ptag, boolean write)"><ins>CheckTag</ins></a><ins>(memaddrdesc, ptag, iswrite) then
                </ins><a href="shared_pseudocode.html#impl-aarch64.TagCheckFail.2" title="function: TagCheckFail(bits(64) vaddress, boolean iswrite)"><ins>TagCheckFail</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><ins>ZeroExtend</ins></a><ins>(address, 64), iswrite);
    _Mem[memaddrdesc, size, accdesc] = value;
    return;</ins><del>(target_el, exception, preferred_exception_return, vect_offset);</del></p></div><div class="ps" psname="aarch64.functions.memory.AddressWithAllocationTag"><a id="aarch64.functions.memory.AddressWithAllocationTag" name="aarch64.functions.memory.AddressWithAllocationTag"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>functions</ins><del>exceptions</del>/<ins>memory</ins><del>traps</del>/<ins>AddressWithAllocationTag</ins><del>AArch64.UndefinedFault</del></h3><p class="pseudocode"><ins>// AddressWithAllocationTag()
// ==========================
// Generate a 64-bit value containing a Logical Address Tag from a 64-bit
// virtual address and an Allocation Tag.
// If the extension is disabled, treats the Allocation Tag as â0000â.

bits(64)</ins><del>// AArch64.UndefinedFault()
// ========================</del> <a id="impl-shared.AddressWithAllocationTag.2_2" name="impl-shared.AddressWithAllocationTag.2_2"></a><ins>AddressWithAllocationTag(bits(64) address, bits(4) allocation_tag)
    bits(64) result = address;
    bits(4) tag = allocation_tag - ('000':address&lt;55>);
    result&lt;59:56> = tag;
    return result;</ins><del>AArch64.UndefinedFault()

    route_to_el2 =</del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; PSTATE.EL == </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del> &amp;&amp; HCR_EL2.TGE == '1';
    bits(64) preferred_exception_return = </del><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><del>ThisInstrAddr</del></a><del>();
    vect_offset = 0x0;

    exception = </del><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a><del>(</del><a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_Uncategorized</del></a><del>);

    if </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(PSTATE.EL) > </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>) then
        </del><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a><del>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
    elsif route_to_el2 then
        </del><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>, exception, preferred_exception_return, vect_offset);
    else
        </del><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a><del>(</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>, exception, preferred_exception_return, vect_offset);</del></p></div><div class="ps" psname="aarch64.functions.memory.AllocationTagFromAddress"><a id="aarch64.functions.memory.AllocationTagFromAddress" name="aarch64.functions.memory.AllocationTagFromAddress"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>functions</ins><del>exceptions</del>/<ins>memory</ins><del>traps</del>/<ins>AllocationTagFromAddress</ins><del>AArch64.WFxTrap</del></h3><p class="pseudocode"><ins>// AllocationTagFromAddress()
// ==========================
// Generate a Tag from a 64-bit value containing a Logical Address Tag.
// If access to Allocation Tags is disabled, this function returns â0000â.

bits(4)</ins><del>// AArch64.WFxTrap()
// =================</del> <a id="impl-shared.AllocationTagFromAddress.1_2" name="impl-shared.AllocationTagFromAddress.1_2"></a><ins>AllocationTagFromAddress(bits(64) tagged_address)
    bits(4) logical_tag = tagged_address&lt;59:56>;
    bits(4) tag = logical_tag + ('000':tagged_address&lt;55>);
    return tag;</ins><del>AArch64.WFxTrap(bits(2) target_el, boolean is_wfe)
    assert</del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(target_el) > </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(PSTATE.EL);

    bits(64) preferred_exception_return = </del><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><del>ThisInstrAddr</del></a><del>();
    vect_offset = 0x0;

    exception = </del><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a><del>(</del><a href="shared_pseudocode.html#Exception_WFxTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_WFxTrap</del></a><del>);
    exception.syndrome&lt;24:20> = </del><a href="shared_pseudocode.html#impl-shared.ConditionSyndrome.0" title="function: bits(5) ConditionSyndrome()"><del>ConditionSyndrome</del></a><del>();
    exception.syndrome&lt;0> = if is_wfe then '1' else '0';

    if target_el == </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del> &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; HCR_EL2.TGE == '1' then
        </del><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>, exception, preferred_exception_return, vect_offset);
    else
        </del><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a><del>(target_el, exception, preferred_exception_return, vect_offset);</del></p></div><div class="ps" psname="aarch64.functions.memory.CheckSPAlignment"><a id="aarch64.functions.memory.CheckSPAlignment" name="aarch64.functions.memory.CheckSPAlignment"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>functions</ins><del>exceptions</del>/<ins>memory</ins><del>traps</del>/<ins>CheckSPAlignment</ins><del>CheckFPAdvSIMDEnabled64</del></h3><p class="pseudocode"><ins>// CheckSPAlignment()
// ==================
// Check correct stack pointer alignment for AArch64 state.</ins><del>// CheckFPAdvSIMDEnabled64()
// =========================
// AArch64 instruction wrapper</del>

<a id="impl-aarch64.CheckSPAlignment.0" name="impl-aarch64.CheckSPAlignment.0"></a><ins>CheckSPAlignment()
    bits(64) sp =</ins><del>CheckFPAdvSIMDEnabled64()</del> <a href="shared_pseudocode.html#impl-aarch64.SP.read.0" title="accessor: bits(width) SP[]"><ins>SP</ins></a><a href="shared_pseudocode.html#AArch64.CheckFPAdvSIMDEnabled.0" title="function: AArch64.CheckFPAdvSIMDEnabled()"><del>AArch64.CheckFPAdvSIMDEnabled</del></a><ins>[];
    if PSTATE.EL == </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins> then
        stack_align_check = (</ins><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><ins>SCTLR</ins></a><ins>[].SA0 != '0');
    else
        stack_align_check = (</ins><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><ins>SCTLR</ins></a><ins>[].SA != '0');

    if stack_align_check &amp;&amp; sp != </ins><a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)"><ins>Align</ins></a><ins>(sp, 16) then
        </ins><a href="shared_pseudocode.html#AArch64.SPAlignmentFault.0" title="function: AArch64.SPAlignmentFault()"><ins>AArch64.SPAlignmentFault</ins></a><ins>();

    return;</ins><del>();</del></p></div><div class="ps" psname="aarch64.functions.memory.CheckTag"><a id="aarch64.functions.memory.CheckTag" name="aarch64.functions.memory.CheckTag"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>memory</ins><del>aborts</del>/<ins>CheckTag</ins><del>AArch64.CreateFaultRecord</del></h3><p class="pseudocode"><ins>// CheckTag()
// ==========
// Performs a Tag Check operation for a memory access and returns
// whether the check passed
</ins><del>// AArch64.CreateFaultRecord()
// ===========================
</del>
<ins>boolean</ins><del>FaultRecord</del> <a id="impl-shared.CheckTag.3_2" name="impl-shared.CheckTag.3_2"></a><ins>CheckTag(</ins><del>AArch64.CreateFaultRecord(</del><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><ins>AddressDescriptor</ins></a><a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault</del></a> <ins>memaddrdesc, bits(4) ptag, boolean write)
    if memaddrdesc.memattrs.tagged then
        bits(64) paddress =</ins><del>type, bits(52) ipaddress, bit NS,
                                      integer level,</del> <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><ins>(memaddrdesc.paddress.address);
        return ptag ==</ins><del>acctype, boolean write, bit extflag,
                                      bits(2) errortype, boolean secondstage, boolean s2fs1walk)</del> <a href="shared_pseudocode.html#impl-aarch64.MemTag.read.1" title="accessor: bits(4) MemTag[bits(64) address]"><ins>MemTag</ins></a><a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><del>FaultRecord</del></a><ins>[paddress];
    else
        return TRUE;</ins><del>fault;
    fault.type = type;
    fault.domain = bits(4) UNKNOWN;         // Not used from AArch64
    fault.debugmoe = bits(4) UNKNOWN;       // Not used from AArch64
    fault.errortype = errortype;
    fault.ipaddress.NS = NS;
    fault.ipaddress.address = ipaddress;
    fault.level = level;
    fault.acctype = acctype;
    fault.write = write;
    fault.extflag = extflag;
    fault.secondstage = secondstage;
    fault.s2fs1walk = s2fs1walk;

    return fault;</del></p></div><div class="ps" psname="aarch64.functions.memory.IsBlockDescriptorNTBitValid"><a id="aarch64.functions.memory.IsBlockDescriptorNTBitValid" name="aarch64.functions.memory.IsBlockDescriptorNTBitValid"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>memory</ins><del>aborts</del>/<ins>IsBlockDescriptorNTBitValid</ins><del>AArch64.FaultSyndrome</del></h3><p class="pseudocode"><ins>// If the implementation supports changing the block size without a break-before-make
// approach, then for implementations that have level 1 or 2 support, the nT bit in
// the block descriptor is valid.
boolean</ins><del>// AArch64.FaultSyndrome()
// =======================
// Creates an exception syndrome value for Abort and Watchpoint exceptions taken to
// an Exception Level using AArch64.

bits(25)</del> <a id="impl-aarch64.IsBlockDescriptorNTBitValid.0" name="impl-aarch64.IsBlockDescriptorNTBitValid.0"></a><ins>IsBlockDescriptorNTBitValid();</ins><del>AArch64.FaultSyndrome(boolean d_side,</del><a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><del>FaultRecord</del></a><del> fault)
    assert fault.type != </del><a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_None</del></a><del>;

    bits(25) iss = </del><a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><del>Zeros</del></a><del>();
    if </del><a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()"><del>HaveRASExt</del></a><del>() &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.IsExternalSyncAbort.1" title="function: boolean IsExternalSyncAbort(Fault type)"><del>IsExternalSyncAbort</del></a><del>(fault) then iss&lt;12:11> = fault.errortype; // SET
    if d_side then
        if </del><a href="shared_pseudocode.html#impl-shared.IsSecondStage.1" title="function: boolean IsSecondStage(FaultRecord fault)"><del>IsSecondStage</del></a><del>(fault) &amp;&amp; !fault.s2fs1walk then iss&lt;24:14> = </del><a href="shared_pseudocode.html#impl-shared.LSInstructionSyndrome.0" title="function: bits(11) LSInstructionSyndrome()"><del>LSInstructionSyndrome</del></a><del>();
        if </del><a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()"><del>HaveNV2Ext</del></a><del>() &amp;&amp; fault.acctype == </del><a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NV2REGISTER</del></a><del> then
            iss&lt;13> = '1';   // Value of '1' indicates fault is generated by use of VNCR_EL2
        if fault.acctype IN {</del><a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_DC</del></a><del>, </del><a href="shared_pseudocode.html#AccType_DC_UNPRIV" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_DC_UNPRIV</del></a><del>, </del><a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IC</del></a><del>, </del><a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_AT</del></a><del>} then
            iss&lt;8> = '1';  iss&lt;6> = '1';
        else
            iss&lt;6> = if fault.write then '1' else '0';
    if </del><a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault type)"><del>IsExternalAbort</del></a><del>(fault) then iss&lt;9> = fault.extflag;
    iss&lt;7> = if fault.s2fs1walk then '1' else '0';
    iss&lt;5:0> = </del><a href="shared_pseudocode.html#impl-shared.EncodeLDFSC.2" title="function: bits(6) EncodeLDFSC(Fault type, integer level)"><del>EncodeLDFSC</del></a><del>(fault.type, fault.level);

    return iss;</del></p></div><div class="ps" psname="aarch64.functions.memory.Mem"><a id="aarch64.functions.memory.Mem" name="aarch64.functions.memory.Mem"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>memory</ins><del>exclusive</del>/<ins>Mem</ins><del>AArch64.ExclusiveMonitorsPass</del></h3><p class="pseudocode"><ins>// Mem[] - non-assignment (read) form
// ==================================
// Perform a read of 'size' bytes. The access byte order is reversed for a big-endian access.
// Instruction fetches would call AArch64.MemSingle directly.
</ins><del>// AArch64.ExclusiveMonitorsPass()
// ===============================
</del>
<ins>bits(size*8)</ins><del>// Return TRUE if the Exclusives monitors for the current PE include all of the addresses
// associated with the virtual address region of size bytes starting at address.
// The immediately following memory write must be to the same addresses.

boolean</del> <a id="impl-aarch64.Mem.read.3" name="impl-aarch64.Mem.read.3"></a><ins>Mem[bits(64) address, integer size,</ins><del>AArch64.ExclusiveMonitorsPass(bits(64) address, integer size)

    // It is IMPLEMENTATION DEFINED whether the detection of memory aborts happens
    // before or after the check on the local Exclusives monitor. As a result a failure
    // of the local monitor can occur on some implementations even if the memory
    // access would give an memory abort.

    acctype =</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><a href="shared_pseudocode.html#AccType_ATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ATOMIC</del></a> <ins>acctype]
    assert size IN {1, 2, 4, 8, 16};
    bits(size*8) value;
    boolean iswrite = FALSE;

    aligned =</ins><del>;
    iswrite = TRUE;
    aligned = (address ==</del> <a href="shared_pseudocode.html#AArch64.CheckAlignment.4" title="function: boolean AArch64.CheckAlignment(bits(64) address, integer alignment, AccType acctype, boolean iswrite)"><ins>AArch64.CheckAlignment</ins></a><ins>(address, size, acctype, iswrite);
    if size != 16 || !(acctype IN {</ins><a href="shared_pseudocode.html#AccType_VEC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_VEC</ins></a><ins>, </ins><a href="shared_pseudocode.html#AccType_VECSTREAM" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_VECSTREAM</ins></a><ins>}) then
        atomic = aligned;
    else
        // 128-bit SIMD&amp;FP loads are treated as a pair of 64-bit single-copy atomic accesses
        // 64-bit aligned.
        atomic = address == </ins><a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a><ins>(address, 8);
</ins><del>(address, size));
</del>
<ins>    if !atomic then
        assert size > 1;
        value&lt;7:0> =</ins><del>    if !aligned then
        secondstage = FALSE;</del> <a href="shared_pseudocode.html#AArch64.MemSingle.read.4" title="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean wasaligned]"><ins>AArch64.MemSingle</ins></a><a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)"><del>AArch64.Abort</del></a><ins>[address, 1, acctype, aligned];

        // For subsequent bytes it is CONSTRAINED UNPREDICTABLE whether an unaligned Device memory
        // access will generate an Alignment Fault, as to get this far means the first byte did
        // not, so we must be changing to a new translation page.
        if !aligned then
            c =</ins><del>(address,</del> <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><ins>ConstrainUnpredictable</ins></a><a href="shared_pseudocode.html#AArch64.AlignmentFault.3" title="function: FaultRecord AArch64.AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)"><del>AArch64.AlignmentFault</del></a><ins>(</ins><del>(acctype, iswrite, secondstage));

    passed =</del><a href="shared_pseudocode.html#Unpredictable_DEVPAGE2" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_DEVPAGE2</ins></a><a href="shared_pseudocode.html#AArch64.IsExclusiveVA.3" title="function: boolean AArch64.IsExclusiveVA(bits(64) address, integer processorid, integer size)"><del>AArch64.IsExclusiveVA</del></a><ins>);
            assert c IN {</ins><del>(address,</del><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FAULT</ins></a><a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><del>ProcessorID</del></a><ins>,</ins><del>(), size);
    if !passed then
        return FALSE;
    memaddrdesc =</del> <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_NONE</ins></a><a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><del>AArch64.TranslateAddress</del></a><ins>};
            if c ==</ins><del>(address, acctype, iswrite, aligned, size);

    // Check for aborts or debug exceptions
    if</del> <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_NONE</ins></a><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a> <ins>then aligned = TRUE;

        for i = 1 to size-1
            value&lt;8*i+7:8*i> =</ins><del>(memaddrdesc) then</del> <a href="shared_pseudocode.html#AArch64.MemSingle.read.4" title="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean wasaligned]"><ins>AArch64.MemSingle</ins></a><a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)"><del>AArch64.Abort</del></a><ins>[address+i, 1, acctype, aligned];
    elsif size == 16 &amp;&amp; acctype IN {</ins><del>(address, memaddrdesc.fault);

    passed =</del><a href="shared_pseudocode.html#AccType_VEC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_VEC</ins></a><a href="shared_pseudocode.html#impl-shared.IsExclusiveLocal.3" title="function: boolean IsExclusiveLocal(FullAddress paddress, integer processorid, integer size)"><del>IsExclusiveLocal</del></a><ins>,</ins><del>(memaddrdesc.paddress,</del> <a href="shared_pseudocode.html#AccType_VECSTREAM" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_VECSTREAM</ins></a><a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><del>ProcessorID</del></a><ins>} then
        value&lt;63:0>   =</ins><del>(), size);

    if passed then</del> <a href="shared_pseudocode.html#AArch64.MemSingle.read.4" title="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean wasaligned]"><ins>AArch64.MemSingle</ins></a><a href="shared_pseudocode.html#impl-shared.ClearExclusiveLocal.1" title="function: ClearExclusiveLocal(integer processorid)"><del>ClearExclusiveLocal</del></a><ins>[address,   8, acctype, aligned];
        value&lt;127:64> =</ins><del>(</del> <a href="shared_pseudocode.html#AArch64.MemSingle.read.4" title="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean wasaligned]"><ins>AArch64.MemSingle</ins></a><a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><del>ProcessorID</del></a><ins>[address+8, 8, acctype, aligned];
    else
        value =</ins><del>());
        if memaddrdesc.memattrs.shareable then
            passed =</del> <a href="shared_pseudocode.html#AArch64.MemSingle.read.4" title="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean wasaligned]"><ins>AArch64.MemSingle</ins></a><a href="shared_pseudocode.html#impl-shared.IsExclusiveGlobal.3" title="function: boolean IsExclusiveGlobal(FullAddress paddress, integer processorid, integer size)"><del>IsExclusiveGlobal</del></a><ins>[address, size, acctype, aligned];

    if (</ins><del>(memaddrdesc.paddress,</del><a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()"><ins>HaveNV2Ext</ins></a><a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><del>ProcessorID</del></a><ins>() &amp;&amp; acctype == </ins><a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NV2REGISTER</ins></a><ins> &amp;&amp; SCTLR_EL2.EE == '1') || </ins><a href="shared_pseudocode.html#impl-shared.BigEndian.0" title="function: boolean BigEndian()"><ins>BigEndian</ins></a><ins>() then
        value = </ins><a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)"><ins>BigEndianReverse</ins></a><ins>(value);
    return value;

// Mem[] - assignment (write) form
// ===============================
// Perform a write of 'size' bytes. The byte order is reversed for a big-endian access.

</ins><a id="impl-aarch64.Mem.write.3" name="impl-aarch64.Mem.write.3"></a><ins>Mem[bits(64) address, integer size, </ins><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><ins> acctype] = bits(size*8) value
    boolean iswrite = TRUE;

    if (</ins><a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()"><ins>HaveNV2Ext</ins></a><ins>() &amp;&amp; acctype == </ins><a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NV2REGISTER</ins></a><ins> &amp;&amp; SCTLR_EL2.EE == '1') || </ins><a href="shared_pseudocode.html#impl-shared.BigEndian.0" title="function: boolean BigEndian()"><ins>BigEndian</ins></a><ins>() then
        value = </ins><a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)"><ins>BigEndianReverse</ins></a><ins>(value);

    aligned = </ins><a href="shared_pseudocode.html#AArch64.CheckAlignment.4" title="function: boolean AArch64.CheckAlignment(bits(64) address, integer alignment, AccType acctype, boolean iswrite)"><ins>AArch64.CheckAlignment</ins></a><ins>(address, size, acctype, iswrite);
    if size != 16 || !(acctype IN {</ins><a href="shared_pseudocode.html#AccType_VEC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_VEC</ins></a><ins>, </ins><a href="shared_pseudocode.html#AccType_VECSTREAM" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_VECSTREAM</ins></a><ins>}) then
        atomic = aligned;
    else
        // 128-bit SIMD&amp;FP stores are treated as a pair of 64-bit single-copy atomic accesses
        // 64-bit aligned.
        atomic = address == </ins><a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)"><ins>Align</ins></a><ins>(address, 8);

    if !atomic then
        assert size > 1;
        </ins><a href="shared_pseudocode.html#AArch64.MemSingle.write.4" title="accessor: AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean wasaligned] = bits(size*8) value"><ins>AArch64.MemSingle</ins></a><ins>[address, 1, acctype, aligned] = value&lt;7:0>;

        // For subsequent bytes it is CONSTRAINED UNPREDICTABLE whether an unaligned Device memory
        // access will generate an Alignment Fault, as to get this far means the first byte did
        // not, so we must be changing to a new translation page.
        if !aligned then
            c = </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><ins>ConstrainUnpredictable</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_DEVPAGE2" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_DEVPAGE2</ins></a><ins>);
            assert c IN {</ins><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FAULT</ins></a><ins>, </ins><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_NONE</ins></a><ins>};
            if c == </ins><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_NONE</ins></a><ins> then aligned = TRUE;

        for i = 1 to size-1
            </ins><a href="shared_pseudocode.html#AArch64.MemSingle.write.4" title="accessor: AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean wasaligned] = bits(size*8) value"><ins>AArch64.MemSingle</ins></a><ins>[address+i, 1, acctype, aligned] = value&lt;8*i+7:8*i>;
    elsif size == 16 &amp;&amp; acctype IN {</ins><a href="shared_pseudocode.html#AccType_VEC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_VEC</ins></a><ins>, </ins><a href="shared_pseudocode.html#AccType_VECSTREAM" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_VECSTREAM</ins></a><ins>} then
        </ins><a href="shared_pseudocode.html#AArch64.MemSingle.write.4" title="accessor: AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean wasaligned] = bits(size*8) value"><ins>AArch64.MemSingle</ins></a><ins>[address,   8, acctype, aligned] = value&lt;63:0>;
        </ins><a href="shared_pseudocode.html#AArch64.MemSingle.write.4" title="accessor: AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean wasaligned] = bits(size*8) value"><ins>AArch64.MemSingle</ins></a><ins>[address+8, 8, acctype, aligned] = value&lt;127:64>;
    else
        </ins><a href="shared_pseudocode.html#AArch64.MemSingle.write.4" title="accessor: AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean wasaligned] = bits(size*8) value"><ins>AArch64.MemSingle</ins></a><ins>[address, size, acctype, aligned] = value;
    return;</ins><del>(), size);

    return passed;</del></p></div><div class="ps" psname="aarch64.functions.memory.MemTag"><a id="aarch64.functions.memory.MemTag" name="aarch64.functions.memory.MemTag"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>memory</ins><del>exclusive</del>/<ins>MemTag</ins><del>AArch64.IsExclusiveVA</del></h3><p class="pseudocode"><ins>// MemTag[] - non-assignment (read) form
// =====================================
// Load an Allocation Tag from memory.

bits(4)</ins><del>// An optional IMPLEMENTATION DEFINED test for an exclusive access to a virtual
// address region of size bytes starting at address.
//
// It is permitted (but not required) for this function to return FALSE and
// cause a store exclusive to fail if the virtual address region is not
// totally included within the region recorded by MarkExclusiveVA().
//
// It is always safe to return TRUE which will check the physical address only.
boolean</del> <a id="impl-shared.MemTag.read.1_2" name="impl-shared.MemTag.read.1_2"></a><ins>MemTag[bits(64) address]</ins><del>AArch64.IsExclusiveVA(bits(64) address, integer processorid, integer size);</del>
    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><ins>AddressDescriptor</ins></a><ins> memaddrdesc;
    bits(4) value;
    iswrite = FALSE;

    memaddrdesc = </ins><a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><ins>AArch64.TranslateAddress</ins></a><ins>(address, </ins><a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NORMAL</ins></a><ins>, iswrite, TRUE, TAG_GRANULE);
    // Check for aborts or debug exceptions
    if </ins><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><ins>(memaddrdesc) then
        </ins><a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)"><ins>AArch64.Abort</ins></a><ins>(address, memaddrdesc.fault);

    // Return the granule tag if tagging is enabled...
    if </ins><a href="shared_pseudocode.html#impl-shared.AllocationTagAccessIsEnabled.0" title="function: boolean AllocationTagAccessIsEnabled()"><ins>AllocationTagAccessIsEnabled</ins></a><ins>() &amp;&amp; memaddrdesc.memattrs.tagged then
        return _MemTag[memaddrdesc];
    else
        // ...otherwise read tag as zero.
        return '0000';

// MemTag[] - assignment (write) form
// ==================================
// Store an Allocation Tag to memory.

</ins><a id="impl-shared.MemTag.write.1_2" name="impl-shared.MemTag.write.1_2"></a><ins>MemTag[bits(64) address] = bits(4) value
    </ins><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><ins>AddressDescriptor</ins></a><ins> memaddrdesc;
    iswrite = TRUE;

    // Stores of allocation tags must be aligned
    if address != </ins><a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)"><ins>Align</ins></a><ins>(address, TAG_GRANULE) then
        boolean secondstage = FALSE;
        </ins><a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)"><ins>AArch64.Abort</ins></a><ins>(address, </ins><a href="shared_pseudocode.html#AArch64.AlignmentFault.3" title="function: FaultRecord AArch64.AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)"><ins>AArch64.AlignmentFault</ins></a><ins>(</ins><a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NORMAL</ins></a><ins>, iswrite, secondstage));

    wasaligned = TRUE;
    memaddrdesc = </ins><a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><ins>AArch64.TranslateAddress</ins></a><ins>(address, </ins><a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NORMAL</ins></a><ins>, iswrite, wasaligned, TAG_GRANULE);

    // Check for aborts or debug exceptions
    if </ins><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><ins>(memaddrdesc) then
        </ins><a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)"><ins>AArch64.Abort</ins></a><ins>(address, memaddrdesc.fault);

    // Memory array access
    if </ins><a href="shared_pseudocode.html#impl-shared.AllocationTagAccessIsEnabled.0" title="function: boolean AllocationTagAccessIsEnabled()"><ins>AllocationTagAccessIsEnabled</ins></a><ins>() &amp;&amp; memaddrdesc.memattrs.tagged then
        _MemTag[memaddrdesc] = value;</ins></p></div><div class="ps" psname="aarch64.functions.memory.TransformTag"><a id="aarch64.functions.memory.TransformTag" name="aarch64.functions.memory.TransformTag"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>memory</ins><del>exclusive</del>/<ins>TransformTag</ins><del>AArch64.MarkExclusiveVA</del></h3><p class="pseudocode"><ins>// TransformTag()
// ==============
// Apply tag transformation rules.

bits(4)</ins><del>// Optionally record an exclusive access to the virtual address region of size bytes
// starting at address for processorid.</del> <a id="impl-shared.TransformTag.1_2" name="impl-shared.TransformTag.1_2"></a><ins>TransformTag(bits(64) vaddr)
    bits(4) vtag = vaddr&lt;59:56>;
    bits(4) tagdelta =</ins><del>AArch64.MarkExclusiveVA(bits(64) address, integer processorid, integer size);</del> <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(vaddr&lt;55>);
    bits(4) ptag = vtag + tagdelta;
    return ptag;</ins></p></div><div class="ps" psname="aarch64.functions.memory.boolean"><a id="aarch64.functions.memory.boolean" name="aarch64.functions.memory.boolean"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>memory</ins><del>exclusive</del>/<ins>boolean</ins><del>AArch64.SetExclusiveMonitors</del></h3><p class="pseudocode"><ins>// boolean AccessIsTagChecked()
// ============================
// TRUE if a given access is tag-checked, FALSE otherwise.
</ins><del>// AArch64.SetExclusiveMonitors()
// ==============================
</del>
<ins>boolean</ins><del>// Sets the Exclusives monitors for the current PE to record the addresses associated
// with the virtual address region of size bytes starting at address.</del> <a id="impl-shared.AccessIsTagChecked.2_2" name="impl-shared.AccessIsTagChecked.2_2"></a><ins>AccessIsTagChecked(bits(64) vaddr,</ins><del>AArch64.SetExclusiveMonitors(bits(64) address, integer size)

    acctype =</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><a href="shared_pseudocode.html#AccType_ATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ATOMIC</del></a> <ins>acctype)
    if PSTATE.M&lt;4> == '1' then return FALSE;

    if</ins><del>;
    iswrite = FALSE;
    aligned = (address ==</del> <a href="shared_pseudocode.html#impl-shared.EffectiveTBI.3" title="function: bit EffectiveTBI(bits(64) address, boolean IsInstr, bits(2) el)"><ins>EffectiveTBI</ins></a><a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)"><del>Align</del></a><ins>(vaddr, FALSE, PSTATE.EL) == '0' then
        return FALSE;

    if</ins><del>(address, size));
    memaddrdesc =</del> <a href="shared_pseudocode.html#impl-shared.EffectiveTCMA.2" title="function: bit EffectiveTCMA(bits(64) address, bits(2) el)"><ins>EffectiveTCMA</ins></a><a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><del>AArch64.TranslateAddress</del></a><ins>(vaddr, PSTATE.EL) == '1' &amp;&amp; (vaddr&lt;59:55> == '00000' || vaddr&lt;59:55> == '11111') then
        return FALSE;
</ins><del>(address, acctype, iswrite, aligned, size);
</del>
<ins>    if !</ins><del>    // Check for aborts or debug exceptions
    if</del><a href="shared_pseudocode.html#impl-shared.AllocationTagAccessIsEnabled.0" title="function: boolean AllocationTagAccessIsEnabled()"><ins>AllocationTagAccessIsEnabled</ins></a><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><ins>() then
        return FALSE;
</ins><del>(memaddrdesc) then
        return;
</del>
<ins>    if acctype IN {</ins><del>    if memaddrdesc.memattrs.shareable then</del><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><a href="shared_pseudocode.html#impl-shared.MarkExclusiveGlobal.3" title="function: MarkExclusiveGlobal(FullAddress paddress, integer processorid, integer size)"><del>MarkExclusiveGlobal</del></a><ins>,</ins><del>(memaddrdesc.paddress,</del> <a href="shared_pseudocode.html#AccType_PTW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_PTW</ins></a><a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><del>ProcessorID</del></a><ins>} then
        return FALSE;

    if acctype ==</ins><del>(), size);</del> <del>(memaddrdesc.paddress, </del><a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><del>ProcessorID</del></a><del>(), size);

    </del><a href="shared_pseudocode.html#AArch64.MarkExclusiveVA.3" title="function: AArch64.MarkExclusiveVA(bits(64) address, integer processorid, integer size)"><del>AArch64.MarkExclusiveVA</del></a><del>(address, </del><a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><del>ProcessorID</del></a><a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NV2REGISTER</ins></a><a href="shared_pseudocode.html#impl-shared.MarkExclusiveLocal.3" title="function: MarkExclusiveLocal(FullAddress paddress, integer processorid, integer size)"><del>MarkExclusiveLocal</del></a> <ins>then
        return FALSE;

    if PSTATE.TCO=='1' then
        return FALSE;

    if IsNonTagCheckedInstruction() then
        return FALSE;

    return TRUE;</ins><del>(), size);</del></p></div><div class="ps" psname="aarch64.functions.pac.addpac.AddPAC"><a id="aarch64.functions.pac.addpac.AddPAC" name="aarch64.functions.pac.addpac.AddPAC"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>pac</ins><del>fusedrstep</del>/<ins>addpac/AddPAC</ins><del>FPRSqrtStepFused</del></h3><p class="pseudocode"><ins>// AddPAC()
// ========
// Calculates the pointer authentication code for a 64-bit quantity and then
// inserts that into pointer authentication code field of that 64-bit quantity.
</ins><del>// FPRSqrtStepFused()
// ==================
</del>
<ins>bits(64)</ins><del>bits(N)</del> <a id="impl-aarch64.AddPAC.4" name="impl-aarch64.AddPAC.4"></a><ins>AddPAC(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data)
    bits(64) PAC;
    bits(64) result;
    bits(64) ext_ptr;
    bits(64) extfield;
    bit selbit;
    boolean tbi =</ins><del>FPRSqrtStepFused(bits(N) op1, bits(N) op2)
    assert N IN {16, 32, 64};
    bits(N) result;
    op1 =</del> <a href="shared_pseudocode.html#impl-aarch64.CalculateTBI.2" title="function: boolean CalculateTBI(bits(64) ptr, boolean data)"><ins>CalculateTBI</ins></a><a href="shared_pseudocode.html#impl-shared.FPNeg.1" title="function: bits(N) FPNeg(bits(N) op)"><del>FPNeg</del></a><ins>(ptr, data);
    integer top_bit = if tbi then 55 else 63;

    // If tagged pointers are in use for a regime with two TTBRs, use bit&lt;55> of
    // the pointer to select between upper and lower ranges, and preserve this.
    // This handles the awkward case where there is apparently no correct choice between
    // the upper and lower address range - ie an addr of 1xxxxxxx0... with TBI0=0 and TBI1=1
    // and 0xxxxxxx1 with TBI1=0 and TBI0=1:
    if</ins><del>(op1);
    (type1,sign1,value1) =</del> <a href="shared_pseudocode.html#impl-aarch64.PtrHasUpperAndLowerAddRanges.0" title="function: boolean PtrHasUpperAndLowerAddRanges()"><ins>PtrHasUpperAndLowerAddRanges</ins></a><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a><ins>() then
        assert</ins><del>(op1, FPCR);
    (type2,sign2,value2) =</del> <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a><ins>() IN {</ins><del>(op2, FPCR);
    (done,result) =</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2, FPCRType fpcr)"><del>FPProcessNaNs</del></a><ins>,</ins><del>(type1, type2, op1, op2, FPCR);
    if !done then
        inf1 = (type1 ==</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a><ins>};
        if</ins><del>);
        inf2 = (type2 ==</del> <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a><ins>() ==</ins><del>);
        zero1 = (type1 ==</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a> <ins>then
            // EL1 translation regime registers
            if data then
                selbit = if TCR_EL1.TBI1 == '1' || TCR_EL1.TBI0 == '1' then ptr&lt;55> else ptr&lt;63>;
            else
                if ((TCR_EL1.TBI1 == '1' &amp;&amp; TCR_EL1.TBID1 == '0') ||
                    (TCR_EL1.TBI0 == '1' &amp;&amp; TCR_EL1.TBID0 == '0')) then
                    selbit = ptr&lt;55>;
                else
                    selbit = ptr&lt;63>;
        else
            // EL2 translation regime registers
            if data then
                selbit = if ((</ins><del>);
        zero2 = (type2 ==</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a><ins>(</ins><del>);
        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            result =</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-shared.FPOnePointFive.1" title="function: bits(N) FPOnePointFive(bit sign)"><del>FPOnePointFive</del></a><ins>) &amp;&amp; TCR_EL2.TBI1 == '1') ||
                             (</ins><del>('0');
        elsif inf1 || inf2 then
            result =</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><del>FPInfinity</del></a><ins>(</ins><del>(sign1 EOR sign2);
        else
            // Fully fused multiply-add and halve
            result_value = (3.0 + (value1 * value2)) / 2.0;
            if result_value == 0.0 then
                // Sign of exact zero result depends on rounding mode
                sign = if</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)"><del>FPRoundingMode</del></a><ins>) &amp;&amp; TCR_EL2.TBI0 == '1')) then ptr&lt;55> else ptr&lt;63>;
            else
                selbit = if ((</ins><del>(FPCR) ==</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_NEGINF</del></a><ins>(</ins><del>then '1' else '0';
                result =</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><del>FPZero</del></a><ins>) &amp;&amp; TCR_EL2.TBI1 == '1' &amp;&amp; TCR_EL1.TBID1 == '0') ||
                             (</ins><del>(sign);
            else
                result =</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-shared.FPRound.2" title="function: bits(N) FPRound(real op, FPCRType fpcr)"><del>FPRound</del></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) &amp;&amp; TCR_EL2.TBI0 == '1' &amp;&amp; TCR_EL1.TBID0 == '0')) then ptr&lt;55> else ptr&lt;63>;
    else selbit = if tbi then ptr&lt;55> else ptr&lt;63>;

    integer bottom_PAC_bit = </ins><a href="shared_pseudocode.html#impl-aarch64.CalculateBottomPACBit.1" title="function: integer CalculateBottomPACBit(bit top_bit)"><ins>CalculateBottomPACBit</ins></a><ins>(selbit);

    // The pointer authentication code field takes all the available bits in between
    extfield = </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(selbit, 64);

    // Compute the pointer authentication code for a ptr with good extension bits
    if tbi then
        ext_ptr = ptr&lt;63:56>:extfield&lt;(56-bottom_PAC_bit)-1:0>:ptr&lt;bottom_PAC_bit-1:0>;
    else
        ext_ptr = extfield&lt;(64-bottom_PAC_bit)-1:0>:ptr&lt;bottom_PAC_bit-1:0>;

    PAC = </ins><a href="shared_pseudocode.html#impl-aarch64.ComputePAC.4" title="function: bits(64) ComputePAC(bits(64) data, bits(64) modifier, bits(64) key0, bits(64) key1)"><ins>ComputePAC</ins></a><ins>(ext_ptr, modifier, K&lt;127:64>, K&lt;63:0>);

    // Check if the ptr has good extension bits and corrupt the pointer authentication code if not
    if !</ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(ptr&lt;top_bit:bottom_PAC_bit>) &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)"><ins>IsOnes</ins></a><ins>(ptr&lt;top_bit:bottom_PAC_bit>) then
        if </ins><a href="shared_pseudocode.html#impl-aarch64.HaveEnhancedPAC.0" title="function: boolean HaveEnhancedPAC()"><ins>HaveEnhancedPAC</ins></a><ins>() then
            PAC = </ins><a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><ins>Zeros</ins></a><ins>();
        else
            PAC&lt;top_bit-1> = NOT(PAC&lt;top_bit-1>);

    // Preserve the determination between upper and lower address at bit&lt;55> and insert PAC
    if tbi then
        result = ptr&lt;63:56>:selbit:PAC&lt;54:bottom_PAC_bit>:ptr&lt;bottom_PAC_bit-1:0>;
    else
        result = PAC&lt;63:56>:selbit:PAC&lt;54:bottom_PAC_bit>:ptr&lt;bottom_PAC_bit-1:0>;
</ins><del>(result_value, FPCR);
</del>    return result;</p></div><div class="ps" psname="aarch64.functions.pac.addpacda.AddPACDA"><a id="aarch64.functions.pac.addpacda.AddPACDA" name="aarch64.functions.pac.addpacda.AddPACDA"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>pac</ins><del>fusedrstep</del>/<ins>addpacda/AddPACDA</ins><del>FPRecipStepFused</del></h3><p class="pseudocode"><ins>// AddPACDA()
// ==========
// Returns a 64-bit value containing X, but replacing the pointer authentication code
// field bits with a pointer authentication code, where the pointer authentication
// code is derived using a cryptographic algorithm as a combination of X, Y and the
// APDAKey_EL1.
</ins><del>// FPRecipStepFused()
// ==================
</del>
<ins>bits(64)</ins><del>bits(N)</del> <a id="impl-aarch64.AddPACDA.2" name="impl-aarch64.AddPACDA.2"></a><ins>AddPACDA(bits(64) X, bits(64) Y)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APDAKey_EL1;

    APDAKey_EL1 = APDAKeyHi_EL1&lt;63:0> : APDAKeyLo_EL1&lt;63:0>;

    case PSTATE.EL of
        when</ins><del>FPRecipStepFused(bits(N) op1, bits(N) op2)
    assert N IN {16, 32, 64};
    bits(N) result;
    op1 =</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#impl-shared.FPNeg.1" title="function: bits(N) FPNeg(bits(N) op)"><del>FPNeg</del></a>
            <ins>boolean IsEL1Regime =</ins><del>(op1);
    (type1,sign1,value1) =</del> <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a><ins>() ==</ins><del>(op1, FPCR);
    (type2,sign2,value2) =</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a><ins>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnDA else SCTLR_EL2.EnDA;
            TrapEL2 = (</ins><del>(op2, FPCR);
    (done,result) =</del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2, FPCRType fpcr)"><del>FPProcessNaNs</del></a><ins>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                        (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 =</ins><del>(type1, type2, op1, op2, FPCR);
    if !done then
        inf1 = (type1 ==</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a><ins>(</ins><del>);
        inf2 = (type2 ==</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a><ins>) &amp;&amp; SCR_EL3.API == '0';
        when</ins><del>);
        zero1 = (type1 ==</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a>
            <ins>Enable = SCTLR_EL1.EnDA;
            TrapEL2 =</ins><del>);
        zero2 = (type2 ==</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a><ins>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 =</ins><del>);
        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            result =</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-shared.FPTwo.1" title="function: bits(N) FPTwo(bit sign)"><del>FPTwo</del></a><ins>(</ins><del>('0');
        elsif inf1 || inf2 then
            result =</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><del>FPInfinity</del></a><ins>) &amp;&amp; SCR_EL3.API == '0';
        when</ins><del>(sign1 EOR sign2);
        else
            // Fully fused multiply-add
            result_value = 2.0 + (value1 * value2);
            if result_value == 0.0 then
                // Sign of exact zero result depends on rounding mode
                sign = if</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)"><del>FPRoundingMode</del></a>
            <ins>Enable = SCTLR_EL2.EnDA;
            TrapEL2 = FALSE;
            TrapEL3 =</ins><del>(FPCR) ==</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_NEGINF</del></a><ins>(</ins><del>then '1' else '0';
                result =</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><del>FPZero</del></a><ins>) &amp;&amp; SCR_EL3.API == '0';
        when</ins><del>(sign);
            else
                result =</del> <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-shared.FPRound.2" title="function: bits(N) FPRound(real op, FPCRType fpcr)"><del>FPRound</del></a><ins>
            Enable = SCTLR_EL3.EnDA;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then return X;
    elsif TrapEL2 then </ins><a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><ins>TrapPACUse</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>);
    elsif TrapEL3 then </ins><a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><ins>TrapPACUse</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>);
    else return </ins><a href="shared_pseudocode.html#impl-aarch64.AddPAC.4" title="function: bits(64) AddPAC(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data)"><ins>AddPAC</ins></a><ins>(X, Y, APDAKey_EL1, TRUE);</ins><del>(result_value, FPCR);
    return result;</del></p></div><div class="ps" psname="aarch64.functions.pac.addpacdb.AddPACDB"><a id="aarch64.functions.pac.addpacdb.AddPACDB" name="aarch64.functions.pac.addpacdb.AddPACDB"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>pac</ins><del>memory</del>/<ins>addpacdb/AddPACDB</ins><del>AArch64.CheckAlignment</del></h3><p class="pseudocode"><ins>// AddPACDB()
// ==========
// Returns a 64-bit value containing X, but replacing the pointer authentication code
// field bits with a pointer authentication code, where the pointer authentication
// code is derived using a cryptographic algorithm as a combination of X, Y and the
// APDBKey_EL1.
</ins><del>// AArch64.CheckAlignment()
// ========================
</del>
<ins>bits(64)</ins><del>boolean</del> <a id="impl-aarch64.AddPACDB.2" name="impl-aarch64.AddPACDB.2"></a><ins>AddPACDB(bits(64) X, bits(64) Y)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APDBKey_EL1;

    APDBKey_EL1 = APDBKeyHi_EL1&lt;63:0> : APDBKeyLo_EL1&lt;63:0>;

    case PSTATE.EL of
        when</ins><del>AArch64.CheckAlignment(bits(64) address, integer alignment,</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a>
            <ins>boolean IsEL1Regime =</ins><del>acctype,
                               boolean iswrite)

    aligned = (address ==</del> <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)"><del>Align</del></a><ins>() ==</ins><del>(address, alignment));
    atomic  = acctype IN {</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#AccType_ATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ATOMIC</del></a><ins>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnDB else SCTLR_EL2.EnDB;
            TrapEL2 = (</ins><del>,</del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#AccType_ATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ATOMICRW</del></a><ins>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                       (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 =</ins><del>,</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#AccType_ORDEREDATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ORDEREDATOMIC</del></a><ins>(</ins><del>,</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#AccType_ORDEREDATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ORDEREDATOMICRW</del></a><ins>) &amp;&amp; SCR_EL3.API == '0';
        when</ins><del>};
    ordered = acctype IN {</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#AccType_ORDERED" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ORDERED</del></a>
            <ins>Enable = SCTLR_EL1.EnDB;
            TrapEL2 =</ins><del>,</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#AccType_ORDEREDRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ORDEREDRW</del></a><ins>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 =</ins><del>,</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#AccType_LIMITEDORDERED" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_LIMITEDORDERED</del></a><ins>(</ins><del>,</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#AccType_ORDEREDATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ORDEREDATOMIC</del></a><ins>) &amp;&amp; SCR_EL3.API == '0';
        when</ins><del>,</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#AccType_ORDEREDATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ORDEREDATOMICRW</del></a>
            <ins>Enable = SCTLR_EL2.EnDB;
            TrapEL2 = FALSE;
            TrapEL3 =</ins><del>};
    vector  = acctype ==</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#AccType_VEC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_VEC</del></a><ins>(</ins><del>;
    if</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><del>SCTLR</del></a><ins>) &amp;&amp; SCR_EL3.API == '0';
        when</ins><del>[].A == '1' then check = TRUE;
    elsif</del> <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-shared.HaveUA16Ext.0" title="function: boolean HaveUA16Ext()"><del>HaveUA16Ext</del></a>
            <ins>Enable = SCTLR_EL3.EnDB;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then return X;
    elsif TrapEL2 then</ins><del>() then
        check = (</del> <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><ins>TrapPACUse</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>(</ins><del>(address&lt;0+:4>) + alignment > 16) &amp;&amp; ((ordered &amp;&amp;</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><del>SCTLR</del></a><ins>);
    elsif TrapEL3 then</ins><del>[].nAA == '0') || atomic);
    else check = atomic || ordered;

    if check &amp;&amp; !aligned then
        secondstage = FALSE;</del> <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><ins>TrapPACUse</ins></a><a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)"><del>AArch64.Abort</del></a><ins>(</ins><del>(address,</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#AArch64.AlignmentFault.3" title="function: FaultRecord AArch64.AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)"><del>AArch64.AlignmentFault</del></a><ins>);
    else return </ins><a href="shared_pseudocode.html#impl-aarch64.AddPAC.4" title="function: bits(64) AddPAC(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data)"><ins>AddPAC</ins></a><ins>(X, Y, APDBKey_EL1, TRUE);</ins><del>(acctype, iswrite, secondstage));

    return aligned;</del></p></div><div class="ps" psname="aarch64.functions.pac.addpacga.AddPACGA"><a id="aarch64.functions.pac.addpacga.AddPACGA" name="aarch64.functions.pac.addpacga.AddPACGA"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>pac</ins><del>memory</del>/<ins>addpacga/AddPACGA</ins><del>AArch64.MemSingle</del></h3><p class="pseudocode"><ins>// AddPACGA()
// ==========
// Returns a 64-bit value where the lower 32 bits are 0, and the upper 32 bits contain
// a 32-bit pointer authentication code which is derived using a cryptographic
// algorithm as a combination of X, Y and the APGAKey_EL1.
</ins><del>// AArch64.MemSingle[] - non-assignment (read) form
// ================================================
// Perform an atomic, little-endian read of 'size' bytes.
</del>
<ins>bits(64)</ins><del>bits(size*8)</del> <a id="impl-aarch64.AddPACGA.2" name="impl-aarch64.AddPACGA.2"></a><ins>AddPACGA(bits(64) X, bits(64) Y)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(128) APGAKey_EL1;

    APGAKey_EL1 = APGAKeyHi_EL1&lt;63:0> : APGAKeyLo_EL1&lt;63:0>;

    case PSTATE.EL of
        when</ins><del>AArch64.MemSingle[bits(64) address, integer size,</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a>
            <ins>TrapEL2 = (</ins><del>acctype, boolean wasaligned]
    assert size IN {1, 2, 4, 8, 16};
    assert address ==</del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)"><del>Align</del></a><ins>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                        (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 =</ins><del>(address, size);</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><del>AddressDescriptor</del></a><ins>(</ins><del>memaddrdesc;
    bits(size*8) value;
    iswrite = FALSE;

    // MMU or MPU
    memaddrdesc =</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><del>AArch64.TranslateAddress</del></a><ins>) &amp;&amp; SCR_EL3.API == '0';
        when</ins><del>(address, acctype, iswrite, wasaligned, size);
    // Check for aborts or debug exceptions
    if</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a>
            <ins>TrapEL2 =</ins><del>(memaddrdesc) then</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)"><del>AArch64.Abort</del></a><ins>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 =</ins><del>(address, memaddrdesc.fault);

    // Memory array access
    accdesc = CreateAccessDescriptor(acctype);
    if</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()"><del>HaveMTEExt</del></a><ins>(</ins><del>() then
        if</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-aarch64.AccessIsTagChecked.2" title="function: boolean AccessIsTagChecked(bits(64) vaddr, AccType acctype)"><del>AccessIsTagChecked</del></a><ins>) &amp;&amp; SCR_EL3.API == '0';
        when</ins><del>(</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><del>ZeroExtend</del></a>
            <ins>TrapEL2 = FALSE;
            TrapEL3 =</ins><del>(address, 64), acctype) then
            bits(4) ptag =</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-aarch64.TransformTag.1" title="function: bits(4) TransformTag(bits(64) vaddr)"><del>TransformTag</del></a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><del>ZeroExtend</del></a><ins>) &amp;&amp; SCR_EL3.API == '0';
        when</ins><del>(address, 64));
            if !</del> <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-aarch64.CheckTag.3" title="function: boolean CheckTag(AddressDescriptor memaddrdesc, bits(4) ptag, boolean write)"><del>CheckTag</del></a>
            <ins>TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if TrapEL2 then</ins><del>(memaddrdesc, ptag, iswrite) then</del> <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><ins>TrapPACUse</ins></a><a href="shared_pseudocode.html#impl-aarch64.TagCheckFail.2" title="function: TagCheckFail(bits(64) vaddress, boolean iswrite)"><del>TagCheckFail</del></a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><del>ZeroExtend</del></a><ins>);
    elsif TrapEL3 then</ins><del>(address, 64), iswrite);
    value = _Mem[memaddrdesc, size, accdesc];
    return value;

// AArch64.MemSingle[] - assignment (write) form
// =============================================
// Perform an atomic, little-endian write of 'size' bytes.</del> <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><ins>TrapPACUse</ins></a><ins>(</ins><del>AArch64.MemSingle[bits(64) address, integer size,</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><ins>);
    else return</ins><del>acctype, boolean wasaligned] = bits(size*8) value
    assert size IN {1, 2, 4, 8, 16};
    assert address ==</del> <a href="shared_pseudocode.html#impl-aarch64.ComputePAC.4" title="function: bits(64) ComputePAC(bits(64) data, bits(64) modifier, bits(64) key0, bits(64) key1)"><ins>ComputePAC</ins></a><a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)"><del>Align</del></a><ins>(X, Y, APGAKey_EL1&lt;127:64>, APGAKey_EL1&lt;63:0>)&lt;63:32>:</ins><del>(address, size);</del><del> memaddrdesc;
    iswrite = TRUE;

    // MMU or MPU
    memaddrdesc = </del><a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><del>AArch64.TranslateAddress</del></a><del>(address, acctype, iswrite, wasaligned, size);

    // Check for aborts or debug exceptions
    if </del><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><del>(memaddrdesc) then
        </del><a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)"><del>AArch64.Abort</del></a><del>(address, memaddrdesc.fault);

    // Effect on exclusives
    if memaddrdesc.memattrs.shareable then
        </del><a href="shared_pseudocode.html#impl-shared.ClearExclusiveByAddress.3" title="function: ClearExclusiveByAddress(FullAddress paddress, integer processorid, integer size)"><del>ClearExclusiveByAddress</del></a><del>(memaddrdesc.paddress, </del><a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><del>ProcessorID</del></a><del>(), size);

    // Memory array access
    accdesc = CreateAccessDescriptor(acctype);
    if </del><a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()"><del>HaveMTEExt</del></a><del>() then
        if </del><a href="shared_pseudocode.html#impl-aarch64.AccessIsTagChecked.2" title="function: boolean AccessIsTagChecked(bits(64) vaddr, AccType acctype)"><del>AccessIsTagChecked</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><del>ZeroExtend</del></a><del>(address, 64), acctype) then
            bits(4) ptag = </del><a href="shared_pseudocode.html#impl-aarch64.TransformTag.1" title="function: bits(4) TransformTag(bits(64) vaddr)"><del>TransformTag</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><del>ZeroExtend</del></a><del>(address, 64));
            if !</del><a href="shared_pseudocode.html#impl-aarch64.CheckTag.3" title="function: boolean CheckTag(AddressDescriptor memaddrdesc, bits(4) ptag, boolean write)"><del>CheckTag</del></a><del>(memaddrdesc, ptag, iswrite) then
                </del><a href="shared_pseudocode.html#impl-aarch64.TagCheckFail.2" title="function: TagCheckFail(bits(64) vaddress, boolean iswrite)"><del>TagCheckFail</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><del>ZeroExtend</del></a><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><del>AddressDescriptor</del></a><ins>(32);</ins><del>(address, 64), iswrite);
    _Mem[memaddrdesc, size, accdesc] = value;
    return;</del></p></div><div class="ps" psname="aarch64.functions.pac.addpacia.AddPACIA"><a id="aarch64.functions.pac.addpacia.AddPACIA" name="aarch64.functions.pac.addpacia.AddPACIA"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>pac</ins><del>memory</del>/<ins>addpacia/AddPACIA</ins><del>AddressWithAllocationTag</del></h3><p class="pseudocode"><ins>// AddPACIA()
// ==========
// Returns a 64-bit value containing X, but replacing the pointer authentication code
// field bits with a pointer authentication code, where the pointer authentication
// code is derived using a cryptographic algorithm as a combination of X, Y, and the
// APIAKey_EL1.
</ins><del>// AddressWithAllocationTag()
// ==========================
// Generate a 64-bit value containing a Logical Address Tag from a 64-bit
// virtual address and an Allocation Tag.
// If the extension is disabled, treats the Allocation Tag as â0000â.
</del>
bits(64) <a id="impl-aarch64.AddPACIA.2" name="impl-aarch64.AddPACIA.2"></a><ins>AddPACIA(bits(64) X, bits(64) Y)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APIAKey_EL1;

    APIAKey_EL1 = APIAKeyHi_EL1&lt;63:0>:APIAKeyLo_EL1&lt;63:0>;

    case PSTATE.EL of
        when</ins><del>AddressWithAllocationTag(bits(64) address, bits(4) allocation_tag)
    bits(64) result = address;
    bits(4) tag = allocation_tag - ('000':address&lt;55>);
    result&lt;59:56> = tag;
    return result;</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>
            boolean IsEL1Regime = </ins><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><ins>() == </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnIA else SCTLR_EL2.EnIA;
            TrapEL2 = (</ins><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                       (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; SCR_EL3.API == '0';
        when </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>
            Enable = SCTLR_EL1.EnIA;
            TrapEL2 = </ins><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; SCR_EL3.API == '0';
        when </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>
            Enable = SCTLR_EL2.EnIA;
            TrapEL2 = FALSE;
            TrapEL3 = </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; SCR_EL3.API == '0';
        when </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>
            Enable = SCTLR_EL3.EnIA;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then return X;
    elsif TrapEL2 then </ins><a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><ins>TrapPACUse</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>);
    elsif TrapEL3 then </ins><a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><ins>TrapPACUse</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>);
    else return </ins><a href="shared_pseudocode.html#impl-aarch64.AddPAC.4" title="function: bits(64) AddPAC(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data)"><ins>AddPAC</ins></a><ins>(X, Y, APIAKey_EL1, FALSE);</ins></p></div><div class="ps" psname="aarch64.functions.pac.addpacib.AddPACIB"><a id="aarch64.functions.pac.addpacib.AddPACIB" name="aarch64.functions.pac.addpacib.AddPACIB"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>pac</ins><del>memory</del>/<ins>addpacib/AddPACIB</ins><del>AllocationTagFromAddress</del></h3><p class="pseudocode"><ins>// AddPACIB()
// ==========
// Returns a 64-bit value containing X, but replacing the pointer authentication code
// field bits with a pointer authentication code, where the pointer authentication
// code is derived using a cryptographic algorithm as a combination of X, Y and the
// APIBKey_EL1.
</ins><del>// AllocationTagFromAddress()
// ==========================
// Generate a Tag from a 64-bit value containing a Logical Address Tag.
// If access to Allocation Tags is disabled, this function returns â0000â.
</del>
<ins>bits(64)</ins><del>bits(4)</del> <a id="impl-aarch64.AddPACIB.2" name="impl-aarch64.AddPACIB.2"></a><ins>AddPACIB(bits(64) X, bits(64) Y)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APIBKey_EL1;

    APIBKey_EL1 = APIBKeyHi_EL1&lt;63:0> : APIBKeyLo_EL1&lt;63:0>;

    case PSTATE.EL of
        when</ins><del>AllocationTagFromAddress(bits(64) tagged_address)
    bits(4) logical_tag = tagged_address&lt;59:56>;
    bits(4) tag = logical_tag + ('000':tagged_address&lt;55>);
    return tag;</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>
            boolean IsEL1Regime = </ins><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><ins>() == </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnIB else SCTLR_EL2.EnIB;
            TrapEL2 = (</ins><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                       (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; SCR_EL3.API == '0';
        when </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>
            Enable = SCTLR_EL1.EnIB;
            TrapEL2 = </ins><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; SCR_EL3.API == '0';
        when </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>
            Enable = SCTLR_EL2.EnIB;
            TrapEL2 = FALSE;
            TrapEL3 = </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; SCR_EL3.API == '0';
        when </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>
            Enable = SCTLR_EL3.EnIB;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then return X;
    elsif TrapEL2 then </ins><a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><ins>TrapPACUse</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>);
    elsif TrapEL3 then </ins><a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><ins>TrapPACUse</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>);
    else return </ins><a href="shared_pseudocode.html#impl-aarch64.AddPAC.4" title="function: bits(64) AddPAC(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data)"><ins>AddPAC</ins></a><ins>(X, Y, APIBKey_EL1, FALSE);</ins></p></div><div class="ps" psname="aarch64.functions.pac.auth.Auth"><a id="aarch64.functions.pac.auth.Auth" name="aarch64.functions.pac.auth.Auth"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>pac</ins><del>memory</del>/<ins>auth/Auth</ins><del>CheckSPAlignment</del></h3><p class="pseudocode"><ins>// Auth()
// ======
// Restores the upper bits of the address to be all zeros or all ones (based on the
// value of bit[55]) and computes and checks the pointer authentication code. If the
// check passes, then the restored address is returned. If the check fails, the
// second-top and third-top bits of the extension bits in the pointer authentication code
// field are corrupted to ensure that accessing the address will give a translation fault.

bits(64)</ins><del>// CheckSPAlignment()
// ==================
// Check correct stack pointer alignment for AArch64 state.</del> <a id="impl-aarch64.Auth.5" name="impl-aarch64.Auth.5"></a><ins>Auth(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data, bit keynumber)
    bits(64) PAC;
    bits(64) result;
    bits(64) original_ptr;
    bits(2) error_code;
    bits(64) extfield;

    // Reconstruct the extension field used of adding the PAC to the pointer
    boolean tbi =</ins><del>CheckSPAlignment()
    bits(64) sp =</del> <a href="shared_pseudocode.html#impl-aarch64.CalculateTBI.2" title="function: boolean CalculateTBI(bits(64) ptr, boolean data)"><ins>CalculateTBI</ins></a><a href="shared_pseudocode.html#impl-aarch64.SP.read.0" title="accessor: bits(width) SP[]"><del>SP</del></a><ins>(ptr, data);
    integer bottom_PAC_bit =</ins><del>[];
    if PSTATE.EL ==</del> <a href="shared_pseudocode.html#impl-aarch64.CalculateBottomPACBit.1" title="function: integer CalculateBottomPACBit(bit top_bit)"><ins>CalculateBottomPACBit</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>(ptr&lt;55>);
    extfield =</ins><del>then
        stack_align_check = (</del> <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><del>SCTLR</del></a><ins>(ptr&lt;55>, 64);

    if tbi then
        original_ptr = ptr&lt;63:56>:extfield&lt;56-bottom_PAC_bit-1:0>:ptr&lt;bottom_PAC_bit-1:0>;
</ins><del>[].SA0 != '0');
</del>    else
<ins>        original_ptr = extfield&lt;64-bottom_PAC_bit-1:0>:ptr&lt;bottom_PAC_bit-1:0>;

    PAC =</ins><del>        stack_align_check = (</del> <del>[].SA != '0');

    if stack_align_check &amp;&amp; sp != </del><a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)"><del>Align</del></a><del>(sp, 16) then
        </del><a href="shared_pseudocode.html#AArch64.SPAlignmentFault.0" title="function: AArch64.SPAlignmentFault()"><del>AArch64.SPAlignmentFault</del></a><a href="shared_pseudocode.html#impl-aarch64.ComputePAC.4" title="function: bits(64) ComputePAC(bits(64) data, bits(64) modifier, bits(64) key0, bits(64) key1)"><ins>ComputePAC</ins></a><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><del>SCTLR</del></a><ins>(original_ptr, modifier, K&lt;127:64>, K&lt;63:0>);
    // Check pointer authentication code
    if tbi then
        if PAC&lt;54:bottom_PAC_bit> == ptr&lt;54:bottom_PAC_bit> then
            result = original_ptr;
        else
            error_code = keynumber:NOT(keynumber);
            result = original_ptr&lt;63:55>:error_code:original_ptr&lt;52:0>;
    else
        if ((PAC&lt;54:bottom_PAC_bit> == ptr&lt;54:bottom_PAC_bit>) &amp;&amp;
            (PAC&lt;63:56> == ptr&lt;63:56>)) then
            result = original_ptr;
        else
            error_code = keynumber:NOT(keynumber);
            result = original_ptr&lt;63>:error_code:original_ptr&lt;60:0>;
    return result;</ins><del>();

    return;</del></p></div><div class="ps" psname="aarch64.functions.pac.authda.AuthDA"><a id="aarch64.functions.pac.authda.AuthDA" name="aarch64.functions.pac.authda.AuthDA"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>pac</ins><del>memory</del>/<ins>authda/AuthDA</ins><del>CheckTag</del></h3><p class="pseudocode"><ins>// AuthDA()
// ========
// Returns a 64-bit value containing X, but replacing the pointer authentication code
// field bits with the extension of the address bits. The instruction checks a pointer
// authentication code in the pointer authentication code field bits of X, using the same
// algorithm and key as AddPACDA().
</ins><del>// CheckTag()
// ==========
// Performs a Tag Check operation for a memory access and returns
// whether the check passed
</del>
<ins>bits(64)</ins><del>boolean</del> <a id="impl-aarch64.AuthDA.2" name="impl-aarch64.AuthDA.2"></a><ins>AuthDA(bits(64) X, bits(64) Y)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APDAKey_EL1;

    APDAKey_EL1 = APDAKeyHi_EL1&lt;63:0> : APDAKeyLo_EL1&lt;63:0>;

    case PSTATE.EL of
        when</ins><del>CheckTag(</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><del>AddressDescriptor</del></a>
            <ins>boolean IsEL1Regime =</ins><del>memaddrdesc, bits(4) ptag, boolean write)
    if memaddrdesc.memattrs.tagged then
        bits(64) paddress =</del> <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><ins>() ==</ins><del>(memaddrdesc.paddress.address);
        return ptag ==</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#impl-aarch64.MemTag.read.1" title="accessor: bits(4) MemTag[bits(64) address]"><del>MemTag</del></a><ins>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnDA else SCTLR_EL2.EnDA;
            TrapEL2 = (</ins><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                       (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; SCR_EL3.API == '0';
        when </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>
            Enable = SCTLR_EL1.EnDA;
            TrapEL2 = </ins><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; SCR_EL3.API == '0';
        when </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>
            Enable = SCTLR_EL2.EnDA;
            TrapEL2 = FALSE;
            TrapEL3 = </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; SCR_EL3.API == '0';
        when </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>
            Enable = SCTLR_EL3.EnDA;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then return X;
    elsif TrapEL2 then </ins><a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><ins>TrapPACUse</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>);
    elsif TrapEL3 then </ins><a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><ins>TrapPACUse</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>);
    else  return </ins><a href="shared_pseudocode.html#impl-aarch64.Auth.5" title="function: bits(64) Auth(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data, bit keynumber)"><ins>Auth</ins></a><ins>(X, Y, APDAKey_EL1, TRUE, '0');</ins><del>[paddress];
    else
        return TRUE;</del></p></div><div class="ps" psname="aarch64.functions.pac.authdb.AuthDB"><a id="aarch64.functions.pac.authdb.AuthDB" name="aarch64.functions.pac.authdb.AuthDB"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>pac</ins><del>memory</del>/<ins>authdb/AuthDB</ins><del>IsBlockDescriptorNTBitValid</del></h3><p class="pseudocode"><ins>// AuthDB()
// ========
// Returns a 64-bit value containing X, but replacing the pointer authentication code
// field bits with the extension of the address bits. The instruction checks a
// pointer authentication code in the pointer authentication code field bits of X, using
// the same algorithm and key as AddPACDB().

bits(64)</ins><del>// If the implementation supports changing the block size without a break-before-make
// approach, then for implementations that have level 1 or 2 support, the nT bit in
// the block descriptor is valid.
boolean</del> <a id="impl-aarch64.AuthDB.2" name="impl-aarch64.AuthDB.2"></a><ins>AuthDB(bits(64) X, bits(64) Y)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APDBKey_EL1;

    APDBKey_EL1 = APDBKeyHi_EL1&lt;63:0> : APDBKeyLo_EL1&lt;63:0>;

    case PSTATE.EL of
        when</ins><del>IsBlockDescriptorNTBitValid();</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>
            boolean IsEL1Regime = </ins><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><ins>() == </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnDB else SCTLR_EL2.EnDB;
            TrapEL2 = (</ins><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                        (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; SCR_EL3.API == '0';
        when </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>
            Enable = SCTLR_EL1.EnDB;
            TrapEL2 = </ins><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; SCR_EL3.API == '0';
        when </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>
            Enable = SCTLR_EL2.EnDB;
            TrapEL2 = FALSE;
            TrapEL3 = </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; SCR_EL3.API == '0';
        when </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>
            Enable = SCTLR_EL3.EnDB;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then return X;
    elsif TrapEL2 then </ins><a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><ins>TrapPACUse</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>);
    elsif TrapEL3 then </ins><a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><ins>TrapPACUse</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>);
    else  return </ins><a href="shared_pseudocode.html#impl-aarch64.Auth.5" title="function: bits(64) Auth(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data, bit keynumber)"><ins>Auth</ins></a><ins>(X, Y, APDBKey_EL1, TRUE, '1');</ins></p></div><div class="ps" psname="aarch64.functions.pac.authia.AuthIA"><a id="aarch64.functions.pac.authia.AuthIA" name="aarch64.functions.pac.authia.AuthIA"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>pac</ins><del>memory</del>/<ins>authia/AuthIA</ins><del>Mem</del></h3><p class="pseudocode"><ins>// AuthIA()
// ========
// Returns a 64-bit value containing X, but replacing the pointer authentication code
// field bits with the extension of the address bits. The instruction checks a pointer
// authentication code in the pointer authentication code field bits of X, using the same
// algorithm and key as AddPACIA().
</ins><del>// Mem[] - non-assignment (read) form
// ==================================
// Perform a read of 'size' bytes. The access byte order is reversed for a big-endian access.
// Instruction fetches would call AArch64.MemSingle directly.
</del>
<ins>bits(64)</ins><del>bits(size*8)</del> <a id="impl-aarch64.AuthIA.2" name="impl-aarch64.AuthIA.2"></a><ins>AuthIA(bits(64) X, bits(64) Y)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APIAKey_EL1;

    APIAKey_EL1 = APIAKeyHi_EL1&lt;63:0> : APIAKeyLo_EL1&lt;63:0>;

    case PSTATE.EL of
        when</ins><del>Mem[bits(64) address, integer size,</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a>
            <ins>boolean IsEL1Regime =</ins><del>acctype]
    assert size IN {1, 2, 4, 8, 16};
    bits(size*8) value;
    boolean iswrite = FALSE;

    aligned =</del> <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><a href="shared_pseudocode.html#AArch64.CheckAlignment.4" title="function: boolean AArch64.CheckAlignment(bits(64) address, integer alignment, AccType acctype, boolean iswrite)"><del>AArch64.CheckAlignment</del></a><ins>() ==</ins><del>(address, size, acctype, iswrite);
    if size != 16 || !(acctype IN {</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#AccType_VEC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_VEC</del></a><ins>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnIA else SCTLR_EL2.EnIA;
            TrapEL2 = (</ins><del>,</del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#AccType_VECSTREAM" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_VECSTREAM</del></a><ins>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                       (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 =</ins><del>}) then
        atomic = aligned;
    else
        // 128-bit SIMD&amp;FP loads are treated as a pair of 64-bit single-copy atomic accesses
        // 64-bit aligned.
        atomic = address ==</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)"><del>Align</del></a><ins>(</ins><del>(address, 8);

    if !atomic then
        assert size > 1;
        value&lt;7:0> =</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#AArch64.MemSingle.read.4" title="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean wasaligned]"><del>AArch64.MemSingle</del></a><ins>) &amp;&amp; SCR_EL3.API == '0';
        when</ins><del>[address, 1, acctype, aligned];

        // For subsequent bytes it is CONSTRAINED UNPREDICTABLE whether an unaligned Device memory
        // access will generate an Alignment Fault, as to get this far means the first byte did
        // not, so we must be changing to a new translation page.
        if !aligned then
            c =</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><del>ConstrainUnpredictable</del></a>
            <ins>Enable = SCTLR_EL1.EnIA;
            TrapEL2 =</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#Unpredictable_DEVPAGE2" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_DEVPAGE2</del></a><ins>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 =</ins><del>);
            assert c IN {</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FAULT</del></a><ins>(</ins><del>,</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_NONE</del></a><ins>) &amp;&amp; SCR_EL3.API == '0';
        when</ins><del>};
            if c ==</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_NONE</del></a>
            <ins>Enable = SCTLR_EL2.EnIA;
            TrapEL2 = FALSE;
            TrapEL3 =</ins><del>then aligned = TRUE;

        for i = 1 to size-1
            value&lt;8*i+7:8*i> =</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#AArch64.MemSingle.read.4" title="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean wasaligned]"><del>AArch64.MemSingle</del></a><ins>(</ins><del>[address+i, 1, acctype, aligned];
    elsif size == 16 &amp;&amp; acctype IN {</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#AccType_VEC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_VEC</del></a><ins>) &amp;&amp; SCR_EL3.API == '0';
        when</ins><del>,</del> <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#AccType_VECSTREAM" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_VECSTREAM</del></a>
            <ins>Enable = SCTLR_EL3.EnIA;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then return X;
    elsif TrapEL2 then</ins><del>} then
        value&lt;63:0>   =</del> <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><ins>TrapPACUse</ins></a><a href="shared_pseudocode.html#AArch64.MemSingle.read.4" title="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean wasaligned]"><del>AArch64.MemSingle</del></a><ins>(</ins><del>[address,   8, acctype, aligned];
        value&lt;127:64> =</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#AArch64.MemSingle.read.4" title="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean wasaligned]"><del>AArch64.MemSingle</del></a><ins>);
    elsif TrapEL3 then</ins><del>[address+8, 8, acctype, aligned];
    else
        value =</del> <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><ins>TrapPACUse</ins></a><a href="shared_pseudocode.html#AArch64.MemSingle.read.4" title="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean wasaligned]"><del>AArch64.MemSingle</del></a><ins>(</ins><del>[address, size, acctype, aligned];

    if (</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()"><del>HaveNV2Ext</del></a><ins>);
    else  return</ins><del>() &amp;&amp; acctype ==</del> <del> &amp;&amp; SCTLR_EL2.EE == '1') || </del><a href="shared_pseudocode.html#impl-shared.BigEndian.0" title="function: boolean BigEndian()"><del>BigEndian</del></a><del>() then
        value = </del><a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)"><del>BigEndianReverse</del></a><del>(value);
    return value;

// Mem[] - assignment (write) form
// ===============================
// Perform a write of 'size' bytes. The byte order is reversed for a big-endian access.

</del><a id="impl-aarch64.Mem.write.3" name="impl-aarch64.Mem.write.3"></a><del>Mem[bits(64) address, integer size, </del><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><del> acctype] = bits(size*8) value
    boolean iswrite = TRUE;

    if (</del><a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()"><del>HaveNV2Ext</del></a><del>() &amp;&amp; acctype == </del><a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NV2REGISTER</del></a><del> &amp;&amp; SCTLR_EL2.EE == '1') || </del><a href="shared_pseudocode.html#impl-shared.BigEndian.0" title="function: boolean BigEndian()"><del>BigEndian</del></a><del>() then
        value = </del><a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)"><del>BigEndianReverse</del></a><del>(value);

    aligned = </del><a href="shared_pseudocode.html#AArch64.CheckAlignment.4" title="function: boolean AArch64.CheckAlignment(bits(64) address, integer alignment, AccType acctype, boolean iswrite)"><del>AArch64.CheckAlignment</del></a><del>(address, size, acctype, iswrite);
    if size != 16 || !(acctype IN {</del><a href="shared_pseudocode.html#AccType_VEC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_VEC</del></a><del>, </del><a href="shared_pseudocode.html#AccType_VECSTREAM" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_VECSTREAM</del></a><del>}) then
        atomic = aligned;
    else
        // 128-bit SIMD&amp;FP stores are treated as a pair of 64-bit single-copy atomic accesses
        // 64-bit aligned.
        atomic = address == </del><a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)"><del>Align</del></a><del>(address, 8);

    if !atomic then
        assert size > 1;
        </del><a href="shared_pseudocode.html#AArch64.MemSingle.write.4" title="accessor: AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean wasaligned] = bits(size*8) value"><del>AArch64.MemSingle</del></a><del>[address, 1, acctype, aligned] = value&lt;7:0>;

        // For subsequent bytes it is CONSTRAINED UNPREDICTABLE whether an unaligned Device memory
        // access will generate an Alignment Fault, as to get this far means the first byte did
        // not, so we must be changing to a new translation page.
        if !aligned then
            c = </del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><del>ConstrainUnpredictable</del></a><del>(</del><a href="shared_pseudocode.html#Unpredictable_DEVPAGE2" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_DEVPAGE2</del></a><del>);
            assert c IN {</del><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FAULT</del></a><del>, </del><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_NONE</del></a><del>};
            if c == </del><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_NONE</del></a><del> then aligned = TRUE;

        for i = 1 to size-1
            </del><a href="shared_pseudocode.html#AArch64.MemSingle.write.4" title="accessor: AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean wasaligned] = bits(size*8) value"><del>AArch64.MemSingle</del></a><del>[address+i, 1, acctype, aligned] = value&lt;8*i+7:8*i>;
    elsif size == 16 &amp;&amp; acctype IN {</del><a href="shared_pseudocode.html#AccType_VEC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_VEC</del></a><del>, </del><a href="shared_pseudocode.html#AccType_VECSTREAM" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_VECSTREAM</del></a><del>} then
        </del><a href="shared_pseudocode.html#AArch64.MemSingle.write.4" title="accessor: AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean wasaligned] = bits(size*8) value"><del>AArch64.MemSingle</del></a><del>[address,   8, acctype, aligned] = value&lt;63:0>;
        </del><a href="shared_pseudocode.html#AArch64.MemSingle.write.4" title="accessor: AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean wasaligned] = bits(size*8) value"><del>AArch64.MemSingle</del></a><del>[address+8, 8, acctype, aligned] = value&lt;127:64>;
    else
        </del><a href="shared_pseudocode.html#AArch64.MemSingle.write.4" title="accessor: AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean wasaligned] = bits(size*8) value"><del>AArch64.MemSingle</del></a><a href="shared_pseudocode.html#impl-aarch64.Auth.5" title="function: bits(64) Auth(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data, bit keynumber)"><ins>Auth</ins></a><a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NV2REGISTER</del></a><ins>(X, Y, APIAKey_EL1, FALSE, '0');</ins><del>[address, size, acctype, aligned] = value;
    return;</del></p></div><div class="ps" psname="aarch64.functions.pac.authib.AuthIB"><a id="aarch64.functions.pac.authib.AuthIB" name="aarch64.functions.pac.authib.AuthIB"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>pac</ins><del>memory</del>/<ins>authib/AuthIB</ins><del>MemTag</del></h3><p class="pseudocode"><ins>// AuthIB()
// ========
// Returns a 64-bit value containing X, but replacing the pointer authentication code
// field bits with the extension of the address bits. The instruction checks a pointer
// authentication code in the pointer authentication code field bits of X, using the same
// algorithm and key as AddPACIB().
</ins><del>// MemTag[] - non-assignment (read) form
// =====================================
// Load an Allocation Tag from memory.
</del>
<ins>bits(64)</ins><del>bits(4)</del> <a id="impl-aarch64.AuthIB.2" name="impl-aarch64.AuthIB.2"></a><ins>AuthIB(bits(64) X, bits(64) Y)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APIBKey_EL1;

    APIBKey_EL1 = APIBKeyHi_EL1&lt;63:0> : APIBKeyLo_EL1&lt;63:0>;

    case PSTATE.EL of
        when</ins><del>MemTag[bits(64) address]</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><del>AddressDescriptor</del></a>
            <ins>boolean IsEL1Regime =</ins><del>memaddrdesc;
    bits(4) value;
    iswrite = FALSE;

    memaddrdesc =</del> <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><del>AArch64.TranslateAddress</del></a><ins>() ==</ins><del>(address,</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NORMAL</del></a><ins>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnIB else SCTLR_EL2.EnIB;
            TrapEL2 = (</ins><del>, iswrite, TRUE, TAG_GRANULE);
    // Check for aborts or debug exceptions
    if</del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><ins>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                       (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 =</ins><del>(memaddrdesc) then</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)"><del>AArch64.Abort</del></a><ins>(</ins><del>(address, memaddrdesc.fault);

    // Return the granule tag if tagging is enabled...
    if</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-shared.AllocationTagAccessIsEnabled.0" title="function: boolean AllocationTagAccessIsEnabled()"><del>AllocationTagAccessIsEnabled</del></a><ins>) &amp;&amp; SCR_EL3.API == '0';
        when</ins><del>() then
        return _MemTag[memaddrdesc];
    else
        // ...otherwise read tag as zero.
        return '0000';

// MemTag[] - assignment (write) form
// ==================================
// Store an Allocation Tag to memory.</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a>
            <ins>Enable = SCTLR_EL1.EnIB;
            TrapEL2 =</ins><del>MemTag[bits(64) address] = bits(4) value</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><del>AddressDescriptor</del></a><ins>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 =</ins><del>memaddrdesc;
    iswrite = TRUE;

    // Stores of allocation tags must be aligned
    if address !=</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)"><del>Align</del></a><ins>(</ins><del>(address, TAG_GRANULE) then
        boolean secondstage = FALSE;</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)"><del>AArch64.Abort</del></a><ins>) &amp;&amp; SCR_EL3.API == '0';
        when</ins><del>(address,</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#AArch64.AlignmentFault.3" title="function: FaultRecord AArch64.AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)"><del>AArch64.AlignmentFault</del></a>
            <ins>Enable = SCTLR_EL2.EnIB;
            TrapEL2 = FALSE;
            TrapEL3 =</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NORMAL</del></a><ins>(</ins><del>, iswrite, secondstage));

    wasaligned = TRUE;
    memaddrdesc =</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><del>AArch64.TranslateAddress</del></a><ins>) &amp;&amp; SCR_EL3.API == '0';
        when</ins><del>(address,</del> <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NORMAL</del></a>
            <ins>Enable = SCTLR_EL3.EnIB;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;
</ins><del>, iswrite, wasaligned, TAG_GRANULE);
</del>
<ins>    if Enable == '0' then return X;
    elsif TrapEL2 then</ins><del>    // Check for aborts or debug exceptions
    if</del> <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><ins>TrapPACUse</ins></a><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><ins>(</ins><del>(memaddrdesc) then</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)"><del>AArch64.Abort</del></a><ins>);
    elsif TrapEL3 then</ins><del>(address, memaddrdesc.fault);

    // Memory array access
    if</del> <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><ins>TrapPACUse</ins></a><a href="shared_pseudocode.html#impl-shared.AllocationTagAccessIsEnabled.0" title="function: boolean AllocationTagAccessIsEnabled()"><del>AllocationTagAccessIsEnabled</del></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>);
    else  return </ins><a href="shared_pseudocode.html#impl-aarch64.Auth.5" title="function: bits(64) Auth(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data, bit keynumber)"><ins>Auth</ins></a><ins>(X, Y, APIBKey_EL1, FALSE, '1');</ins><del>() then
        _MemTag[memaddrdesc] = value;</del></p></div><div class="ps" psname="aarch64.functions.pac.calcbottompacbit.CalculateBottomPACBit"><a id="aarch64.functions.pac.calcbottompacbit.CalculateBottomPACBit" name="aarch64.functions.pac.calcbottompacbit.CalculateBottomPACBit"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>pac</ins><del>memory</del>/<ins>calcbottompacbit/CalculateBottomPACBit</ins><del>TransformTag</del></h3><p class="pseudocode"><ins>// CalculateBottomPACBit()
// =======================
</ins><del>// TransformTag()
// ==============
// Apply tag transformation rules.
</del>
<ins>integer</ins><del>bits(4)</del> <a id="impl-aarch64.CalculateBottomPACBit.1" name="impl-aarch64.CalculateBottomPACBit.1"></a><ins>CalculateBottomPACBit(bit top_bit)
    integer tsz_field;

    if</ins><del>TransformTag(bits(64) vaddr)
    bits(4) vtag = vaddr&lt;59:56>;
    bits(4) tagdelta =</del> <a href="shared_pseudocode.html#impl-aarch64.PtrHasUpperAndLowerAddRanges.0" title="function: boolean PtrHasUpperAndLowerAddRanges()"><ins>PtrHasUpperAndLowerAddRanges</ins></a><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><ins>() then
        assert </ins><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><ins>() IN {</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>, </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>};
        if </ins><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><ins>() == </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins> then
            // EL1 translation regime registers
            tsz_field = if top_bit == '1' then </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(TCR_EL1.T1SZ) else </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(TCR_EL1.T0SZ);
            using64k = if top_bit == '1' then TCR_EL1.TG1 == '11' else TCR_EL1.TG0 == '01';
        else
            // EL2 translation regime registers
            assert </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>);
            tsz_field = if top_bit == '1' then </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(TCR_EL2.T1SZ) else </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(TCR_EL2.T0SZ);
            using64k = if top_bit == '1' then TCR_EL2.TG1 == '11' else TCR_EL2.TG0 == '01';
    else
        tsz_field = if PSTATE.EL == </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins> then </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(TCR_EL2.T0SZ) else </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(TCR_EL3.T0SZ);
        using64k = if PSTATE.EL == </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins> then TCR_EL2.TG0 == '01' else TCR_EL3.TG0 == '01';

    max_limit_tsz_field = (if !</ins><a href="shared_pseudocode.html#impl-shared.HaveSmallPageTblExt.0" title="function: boolean HaveSmallPageTblExt()"><ins>HaveSmallPageTblExt</ins></a><ins>() then 39 else if using64k then 47 else 48);
    if tsz_field > max_limit_tsz_field then
        // TCR_ELx.TySZ is out of range
        c = </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><ins>ConstrainUnpredictable</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_RESTnSZ" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESTnSZ</ins></a><ins>);
        assert c IN {</ins><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FORCE</ins></a><ins>, </ins><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_NONE</ins></a><ins>};
        if c == </ins><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FORCE</ins></a><ins> then tsz_field = max_limit_tsz_field;
    tszmin = if using64k &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.VAMax.0" title="function: integer VAMax()"><ins>VAMax</ins></a><ins>() == 52 then 12 else 16;
    if tsz_field &lt; tszmin then
        c = </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><ins>ConstrainUnpredictable</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_RESTnSZ" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESTnSZ</ins></a><ins>);
        assert c IN {</ins><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FORCE</ins></a><ins>, </ins><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_NONE</ins></a><ins>};
        if c == </ins><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FORCE</ins></a> <ins>then tsz_field = tszmin;
    return (64-tsz_field);</ins><del>(vaddr&lt;55>);
    bits(4) ptag = vtag + tagdelta;
    return ptag;</del></p></div><div class="ps" psname="aarch64.functions.pac.calculatetbi.CalculateTBI"><a id="aarch64.functions.pac.calculatetbi.CalculateTBI" name="aarch64.functions.pac.calculatetbi.CalculateTBI"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>pac</ins><del>memory</del>/<ins>calculatetbi/CalculateTBI</ins><del>boolean</del></h3><p class="pseudocode"><ins>// CalculateTBI()
// ==============
</ins><del>// boolean AccessIsTagChecked()
// ============================
// TRUE if a given access is tag-checked, FALSE otherwise.
</del>
boolean <a id="impl-aarch64.CalculateTBI.2" name="impl-aarch64.CalculateTBI.2"></a><ins>CalculateTBI(bits(64) ptr, boolean data)
    boolean tbi = FALSE;

    if</ins><del>AccessIsTagChecked(bits(64) vaddr,</del> <a href="shared_pseudocode.html#impl-aarch64.PtrHasUpperAndLowerAddRanges.0" title="function: boolean PtrHasUpperAndLowerAddRanges()"><ins>PtrHasUpperAndLowerAddRanges</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><ins>() then
        assert</ins><del>acctype)
    if PSTATE.M&lt;4> == '1' then return FALSE;

    if</del> <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><a href="shared_pseudocode.html#impl-shared.EffectiveTBI.3" title="function: bit EffectiveTBI(bits(64) address, boolean IsInstr, bits(2) el)"><del>EffectiveTBI</del></a><ins>() IN {</ins><del>(vaddr, FALSE, PSTATE.EL) == '0' then
        return FALSE;

    if</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#impl-shared.EffectiveTCMA.2" title="function: bit EffectiveTCMA(bits(64) address, bits(2) el)"><del>EffectiveTCMA</del></a><ins>,</ins><del>(vaddr, PSTATE.EL) == '1' &amp;&amp; (vaddr&lt;59:55> == '00000' || vaddr&lt;59:55> == '11111') then
        return FALSE;

    if !</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-shared.AllocationTagAccessIsEnabled.0" title="function: boolean AllocationTagAccessIsEnabled()"><del>AllocationTagAccessIsEnabled</del></a><ins>};
        if</ins><del>() then
        return FALSE;

    if acctype IN {</del> <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IFETCH</del></a><ins>() ==</ins><del>,</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#AccType_PTW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_PTW</del></a> <ins>then
            // EL1 translation regime registers
            if data then
                tbi = if ptr&lt;55> == '1' then TCR_EL1.TBI1 == '1' else TCR_EL1.TBI0 == '1';
            else
                if ptr&lt;55> == '1' then
                    tbi = TCR_EL1.TBI1 == '1' &amp;&amp; TCR_EL1.TBID1 == '0';
                else
                    tbi = TCR_EL1.TBI0 == '1' &amp;&amp; TCR_EL1.TBID0 == '0';
        else
            // EL2 translation regime registers
            if data then
                tbi = if ptr&lt;55> == '1' then TCR_EL2.TBI1 == '1' else TCR_EL2.TBI0 == '1';
            else
                if ptr&lt;55> == '1' then
                    tbi = TCR_EL2.TBI1 == '1' &amp;&amp; TCR_EL2.TBID1 == '0';
                else
                    tbi = TCR_EL2.TBI0 == '1' &amp;&amp; TCR_EL2.TBID0 == '0';
    elsif PSTATE.EL ==</ins><del>} then
        return FALSE;

    if acctype ==</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NV2REGISTER</del></a><ins> then
        tbi = if data then TCR_EL2.TBI=='1' else TCR_EL2.TBI=='1' &amp;&amp; TCR_EL2.TBID=='0';
    elsif PSTATE.EL == </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a> then
<ins>        tbi = if data then TCR_EL3.TBI=='1' else TCR_EL3.TBI=='1' &amp;&amp; TCR_EL3.TBID=='0';
</ins><del>        return FALSE;
</del>
<ins>    return tbi;</ins><del>    if PSTATE.TCO=='1' then
        return FALSE;

    if IsNonTagCheckedInstruction() then
        return FALSE;

    return TRUE;</del></p></div><div class="ps" psname="aarch64.functions.pac.computepac.ComputePAC"><a id="aarch64.functions.pac.computepac.ComputePAC" name="aarch64.functions.pac.computepac.ComputePAC"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/<ins>computepac</ins><del>addpac</del>/<ins>ComputePAC</ins><del>AddPAC</del></h3><p class="pseudocode"><ins>array bits(64) RC[0..4];
</ins><del>// AddPAC()
// ========
// Calculates the pointer authentication code for a 64-bit quantity and then
// inserts that into pointer authentication code field of that 64-bit quantity.
</del>
bits(64) <a id="impl-aarch64.ComputePAC.4" name="impl-aarch64.ComputePAC.4"></a><ins>ComputePAC(bits(64) data, bits(64) modifier, bits(64) key0, bits(64) key1)
    bits(64)  workingval;
    bits(64)  runningmod;
    bits(64)  roundkey;
    bits(64)  modk0;
    constant bits(64) Alpha = 0xC0AC29B7C97C50DD&lt;63:0>;

    RC[0] = 0x0000000000000000&lt;63:0>;
    RC[1] = 0x13198A2E03707344&lt;63:0>;
    RC[2] = 0xA4093822299F31D0&lt;63:0>;
    RC[3] = 0x082EFA98EC4E6C89&lt;63:0>;
    RC[4] = 0x452821E638D01377&lt;63:0>;

    modk0 = key0&lt;0>:key0&lt;63:2>:(key0&lt;63> EOR key0&lt;1>);
    runningmod = modifier;
    workingval = data EOR key0;
    for i = 0 to 4
        roundkey = key1 EOR runningmod;
        workingval  = workingval EOR roundkey;
        workingval = workingval EOR RC[i];
        if i > 0 then
            workingval =</ins><del>AddPAC(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data)
    bits(64) PAC;
    bits(64) result;
    bits(64) ext_ptr;
    bits(64) extfield;
    bit selbit;
    boolean tbi =</del> <a href="shared_pseudocode.html#impl-aarch64.PACCellShuffle.1" title="function: bits(64) PACCellShuffle(bits(64) indata)"><ins>PACCellShuffle</ins></a><a href="shared_pseudocode.html#impl-aarch64.CalculateTBI.2" title="function: boolean CalculateTBI(bits(64) ptr, boolean data)"><del>CalculateTBI</del></a><ins>(workingval);
            workingval =</ins><del>(ptr, data);
    integer top_bit = if tbi then 55 else 63;

    // If tagged pointers are in use for a regime with two TTBRs, use bit&lt;55> of
    // the pointer to select between upper and lower ranges, and preserve this.
    // This handles the awkward case where there is apparently no correct choice between
    // the upper and lower address range - ie an addr of 1xxxxxxx0... with TBI0=0 and TBI1=1
    // and 0xxxxxxx1 with TBI1=0 and TBI0=1:
    if</del> <a href="shared_pseudocode.html#impl-aarch64.PACMult.1" title="function: bits(64) PACMult(bits(64) Sinput)"><ins>PACMult</ins></a><a href="shared_pseudocode.html#impl-aarch64.PtrHasUpperAndLowerAddRanges.0" title="function: boolean PtrHasUpperAndLowerAddRanges()"><del>PtrHasUpperAndLowerAddRanges</del></a><ins>(workingval);
        workingval =</ins><del>() then
        assert</del> <a href="shared_pseudocode.html#impl-aarch64.PACSub.1" title="function: bits(64) PACSub(bits(64) Tinput)"><ins>PACSub</ins></a><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><ins>(workingval);
        runningmod =</ins><del>() IN {</del> <a href="shared_pseudocode.html#impl-aarch64.TweakShuffle.1" title="function: bits(64) TweakShuffle(bits(64) indata)"><ins>TweakShuffle</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>(runningmod&lt;63:0>);
    roundkey = modk0 EOR runningmod;
    workingval = workingval EOR roundkey;
    workingval =</ins><del>,</del> <a href="shared_pseudocode.html#impl-aarch64.PACCellShuffle.1" title="function: bits(64) PACCellShuffle(bits(64) indata)"><ins>PACCellShuffle</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>(workingval);
    workingval =</ins><del>};
        if</del> <a href="shared_pseudocode.html#impl-aarch64.PACMult.1" title="function: bits(64) PACMult(bits(64) Sinput)"><ins>PACMult</ins></a><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><ins>(workingval);
    workingval =</ins><del>() ==</del> <a href="shared_pseudocode.html#impl-aarch64.PACSub.1" title="function: bits(64) PACSub(bits(64) Tinput)"><ins>PACSub</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>(workingval);
    workingval =</ins><del>then
            // EL1 translation regime registers
            if data then
                selbit = if TCR_EL1.TBI1 == '1' || TCR_EL1.TBI0 == '1' then ptr&lt;55> else ptr&lt;63>;
            else
                if ((TCR_EL1.TBI1 == '1' &amp;&amp; TCR_EL1.TBID1 == '0') ||
                    (TCR_EL1.TBI0 == '1' &amp;&amp; TCR_EL1.TBID0 == '0')) then
                    selbit = ptr&lt;55>;
                else
                    selbit = ptr&lt;63>;
        else
            // EL2 translation regime registers
            if data then
                selbit = if ((</del> <a href="shared_pseudocode.html#impl-aarch64.PACCellShuffle.1" title="function: bits(64) PACCellShuffle(bits(64) indata)"><ins>PACCellShuffle</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>(workingval);
    workingval =</ins><del>(</del> <a href="shared_pseudocode.html#impl-aarch64.PACMult.1" title="function: bits(64) PACMult(bits(64) Sinput)"><ins>PACMult</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>(workingval);
    workingval = key1 EOR workingval;
    workingval =</ins><del>) &amp;&amp; TCR_EL2.TBI1 == '1') ||
                             (</del> <a href="shared_pseudocode.html#impl-aarch64.PACCellInvShuffle.1" title="function: bits(64) PACCellInvShuffle(bits(64) indata)"><ins>PACCellInvShuffle</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>(workingval);
    workingval =</ins><del>(</del> <a href="shared_pseudocode.html#impl-aarch64.PACInvSub.1" title="function: bits(64) PACInvSub(bits(64) Tinput)"><ins>PACInvSub</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>(workingval);
    workingval =</ins><del>) &amp;&amp; TCR_EL2.TBI0 == '1')) then ptr&lt;55> else ptr&lt;63>;
            else
                selbit = if ((</del> <a href="shared_pseudocode.html#impl-aarch64.PACMult.1" title="function: bits(64) PACMult(bits(64) Sinput)"><ins>PACMult</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>(workingval);
    workingval =</ins><del>(</del> <a href="shared_pseudocode.html#impl-aarch64.PACCellInvShuffle.1" title="function: bits(64) PACCellInvShuffle(bits(64) indata)"><ins>PACCellInvShuffle</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>(workingval);
    workingval = workingval EOR key0;
    workingval = workingval EOR runningmod;
    for i = 0 to 4
        workingval =</ins><del>) &amp;&amp; TCR_EL2.TBI1 == '1' &amp;&amp; TCR_EL1.TBID1 == '0') ||
                             (</del> <a href="shared_pseudocode.html#impl-aarch64.PACInvSub.1" title="function: bits(64) PACInvSub(bits(64) Tinput)"><ins>PACInvSub</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>(workingval);
        if i &lt; 4 then
            workingval =</ins><del>(</del> <a href="shared_pseudocode.html#impl-aarch64.PACMult.1" title="function: bits(64) PACMult(bits(64) Sinput)"><ins>PACMult</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>(workingval);
            workingval =</ins><del>) &amp;&amp; TCR_EL2.TBI0 == '1' &amp;&amp; TCR_EL1.TBID0 == '0')) then ptr&lt;55> else ptr&lt;63>;
    else selbit = if tbi then ptr&lt;55> else ptr&lt;63>;

    integer bottom_PAC_bit =</del> <del>(selbit);

    // The pointer authentication code field takes all the available bits in between
    extfield = </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(selbit, 64);

    // Compute the pointer authentication code for a ptr with good extension bits
    if tbi then
        ext_ptr = ptr&lt;63:56>:extfield&lt;(56-bottom_PAC_bit)-1:0>:ptr&lt;bottom_PAC_bit-1:0>;
    else
        ext_ptr = extfield&lt;(64-bottom_PAC_bit)-1:0>:ptr&lt;bottom_PAC_bit-1:0>;

    PAC = </del><a href="shared_pseudocode.html#impl-aarch64.ComputePAC.4" title="function: bits(64) ComputePAC(bits(64) data, bits(64) modifier, bits(64) key0, bits(64) key1)"><del>ComputePAC</del></a><del>(ext_ptr, modifier, K&lt;127:64>, K&lt;63:0>);

    // Check if the ptr has good extension bits and corrupt the pointer authentication code if not;
    if !</del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(ptr&lt;top_bit:bottom_PAC_bit>) &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)"><del>IsOnes</del></a><a href="shared_pseudocode.html#impl-aarch64.PACCellInvShuffle.1" title="function: bits(64) PACCellInvShuffle(bits(64) indata)"><ins>PACCellInvShuffle</ins></a><a href="shared_pseudocode.html#impl-aarch64.CalculateBottomPACBit.1" title="function: integer CalculateBottomPACBit(bit top_bit)"><del>CalculateBottomPACBit</del></a><ins>(workingval);
        runningmod = TweakInvShuffle(runningmod&lt;63:0>);
        roundkey = key1 EOR runningmod;
        workingval = workingval EOR RC[4-i];
        workingval = workingval EOR roundkey;
        workingval = workingval EOR Alpha;
    workingval = workingval EOR modk0;
</ins><del>(ptr&lt;top_bit:bottom_PAC_bit>) then
        PAC&lt;top_bit-1> = NOT(PAC&lt;top_bit-1>);
</del>
<ins>    return workingval;</ins><del>    // Preserve the determination between upper and lower address at bit&lt;55> and insert PAC
    if tbi then
        result = ptr&lt;63:56>:selbit:PAC&lt;54:bottom_PAC_bit>:ptr&lt;bottom_PAC_bit-1:0>;
    else
        result = PAC&lt;63:56>:selbit:PAC&lt;54:bottom_PAC_bit>:ptr&lt;bottom_PAC_bit-1:0>;
    return result;</del></p></div><div class="ps" psname="aarch64.functions.pac.computepac.PACCellInvShuffle"><a id="aarch64.functions.pac.computepac.PACCellInvShuffle" name="aarch64.functions.pac.computepac.PACCellInvShuffle"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/<ins>computepac</ins><del>addpacda</del>/<ins>PACCellInvShuffle</ins><del>AddPACDA</del></h3><p class="pseudocode"><ins>// PACCellInvShuffle()
// ===================
</ins><del>// AddPACDA()
// ==========
// Returns a 64-bit value containing X, but replacing the pointer authentication code
// field bits with a pointer authentication code, where the pointer authentication
// code is derived using a cryptographic algorithm as a combination of X, Y and the
// APDAKey_EL1.
</del>
bits(64) <a id="impl-aarch64.PACCellInvShuffle.1" name="impl-aarch64.PACCellInvShuffle.1"></a><ins>PACCellInvShuffle(bits(64) indata)
    bits(64) outdata;
    outdata&lt;3:0> = indata&lt;15:12>;
    outdata&lt;7:4> = indata&lt;27:24>;
    outdata&lt;11:8> = indata&lt;51:48>;
    outdata&lt;15:12> = indata&lt;39:36>;
    outdata&lt;19:16> = indata&lt;59:56>;
    outdata&lt;23:20> = indata&lt;47:44>;
    outdata&lt;27:24> = indata&lt;7:4>;
    outdata&lt;31:28> = indata&lt;19:16>;
    outdata&lt;35:32> = indata&lt;35:32>;
    outdata&lt;39:36> = indata&lt;55:52>;
    outdata&lt;43:40> = indata&lt;31:28>;
    outdata&lt;47:44> = indata&lt;11:8>;
    outdata&lt;51:48> = indata&lt;23:20>;
    outdata&lt;55:52> = indata&lt;3:0>;
    outdata&lt;59:56> = indata&lt;43:40>;
    outdata&lt;63:60> = indata&lt;63:60>;
    return outdata;</ins><del>AddPACDA(bits(64) X, bits(64) Y)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APDAKey_EL1;

    APDAKey_EL1 = APDAKeyHi_EL1&lt;63:0> : APDAKeyLo_EL1&lt;63:0>;

    case PSTATE.EL of
        when</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>
            boolean IsEL1Regime = </del><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><del>() == </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnDA else SCTLR_EL2.EnDA;
            TrapEL2 = (</del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                        (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; SCR_EL3.API == '0';
        when </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>
            Enable = SCTLR_EL1.EnDA;
            TrapEL2 = </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; SCR_EL3.API == '0';
        when </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>
            Enable = SCTLR_EL2.EnDA;
            TrapEL2 = FALSE;
            TrapEL3 = </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; SCR_EL3.API == '0';
        when </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>
            Enable = SCTLR_EL3.EnDA;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then return X;
    elsif TrapEL2 then </del><a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><del>TrapPACUse</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>);
    elsif TrapEL3 then </del><a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><del>TrapPACUse</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>);
    else return </del><a href="shared_pseudocode.html#impl-aarch64.AddPAC.4" title="function: bits(64) AddPAC(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data)"><del>AddPAC</del></a><del>(X, Y, APDAKey_EL1, TRUE);</del></p></div><div class="ps" psname="aarch64.functions.pac.computepac.PACCellShuffle"><a id="aarch64.functions.pac.computepac.PACCellShuffle" name="aarch64.functions.pac.computepac.PACCellShuffle"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/<ins>computepac</ins><del>addpacdb</del>/<ins>PACCellShuffle</ins><del>AddPACDB</del></h3><p class="pseudocode"><ins>// PACCellShuffle()
// ================
</ins><del>// AddPACDB()
// ==========
// Returns a 64-bit value containing X, but replacing the pointer authentication code
// field bits with a pointer authentication code, where the pointer authentication
// code is derived using a cryptographic algorithm as a combination of X, Y and the
// APDBKey_EL1.
</del>
bits(64) <a id="impl-aarch64.PACCellShuffle.1" name="impl-aarch64.PACCellShuffle.1"></a><ins>PACCellShuffle(bits(64) indata)
    bits(64) outdata;
    outdata&lt;3:0> = indata&lt;55:52>;
    outdata&lt;7:4> = indata&lt;27:24>;
    outdata&lt;11:8> = indata&lt;47:44>;
    outdata&lt;15:12> = indata&lt;3:0>;
    outdata&lt;19:16> = indata&lt;31:28>;
    outdata&lt;23:20> = indata&lt;51:48>;
    outdata&lt;27:24> = indata&lt;7:4>;
    outdata&lt;31:28> = indata&lt;43:40>;
    outdata&lt;35:32> = indata&lt;35:32>;
    outdata&lt;39:36> = indata&lt;15:12>;
    outdata&lt;43:40> = indata&lt;59:56>;
    outdata&lt;47:44> = indata&lt;23:20>;
    outdata&lt;51:48> = indata&lt;11:8>;
    outdata&lt;55:52> = indata&lt;39:36>;
    outdata&lt;59:56> = indata&lt;19:16>;
    outdata&lt;63:60> = indata&lt;63:60>;
    return outdata;</ins><del>AddPACDB(bits(64) X, bits(64) Y)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APDBKey_EL1;

    APDBKey_EL1 = APDBKeyHi_EL1&lt;63:0> : APDBKeyLo_EL1&lt;63:0>;

    case PSTATE.EL of
        when</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>
            boolean IsEL1Regime = </del><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><del>() == </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnDB else SCTLR_EL2.EnDB;
            TrapEL2 = (</del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                       (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; SCR_EL3.API == '0';
        when </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>
            Enable = SCTLR_EL1.EnDB;
            TrapEL2 = </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; SCR_EL3.API == '0';
        when </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>
            Enable = SCTLR_EL2.EnDB;
            TrapEL2 = FALSE;
            TrapEL3 = </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; SCR_EL3.API == '0';
        when </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>
            Enable = SCTLR_EL3.EnDB;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then return X;
    elsif TrapEL2 then </del><a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><del>TrapPACUse</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>);
    elsif TrapEL3 then </del><a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><del>TrapPACUse</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>);
    else return </del><a href="shared_pseudocode.html#impl-aarch64.AddPAC.4" title="function: bits(64) AddPAC(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data)"><del>AddPAC</del></a><del>(X, Y, APDBKey_EL1, TRUE);</del></p></div><div class="ps" psname="aarch64.functions.pac.computepac.PACInvSub"><a id="aarch64.functions.pac.computepac.PACInvSub" name="aarch64.functions.pac.computepac.PACInvSub"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/<ins>computepac</ins><del>addpacga</del>/<ins>PACInvSub</ins><del>AddPACGA</del></h3><p class="pseudocode"><ins>// PACInvSub()
// ===========
</ins><del>// AddPACGA()
// ==========
// Returns a 64-bit value where the lower 32 bits are 0, and the upper 32 bits contain
// a 32-bit pointer authentication code which is derived using a cryptographic
// algorithm as a combination of X, Y and the APGAKey_EL1.
</del>
bits(64) <a id="impl-aarch64.PACInvSub.1" name="impl-aarch64.PACInvSub.1"></a><ins>PACInvSub(bits(64) Tinput)
    // This is a 4-bit substitution from the PRINCE-family cipher
</ins><del>AddPACGA(bits(64) X, bits(64) Y)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(128) APGAKey_EL1;
</del>
<ins>    bits(64) Toutput;
    for i = 0 to 15
        case Tinput&lt;4*i+3:4*i> of
            when '0000'  Toutput&lt;4*i+3:4*i> = '0101';
            when '0001'  Toutput&lt;4*i+3:4*i> = '1110';
            when '0010'  Toutput&lt;4*i+3:4*i> = '1101';
            when '0011'  Toutput&lt;4*i+3:4*i> = '1000';
            when '0100'  Toutput&lt;4*i+3:4*i> = '1010';
            when '0101'  Toutput&lt;4*i+3:4*i> = '1011';
            when '0110'  Toutput&lt;4*i+3:4*i> = '0001';
            when '0111'  Toutput&lt;4*i+3:4*i> = '1001';
            when '1000'  Toutput&lt;4*i+3:4*i> = '0010';
            when '1001'  Toutput&lt;4*i+3:4*i> = '0110';
            when '1010'  Toutput&lt;4*i+3:4*i> = '1111';
            when '1011'  Toutput&lt;4*i+3:4*i> = '0000';
            when '1100'  Toutput&lt;4*i+3:4*i> = '0100';
            when '1101'  Toutput&lt;4*i+3:4*i> = '1100';
            when '1110'  Toutput&lt;4*i+3:4*i> = '0111';
            when '1111'  Toutput&lt;4*i+3:4*i> = '0011';
    return Toutput;</ins><del>    APGAKey_EL1 = APGAKeyHi_EL1&lt;63:0> : APGAKeyLo_EL1&lt;63:0>;

    case PSTATE.EL of
        when</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>
            TrapEL2 = (</del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                        (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; SCR_EL3.API == '0';
        when </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>
            TrapEL2 = </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; SCR_EL3.API == '0';
        when </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>
            TrapEL2 = FALSE;
            TrapEL3 = </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; SCR_EL3.API == '0';
        when </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if TrapEL2 then </del><a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><del>TrapPACUse</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>);
    elsif TrapEL3 then </del><a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><del>TrapPACUse</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>);
    else return </del><a href="shared_pseudocode.html#impl-aarch64.ComputePAC.4" title="function: bits(64) ComputePAC(bits(64) data, bits(64) modifier, bits(64) key0, bits(64) key1)"><del>ComputePAC</del></a><del>(X, Y, APGAKey_EL1&lt;127:64>, APGAKey_EL1&lt;63:0>)&lt;63:32>:</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(32);</del></p></div><div class="ps" psname="aarch64.functions.pac.computepac.PACMult"><a id="aarch64.functions.pac.computepac.PACMult" name="aarch64.functions.pac.computepac.PACMult"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/<ins>computepac</ins><del>addpacia</del>/<ins>PACMult</ins><del>AddPACIA</del></h3><p class="pseudocode"><ins>// PACMult()
// =========
</ins><del>// AddPACIA()
// ==========
// Returns a 64-bit value containing X, but replacing the pointer authentication code
// field bits with a pointer authentication code, where the pointer authentication
// code is derived using a cryptographic algorithm as a combination of X, Y, and the
// APIAKey_EL1.
</del>
bits(64) <a id="impl-aarch64.PACMult.1" name="impl-aarch64.PACMult.1"></a><ins>PACMult(bits(64) Sinput)
    bits(4)  t0;
    bits(4)  t1;
    bits(4)  t2;
    bits(4)  t3;
    bits(64) Soutput;
</ins><del>AddPACIA(bits(64) X, bits(64) Y)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APIAKey_EL1;
</del>
<ins>    for i = 0 to 3
        t0&lt;3:0> =</ins><del>    APIAKey_EL1 = APIAKeyHi_EL1&lt;63:0>:APIAKeyLo_EL1&lt;63:0>;

    case PSTATE.EL of
        when</del> <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)"><ins>RotCell</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>(Sinput&lt;4*(i+8)+3:4*(i+8)>, 1) EOR</ins><del>boolean IsEL1Regime =</del> <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)"><ins>RotCell</ins></a><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><ins>(Sinput&lt;4*(i+4)+3:4*(i+4)>, 2);
        t0&lt;3:0> = t0&lt;3:0> EOR</ins><del>() ==</del> <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)"><ins>RotCell</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>(Sinput&lt;4*(i)+3:4*(i)>, 1);
        t1&lt;3:0> =</ins><del>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnIA else SCTLR_EL2.EnIA;
            TrapEL2 = (</del> <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)"><ins>RotCell</ins></a><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><ins>(Sinput&lt;4*(i+12)+3:4*(i+12)>, 1) EOR</ins><del>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                       (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 =</del> <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)"><ins>RotCell</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>(Sinput&lt;4*(i+4)+3:4*(i+4)>, 1);
        t1&lt;3:0> = t1&lt;3:0> EOR</ins><del>(</del> <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)"><ins>RotCell</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><ins>(Sinput&lt;4*(i)+3:4*(i)>, 2);
        t2&lt;3:0> =</ins><del>) &amp;&amp; SCR_EL3.API == '0';
        when</del> <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)"><ins>RotCell</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>(Sinput&lt;4*(i+12)+3:4*(i+12)>, 2) EOR</ins><del>Enable = SCTLR_EL1.EnIA;
            TrapEL2 =</del> <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)"><ins>RotCell</ins></a><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><ins>(Sinput&lt;4*(i+8)+3:4*(i+8)>, 1);
        t2&lt;3:0> = t2&lt;3:0> EOR</ins><del>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 =</del> <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)"><ins>RotCell</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>(Sinput&lt;4*(i)+3:4*(i)>, 1);
        t3&lt;3:0> =</ins><del>(</del> <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)"><ins>RotCell</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><ins>(Sinput&lt;4*(i+12)+3:4*(i+12)>, 1) EOR</ins><del>) &amp;&amp; SCR_EL3.API == '0';
        when</del> <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)"><ins>RotCell</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>(Sinput&lt;4*(i+8)+3:4*(i+8)>, 2);
        t3&lt;3:0> = t3&lt;3:0> EOR</ins><del>Enable = SCTLR_EL2.EnIA;
            TrapEL2 = FALSE;
            TrapEL3 =</del> <del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; SCR_EL3.API == '0';
        when </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>
            Enable = SCTLR_EL3.EnIA;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then return X;
    elsif TrapEL2 then </del><a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><del>TrapPACUse</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>);
    elsif TrapEL3 then </del><a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><del>TrapPACUse</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>);
    else return </del><a href="shared_pseudocode.html#impl-aarch64.AddPAC.4" title="function: bits(64) AddPAC(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data)"><del>AddPAC</del></a><a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)"><ins>RotCell</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>(Sinput&lt;4*(i+4)+3:4*(i+4)>, 1);
        Soutput&lt;4*i+3:4*i> = t3&lt;3:0>;
        Soutput&lt;4*(i+4)+3:4*(i+4)> = t2&lt;3:0>;
        Soutput&lt;4*(i+8)+3:4*(i+8)> = t1&lt;3:0>;
        Soutput&lt;4*(i+12)+3:4*(i+12)> = t0&lt;3:0>;
    return Soutput;</ins><del>(X, Y, APIAKey_EL1, FALSE);</del></p></div><div class="ps" psname="aarch64.functions.pac.computepac.PACSub"><a id="aarch64.functions.pac.computepac.PACSub" name="aarch64.functions.pac.computepac.PACSub"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/<ins>computepac</ins><del>addpacib</del>/<ins>PACSub</ins><del>AddPACIB</del></h3><p class="pseudocode"><ins>// PACSub()
// ========
</ins><del>// AddPACIB()
// ==========
// Returns a 64-bit value containing X, but replacing the pointer authentication code
// field bits with a pointer authentication code, where the pointer authentication
// code is derived using a cryptographic algorithm as a combination of X, Y and the
// APIBKey_EL1.
</del>
bits(64) <a id="impl-aarch64.PACSub.1" name="impl-aarch64.PACSub.1"></a><ins>PACSub(bits(64) Tinput)
    // This is a 4-bit substitution from the PRINCE-family cipher
    bits(64) Toutput;
    for i = 0 to 15
        case Tinput&lt;4*i+3:4*i> of
            when '0000'  Toutput&lt;4*i+3:4*i> = '1011';
            when '0001'  Toutput&lt;4*i+3:4*i> = '0110';
            when '0010'  Toutput&lt;4*i+3:4*i> = '1000';
            when '0011'  Toutput&lt;4*i+3:4*i> = '1111';
            when '0100'  Toutput&lt;4*i+3:4*i> = '1100';
            when '0101'  Toutput&lt;4*i+3:4*i> = '0000';
            when '0110'  Toutput&lt;4*i+3:4*i> = '1001';
            when '0111'  Toutput&lt;4*i+3:4*i> = '1110';
            when '1000'  Toutput&lt;4*i+3:4*i> = '0011';
            when '1001'  Toutput&lt;4*i+3:4*i> = '0111';
            when '1010'  Toutput&lt;4*i+3:4*i> = '0100';
            when '1011'  Toutput&lt;4*i+3:4*i> = '0101';
            when '1100'  Toutput&lt;4*i+3:4*i> = '1101';
            when '1101'  Toutput&lt;4*i+3:4*i> = '0010';
            when '1110'  Toutput&lt;4*i+3:4*i> = '0001';
            when '1111'  Toutput&lt;4*i+3:4*i> = '1010';
    return Toutput;</ins><del>AddPACIB(bits(64) X, bits(64) Y)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APIBKey_EL1;

    APIBKey_EL1 = APIBKeyHi_EL1&lt;63:0> : APIBKeyLo_EL1&lt;63:0>;

    case PSTATE.EL of
        when</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>
            boolean IsEL1Regime = </del><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><del>() == </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnIB else SCTLR_EL2.EnIB;
            TrapEL2 = (</del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                       (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; SCR_EL3.API == '0';
        when </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>
            Enable = SCTLR_EL1.EnIB;
            TrapEL2 = </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; SCR_EL3.API == '0';
        when </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>
            Enable = SCTLR_EL2.EnIB;
            TrapEL2 = FALSE;
            TrapEL3 = </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; SCR_EL3.API == '0';
        when </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>
            Enable = SCTLR_EL3.EnIB;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then return X;
    elsif TrapEL2 then </del><a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><del>TrapPACUse</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>);
    elsif TrapEL3 then </del><a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><del>TrapPACUse</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>);
    else return </del><a href="shared_pseudocode.html#impl-aarch64.AddPAC.4" title="function: bits(64) AddPAC(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data)"><del>AddPAC</del></a><del>(X, Y, APIBKey_EL1, FALSE);</del></p></div><div class="ps" psname="aarch64.functions.pac.computepac.RotCell"><a id="aarch64.functions.pac.computepac.RotCell" name="aarch64.functions.pac.computepac.RotCell"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/<ins>computepac</ins><del>auth</del>/<ins>RotCell</ins><del>Auth</del></h3><p class="pseudocode"><ins>// RotCell()
// =========
</ins><del>// Auth()
// ======
// Restores the upper bits of the address to be all zeros or all ones (based on the
// value of bit[55]) and computes and checks the pointer authentication code. If the
// check passes, then the restored address is returned. If the check fails, the
// second-top and third-top bits of the extension bits in the pointer authentication code
// field are corrupted to ensure that accessing the address will give a translation fault.
</del>
<ins>bits(4)</ins><del>bits(64)</del> <a id="impl-aarch64.RotCell.2" name="impl-aarch64.RotCell.2"></a><ins>RotCell(bits(4) incell, integer amount)
    bits(8) tmp;
    bits(4) outcell;
</ins><del>Auth(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data, bit keynumber)
    bits(64) PAC;
    bits(64) result;
    bits(64) original_ptr;
    bits(2) error_code;
    bits(64) extfield;
</del>
<ins>    // assert amount>3 || amount&lt;1;
    tmp&lt;7:0> = incell&lt;3:0>:incell&lt;3:0>;
    outcell = tmp&lt;7-amount:4-amount>;
    return outcell;</ins><del>    // Reconstruct the extension field used of adding the PAC to the pointer
    boolean tbi =</del><a href="shared_pseudocode.html#impl-aarch64.CalculateTBI.2" title="function: boolean CalculateTBI(bits(64) ptr, boolean data)"><del>CalculateTBI</del></a><del>(ptr, data);
    integer bottom_PAC_bit = </del><a href="shared_pseudocode.html#impl-aarch64.CalculateBottomPACBit.1" title="function: integer CalculateBottomPACBit(bit top_bit)"><del>CalculateBottomPACBit</del></a><del>(ptr&lt;55>);
    extfield = </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(ptr&lt;55>, 64);

    if tbi then
        original_ptr = ptr&lt;63:56>:extfield&lt;56-bottom_PAC_bit-1:0>:ptr&lt;bottom_PAC_bit-1:0>;
    else
        original_ptr = extfield&lt;64-bottom_PAC_bit-1:0>:ptr&lt;bottom_PAC_bit-1:0>;

    PAC = </del><a href="shared_pseudocode.html#impl-aarch64.ComputePAC.4" title="function: bits(64) ComputePAC(bits(64) data, bits(64) modifier, bits(64) key0, bits(64) key1)"><del>ComputePAC</del></a><del>(original_ptr, modifier, K&lt;127:64>, K&lt;63:0>);
    // Check pointer authentication code
    if tbi then
        if PAC&lt;54:bottom_PAC_bit> == ptr&lt;54:bottom_PAC_bit> then
            result = original_ptr;
        else
            error_code = keynumber:NOT(keynumber);
            result = original_ptr&lt;63:55>:error_code:original_ptr&lt;52:0>;
    else
        if ((PAC&lt;54:bottom_PAC_bit> == ptr&lt;54:bottom_PAC_bit>) &amp;&amp;
            (PAC&lt;63:56> == ptr&lt;63:56>)) then
            result = original_ptr;
        else
            error_code = keynumber:NOT(keynumber);
            result = original_ptr&lt;63>:error_code:original_ptr&lt;60:0>;
    return result;</del></p></div><div class="ps" psname="aarch64.functions.pac.computepac.TweakCellInvRot"><a id="aarch64.functions.pac.computepac.TweakCellInvRot" name="aarch64.functions.pac.computepac.TweakCellInvRot"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/<ins>computepac</ins><del>authda</del>/<ins>TweakCellInvRot</ins><del>AuthDA</del></h3><p class="pseudocode"><ins>// TweakCellInvRot()
// =================
</ins><del>// AuthDA()
// ========
// Returns a 64-bit value containing X, but replacing the pointer authentication code
// field bits with the extension of the address bits. The instruction checks a pointer
// authentication code in the pointer authentication code field bits of X, using the same
// algorithm and key as AddPACDA().
</del>
<ins>bits(4) TweakCellInvRot(bits(4)incell)
    bits(4) outcell;
    outcell&lt;3> = incell&lt;2>;
    outcell&lt;2> = incell&lt;1>;
    outcell&lt;1> = incell&lt;0>;
    outcell&lt;0> = incell&lt;0> EOR incell&lt;3>;
    return outcell;</ins><del>bits(64)</del><a id="impl-aarch64.AuthDA.2" name="impl-aarch64.AuthDA.2"></a><del>AuthDA(bits(64) X, bits(64) Y)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APDAKey_EL1;

    APDAKey_EL1 = APDAKeyHi_EL1&lt;63:0> : APDAKeyLo_EL1&lt;63:0>;

    case PSTATE.EL of
        when </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>
            boolean IsEL1Regime = </del><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><del>() == </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnDA else SCTLR_EL2.EnDA;
            TrapEL2 = (</del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                       (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; SCR_EL3.API == '0';
        when </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>
            Enable = SCTLR_EL1.EnDA;
            TrapEL2 = </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; SCR_EL3.API == '0';
        when </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>
            Enable = SCTLR_EL2.EnDA;
            TrapEL2 = FALSE;
            TrapEL3 = </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; SCR_EL3.API == '0';
        when </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>
            Enable = SCTLR_EL3.EnDA;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then return X;
    elsif TrapEL2 then </del><a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><del>TrapPACUse</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>);
    elsif TrapEL3 then </del><a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><del>TrapPACUse</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>);
    else  return </del><a href="shared_pseudocode.html#impl-aarch64.Auth.5" title="function: bits(64) Auth(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data, bit keynumber)"><del>Auth</del></a><del>(X, Y, APDAKey_EL1, TRUE, '0');</del></p></div><div class="ps" psname="aarch64.functions.pac.computepac.TweakCellRot"><a id="aarch64.functions.pac.computepac.TweakCellRot" name="aarch64.functions.pac.computepac.TweakCellRot"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/<ins>computepac</ins><del>authdb</del>/<ins>TweakCellRot</ins><del>AuthDB</del></h3><p class="pseudocode"><ins>// TweakCellRot()
// ==============
</ins><del>// AuthDB()
// ========
// Returns a 64-bit value containing X, but replacing the pointer authentication code
// field bits with the extension of the address bits. The instruction checks a
// pointer authentication code in the pointer authentication code field bits of X, using
// the same algorithm and key as AddPACDB().
</del>
<ins>bits(4)</ins><del>bits(64)</del> <a id="impl-aarch64.TweakCellRot.1" name="impl-aarch64.TweakCellRot.1"></a><ins>TweakCellRot(bits(4) incell)
    bits(4) outcell;
    outcell&lt;3> = incell&lt;0> EOR incell&lt;1>;
    outcell&lt;2> = incell&lt;3>;
    outcell&lt;1> = incell&lt;2>;
    outcell&lt;0> = incell&lt;1>;
    return outcell;</ins><del>AuthDB(bits(64) X, bits(64) Y)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APDBKey_EL1;

    APDBKey_EL1 = APDBKeyHi_EL1&lt;63:0> : APDBKeyLo_EL1&lt;63:0>;

    case PSTATE.EL of
        when</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>
            boolean IsEL1Regime = </del><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><del>() == </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnDB else SCTLR_EL2.EnDB;
            TrapEL2 = (</del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                        (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; SCR_EL3.API == '0';
        when </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>
            Enable = SCTLR_EL1.EnDB;
            TrapEL2 = </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; SCR_EL3.API == '0';
        when </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>
            Enable = SCTLR_EL2.EnDB;
            TrapEL2 = FALSE;
            TrapEL3 = </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; SCR_EL3.API == '0';
        when </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>
            Enable = SCTLR_EL3.EnDB;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then return X;
    elsif TrapEL2 then </del><a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><del>TrapPACUse</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>);
    elsif TrapEL3 then </del><a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><del>TrapPACUse</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>);
    else  return </del><a href="shared_pseudocode.html#impl-aarch64.Auth.5" title="function: bits(64) Auth(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data, bit keynumber)"><del>Auth</del></a><del>(X, Y, APDBKey_EL1, TRUE, '1');</del></p></div><div class="ps" psname="aarch64.functions.pac.computepac.TweakInvShuffle"><a id="aarch64.functions.pac.computepac.TweakInvShuffle" name="aarch64.functions.pac.computepac.TweakInvShuffle"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/<ins>computepac</ins><del>authia</del>/<ins>TweakInvShuffle</ins><del>AuthIA</del></h3><p class="pseudocode"><ins>// TweakInvShuffle()
// =================
</ins><del>// AuthIA()
// ========
// Returns a 64-bit value containing X, but replacing the pointer authentication code
// field bits with the extension of the address bits. The instruction checks a pointer
// authentication code in the pointer authentication code field bits of X, using the same
// algorithm and key as AddPACIA().
</del>
<ins>bits(64) TweakInvShuffle(bits(64)indata)
    bits(64) outdata;
    outdata&lt;3:0> = TweakCellInvRot(indata&lt;51:48>);
    outdata&lt;7:4> = indata&lt;55:52>;
    outdata&lt;11:8> = indata&lt;23:20>;
    outdata&lt;15:12> = indata&lt;27:24>;
    outdata&lt;19:16> = indata&lt;3:0>;
    outdata&lt;23:20> = indata&lt;7:4>;
    outdata&lt;27:24> = TweakCellInvRot(indata&lt;11:8>);
    outdata&lt;31:28> = indata&lt;15:12>;
    outdata&lt;35:32> = TweakCellInvRot(indata&lt;31:28>);
    outdata&lt;39:36> = TweakCellInvRot(indata&lt;63:60>);
    outdata&lt;43:40> = TweakCellInvRot(indata&lt;59:56>);
    outdata&lt;47:44> = TweakCellInvRot(indata&lt;19:16>);
    outdata&lt;51:48> = indata&lt;35:32>;
    outdata&lt;55:52> = indata&lt;39:36>;
    outdata&lt;59:56> = indata&lt;43:40>;
    outdata&lt;63:60> = TweakCellInvRot(indata&lt;47:44>);
    return outdata;</ins><del>bits(64)</del><a id="impl-aarch64.AuthIA.2" name="impl-aarch64.AuthIA.2"></a><del>AuthIA(bits(64) X, bits(64) Y)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APIAKey_EL1;

    APIAKey_EL1 = APIAKeyHi_EL1&lt;63:0> : APIAKeyLo_EL1&lt;63:0>;

    case PSTATE.EL of
        when </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>
            boolean IsEL1Regime = </del><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><del>() == </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnIA else SCTLR_EL2.EnIA;
            TrapEL2 = (</del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                       (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; SCR_EL3.API == '0';
        when </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>
            Enable = SCTLR_EL1.EnIA;
            TrapEL2 = </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; SCR_EL3.API == '0';
        when </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>
            Enable = SCTLR_EL2.EnIA;
            TrapEL2 = FALSE;
            TrapEL3 = </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; SCR_EL3.API == '0';
        when </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>
            Enable = SCTLR_EL3.EnIA;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then return X;
    elsif TrapEL2 then </del><a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><del>TrapPACUse</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>);
    elsif TrapEL3 then </del><a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><del>TrapPACUse</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>);
    else  return </del><a href="shared_pseudocode.html#impl-aarch64.Auth.5" title="function: bits(64) Auth(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data, bit keynumber)"><del>Auth</del></a><del>(X, Y, APIAKey_EL1, FALSE, '0');</del></p></div><div class="ps" psname="aarch64.functions.pac.computepac.TweakShuffle"><a id="aarch64.functions.pac.computepac.TweakShuffle" name="aarch64.functions.pac.computepac.TweakShuffle"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/<ins>computepac</ins><del>authib</del>/<ins>TweakShuffle</ins><del>AuthIB</del></h3><p class="pseudocode"><ins>// TweakShuffle()
// ==============
</ins><del>// AuthIB()
// ========
// Returns a 64-bit value containing X, but replacing the pointer authentication code
// field bits with the extension of the address bits. The instruction checks a pointer
// authentication code in the pointer authentication code field bits of X, using the same
// algorithm and key as AddPACIB().
</del>
bits(64) <a id="impl-aarch64.TweakShuffle.1" name="impl-aarch64.TweakShuffle.1"></a><ins>TweakShuffle(bits(64) indata)
    bits(64) outdata;
    outdata&lt;3:0> = indata&lt;19:16>;
    outdata&lt;7:4> = indata&lt;23:20>;
    outdata&lt;11:8> =</ins><del>AuthIB(bits(64) X, bits(64) Y)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APIBKey_EL1;

    APIBKey_EL1 = APIBKeyHi_EL1&lt;63:0> : APIBKeyLo_EL1&lt;63:0>;

    case PSTATE.EL of
        when</del> <a href="shared_pseudocode.html#impl-aarch64.TweakCellRot.1" title="function: bits(4) TweakCellRot(bits(4) incell)"><ins>TweakCellRot</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>(indata&lt;27:24>);
    outdata&lt;15:12> = indata&lt;31:28>;
    outdata&lt;19:16> =</ins><del>boolean IsEL1Regime =</del> <a href="shared_pseudocode.html#impl-aarch64.TweakCellRot.1" title="function: bits(4) TweakCellRot(bits(4) incell)"><ins>TweakCellRot</ins></a><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><ins>(indata&lt;47:44>);
    outdata&lt;23:20> = indata&lt;11:8>;
    outdata&lt;27:24> = indata&lt;15:12>;
    outdata&lt;31:28> =</ins><del>() ==</del> <a href="shared_pseudocode.html#impl-aarch64.TweakCellRot.1" title="function: bits(4) TweakCellRot(bits(4) incell)"><ins>TweakCellRot</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>(indata&lt;35:32>);
    outdata&lt;35:32> = indata&lt;51:48>;
    outdata&lt;39:36> = indata&lt;55:52>;
    outdata&lt;43:40> = indata&lt;59:56>;
    outdata&lt;47:44> =</ins><del>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnIB else SCTLR_EL2.EnIB;
            TrapEL2 = (</del> <a href="shared_pseudocode.html#impl-aarch64.TweakCellRot.1" title="function: bits(4) TweakCellRot(bits(4) incell)"><ins>TweakCellRot</ins></a><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><ins>(indata&lt;63:60>);
    outdata&lt;51:48> =</ins><del>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                       (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 =</del> <a href="shared_pseudocode.html#impl-aarch64.TweakCellRot.1" title="function: bits(4) TweakCellRot(bits(4) incell)"><ins>TweakCellRot</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>(indata&lt;3:0>);
    outdata&lt;55:52> = indata&lt;7:4>;
    outdata&lt;59:56> =</ins><del>(</del> <a href="shared_pseudocode.html#impl-aarch64.TweakCellRot.1" title="function: bits(4) TweakCellRot(bits(4) incell)"><ins>TweakCellRot</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><ins>(indata&lt;43:40>);
    outdata&lt;63:60> =</ins><del>) &amp;&amp; SCR_EL3.API == '0';
        when</del> <del>
            Enable = SCTLR_EL1.EnIB;
            TrapEL2 = </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; SCR_EL3.API == '0';
        when </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>
            Enable = SCTLR_EL2.EnIB;
            TrapEL2 = FALSE;
            TrapEL3 = </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; SCR_EL3.API == '0';
        when </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>
            Enable = SCTLR_EL3.EnIB;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then return X;
    elsif TrapEL2 then </del><a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><del>TrapPACUse</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>);
    elsif TrapEL3 then </del><a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><del>TrapPACUse</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>);
    else  return </del><a href="shared_pseudocode.html#impl-aarch64.Auth.5" title="function: bits(64) Auth(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data, bit keynumber)"><del>Auth</del></a><a href="shared_pseudocode.html#impl-aarch64.TweakCellRot.1" title="function: bits(4) TweakCellRot(bits(4) incell)"><ins>TweakCellRot</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>(indata&lt;39:36>);
    return outdata;</ins><del>(X, Y, APIBKey_EL1, FALSE, '1');</del></p></div><div class="ps" psname="aarch64.functions.pac.pac.HavePACExt"><a id="aarch64.functions.pac.pac.HavePACExt" name="aarch64.functions.pac.pac.HavePACExt"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/<ins>pac</ins><del>calcbottompacbit</del>/<ins>HavePACExt</ins><del>CalculateBottomPACBit</del></h3><p class="pseudocode"><ins>// HavePACExt()
// ============
</ins><del>// CalculateBottomPACBit()
// =======================
</del>
<ins>boolean</ins><del>integer</del> <a id="impl-aarch64.HavePACExt.0" name="impl-aarch64.HavePACExt.0"></a><ins>HavePACExt()
    return</ins><del>CalculateBottomPACBit(bit top_bit)
    integer tsz_field;

    if</del> <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><ins>HasArchVersion</ins></a><a href="shared_pseudocode.html#impl-aarch64.PtrHasUpperAndLowerAddRanges.0" title="function: boolean PtrHasUpperAndLowerAddRanges()"><del>PtrHasUpperAndLowerAddRanges</del></a><ins>(</ins><del>() then
        assert</del><a href="shared_pseudocode.html#ARMv8p3" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p3</ins></a><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><ins>);

boolean</ins><del>() IN {</del> <a id="impl-aarch64.HaveEnhancedPAC.0" name="impl-aarch64.HaveEnhancedPAC.0"></a><ins>HaveEnhancedPAC()
    return (</ins><del>,</del> <del>};
        if </del><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><del>() == </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del> then
            // EL1 translation regime registers
            tsz_field = if top_bit == '1' then </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(TCR_EL1.T1SZ) else </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(TCR_EL1.T0SZ);
            using64k = if top_bit == '1' then TCR_EL1.TG1 == '11' else TCR_EL1.TG0 == '01';
        else
            // EL2 translation regime registers
            assert </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>);
            tsz_field = if top_bit == '1' then </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(TCR_EL2.T1SZ) else </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(TCR_EL2.T0SZ);
            using64k = if top_bit == '1' then TCR_EL2.TG1 == '11' else TCR_EL2.TG0 == '01';
    else
        tsz_field = if PSTATE.EL == </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del> then </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(TCR_EL2.T0SZ) else </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(TCR_EL3.T0SZ);
        using64k = if PSTATE.EL == </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del> then TCR_EL2.TG0 == '01' else TCR_EL3.TG0 == '01';

    max_limit_tsz_field = (if !</del><a href="shared_pseudocode.html#impl-shared.HaveSmallPageTblExt.0" title="function: boolean HaveSmallPageTblExt()"><del>HaveSmallPageTblExt</del></a><del>() then 39 else if using64k then 47 else 48);
    if tsz_field > max_limit_tsz_field then
        // TCR_ELx.TySZ is out of range
        c = </del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><del>ConstrainUnpredictable</del></a><del>(</del><a href="shared_pseudocode.html#Unpredictable_RESTnSZ" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESTnSZ</del></a><del>);
        assert c IN {</del><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FORCE</del></a><del>, </del><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_NONE</del></a><del>};
        if c == </del><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FORCE</del></a><del> then tsz_field = max_limit_tsz_field;
    tszmin = if using64k &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.VAMax.0" title="function: integer VAMax()"><del>VAMax</del></a><del>() == 52 then 12 else 16;
    if tsz_field &lt; tszmin then
        c = </del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><del>ConstrainUnpredictable</del></a><del>(</del><a href="shared_pseudocode.html#Unpredictable_RESTnSZ" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESTnSZ</del></a><del>);
        assert c IN {</del><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FORCE</del></a><del>, </del><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_NONE</del></a><del>};
        if c == </del><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FORCE</del></a><a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()"><ins>HavePACExt</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>()
        &amp;&amp; boolean IMPLEMENTATION_DEFINED "Has enhanced PAC functionality" );</ins><del>then tsz_field = tszmin;
    return (64-tsz_field);</del></p></div><div class="ps" psname="aarch64.functions.pac.pac.PtrHasUpperAndLowerAddRanges"><a id="aarch64.functions.pac.pac.PtrHasUpperAndLowerAddRanges" name="aarch64.functions.pac.pac.PtrHasUpperAndLowerAddRanges"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/<ins>pac</ins><del>calculatetbi</del>/<ins>PtrHasUpperAndLowerAddRanges</ins><del>CalculateTBI</del></h3><p class="pseudocode"><ins>// PtrHasUpperAndLowerAddRanges()
// ==============================

// Returns TRUE if the pointer has upper and lower address ranges
</ins><del>// CalculateTBI()
// ==============
</del>
boolean <a id="impl-aarch64.PtrHasUpperAndLowerAddRanges.0" name="impl-aarch64.PtrHasUpperAndLowerAddRanges.0"></a><ins>PtrHasUpperAndLowerAddRanges()
    return PSTATE.EL ==</ins><del>CalculateTBI(bits(64) ptr, boolean data)
    boolean tbi = FALSE;

    if</del> <a href="shared_pseudocode.html#impl-aarch64.PtrHasUpperAndLowerAddRanges.0" title="function: boolean PtrHasUpperAndLowerAddRanges()"><del>PtrHasUpperAndLowerAddRanges</del></a><del>() then
        assert </del><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><del>() IN {</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> <ins>|| PSTATE.EL ==</ins><del>,</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a> <ins>|| (PSTATE.EL ==</ins><del>};
        if</del> <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><del>() == </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del> then
            // EL1 translation regime registers
            if data then
                tbi = if ptr&lt;55> == '1' then TCR_EL1.TBI1 == '1' else TCR_EL1.TBI0 == '1';
            else
                if ptr&lt;55> == '1' then
                    tbi = TCR_EL1.TBI1 == '1' &amp;&amp; TCR_EL1.TBID1 == '0';
                else
                    tbi = TCR_EL1.TBI0 == '1' &amp;&amp; TCR_EL1.TBID0 == '0';
        else
            // EL2 translation regime registers
            if data then
                tbi = if ptr&lt;55> == '1' then TCR_EL2.TBI1 == '1' else TCR_EL2.TBI0 == '1';
            else
                if ptr&lt;55> == '1' then
                    tbi = TCR_EL2.TBI1 == '1' &amp;&amp; TCR_EL2.TBID1 == '0';
                else
                    tbi = TCR_EL2.TBI0 == '1' &amp;&amp; TCR_EL2.TBID0 == '0';
    elsif PSTATE.EL == </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a><del> then
        tbi = if data then TCR_EL2.TBI=='1' else TCR_EL2.TBI=='1' &amp;&amp; TCR_EL2.TBID=='0';
    elsif PSTATE.EL == </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a> <ins>&amp;&amp; HCR_EL2.E2H == '1');</ins><del>then
        tbi = if data then TCR_EL3.TBI=='1' else TCR_EL3.TBI=='1' &amp;&amp; TCR_EL3.TBID=='0';

    return tbi;</del></p></div><div class="ps" psname="aarch64.functions.pac.strip.Strip"><a id="aarch64.functions.pac.strip.Strip" name="aarch64.functions.pac.strip.Strip"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/<ins>strip</ins><del>computepac</del>/<ins>Strip</ins><del>ComputePAC</del></h3><p class="pseudocode"><ins>// Strip()
// =======
// Strip() returns a 64-bit value containing A, but replacing the pointer authentication
// code field bits with the extension of the address bits. This can apply to either
// instructions or data, where, as the use of tagged pointers is distinct, it might be
// handled differently.
</ins><del>array bits(64) RC[0..4];
</del>
bits(64) <a id="impl-aarch64.Strip.2" name="impl-aarch64.Strip.2"></a><ins>Strip(bits(64) A, boolean data)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(64) original_ptr;
    bits(64) extfield;
    boolean tbi =</ins><del>ComputePAC(bits(64) data, bits(64) modifier, bits(64) key0, bits(64) key1)
    bits(64)  workingval;
    bits(64)  runningmod;
    bits(64)  roundkey;
    bits(64)  modk0;
    constant bits(64) Alpha = 0xC0AC29B7C97C50DD&lt;63:0>;

    RC[0] = 0x0000000000000000&lt;63:0>;
    RC[1] = 0x13198A2E03707344&lt;63:0>;
    RC[2] = 0xA4093822299F31D0&lt;63:0>;
    RC[3] = 0x082EFA98EC4E6C89&lt;63:0>;
    RC[4] = 0x452821E638D01377&lt;63:0>;

    modk0 = key0&lt;0>:key0&lt;63:2>:(key0&lt;63> EOR key0&lt;1>);
    runningmod = modifier;
    workingval = data EOR key0;
    for i = 0 to 4
        roundkey = key1 EOR runningmod;
        workingval  = workingval EOR roundkey;
        workingval = workingval EOR RC[i];
        if i > 0 then
            workingval =</del> <a href="shared_pseudocode.html#impl-aarch64.CalculateTBI.2" title="function: boolean CalculateTBI(bits(64) ptr, boolean data)"><ins>CalculateTBI</ins></a><a href="shared_pseudocode.html#impl-aarch64.PACCellShuffle.1" title="function: bits(64) PACCellShuffle(bits(64) indata)"><del>PACCellShuffle</del></a><ins>(A, data);
    integer bottom_PAC_bit =</ins><del>(workingval);
            workingval =</del> <a href="shared_pseudocode.html#impl-aarch64.CalculateBottomPACBit.1" title="function: integer CalculateBottomPACBit(bit top_bit)"><ins>CalculateBottomPACBit</ins></a><a href="shared_pseudocode.html#impl-aarch64.PACMult.1" title="function: bits(64) PACMult(bits(64) Sinput)"><del>PACMult</del></a><ins>(A&lt;55>);
    extfield =</ins><del>(workingval);
        workingval =</del> <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><a href="shared_pseudocode.html#impl-aarch64.PACSub.1" title="function: bits(64) PACSub(bits(64) Tinput)"><del>PACSub</del></a><ins>(A&lt;55>, 64);

    if tbi then
        original_ptr = A&lt;63:56>:extfield&lt; 56-bottom_PAC_bit-1:0>:A&lt;bottom_PAC_bit-1:0>;
    else
        original_ptr = extfield&lt; 64-bottom_PAC_bit-1:0>:A&lt;bottom_PAC_bit-1:0>;

    case PSTATE.EL of
        when</ins><del>(workingval);
        runningmod =</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#impl-aarch64.TweakShuffle.1" title="function: bits(64) TweakShuffle(bits(64) indata)"><del>TweakShuffle</del></a>
            <ins>TrapEL2 = (</ins><del>(runningmod&lt;63:0>);
    roundkey = modk0 EOR runningmod;
    workingval = workingval EOR roundkey;
    workingval =</del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#impl-aarch64.PACCellShuffle.1" title="function: bits(64) PACCellShuffle(bits(64) indata)"><del>PACCellShuffle</del></a><ins>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                        (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 =</ins><del>(workingval);
    workingval =</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-aarch64.PACMult.1" title="function: bits(64) PACMult(bits(64) Sinput)"><del>PACMult</del></a><ins>(</ins><del>(workingval);
    workingval =</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-aarch64.PACSub.1" title="function: bits(64) PACSub(bits(64) Tinput)"><del>PACSub</del></a><ins>) &amp;&amp; SCR_EL3.API == '0';
        when</ins><del>(workingval);
    workingval =</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#impl-aarch64.PACCellShuffle.1" title="function: bits(64) PACCellShuffle(bits(64) indata)"><del>PACCellShuffle</del></a>
            <ins>TrapEL2 =</ins><del>(workingval);
    workingval =</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#impl-aarch64.PACMult.1" title="function: bits(64) PACMult(bits(64) Sinput)"><del>PACMult</del></a><ins>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 =</ins><del>(workingval);
    workingval = key1 EOR workingval;
    workingval =</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-aarch64.PACCellInvShuffle.1" title="function: bits(64) PACCellInvShuffle(bits(64) indata)"><del>PACCellInvShuffle</del></a><ins>(</ins><del>(workingval);
    workingval =</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-aarch64.PACInvSub.1" title="function: bits(64) PACInvSub(bits(64) Tinput)"><del>PACInvSub</del></a><ins>) &amp;&amp; SCR_EL3.API == '0';
        when</ins><del>(workingval);
    workingval =</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-aarch64.PACMult.1" title="function: bits(64) PACMult(bits(64) Sinput)"><del>PACMult</del></a>
            <ins>TrapEL2 = FALSE;
            TrapEL3 =</ins><del>(workingval);
    workingval =</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-aarch64.PACCellInvShuffle.1" title="function: bits(64) PACCellInvShuffle(bits(64) indata)"><del>PACCellInvShuffle</del></a><ins>(</ins><del>(workingval);
    workingval = workingval EOR key0;
    workingval = workingval EOR runningmod;
    for i = 0 to 4
        workingval =</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-aarch64.PACInvSub.1" title="function: bits(64) PACInvSub(bits(64) Tinput)"><del>PACInvSub</del></a><ins>) &amp;&amp; SCR_EL3.API == '0';
        when</ins><del>(workingval);
        if i &lt; 4 then
            workingval =</del> <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-aarch64.PACMult.1" title="function: bits(64) PACMult(bits(64) Sinput)"><del>PACMult</del></a>
            <ins>TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if TrapEL2 then</ins><del>(workingval);
            workingval =</del> <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><ins>TrapPACUse</ins></a><a href="shared_pseudocode.html#impl-aarch64.PACCellInvShuffle.1" title="function: bits(64) PACCellInvShuffle(bits(64) indata)"><del>PACCellInvShuffle</del></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>);
    elsif TrapEL3 then </ins><a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><ins>TrapPACUse</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>);
    else  return original_ptr;</ins><del>(workingval);
        runningmod = TweakInvShuffle(runningmod&lt;63:0>);
        roundkey = key1 EOR runningmod;
        workingval = workingval EOR RC[4-i];
        workingval = workingval EOR roundkey;
        workingval = workingval EOR Alpha;
    workingval = workingval EOR modk0;

    return workingval;</del></p></div><div class="ps" psname="aarch64.functions.pac.trappacuse.TrapPACUse"><a id="aarch64.functions.pac.trappacuse.TrapPACUse" name="aarch64.functions.pac.trappacuse.TrapPACUse"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/<ins>trappacuse</ins><del>computepac</del>/<ins>TrapPACUse</ins><del>PACCellInvShuffle</del></h3><p class="pseudocode"><ins>// TrapPACUse()
// ============
// Used for the trapping of the pointer authentication functions by higher exception
// levels.</ins><del>// PACCellInvShuffle()
// ===================

bits(64)</del>

<a id="impl-aarch64.TrapPACUse.1" name="impl-aarch64.TrapPACUse.1"></a><ins>TrapPACUse(bits(2) target_el)
    assert</ins><del>PACCellInvShuffle(bits(64) indata)
    bits(64) outdata;
    outdata&lt;3:0> = indata&lt;15:12>;
    outdata&lt;7:4> = indata&lt;27:24>;
    outdata&lt;11:8> = indata&lt;51:48>;
    outdata&lt;15:12> = indata&lt;39:36>;
    outdata&lt;19:16> = indata&lt;59:56>;
    outdata&lt;23:20> = indata&lt;47:44>;
    outdata&lt;27:24> = indata&lt;7:4>;
    outdata&lt;31:28> = indata&lt;19:16>;
    outdata&lt;35:32> = indata&lt;35:32>;
    outdata&lt;39:36> = indata&lt;55:52>;
    outdata&lt;43:40> = indata&lt;31:28>;
    outdata&lt;47:44> = indata&lt;11:8>;
    outdata&lt;51:48> = indata&lt;23:20>;
    outdata&lt;55:52> = indata&lt;3:0>;
    outdata&lt;59:56> = indata&lt;43:40>;
    outdata&lt;63:60> = indata&lt;63:60>;
    return outdata;</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(target_el) &amp;&amp; target_el !=  </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins> &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(target_el) >= </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(PSTATE.EL);

    bits(64) preferred_exception_return = </ins><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><ins>ThisInstrAddr</ins></a><ins>();
    </ins><a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is (Exception type, bits(25) syndrome, bits(64) vaddress, boolean ipavalid, bits(1) NS, bits(52) ipaddress)"><ins>ExceptionRecord</ins></a><ins> exception;
    vect_offset = 0;
    exception = </ins><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><ins>(</ins><a href="shared_pseudocode.html#Exception_PACTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_PACTrap</ins></a><ins>);
    </ins><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><ins>(target_el, exception, preferred_exception_return, vect_offset);</ins></p></div><div class="ps" psname="aarch64.functions.ras.AArch64.ESBOperation"><a id="aarch64.functions.ras.AArch64.ESBOperation" name="aarch64.functions.ras.AArch64.ESBOperation"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>ras</ins><del>pac</del>/<ins>AArch64.ESBOperation</ins><del>computepac/PACCellShuffle</del></h3><p class="pseudocode"><ins>// AArch64.ESBOperation()
// ======================
// Perform the AArch64 ESB operation, either for ESB executed in AArch64 state, or for
// ESB in AArch32 state when SError interrupts are routed to an Exception level using
// AArch64</ins><del>// PACCellShuffle()
// ================

bits(64)</del>

<a id="AArch64.ESBOperation.0" name="AArch64.ESBOperation.0"></a><ins>AArch64.ESBOperation()

    route_to_el3 = (</ins><del>PACCellShuffle(bits(64) indata)
    bits(64) outdata;
    outdata&lt;3:0> = indata&lt;55:52>;
    outdata&lt;7:4> = indata&lt;27:24>;
    outdata&lt;11:8> = indata&lt;47:44>;
    outdata&lt;15:12> = indata&lt;3:0>;
    outdata&lt;19:16> = indata&lt;31:28>;
    outdata&lt;23:20> = indata&lt;51:48>;
    outdata&lt;27:24> = indata&lt;7:4>;
    outdata&lt;31:28> = indata&lt;43:40>;
    outdata&lt;35:32> = indata&lt;35:32>;
    outdata&lt;39:36> = indata&lt;15:12>;
    outdata&lt;43:40> = indata&lt;59:56>;
    outdata&lt;47:44> = indata&lt;23:20>;
    outdata&lt;51:48> = indata&lt;11:8>;
    outdata&lt;55:52> = indata&lt;39:36>;
    outdata&lt;59:56> = indata&lt;19:16>;
    outdata&lt;63:60> = indata&lt;63:60>;
    return outdata;</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; SCR_EL3.EA == '1');
    route_to_el2 = (</ins><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>() &amp;&amp;
                    (HCR_EL2.TGE == '1' || HCR_EL2.AMO == '1'));

    target = (if route_to_el3 then </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins> elsif route_to_el2 then </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins> else </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>);

    if target == </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins> then
        mask_active = (PSTATE.EL IN {</ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>,</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>});
    elsif </ins><a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><ins>HaveVirtHostExt</ins></a><ins>() &amp;&amp; target == </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins> &amp;&amp; HCR_EL2.&lt;E2H,TGE> == '11' then
        mask_active = (PSTATE.EL IN {</ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>,</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>});
    else
        mask_active = (PSTATE.EL == target);

    mask_set = (PSTATE.A == '1' &amp;&amp; (!</ins><a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()"><ins>HaveDoubleFaultExt</ins></a><ins>() || SCR_EL3.EA == '0' ||
                                    PSTATE.EL != </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins> || SCR_EL3.NMEA == '0'));
    intdis = (</ins><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><ins>Halted</ins></a><ins>() || </ins><a href="shared_pseudocode.html#impl-shared.ExternalDebugInterruptsDisabled.1" title="function: boolean ExternalDebugInterruptsDisabled(bits(2) target)"><ins>ExternalDebugInterruptsDisabled</ins></a><ins>(target));
    masked = (</ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(target) &lt; </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(PSTATE.EL)) || intdis || (mask_active &amp;&amp; mask_set);

    // Check for a masked Physical SError pending
    if </ins><a href="shared_pseudocode.html#impl-shared.IsPhysicalSErrorPending.0" title="function: boolean IsPhysicalSErrorPending()"><ins>IsPhysicalSErrorPending</ins></a><ins>() &amp;&amp; masked then
        // This function might be called for an interworking case, and INTdis is masking
        // the SError interrupt.
        if </ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><ins>()) then
            syndrome32 = </ins><a href="shared_pseudocode.html#AArch32.PhysicalSErrorSyndrome.0" title="function: AArch32.SErrorSyndrome AArch32.PhysicalSErrorSyndrome()"><ins>AArch32.PhysicalSErrorSyndrome</ins></a><ins>();
            DISR = </ins><a href="shared_pseudocode.html#AArch32.ReportDeferredSError.2" title="function: bits(32) AArch32.ReportDeferredSError(bits(2) AET, bit ExT)"><ins>AArch32.ReportDeferredSError</ins></a><ins>(syndrome32.AET, syndrome32.ExT);
        else
            implicit_esb = FALSE;
            syndrome64 = </ins><a href="shared_pseudocode.html#AArch64.PhysicalSErrorSyndrome.1" title="function: bits(25) AArch64.PhysicalSErrorSyndrome(boolean implicit_esb)"><ins>AArch64.PhysicalSErrorSyndrome</ins></a><ins>(implicit_esb);
            DISR_EL1 = </ins><a href="shared_pseudocode.html#AArch64.ReportDeferredSError.1" title="function: bits(64) AArch64.ReportDeferredSError(bits(25) syndrome)"><ins>AArch64.ReportDeferredSError</ins></a><ins>(syndrome64);
        </ins><a href="shared_pseudocode.html#impl-shared.ClearPendingPhysicalSError.0" title="function: ClearPendingPhysicalSError()"><ins>ClearPendingPhysicalSError</ins></a><ins>();               // Set ISR_EL1.A to 0

    return;</ins></p></div><div class="ps" psname="aarch64.functions.ras.AArch64.PhysicalSErrorSyndrome"><a id="aarch64.functions.ras.AArch64.PhysicalSErrorSyndrome" name="aarch64.functions.ras.AArch64.PhysicalSErrorSyndrome"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>ras</ins><del>pac</del>/<ins>AArch64.PhysicalSErrorSyndrome</ins><del>computepac/PACInvSub</del></h3><p class="pseudocode"><ins>// Return the SError syndrome
bits(25)</ins><del>// PACInvSub()
// ===========

bits(64)</del> <a id="AArch64.PhysicalSErrorSyndrome.1" name="AArch64.PhysicalSErrorSyndrome.1"></a><ins>AArch64.PhysicalSErrorSyndrome(boolean implicit_esb);</ins><del>PACInvSub(bits(64) Tinput)
    // This is a 4-bit substitution from the PRINCE-family cipher

    bits(64) Toutput;
    for i = 0 to 15
        case Tinput&lt;4*i+3:4*i> of
            when '0000'  Toutput&lt;4*i+3:4*i> = '0101';
            when '0001'  Toutput&lt;4*i+3:4*i> = '1110';
            when '0010'  Toutput&lt;4*i+3:4*i> = '1101';
            when '0011'  Toutput&lt;4*i+3:4*i> = '1000';
            when '0100'  Toutput&lt;4*i+3:4*i> = '1010';
            when '0101'  Toutput&lt;4*i+3:4*i> = '1011';
            when '0110'  Toutput&lt;4*i+3:4*i> = '0001';
            when '0111'  Toutput&lt;4*i+3:4*i> = '1001';
            when '1000'  Toutput&lt;4*i+3:4*i> = '0010';
            when '1001'  Toutput&lt;4*i+3:4*i> = '0110';
            when '1010'  Toutput&lt;4*i+3:4*i> = '1111';
            when '1011'  Toutput&lt;4*i+3:4*i> = '0000';
            when '1100'  Toutput&lt;4*i+3:4*i> = '0100';
            when '1101'  Toutput&lt;4*i+3:4*i> = '1100';
            when '1110'  Toutput&lt;4*i+3:4*i> = '0111';
            when '1111'  Toutput&lt;4*i+3:4*i> = '0011';
    return Toutput;</del></p></div><div class="ps" psname="aarch64.functions.ras.AArch64.ReportDeferredSError"><a id="aarch64.functions.ras.AArch64.ReportDeferredSError" name="aarch64.functions.ras.AArch64.ReportDeferredSError"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>ras</ins><del>pac</del>/<ins>AArch64.ReportDeferredSError</ins><del>computepac/PACMult</del></h3><p class="pseudocode"><ins>// AArch64.ReportDeferredSError()
// ==============================
// Generate deferred SError syndrome
</ins><del>// PACMult()
// =========
</del>
bits(64) <a id="AArch64.ReportDeferredSError.1" name="AArch64.ReportDeferredSError.1"></a><ins>AArch64.ReportDeferredSError(bits(25) syndrome)
    bits(64) target;
    target&lt;31>   = '1';              // A
    target&lt;24>   = syndrome&lt;24>;     // IDS
    target&lt;23:0> = syndrome&lt;23:0>;   // ISS
    return target;</ins><del>PACMult(bits(64) Sinput)
    bits(4)  t0;
    bits(4)  t1;
    bits(4)  t2;
    bits(4)  t3;
    bits(64) Soutput;

    for i = 0 to 3
        t0&lt;3:0> =</del><a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)"><del>RotCell</del></a><del>(Sinput&lt;4*(i+8)+3:4*(i+8)>, 1) EOR </del><a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)"><del>RotCell</del></a><del>(Sinput&lt;4*(i+4)+3:4*(i+4)>, 2);
        t0&lt;3:0> = t0&lt;3:0> EOR </del><a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)"><del>RotCell</del></a><del>(Sinput&lt;4*(i)+3:4*(i)>, 1);
        t1&lt;3:0> = </del><a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)"><del>RotCell</del></a><del>(Sinput&lt;4*(i+12)+3:4*(i+12)>, 1) EOR </del><a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)"><del>RotCell</del></a><del>(Sinput&lt;4*(i+4)+3:4*(i+4)>, 1);
        t1&lt;3:0> = t1&lt;3:0> EOR </del><a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)"><del>RotCell</del></a><del>(Sinput&lt;4*(i)+3:4*(i)>, 2);
        t2&lt;3:0> = </del><a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)"><del>RotCell</del></a><del>(Sinput&lt;4*(i+12)+3:4*(i+12)>, 2) EOR </del><a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)"><del>RotCell</del></a><del>(Sinput&lt;4*(i+8)+3:4*(i+8)>, 1);
        t2&lt;3:0> = t2&lt;3:0> EOR </del><a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)"><del>RotCell</del></a><del>(Sinput&lt;4*(i)+3:4*(i)>, 1);
        t3&lt;3:0> = </del><a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)"><del>RotCell</del></a><del>(Sinput&lt;4*(i+12)+3:4*(i+12)>, 1) EOR </del><a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)"><del>RotCell</del></a><del>(Sinput&lt;4*(i+8)+3:4*(i+8)>, 2);
        t3&lt;3:0> = t3&lt;3:0> EOR </del><a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)"><del>RotCell</del></a><del>(Sinput&lt;4*(i+4)+3:4*(i+4)>, 1);
        Soutput&lt;4*i+3:4*i> = t3&lt;3:0>;
        Soutput&lt;4*(i+4)+3:4*(i+4)> = t2&lt;3:0>;
        Soutput&lt;4*(i+8)+3:4*(i+8)> = t1&lt;3:0>;
        Soutput&lt;4*(i+12)+3:4*(i+12)> = t0&lt;3:0>;
    return Soutput;</del></p></div><div class="ps" psname="aarch64.functions.ras.AArch64.vESBOperation"><a id="aarch64.functions.ras.AArch64.vESBOperation" name="aarch64.functions.ras.AArch64.vESBOperation"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>ras</ins><del>pac</del>/<ins>AArch64.vESBOperation</ins><del>computepac/PACSub</del></h3><p class="pseudocode"><ins>// AArch64.vESBOperation()
// =======================
// Perform the AArch64 ESB operation for virtual SError interrupts, either for ESB
// executed in AArch64 state, or for ESB in AArch32 state with EL2 using AArch64 state</ins><del>// PACSub()
// ========

bits(64)</del>

<a id="AArch64.vESBOperation.0" name="AArch64.vESBOperation.0"></a><ins>AArch64.vESBOperation()
    assert</ins><del>PACSub(bits(64) Tinput)
    // This is a 4-bit substitution from the PRINCE-family cipher
    bits(64) Toutput;
    for i = 0 to 15
        case Tinput&lt;4*i+3:4*i> of
            when '0000'  Toutput&lt;4*i+3:4*i> = '1011';
            when '0001'  Toutput&lt;4*i+3:4*i> = '0110';
            when '0010'  Toutput&lt;4*i+3:4*i> = '1000';
            when '0011'  Toutput&lt;4*i+3:4*i> = '1111';
            when '0100'  Toutput&lt;4*i+3:4*i> = '1100';
            when '0101'  Toutput&lt;4*i+3:4*i> = '0000';
            when '0110'  Toutput&lt;4*i+3:4*i> = '1001';
            when '0111'  Toutput&lt;4*i+3:4*i> = '1110';
            when '1000'  Toutput&lt;4*i+3:4*i> = '0011';
            when '1001'  Toutput&lt;4*i+3:4*i> = '0111';
            when '1010'  Toutput&lt;4*i+3:4*i> = '0100';
            when '1011'  Toutput&lt;4*i+3:4*i> = '0101';
            when '1100'  Toutput&lt;4*i+3:4*i> = '1101';
            when '1101'  Toutput&lt;4*i+3:4*i> = '0010';
            when '1110'  Toutput&lt;4*i+3:4*i> = '0001';
            when '1111'  Toutput&lt;4*i+3:4*i> = '1010';
    return Toutput;</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>() &amp;&amp; PSTATE.EL IN {</ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>,</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>};

    // If physical SError interrupts are routed to EL2, and TGE is not set, then a virtual
    // SError interrupt might be pending
    vSEI_enabled = HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.AMO == '1';
    vSEI_pending = vSEI_enabled &amp;&amp; HCR_EL2.VSE == '1';
    vintdis      = </ins><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><ins>Halted</ins></a><ins>() || </ins><a href="shared_pseudocode.html#impl-shared.ExternalDebugInterruptsDisabled.1" title="function: boolean ExternalDebugInterruptsDisabled(bits(2) target)"><ins>ExternalDebugInterruptsDisabled</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>);
    vmasked      = vintdis || PSTATE.A == '1';

    // Check for a masked virtual SError pending
    if vSEI_pending &amp;&amp; vmasked then
        // This function might be called for the interworking case, and INTdis is masking
        // the virtual SError interrupt.
        if </ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>) then
            VDISR = </ins><a href="shared_pseudocode.html#AArch32.ReportDeferredSError.2" title="function: bits(32) AArch32.ReportDeferredSError(bits(2) AET, bit ExT)"><ins>AArch32.ReportDeferredSError</ins></a><ins>(VDFSR&lt;15:14>, VDFSR&lt;12>);
        else
            VDISR_EL2 = </ins><a href="shared_pseudocode.html#AArch64.ReportDeferredSError.1" title="function: bits(64) AArch64.ReportDeferredSError(bits(25) syndrome)"><ins>AArch64.ReportDeferredSError</ins></a><ins>(VSESR_EL2&lt;24:0>);
        HCR_EL2.VSE = '0';                       // Clear pending virtual SError

    return;</ins></p></div><div class="ps" psname="aarch64.functions.registers.AArch64.MaybeZeroRegisterUppers"><a id="aarch64.functions.registers.AArch64.MaybeZeroRegisterUppers" name="aarch64.functions.registers.AArch64.MaybeZeroRegisterUppers"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>registers</ins><del>pac</del>/<ins>AArch64.MaybeZeroRegisterUppers</ins><del>computepac/RotCell</del></h3><p class="pseudocode"><ins>// AArch64.MaybeZeroRegisterUppers()
// =================================
// On taking an exception to  AArch64 from AArch32, it is CONSTRAINED UNPREDICTABLE whether the top
// 32 bits of registers visible at any lower Exception level using AArch32 are set to zero.</ins><del>// RotCell()
// =========

bits(4)</del>

<a id="AArch64.MaybeZeroRegisterUppers.0" name="AArch64.MaybeZeroRegisterUppers.0"></a><ins>AArch64.MaybeZeroRegisterUppers()
    assert</ins><del>RotCell(bits(4) incell, integer amount)
    bits(8) tmp;
    bits(4) outcell;

    // assert amount>3 || amount&lt;1;
    tmp&lt;7:0> = incell&lt;3:0>:incell&lt;3:0>;
    outcell = tmp&lt;7-amount:4-amount>;
    return outcell;</del> <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>();         // Always called from AArch32 state before entering AArch64 state

    if PSTATE.EL == </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins> &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>) then
        first = 0;  last = 14;  include_R15 = FALSE;
    elsif PSTATE.EL IN {</ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>,</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>} &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>() &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) then
        first = 0;  last = 30;  include_R15 = FALSE;
    else
        first = 0;  last = 30;  include_R15 = TRUE;

    for n = first to last
        if (n != 15 || include_R15) &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><ins>ConstrainUnpredictableBool</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_ZEROUPPER" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_ZEROUPPER</ins></a><ins>) then
            _R[n]&lt;63:32> = </ins><a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><ins>Zeros</ins></a><ins>();

    return;</ins></p></div><div class="ps" psname="aarch64.functions.registers.AArch64.ResetGeneralRegisters"><a id="aarch64.functions.registers.AArch64.ResetGeneralRegisters" name="aarch64.functions.registers.AArch64.ResetGeneralRegisters"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>registers</ins><del>pac</del>/<ins>AArch64.ResetGeneralRegisters</ins><del>computepac/TweakCellInvRot</del></h3><p class="pseudocode"><ins>// AArch64.ResetGeneralRegisters()
// ===============================</ins><del>// TweakCellInvRot()
// =================

bits(4) TweakCellInvRot(bits(4)incell)
    bits(4) outcell;
    outcell&lt;3> = incell&lt;2>;
    outcell&lt;2> = incell&lt;1>;
    outcell&lt;1> = incell&lt;0>;
    outcell&lt;0> = incell&lt;0> EOR incell&lt;3>;
    return outcell;</del>

<a id="AArch64.ResetGeneralRegisters.0" name="AArch64.ResetGeneralRegisters.0"></a><ins>AArch64.ResetGeneralRegisters()

    for i = 0 to 30
        </ins><a href="shared_pseudocode.html#impl-aarch64.X.write.1" title="accessor: X[integer n] = bits(width) value"><ins>X</ins></a><ins>[i] = bits(64) UNKNOWN;

    return;</ins></p></div><div class="ps" psname="aarch64.functions.registers.AArch64.ResetSIMDFPRegisters"><a id="aarch64.functions.registers.AArch64.ResetSIMDFPRegisters" name="aarch64.functions.registers.AArch64.ResetSIMDFPRegisters"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>registers</ins><del>pac</del>/<ins>AArch64.ResetSIMDFPRegisters</ins><del>computepac/TweakCellRot</del></h3><p class="pseudocode"><ins>// AArch64.ResetSIMDFPRegisters()
// ==============================</ins><del>// TweakCellRot()
// ==============

bits(4)</del>

<a id="AArch64.ResetSIMDFPRegisters.0" name="AArch64.ResetSIMDFPRegisters.0"></a><ins>AArch64.ResetSIMDFPRegisters()

    for i = 0 to 31</ins><del>TweakCellRot(bits(4) incell)
    bits(4) outcell;
    outcell&lt;3> = incell&lt;0> EOR incell&lt;1>;
    outcell&lt;2> = incell&lt;3>;
    outcell&lt;1> = incell&lt;2>;
    outcell&lt;0> = incell&lt;1>;
    return outcell;</del>
        <a href="shared_pseudocode.html#impl-aarch64.V.write.1" title="accessor: V[integer n] = bits(width) value"><ins>V</ins></a><ins>[i] = bits(128) UNKNOWN;

    return;</ins></p></div><div class="ps" psname="aarch64.functions.registers.AArch64.ResetSpecialRegisters"><a id="aarch64.functions.registers.AArch64.ResetSpecialRegisters" name="aarch64.functions.registers.AArch64.ResetSpecialRegisters"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>registers</ins><del>pac</del>/<ins>AArch64.ResetSpecialRegisters</ins><del>computepac/TweakInvShuffle</del></h3><p class="pseudocode"><ins>// AArch64.ResetSpecialRegisters()
// ===============================</ins><del>// TweakInvShuffle()
// =================

bits(64) TweakInvShuffle(bits(64)indata)
    bits(64) outdata;
    outdata&lt;3:0> = TweakCellInvRot(indata&lt;51:48>);
    outdata&lt;7:4> = indata&lt;55:52>;
    outdata&lt;11:8> = indata&lt;23:20>;
    outdata&lt;15:12> = indata&lt;27:24>;
    outdata&lt;19:16> = indata&lt;3:0>;
    outdata&lt;23:20> = indata&lt;7:4>;
    outdata&lt;27:24> = TweakCellInvRot(indata&lt;11:8>);
    outdata&lt;31:28> = indata&lt;15:12>;
    outdata&lt;35:32> = TweakCellInvRot(indata&lt;31:28>);
    outdata&lt;39:36> = TweakCellInvRot(indata&lt;63:60>);
    outdata&lt;43:40> = TweakCellInvRot(indata&lt;59:56>);
    outdata&lt;47:44> = TweakCellInvRot(indata&lt;19:16>);
    outdata&lt;51:48> = indata&lt;35:32>;
    outdata&lt;55:52> = indata&lt;39:36>;
    outdata&lt;59:56> = indata&lt;43:40>;
    outdata&lt;63:60> = TweakCellInvRot(indata&lt;47:44>);
    return outdata;</del>

<a id="AArch64.ResetSpecialRegisters.0" name="AArch64.ResetSpecialRegisters.0"></a><ins>AArch64.ResetSpecialRegisters()

    // AArch64 special registers
    SP_EL0 = bits(64) UNKNOWN;
    SP_EL1 = bits(64) UNKNOWN;
    SPSR_EL1 = bits(32) UNKNOWN;
    ELR_EL1  = bits(64) UNKNOWN;
    if </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) then
        SP_EL2 = bits(64) UNKNOWN;
        SPSR_EL2 = bits(32) UNKNOWN;
        ELR_EL2  = bits(64) UNKNOWN;
    if </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) then
        SP_EL3 = bits(64) UNKNOWN;
        SPSR_EL3 = bits(32) UNKNOWN;
        ELR_EL3  = bits(64) UNKNOWN;

    // AArch32 special registers that are not architecturally mapped to AArch64 registers
    if </ins><a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)"><ins>HaveAArch32EL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>) then
        SPSR_fiq = bits(32) UNKNOWN;
        SPSR_irq = bits(32) UNKNOWN;
        SPSR_abt = bits(32) UNKNOWN;
        SPSR_und = bits(32) UNKNOWN;

    // External debug special registers
    DLR_EL0 = bits(64) UNKNOWN;
    DSPSR_EL0 = bits(32) UNKNOWN;

    return;</ins></p></div><div class="ps" psname="aarch64.functions.registers.AArch64.ResetSystemRegisters"><a id="aarch64.functions.registers.AArch64.ResetSystemRegisters" name="aarch64.functions.registers.AArch64.ResetSystemRegisters"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>registers</ins><del>pac</del>/<ins>AArch64.ResetSystemRegisters</ins><del>computepac/TweakShuffle</del></h3><p class="pseudocode"><del>// TweakShuffle()
// ==============

bits(64) </del><a id="AArch64.ResetSystemRegisters.1" name="AArch64.ResetSystemRegisters.1"></a><del>TweakShuffle(bits(64) indata)
    bits(64) outdata;
    outdata&lt;3:0> = indata&lt;19:16>;
    outdata&lt;7:4> = indata&lt;23:20>;
    outdata&lt;11:8> = </del><a href="shared_pseudocode.html#impl-aarch64.TweakCellRot.1" title="function: bits(4) TweakCellRot(bits(4) incell)"><del>TweakCellRot</del></a><del>(indata&lt;27:24>);
    outdata&lt;15:12> = indata&lt;31:28>;
    outdata&lt;19:16> = </del><a href="shared_pseudocode.html#impl-aarch64.TweakCellRot.1" title="function: bits(4) TweakCellRot(bits(4) incell)"><del>TweakCellRot</del></a><del>(indata&lt;47:44>);
    outdata&lt;23:20> = indata&lt;11:8>;
    outdata&lt;27:24> = indata&lt;15:12>;
    outdata&lt;31:28> = </del><a href="shared_pseudocode.html#impl-aarch64.TweakCellRot.1" title="function: bits(4) TweakCellRot(bits(4) incell)"><del>TweakCellRot</del></a><del>(indata&lt;35:32>);
    outdata&lt;35:32> = indata&lt;51:48>;
    outdata&lt;39:36> = indata&lt;55:52>;
    outdata&lt;43:40> = indata&lt;59:56>;
    outdata&lt;47:44> = </del><a href="shared_pseudocode.html#impl-aarch64.TweakCellRot.1" title="function: bits(4) TweakCellRot(bits(4) incell)"><del>TweakCellRot</del></a><del>(indata&lt;63:60>);
    outdata&lt;51:48> = </del><a href="shared_pseudocode.html#impl-aarch64.TweakCellRot.1" title="function: bits(4) TweakCellRot(bits(4) incell)"><del>TweakCellRot</del></a><del>(indata&lt;3:0>);
    outdata&lt;55:52> = indata&lt;7:4>;
    outdata&lt;59:56> = </del><a href="shared_pseudocode.html#impl-aarch64.TweakCellRot.1" title="function: bits(4) TweakCellRot(bits(4) incell)"><del>TweakCellRot</del></a><del>(indata&lt;43:40>);
    outdata&lt;63:60> = </del><a href="shared_pseudocode.html#impl-aarch64.TweakCellRot.1" title="function: bits(4) TweakCellRot(bits(4) incell)"><del>TweakCellRot</del></a><ins>AArch64.ResetSystemRegisters(boolean cold_reset);</ins><del>(indata&lt;39:36>);
    return outdata;</del></p></div><div class="ps" psname="aarch64.functions.registers.PC"><a id="aarch64.functions.registers.PC" name="aarch64.functions.registers.PC"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>registers</ins><del>pac</del>/<ins>PC</ins><del>pac/HavePACExt</del></h3><p class="pseudocode"><ins>// PC - non-assignment form
// ========================
// Read program counter.
</ins><del>// HavePACExt()
// ============
</del>
<ins>bits(64)</ins><del>boolean</del> <a id="impl-aarch64.PC.read.0" name="impl-aarch64.PC.read.0"></a><ins>PC[]
    return _PC;</ins><del>HavePACExt()
    return</del><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><del>HasArchVersion</del></a><del>(</del><a href="shared_pseudocode.html#ARMv8p3" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p3</del></a><del>);</del></p></div><div class="ps" psname="aarch64.functions.registers.SP"><a id="aarch64.functions.registers.SP" name="aarch64.functions.registers.SP"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>registers</ins><del>pac</del>/<ins>SP</ins><del>pac/PtrHasUpperAndLowerAddRanges</del></h3><p class="pseudocode"><ins>// SP[] - assignment form
// ======================
// Write to stack pointer from either a 32-bit or a 64-bit value.</ins><del>// PtrHasUpperAndLowerAddRanges()
// ==============================

// Returns TRUE if the pointer has upper and lower address ranges

boolean</del>

<a id="impl-aarch64.SP.write.0" name="impl-aarch64.SP.write.0"></a><ins>SP[] = bits(width) value
    assert width IN {32,64};
    if PSTATE.SP == '0' then
        SP_EL0 =</ins><del>PtrHasUpperAndLowerAddRanges()
    return PSTATE.EL ==</del> <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(value);
    else
        case PSTATE.EL of
            when </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>  SP_EL0 = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(value);
            when </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  <ins>SP_EL1 =</ins><del>|| PSTATE.EL ==</del> <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(value);
            when </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>  SP_EL2 = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(value);
            when </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>  SP_EL3 = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(value);
    return;

// SP[] - non-assignment form
// ==========================
// Read stack pointer with implicit slice of 8, 16, 32 or 64 bits.

bits(width) </ins><a id="impl-aarch64.SP.read.0" name="impl-aarch64.SP.read.0"></a><ins>SP[]
    assert width IN {8,16,32,64};
    if PSTATE.SP == '0' then
        return SP_EL0&lt;width-1:0>;
    else
        case PSTATE.EL of
            when </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>  <ins>return SP_EL0&lt;width-1:0>;
            when</ins><del>|| (PSTATE.EL ==</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>  return SP_EL1&lt;width-1:0>;
            when </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a><ins>  return SP_EL2&lt;width-1:0>;
            when </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a>  <ins>return SP_EL3&lt;width-1:0>;</ins><del>&amp;&amp; HCR_EL2.E2H == '1');</del></p></div><div class="ps" psname="aarch64.functions.registers.V"><a id="aarch64.functions.registers.V" name="aarch64.functions.registers.V"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>registers</ins><del>pac</del>/<ins>V</ins><del>strip/Strip</del></h3><p class="pseudocode"><ins>// V[] - assignment form
// =====================</ins><del>// Strip()
// =======
// Strip() returns a 64-bit value containing A, but replacing the pointer authentication
// code field bits with the extension of the address bits. This can apply to either
// instructions or data, where, as the use of tagged pointers is distinct, it might be
// handled differently.

bits(64)</del>

<a id="impl-aarch64.V.write.1" name="impl-aarch64.V.write.1"></a><ins>V[integer n] = bits(width) value
    assert n >= 0 &amp;&amp; n &lt;= 31;
    assert width IN {8,16,32,64,128};
    integer vlen = if</ins><del>Strip(bits(64) A, boolean data)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(64) original_ptr;
    bits(64) extfield;
    boolean tbi =</del> <a href="shared_pseudocode.html#impl-aarch64.IsSVEEnabled.1" title="function: boolean IsSVEEnabled(bits(2) el)"><ins>IsSVEEnabled</ins></a><a href="shared_pseudocode.html#impl-aarch64.CalculateTBI.2" title="function: boolean CalculateTBI(bits(64) ptr, boolean data)"><del>CalculateTBI</del></a><ins>(PSTATE.EL) then VL else 128;
    if</ins><del>(A, data);
    integer bottom_PAC_bit =</del> <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><ins>ConstrainUnpredictableBool</ins></a><a href="shared_pseudocode.html#impl-aarch64.CalculateBottomPACBit.1" title="function: integer CalculateBottomPACBit(bit top_bit)"><del>CalculateBottomPACBit</del></a><ins>(</ins><del>(A&lt;55>);
    extfield =</del><a href="shared_pseudocode.html#Unpredictable_SVEZEROUPPER" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_SVEZEROUPPER</ins></a><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><ins>) then
        _Z[n] =</ins><del>(A&lt;55>, 64);

    if tbi then
        original_ptr = A&lt;63:56>:extfield&lt; 56-bottom_PAC_bit-1:0>:A&lt;bottom_PAC_bit-1:0>;
    else
        original_ptr = extfield&lt; 64-bottom_PAC_bit-1:0>:A&lt;bottom_PAC_bit-1:0>;

    case PSTATE.EL of
        when</del> <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>(value);
    else
        _Z[n]&lt;vlen-1:0> =</ins><del>TrapEL2 = (</del> <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><ins>(value);

// V[] - non-assignment form
// =========================

bits(width)</ins><del>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                        (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 =</del> <del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; SCR_EL3.API == '0';
        when </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>
            TrapEL2 = </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; SCR_EL3.API == '0';
        when </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>
            TrapEL2 = FALSE;
            TrapEL3 = </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; SCR_EL3.API == '0';
        when </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if TrapEL2 then </del><a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><del>TrapPACUse</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>);
    elsif TrapEL3 then </del><a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)"><del>TrapPACUse</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><a id="impl-aarch64.V.read.1" name="impl-aarch64.V.read.1"></a><ins>V[integer n]
    assert n >= 0 &amp;&amp; n &lt;= 31;
    assert width IN {8,16,32,64,128};
    return _Z[n]&lt;width-1:0>;</ins><del>);
    else  return original_ptr;</del></p></div><div class="ps" psname="aarch64.functions.registers.Vpart"><a id="aarch64.functions.registers.Vpart" name="aarch64.functions.registers.Vpart"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>registers</ins><del>pac</del>/<ins>Vpart</ins><del>trappacuse/TrapPACUse</del></h3><p class="pseudocode"><ins>// Vpart[] - non-assignment form
// =============================

bits(width)</ins><del>// TrapPACUse()
// ============
// Used for the trapping of the pointer authentication functions by higher exception
// levels.</del> <a id="impl-aarch64.Vpart.read.2" name="impl-aarch64.Vpart.read.2"></a><ins>Vpart[integer n, integer part]
    assert n >= 0 &amp;&amp; n &lt;= 31;
    assert part IN {0, 1};
    if part == 0 then
        assert width IN {8,16,32,64};
        return</ins><del>TrapPACUse(bits(2) target_el)
    assert</del> <a href="shared_pseudocode.html#impl-aarch64.V.read.1" title="accessor: bits(width) V[integer n]"><ins>V</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>[n];
    else
        assert width == 64;
        return _V[n]&lt;(width * 2)-1:width>;

// Vpart[] - assignment form
// =========================</ins><del>(target_el) &amp;&amp; target_el !=</del>

<a id="impl-aarch64.Vpart.write.2" name="impl-aarch64.Vpart.write.2"></a><ins>Vpart[integer n, integer part] = bits(width) value
    assert n >= 0 &amp;&amp; n &lt;= 31;
    assert part IN {0, 1};
    if part == 0 then
        assert width IN {8,16,32,64};</ins><del>&amp;&amp;</del>
        <a href="shared_pseudocode.html#impl-aarch64.V.write.1" title="accessor: V[integer n] = bits(width) value"><ins>V</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>[n] = value;
    else
        assert width == 64;
        bits(64) vreg =</ins><del>(target_el) >=</del> <a href="shared_pseudocode.html#impl-aarch64.V.read.1" title="accessor: bits(width) V[integer n]"><ins>V</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>[n];</ins><del>(PSTATE.EL);

    bits(64) preferred_exception_return =</del>
        <del>();
    </del><a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is (Exception type, bits(25) syndrome, bits(64) vaddress, boolean ipavalid, bits(1) NS, bits(52) ipaddress)"><del>ExceptionRecord</del></a><del> exception;
    vect_offset = 0;
    exception = </del><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a><del>(</del><a href="shared_pseudocode.html#Exception_PACTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception_PACTrap</del></a><del>);
    </del><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a><a href="shared_pseudocode.html#impl-aarch64.V.write.1" title="accessor: V[integer n] = bits(width) value"><ins>V</ins></a><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><del>ThisInstrAddr</del></a><ins>[n] = value&lt;63:0> : vreg;</ins><del>(target_el, exception, preferred_exception_return, vect_offset);</del></p></div><div class="ps" psname="aarch64.functions.registers.X"><a id="aarch64.functions.registers.X" name="aarch64.functions.registers.X"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>registers</ins><del>ras</del>/<ins>X</ins><del>AArch64.ESBOperation</del></h3><p class="pseudocode"><ins>// X[] - assignment form
// =====================
// Write to general-purpose register from either a 32-bit or a 64-bit value.</ins><del>// AArch64.ESBOperation()
// ======================
// Perform the AArch64 ESB operation, either for ESB executed in AArch64 state, or for
// ESB in AArch32 state when SError interrupts are routed to an Exception level using
// AArch64</del>

<a id="impl-aarch64.X.write.1" name="impl-aarch64.X.write.1"></a><ins>X[integer n] = bits(width) value
    assert n >= 0 &amp;&amp; n &lt;= 31;
    assert width IN {32,64};
    if n != 31 then
        _R[n] =</ins><del>AArch64.ESBOperation()

    route_to_el3 = (</del> <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>(value);
    return;

// X[] - non-assignment form
// =========================
// Read from general-purpose register with implicit slice of 8, 16, 32 or 64 bits.

bits(width)</ins><del>(</del> <a id="impl-aarch64.X.read.1" name="impl-aarch64.X.read.1"></a><ins>X[integer n]
    assert n >= 0 &amp;&amp; n &lt;= 31;
    assert width IN {8,16,32,64};
    if n != 31 then
        return _R[n]&lt;width-1:0>;
    else
        return</ins><del>) &amp;&amp; SCR_EL3.EA == '1');
    route_to_el2 = (</del> <del>() &amp;&amp;
                    (HCR_EL2.TGE == '1' || HCR_EL2.AMO == '1'));

    target = (if route_to_el3 then </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del> elsif route_to_el2 then </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del> else </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>);

    if target == </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del> then
        mask_active = (PSTATE.EL IN {</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>,</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>});
    elsif </del><a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><del>HaveVirtHostExt</del></a><del>() &amp;&amp; target == </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del> &amp;&amp; HCR_EL2.&lt;E2H,TGE> == '11' then
        mask_active = (PSTATE.EL IN {</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>,</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>});
    else
        mask_active = (PSTATE.EL == target);

    mask_set = (PSTATE.A == '1' &amp;&amp; (!</del><a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()"><del>HaveDoubleFaultExt</del></a><del>() || SCR_EL3.EA == '0' ||
                                    PSTATE.EL != </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del> || SCR_EL3.NMEA == '0'));
    intdis = (</del><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><del>Halted</del></a><del>() || </del><a href="shared_pseudocode.html#impl-shared.ExternalDebugInterruptsDisabled.1" title="function: boolean ExternalDebugInterruptsDisabled(bits(2) target)"><del>ExternalDebugInterruptsDisabled</del></a><del>(target));
    masked = (</del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(target) &lt; </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(PSTATE.EL)) || intdis || (mask_active &amp;&amp; mask_set);

    // Check for a masked Physical SError pending
    if </del><a href="shared_pseudocode.html#impl-shared.IsPhysicalSErrorPending.0" title="function: boolean IsPhysicalSErrorPending()"><del>IsPhysicalSErrorPending</del></a><del>() &amp;&amp; masked then
        // This function might be called for an interworking case, and INTdis is masking
        // the SError interrupt.
        if </del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><del>()) then
            syndrome32 = </del><a href="shared_pseudocode.html#AArch32.PhysicalSErrorSyndrome.0" title="function: AArch32.SErrorSyndrome AArch32.PhysicalSErrorSyndrome()"><del>AArch32.PhysicalSErrorSyndrome</del></a><del>();
            DISR = </del><a href="shared_pseudocode.html#AArch32.ReportDeferredSError.2" title="function: bits(32) AArch32.ReportDeferredSError(bits(2) AET, bit ExT)"><del>AArch32.ReportDeferredSError</del></a><del>(syndrome32.AET, syndrome32.ExT);
        else
            implicit_esb = FALSE;
            syndrome64 = </del><a href="shared_pseudocode.html#AArch64.PhysicalSErrorSyndrome.1" title="function: bits(25) AArch64.PhysicalSErrorSyndrome(boolean implicit_esb)"><del>AArch64.PhysicalSErrorSyndrome</del></a><del>(implicit_esb);
            DISR_EL1 = </del><a href="shared_pseudocode.html#AArch64.ReportDeferredSError.1" title="function: bits(64) AArch64.ReportDeferredSError(bits(25) syndrome)"><del>AArch64.ReportDeferredSError</del></a><del>(syndrome64);
        </del><a href="shared_pseudocode.html#impl-shared.ClearPendingPhysicalSError.0" title="function: ClearPendingPhysicalSError()"><del>ClearPendingPhysicalSError</del></a><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><ins>(width);</ins><del>();               // Set ISR_EL1.A to 0

    return;</del></p></div><div class="ps" psname="aarch64.functions.sve.AArch32.IsFPEnabled"><a id="aarch64.functions.sve.AArch32.IsFPEnabled" name="aarch64.functions.sve.AArch32.IsFPEnabled"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>sve</ins><del>ras</del>/<ins>AArch32.IsFPEnabled</ins><del>AArch64.PhysicalSErrorSyndrome</del></h3><p class="pseudocode"><ins>// AArch32.IsFPEnabled()
// =====================

boolean</ins><del>// Return the SError syndrome
bits(25)</del> <a id="AArch32.IsFPEnabled.1" name="AArch32.IsFPEnabled.1"></a><ins>AArch32.IsFPEnabled(bits(2) el)
    if el ==</ins><del>AArch64.PhysicalSErrorSyndrome(boolean implicit_esb);</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins> &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>) then
        return </ins><a href="shared_pseudocode.html#AArch64.IsFPEnabled.1" title="function: boolean AArch64.IsFPEnabled(bits(2) el)"><ins>AArch64.IsFPEnabled</ins></a><ins>(el);

    if </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>() then
        // Check if access disabled in NSACR
        if NSACR.cp10 == '0' then return FALSE;

    if el IN {</ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>, </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>} then
        // Check if access disabled in CPACR
        case CPACR.cp10 of
            when 'x0' disabled = TRUE;
            when '01' disabled = (el == </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>);
            when '11' disabled = FALSE;
        if disabled then return FALSE;

    if el IN {</ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>, </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>, </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>} then
        if </ins><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>() then
            if !</ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) then
                if CPTR_EL2.TFP == '1' then return FALSE;
            else
                if HCPTR.TCP10 == '1' then return FALSE;

    if </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) then
        // Check if access disabled in CPTR_EL3
        if CPTR_EL3.TFP == '1' then return FALSE;

    return TRUE;</ins></p></div><div class="ps" psname="aarch64.functions.sve.AArch64.IsFPEnabled"><a id="aarch64.functions.sve.AArch64.IsFPEnabled" name="aarch64.functions.sve.AArch64.IsFPEnabled"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>sve</ins><del>ras</del>/<ins>AArch64.IsFPEnabled</ins><del>AArch64.ReportDeferredSError</del></h3><p class="pseudocode"><ins>// AArch64.IsFPEnabled()
// =====================
</ins><del>// AArch64.ReportDeferredSError()
// ==============================
// Generate deferred SError syndrome
</del>
<ins>boolean</ins><del>bits(64)</del> <a id="AArch64.IsFPEnabled.1" name="AArch64.IsFPEnabled.1"></a><ins>AArch64.IsFPEnabled(bits(2) el)
    // Check if access disabled in CPACR_EL1
    if el IN {</ins><del>AArch64.ReportDeferredSError(bits(25) syndrome)
    bits(64) target;
    target&lt;31>   = '1';              // A
    target&lt;24>   = syndrome&lt;24>;     // IDS
    target&lt;23:0> = syndrome&lt;23:0>;   // ISS
    return target;</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>, </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>} then
        // Check FP&amp;SIMD at EL0/EL1
        case </ins><a href="shared_pseudocode.html#impl-aarch64.CPACR.read.0" title="accessor: CPACRType CPACR[]"><ins>CPACR</ins></a><ins>[].FPEN of
            when 'x0' disabled = TRUE;
            when '01' disabled = (el == </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>);
            when '11' disabled = FALSE;
        if disabled then return FALSE;

    // Check if access disabled in CPTR_EL2
    if el IN {</ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>, </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>, </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>} &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>() then
        if </ins><a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><ins>HaveVirtHostExt</ins></a><ins>() &amp;&amp; HCR_EL2.E2H == '1' then
            if CPTR_EL2.FPEN == 'x0' then return FALSE;
        else
            if CPTR_EL2.TFP == '1' then return FALSE;

    // Check if access disabled in CPTR_EL3
    if </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) then
        if CPTR_EL3.TFP == '1' then return FALSE;

    return TRUE;</ins></p></div><div class="ps" psname="aarch64.functions.sve.CeilPow2"><a id="aarch64.functions.sve.CeilPow2" name="aarch64.functions.sve.CeilPow2"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>sve</ins><del>ras</del>/<ins>CeilPow2</ins><del>AArch64.vESBOperation</del></h3><p class="pseudocode"><ins>// CeilPow2()
// ==========

// For a positive integer X, return the smallest power of 2 >= X

integer</ins><del>// AArch64.vESBOperation()
// =======================
// Perform the AArch64 ESB operation for virtual SError interrupts, either for ESB
// executed in AArch64 state, or for ESB in AArch32 state with EL2 using AArch64 state</del> <a id="impl-aarch64.CeilPow2.1" name="impl-aarch64.CeilPow2.1"></a><ins>CeilPow2(integer x)
    if x == 0 then return 0;
    if x == 1 then return 2;
    return</ins><del>AArch64.vESBOperation()
    assert</del> <del>() &amp;&amp; PSTATE.EL IN {</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>,</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>};

    // If physical SError interrupts are routed to EL2, and TGE is not set, then a virtual
    // SError interrupt might be pending
    vSEI_enabled = HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.AMO == '1';
    vSEI_pending = vSEI_enabled &amp;&amp; HCR_EL2.VSE == '1';
    vintdis      = </del><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><del>Halted</del></a><del>() || </del><a href="shared_pseudocode.html#impl-shared.ExternalDebugInterruptsDisabled.1" title="function: boolean ExternalDebugInterruptsDisabled(bits(2) target)"><del>ExternalDebugInterruptsDisabled</del></a><del>(</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>);
    vmasked      = vintdis || PSTATE.A == '1';

    // Check for a masked virtual SError pending
    if vSEI_pending &amp;&amp; vmasked then
        // This function might be called for the interworking case, and INTdis is masking
        // the virtual SError interrupt.
        if </del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>) then
            VDISR = </del><a href="shared_pseudocode.html#AArch32.ReportDeferredSError.2" title="function: bits(32) AArch32.ReportDeferredSError(bits(2) AET, bit ExT)"><del>AArch32.ReportDeferredSError</del></a><del>(VDFSR&lt;15:14>, VDFSR&lt;12>);
        else
            VDISR_EL2 = </del><a href="shared_pseudocode.html#AArch64.ReportDeferredSError.1" title="function: bits(64) AArch64.ReportDeferredSError(bits(25) syndrome)"><del>AArch64.ReportDeferredSError</del></a><a href="shared_pseudocode.html#impl-aarch64.FloorPow2.1" title="function: integer FloorPow2(integer x)"><ins>FloorPow2</ins></a><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><ins>(x - 1) * 2;</ins><del>(VSESR_EL2&lt;24:0>);
        HCR_EL2.VSE = '0';                       // Clear pending virtual SError

    return;</del></p></div><div class="ps" psname="aarch64.functions.sve.CheckSVEEnabled"><a id="aarch64.functions.sve.CheckSVEEnabled" name="aarch64.functions.sve.CheckSVEEnabled"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>sve</ins><del>registers</del>/<ins>CheckSVEEnabled</ins><del>AArch64.MaybeZeroRegisterUppers</del></h3><p class="pseudocode"><ins>// CheckSVEEnabled()
// =================</ins><del>// AArch64.MaybeZeroRegisterUppers()
// =================================
// On taking an exception to  AArch64 from AArch32, it is CONSTRAINED UNPREDICTABLE whether the top
// 32 bits of registers visible at any lower Exception level using AArch32 are set to zero.</del>

<a id="impl-aarch64.CheckSVEEnabled.0" name="impl-aarch64.CheckSVEEnabled.0"></a><ins>CheckSVEEnabled()
    // Check if access disabled in CPACR_EL1
    if PSTATE.EL IN {</ins><del>AArch64.MaybeZeroRegisterUppers()
    assert</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><ins>,</ins><del>();         // Always called from AArch32 state before entering AArch64 state

    if PSTATE.EL ==</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>} then
        // Check SVE at EL0/EL1
        case </ins><a href="shared_pseudocode.html#impl-aarch64.CPACR.read.0" title="accessor: CPACRType CPACR[]"><ins>CPACR</ins></a><ins>[].ZEN of
            when 'x0'  disabled = TRUE;
            when '01'  disabled = PSTATE.EL == </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a><ins>;
            when '11'  disabled = FALSE;
        if disabled then</ins><del>&amp;&amp; !</del> <a href="shared_pseudocode.html#impl-aarch64.SVEAccessTrap.1" title="function: SVEAccessTrap(bits(2) target_el)"><ins>SVEAccessTrap</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a><ins>);

        // Check FP&amp;SIMD at EL0/EL1
        case</ins><del>) then
        first = 0;  last = 14;  include_R15 = FALSE;
    elsif PSTATE.EL IN {</del> <a href="shared_pseudocode.html#impl-aarch64.CPACR.read.0" title="accessor: CPACRType CPACR[]"><ins>CPACR</ins></a><ins>[].FPEN of
            when 'x0'  disabled = TRUE;
            when '01'  disabled = PSTATE.EL == </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a><ins>;
            when '11'  disabled = FALSE;
        if disabled then</ins><del>,</del> <a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)"><ins>AArch64.AdvSIMDFPAccessTrap</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a><ins>);

    if PSTATE.EL IN {</ins><del>} &amp;&amp;</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>, </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>, </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>} &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a><ins>() then
        if</ins><del>() &amp;&amp; !</del> <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><ins>HaveVirtHostExt</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><ins>() &amp;&amp; HCR_EL2.E2H == '1' then
            if CPTR_EL2.ZEN == 'x0' then</ins><del>(</del> <a href="shared_pseudocode.html#impl-aarch64.SVEAccessTrap.1" title="function: SVEAccessTrap(bits(2) target_el)"><ins>SVEAccessTrap</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a><ins>);
            if CPTR_EL2.FPEN == 'x0' then</ins><del>) then
        first = 0;  last = 30;  include_R15 = FALSE;
    else
        first = 0;  last = 30;  include_R15 = TRUE;

    for n = first to last
        if (n != 15 || include_R15) &amp;&amp;</del> <a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)"><ins>AArch64.AdvSIMDFPAccessTrap</ins></a><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><del>ConstrainUnpredictableBool</del></a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#Unpredictable_ZEROUPPER" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_ZEROUPPER</del></a><ins>);
        else
            if CPTR_EL2.TZ == '1' then</ins><del>) then
            _R[n]&lt;63:32> =</del> <a href="shared_pseudocode.html#impl-aarch64.SVEAccessTrap.1" title="function: SVEAccessTrap(bits(2) target_el)"><ins>SVEAccessTrap</ins></a><a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><del>Zeros</del></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>);
            if CPTR_EL2.TFP == '1' then </ins><a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)"><ins>AArch64.AdvSIMDFPAccessTrap</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>);

    // Check if access disabled in CPTR_EL3
    if </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) then
        if CPTR_EL3.EZ == '0' then </ins><a href="shared_pseudocode.html#impl-aarch64.SVEAccessTrap.1" title="function: SVEAccessTrap(bits(2) target_el)"><ins>SVEAccessTrap</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>);
        if CPTR_EL3.TFP == '1' then </ins><a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)"><ins>AArch64.AdvSIMDFPAccessTrap</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>);</ins><del>();

    return;</del></p></div><div class="ps" psname="aarch64.functions.sve.DecodePredCount"><a id="aarch64.functions.sve.DecodePredCount" name="aarch64.functions.sve.DecodePredCount"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>sve</ins><del>registers</del>/<ins>DecodePredCount</ins><del>AArch64.ResetGeneralRegisters</del></h3><p class="pseudocode"><ins>// DecodePredCount()
// =================

integer</ins><del>// AArch64.ResetGeneralRegisters()
// ===============================</del> <a id="impl-aarch64.DecodePredCount.2" name="impl-aarch64.DecodePredCount.2"></a><ins>DecodePredCount(bits(5) pattern, integer esize)
    integer elements = VL DIV esize;
    integer numElem;
    case pattern of
        when '00000' numElem =</ins><del>AArch64.ResetGeneralRegisters()

    for i = 0 to 30</del> <a href="shared_pseudocode.html#impl-aarch64.FloorPow2.1" title="function: integer FloorPow2(integer x)"><ins>FloorPow2</ins></a><a href="shared_pseudocode.html#impl-aarch64.X.write.1" title="accessor: X[integer n] = bits(width) value"><del>X</del></a><ins>(elements);
        when '00001' numElem = if elements >= 1 then 1 else 0;
        when '00010' numElem = if elements >= 2 then 2 else 0;
        when '00011' numElem = if elements >= 3 then 3 else 0;
        when '00100' numElem = if elements >= 4 then 4 else 0;
        when '00101' numElem = if elements >= 5 then 5 else 0;
        when '00110' numElem = if elements >= 6 then 6 else 0;
        when '00111' numElem = if elements >= 7 then 7 else 0;
        when '01000' numElem = if elements >= 8 then 8 else 0;
        when '01001' numElem = if elements >= 16 then 16 else 0;
        when '01010' numElem = if elements >= 32 then 32 else 0;
        when '01011' numElem = if elements >= 64 then 64 else 0;
        when '01100' numElem = if elements >= 128 then 128 else 0;
        when '01101' numElem = if elements >= 256 then 256 else 0;
        when '11101' numElem = elements - (elements MOD 4);
        when '11110' numElem = elements - (elements MOD 3);
        when '11111' numElem = elements;
        otherwise    numElem = 0;
    return numElem;</ins><del>[i] = bits(64) UNKNOWN;

    return;</del></p></div><div class="ps" psname="aarch64.functions.sve.ElemFFR"><a id="aarch64.functions.sve.ElemFFR" name="aarch64.functions.sve.ElemFFR"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>sve</ins><del>registers</del>/<ins>ElemFFR</ins><del>AArch64.ResetSIMDFPRegisters</del></h3><p class="pseudocode"><ins>// ElemFFR[] - non-assignment form
// ===============================

bit</ins><del>// AArch64.ResetSIMDFPRegisters()
// ==============================</del> <a id="impl-aarch64.ElemFFR.read.2" name="impl-aarch64.ElemFFR.read.2"></a><ins>ElemFFR[integer e, integer esize]
    return</ins><del>AArch64.ResetSIMDFPRegisters()

    for i = 0 to 31</del> <a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]"><ins>ElemP</ins></a><a href="shared_pseudocode.html#impl-aarch64.V.write.1" title="accessor: V[integer n] = bits(width) value"><del>V</del></a><ins>[_FFR, e, esize];

// ElemFFR[] - assignment form
// ===========================

</ins><a id="impl-aarch64.ElemFFR.write.2" name="impl-aarch64.ElemFFR.write.2"></a><ins>ElemFFR[integer e, integer esize] = bit value
    integer psize = esize DIV 8;
    integer n = e * psize;
    assert n >= 0 &amp;&amp; (n + psize) &lt;= PL;
    _FFR&lt;n+psize-1:n> = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><ins>ZeroExtend</ins></a><ins>(value, psize);
</ins><del>[i] = bits(128) UNKNOWN;

</del>    return;</p></div><div class="ps" psname="aarch64.functions.sve.ElemP"><a id="aarch64.functions.sve.ElemP" name="aarch64.functions.sve.ElemP"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>sve</ins><del>registers</del>/<ins>ElemP</ins><del>AArch64.ResetSpecialRegisters</del></h3><p class="pseudocode"><ins>// ElemP[] - non-assignment form
// =============================

bit</ins><del>// AArch64.ResetSpecialRegisters()
// ===============================</del> <a id="impl-aarch64.ElemP.read.3" name="impl-aarch64.ElemP.read.3"></a><ins>ElemP[bits(N) pred, integer e, integer esize]
    integer n = e * (esize DIV 8);
    assert n >= 0 &amp;&amp; n &lt; N;
    return pred&lt;n>;
</ins><del>AArch64.ResetSpecialRegisters()
</del>
<ins>// ElemP[] - assignment form
// =========================</ins><del>    // AArch64 special registers
    SP_EL0 = bits(64) UNKNOWN;
    SP_EL1 = bits(64) UNKNOWN;
    SPSR_EL1 = bits(32) UNKNOWN;
    ELR_EL1  = bits(64) UNKNOWN;
    if</del>

<a id="impl-aarch64.ElemP.write.3" name="impl-aarch64.ElemP.write.3"></a><ins>ElemP[bits(N) &amp;pred, integer e, integer esize] = bit value
    integer psize = esize DIV 8;
    integer n = e * psize;
    assert n >= 0 &amp;&amp; (n + psize) &lt;= N;
    pred&lt;n+psize-1:n> =</ins><del>(</del> <del>) then
        SP_EL2 = bits(64) UNKNOWN;
        SPSR_EL2 = bits(32) UNKNOWN;
        ELR_EL2  = bits(64) UNKNOWN;
    if </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) then
        SP_EL3 = bits(64) UNKNOWN;
        SPSR_EL3 = bits(32) UNKNOWN;
        ELR_EL3  = bits(64) UNKNOWN;

    // AArch32 special registers that are not architecturally mapped to AArch64 registers
    if </del><a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)"><del>HaveAArch32EL</del></a><del>(</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><ins>ZeroExtend</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>(value, psize);
</ins><del>) then
        SPSR_fiq = bits(32) UNKNOWN;
        SPSR_irq = bits(32) UNKNOWN;
        SPSR_abt = bits(32) UNKNOWN;
        SPSR_und = bits(32) UNKNOWN;

    // External debug special registers
    DLR_EL0 = bits(64) UNKNOWN;
    DSPSR_EL0 = bits(32) UNKNOWN;

</del>    return;</p></div><div class="ps" psname="aarch64.functions.sve.FFR"><a id="aarch64.functions.sve.FFR" name="aarch64.functions.sve.FFR"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>sve</ins><del>registers</del>/<ins>FFR</ins><del>AArch64.ResetSystemRegisters</del></h3><p class="pseudocode"><ins>// FFR[] - non-assignment form
// ===========================

bits(width) </ins><a id="impl-aarch64.FFR.read.0" name="impl-aarch64.FFR.read.0"></a><ins>FFR[]
    assert width == PL;
    return _FFR&lt;width-1:0>;

// FFR[] - assignment form
// =======================

</ins><a id="impl-aarch64.FFR.write.0" name="impl-aarch64.FFR.write.0"></a><ins>FFR[] = bits(width) value
    assert width == PL;
    if </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><ins>ConstrainUnpredictableBool</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_SVEZEROUPPER" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_SVEZEROUPPER</ins></a><ins>) then
        _FFR = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(value);
    else
        _FFR&lt;width-1:0> = value;</ins><del>AArch64.ResetSystemRegisters(boolean cold_reset);</del></p></div><div class="ps" psname="aarch64.functions.sve.FPCompareNE"><a id="aarch64.functions.sve.FPCompareNE" name="aarch64.functions.sve.FPCompareNE"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>sve</ins><del>registers</del>/<ins>FPCompareNE</ins><del>PC</del></h3><p class="pseudocode"><ins>// FPCompareNE()
// =============
</ins><del>// PC - non-assignment form
// ========================
// Read program counter.
</del>
<ins>boolean</ins><del>bits(64)</del> <a id="impl-aarch64.FPCompareNE.3" name="impl-aarch64.FPCompareNE.3"></a><ins>FPCompareNE(bits(N) op1, bits(N) op2,</ins><del>PC[]
    return _PC;</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><ins>FPCRType</ins></a><ins> fpcr)
    assert N IN {16,32,64};
    (type1,sign1,value1) = </ins><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><ins>(op1, fpcr);
    (type2,sign2,value2) = </ins><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><ins>(op2, fpcr);
    if type1==</ins><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><ins> || type1==</ins><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><ins> || type2==</ins><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><ins> || type2==</ins><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><ins> then
        result = TRUE;
        if type1==</ins><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><ins> || type2==</ins><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><ins> then
            </ins><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><ins>(</ins><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_InvalidOp</ins></a><ins>, fpcr);
    else // All non-NaN cases can be evaluated on the values produced by FPUnpack()
        result = (value1 != value2);
    return result;</ins></p></div><div class="ps" psname="aarch64.functions.sve.FPCompareUN"><a id="aarch64.functions.sve.FPCompareUN" name="aarch64.functions.sve.FPCompareUN"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>sve</ins><del>registers</del>/<ins>FPCompareUN</ins><del>SP</del></h3><p class="pseudocode"><ins>// FPCompareUN()
// =============

boolean</ins><del>// SP[] - assignment form
// ======================
// Write to stack pointer from either a 32-bit or a 64-bit value.</del> <a id="impl-aarch64.FPCompareUN.3" name="impl-aarch64.FPCompareUN.3"></a><ins>FPCompareUN(bits(N) op1, bits(N) op2,</ins><del>SP[] = bits(width) value
    assert width IN {32,64};
    if PSTATE.SP == '0' then
        SP_EL0 =</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><ins>FPCRType</ins></a><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a> <ins>fpcr)
    assert N IN {16,32,64};
    (type1,sign1,value1) =</ins><del>(value);
    else
        case PSTATE.EL of
            when</del> <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>(op1, fpcr);
    (type2,sign2,value2) =</ins><del>SP_EL0 =</del> <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><ins>(op2, fpcr);
    if type1==</ins><del>(value);
            when</del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a> <ins>|| type2==</ins><del>SP_EL1 =</del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a> <ins>then</ins><del>(value);
            when</del>
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>(</ins><del>SP_EL2 =</del><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_InvalidOp</ins></a><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><ins>, fpcr);
    return (type1==</ins><del>(value);
            when</del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a> <ins>|| type1==</ins><del>SP_EL3 =</del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a> <ins>|| type2==</ins><del>(value);
    return;

// SP[] - non-assignment form
// ==========================
// Read stack pointer with implicit slice of 8, 16, 32 or 64 bits.

bits(width)</del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a> <ins>|| type2==</ins><del>SP[]
    assert width IN {8,16,32,64};
    if PSTATE.SP == '0' then
        return SP_EL0&lt;width-1:0>;
    else
        case PSTATE.EL of
            when</del><del>  return SP_EL0&lt;width-1:0>;
            when </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>  return SP_EL1&lt;width-1:0>;
            when </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>  return SP_EL2&lt;width-1:0>;
            when </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>);</ins><del>return SP_EL3&lt;width-1:0>;</del></p></div><div class="ps" psname="aarch64.functions.sve.FPConvertSVE"><a id="aarch64.functions.sve.FPConvertSVE" name="aarch64.functions.sve.FPConvertSVE"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>sve</ins><del>registers</del>/<ins>FPConvertSVE</ins><del>V</del></h3><p class="pseudocode"><ins>// FPConvertSVE()
// ==============

bits(M)</ins><del>// V[] - assignment form
// =====================</del> <a id="impl-aarch64.FPConvertSVE.3" name="impl-aarch64.FPConvertSVE.3"></a><ins>FPConvertSVE(bits(N) op,</ins><del>V[integer n] = bits(width) value
    assert n >= 0 &amp;&amp; n &lt;= 31;
    assert width IN {8,16,32,64,128};
    integer vlen = if</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><ins>FPCRType</ins></a><a href="shared_pseudocode.html#impl-aarch64.IsSVEEnabled.1" title="function: boolean IsSVEEnabled(bits(2) el)"><del>IsSVEEnabled</del></a> <ins>fpcr,</ins><del>(PSTATE.EL) then VL else 128;
    if</del> <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding</ins></a><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><del>ConstrainUnpredictableBool</del></a> <ins>rounding)
    fpcr.AHP = '0';
    return</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.FPConvert.3" title="function: bits(M) FPConvert(bits(N) op, FPCRType fpcr, FPRounding rounding)"><ins>FPConvert</ins></a><a href="shared_pseudocode.html#Unpredictable_SVEZEROUPPER" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_SVEZEROUPPER</del></a><ins>(op, fpcr, rounding);

// FPConvertSVE()
// ==============

bits(M)</ins><del>) then
        _Z[n] =</del> <a id="impl-aarch64.FPConvertSVE.2" name="impl-aarch64.FPConvertSVE.2"></a><ins>FPConvertSVE(bits(N) op,</ins><del>(value);
    else
        _Z[n]&lt;vlen-1:0> =</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><ins>FPCRType</ins></a><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a> <ins>fpcr)
    fpcr.AHP = '0';
    return</ins><del>(value);

// V[] - non-assignment form
// =========================

bits(width)</del> <a href="shared_pseudocode.html#impl-shared.FPConvert.3" title="function: bits(M) FPConvert(bits(N) op, FPCRType fpcr, FPRounding rounding)"><ins>FPConvert</ins></a><ins>(op, fpcr, </ins><a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)"><ins>FPRoundingMode</ins></a><ins>(fpcr));</ins><del>V[integer n]
    assert n >= 0 &amp;&amp; n &lt;= 31;
    assert width IN {8,16,32,64,128};
    return _Z[n]&lt;width-1:0>;</del></p></div><div class="ps" psname="aarch64.functions.sve.FPExpA"><a id="aarch64.functions.sve.FPExpA" name="aarch64.functions.sve.FPExpA"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>sve</ins><del>registers</del>/<ins>FPExpA</ins><del>Vpart</del></h3><p class="pseudocode"><ins>// FPExpA()
// ========
</ins><del>// Vpart[] - non-assignment form
// =============================
</del>
<ins>bits(N)</ins><del>bits(width)</del> <a id="impl-aarch64.FPExpA.1" name="impl-aarch64.FPExpA.1"></a><ins>FPExpA(bits(N) op)
    assert N IN {16,32,64};
    bits(N) result;
    bits(N) coeff;
    integer idx = if N == 16 then</ins><del>Vpart[integer n, integer part]
    assert n >= 0 &amp;&amp; n &lt;= 31;
    assert part IN {0, 1};
    if part == 0 then
        assert width IN {8,16,32,64};
        return</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#impl-aarch64.V.read.1" title="accessor: bits(width) V[integer n]"><del>V</del></a><ins>(op&lt;4:0>) else</ins><del>[n];
    else
        assert width == 64;
        return _V[n]&lt;(width * 2)-1:width>;

// Vpart[] - assignment form
// =========================</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(op&lt;5:0>);
    coeff =</ins><del>Vpart[integer n, integer part] = bits(width) value
    assert n >= 0 &amp;&amp; n &lt;= 31;
    assert part IN {0, 1};
    if part == 0 then
        assert width IN {8,16,32,64};</del> <del>[n] = value;
    else
        assert width == 64;
        bits(64) vreg = </del><a href="shared_pseudocode.html#impl-aarch64.V.read.1" title="accessor: bits(width) V[integer n]"><del>V</del></a><del>[n];
        </del><a href="shared_pseudocode.html#impl-aarch64.V.write.1" title="accessor: V[integer n] = bits(width) value"><del>V</del></a><a href="shared_pseudocode.html#impl-aarch64.FPExpCoefficient.read.1" title="accessor: bits(N) FPExpCoefficient[integer index]"><ins>FPExpCoefficient</ins></a><a href="shared_pseudocode.html#impl-aarch64.V.write.1" title="accessor: V[integer n] = bits(width) value"><del>V</del></a><ins>[idx];
    if N == 16 then
        result&lt;15:0> = '0':op&lt;9:5>:coeff&lt;9:0>;
    elsif N == 32 then
        result&lt;31:0> = '0':op&lt;13:6>:coeff&lt;22:0>;
    else // N == 64
        result&lt;63:0> = '0':op&lt;16:6>:coeff&lt;51:0>;

    return result;</ins><del>[n] = value&lt;63:0> : vreg;</del></p></div><div class="ps" psname="aarch64.functions.sve.FPExpCoefficient"><a id="aarch64.functions.sve.FPExpCoefficient" name="aarch64.functions.sve.FPExpCoefficient"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>sve</ins><del>registers</del>/<ins>FPExpCoefficient</ins><del>X</del></h3><p class="pseudocode"><ins>// FPExpCoefficient()
// ==================

bits(N)</ins><del>// X[] - assignment form
// =====================
// Write to general-purpose register from either a 32-bit or a 64-bit value.</del> <a id="impl-aarch64.FPExpCoefficient.read.1" name="impl-aarch64.FPExpCoefficient.read.1"></a><ins>FPExpCoefficient[integer index]
    assert N IN {16,32,64};
    integer result;

    if N == 16 then
        case index of
            when  0 result = 0x0000;
            when  1 result = 0x0016;
            when  2 result = 0x002d;
            when  3 result = 0x0045;
            when  4 result = 0x005d;
            when  5 result = 0x0075;
            when  6 result = 0x008e;
            when  7 result = 0x00a8;
            when  8 result = 0x00c2;
            when  9 result = 0x00dc;
            when 10 result = 0x00f8;
            when 11 result = 0x0114;
            when 12 result = 0x0130;
            when 13 result = 0x014d;
            when 14 result = 0x016b;
            when 15 result = 0x0189;
            when 16 result = 0x01a8;
            when 17 result = 0x01c8;
            when 18 result = 0x01e8;
            when 19 result = 0x0209;
            when 20 result = 0x022b;
            when 21 result = 0x024e;
            when 22 result = 0x0271;
            when 23 result = 0x0295;
            when 24 result = 0x02ba;
            when 25 result = 0x02e0;
            when 26 result = 0x0306;
            when 27 result = 0x032e;
            when 28 result = 0x0356;
            when 29 result = 0x037f;
            when 30 result = 0x03a9;
            when 31 result = 0x03d4;

    elsif N == 32 then
        case index of
            when  0 result = 0x000000;
            when  1 result = 0x0164d2;
            when  2 result = 0x02cd87;
            when  3 result = 0x043a29;
            when  4 result = 0x05aac3;
            when  5 result = 0x071f62;
            when  6 result = 0x08980f;
            when  7 result = 0x0a14d5;
            when  8 result = 0x0b95c2;
            when  9 result = 0x0d1adf;
            when 10 result = 0x0ea43a;
            when 11 result = 0x1031dc;
            when 12 result = 0x11c3d3;
            when 13 result = 0x135a2b;
            when 14 result = 0x14f4f0;
            when 15 result = 0x16942d;
            when 16 result = 0x1837f0;
            when 17 result = 0x19e046;
            when 18 result = 0x1b8d3a;
            when 19 result = 0x1d3eda;
            when 20 result = 0x1ef532;
            when 21 result = 0x20b051;
            when 22 result = 0x227043;
            when 23 result = 0x243516;
            when 24 result = 0x25fed7;
            when 25 result = 0x27cd94;
            when 26 result = 0x29a15b;
            when 27 result = 0x2b7a3a;
            when 28 result = 0x2d583f;
            when 29 result = 0x2f3b79;
            when 30 result = 0x3123f6;
            when 31 result = 0x3311c4;
            when 32 result = 0x3504f3;
            when 33 result = 0x36fd92;
            when 34 result = 0x38fbaf;
            when 35 result = 0x3aff5b;
            when 36 result = 0x3d08a4;
            when 37 result = 0x3f179a;
            when 38 result = 0x412c4d;
            when 39 result = 0x4346cd;
            when 40 result = 0x45672a;
            when 41 result = 0x478d75;
            when 42 result = 0x49b9be;
            when 43 result = 0x4bec15;
            when 44 result = 0x4e248c;
            when 45 result = 0x506334;
            when 46 result = 0x52a81e;
            when 47 result = 0x54f35b;
            when 48 result = 0x5744fd;
            when 49 result = 0x599d16;
            when 50 result = 0x5bfbb8;
            when 51 result = 0x5e60f5;
            when 52 result = 0x60ccdf;
            when 53 result = 0x633f89;
            when 54 result = 0x65b907;
            when 55 result = 0x68396a;
            when 56 result = 0x6ac0c7;
            when 57 result = 0x6d4f30;
            when 58 result = 0x6fe4ba;
            when 59 result = 0x728177;
            when 60 result = 0x75257d;
            when 61 result = 0x77d0df;
            when 62 result = 0x7a83b3;
            when 63 result = 0x7d3e0c;

    else // N == 64
        case index of
            when  0 result = 0x0000000000000;
            when  1 result = 0x02C9A3E778061;
            when  2 result = 0x059B0D3158574;
            when  3 result = 0x0874518759BC8;
            when  4 result = 0x0B5586CF9890F;
            when  5 result = 0x0E3EC32D3D1A2;
            when  6 result = 0x11301D0125B51;
            when  7 result = 0x1429AAEA92DE0;
            when  8 result = 0x172B83C7D517B;
            when  9 result = 0x1A35BEB6FCB75;
            when 10 result = 0x1D4873168B9AA;
            when 11 result = 0x2063B88628CD6;
            when 12 result = 0x2387A6E756238;
            when 13 result = 0x26B4565E27CDD;
            when 14 result = 0x29E9DF51FDEE1;
            when 15 result = 0x2D285A6E4030B;
            when 16 result = 0x306FE0A31B715;
            when 17 result = 0x33C08B26416FF;
            when 18 result = 0x371A7373AA9CB;
            when 19 result = 0x3A7DB34E59FF7;
            when 20 result = 0x3DEA64C123422;
            when 21 result = 0x4160A21F72E2A;
            when 22 result = 0x44E086061892D;
            when 23 result = 0x486A2B5C13CD0;
            when 24 result = 0x4BFDAD5362A27;
            when 25 result = 0x4F9B2769D2CA7;
            when 26 result = 0x5342B569D4F82;
            when 27 result = 0x56F4736B527DA;
            when 28 result = 0x5AB07DD485429;
            when 29 result = 0x5E76F15AD2148;
            when 30 result = 0x6247EB03A5585;
            when 31 result = 0x6623882552225;
            when 32 result = 0x6A09E667F3BCD;
            when 33 result = 0x6DFB23C651A2F;
            when 34 result = 0x71F75E8EC5F74;
            when 35 result = 0x75FEB564267C9;
            when 36 result = 0x7A11473EB0187;
            when 37 result = 0x7E2F336CF4E62;
            when 38 result = 0x82589994CCE13;
            when 39 result = 0x868D99B4492ED;
            when 40 result = 0x8ACE5422AA0DB;
            when 41 result = 0x8F1AE99157736;
            when 42 result = 0x93737B0CDC5E5;
            when 43 result = 0x97D829FDE4E50;
            when 44 result = 0x9C49182A3F090;
            when 45 result = 0xA0C667B5DE565;
            when 46 result = 0xA5503B23E255D;
            when 47 result = 0xA9E6B5579FDBF;
            when 48 result = 0xAE89F995AD3AD;
            when 49 result = 0xB33A2B84F15FB;
            when 50 result = 0xB7F76F2FB5E47;
            when 51 result = 0xBCC1E904BC1D2;
            when 52 result = 0xC199BDD85529C;
            when 53 result = 0xC67F12E57D14B;
            when 54 result = 0xCB720DCEF9069;
            when 55 result = 0xD072D4A07897C;
            when 56 result = 0xD5818DCFBA487;
            when 57 result = 0xDA9E603DB3285;
            when 58 result = 0xDFC97337B9B5F;
            when 59 result = 0xE502EE78B3FF6;
            when 60 result = 0xEA4AFA2A490DA;
            when 61 result = 0xEFA1BEE615A27;
            when 62 result = 0xF50765B6E4540;
            when 63 result = 0xFA7C1819E90D8;

    return result&lt;N-1:0>;</ins><del>X[integer n] = bits(width) value
    assert n >= 0 &amp;&amp; n &lt;= 31;
    assert width IN {32,64};
    if n != 31 then
        _R[n] =</del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><del>(value);
    return;

// X[] - non-assignment form
// =========================
// Read from general-purpose register with implicit slice of 8, 16, 32 or 64 bits.

bits(width) </del><a id="impl-aarch64.X.read.1" name="impl-aarch64.X.read.1"></a><del>X[integer n]
    assert n >= 0 &amp;&amp; n &lt;= 31;
    assert width IN {8,16,32,64};
    if n != 31 then
        return _R[n]&lt;width-1:0>;
    else
        return </del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(width);</del></p></div><div class="ps" psname="aarch64.functions.sve.FPMinNormal"><a id="aarch64.functions.sve.FPMinNormal" name="aarch64.functions.sve.FPMinNormal"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>FPMinNormal</ins><del>AArch32.IsFPEnabled</del></h3><p class="pseudocode"><ins>// FPMinNormal()
// =============
</ins><del>// AArch32.IsFPEnabled()
// =====================
</del>
<ins>bits(N)</ins><del>boolean</del> <a id="impl-aarch64.FPMinNormal.1" name="impl-aarch64.FPMinNormal.1"></a><ins>FPMinNormal(bit sign)
    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp =</ins><del>AArch32.IsFPEnabled(bits(2) el)
    if el ==</del> <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>(E-1):'1';
    frac =</ins><del>&amp;&amp; !</del> <del>(</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>) then
        return </del><a href="shared_pseudocode.html#AArch64.IsFPEnabled.1" title="function: boolean AArch64.IsFPEnabled(bits(2) el)"><del>AArch64.IsFPEnabled</del></a><del>(el);

    if </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>() then
        // Check if access disabled in NSACR
        if NSACR.cp10 == '0' then return FALSE;

    if el IN {</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>, </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>} then
        // Check if access disabled in CPACR
        case CPACR.cp10 of
            when 'x0' disabled = TRUE;
            when '01' disabled = (el == </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>);
            when '11' disabled = FALSE;
        if disabled then return FALSE;

    if el IN {</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>, </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>, </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>} then
        if </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() then
            if !</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) then
                if CPTR_EL2.TFP == '1' then return FALSE;
            else
                if HCPTR.TCP10 == '1' then return FALSE;

    if </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><ins>(F);
    return sign : exp : frac;</ins><del>) then
        // Check if access disabled in CPTR_EL3
        if CPTR_EL3.TFP == '1' then return FALSE;

    return TRUE;</del></p></div><div class="ps" psname="aarch64.functions.sve.FPOne"><a id="aarch64.functions.sve.FPOne" name="aarch64.functions.sve.FPOne"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>FPOne</ins><del>AArch64.IsFPEnabled</del></h3><p class="pseudocode"><ins>// FPOne()
// =======
</ins><del>// AArch64.IsFPEnabled()
// =====================
</del>
<ins>bits(N)</ins><del>boolean</del> <a id="impl-aarch64.FPOne.1" name="impl-aarch64.FPOne.1"></a><ins>FPOne(bit sign)
    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp = '0':</ins><del>AArch64.IsFPEnabled(bits(2) el)
    // Check if access disabled in CPACR_EL1
    if el IN {</del><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>(E-1);
    frac =</ins><del>,</del> <del>} then
        // Check FP&amp;SIMD at EL0/EL1
        case </del><a href="shared_pseudocode.html#impl-aarch64.CPACR.read.0" title="accessor: CPACRType CPACR[]"><del>CPACR</del></a><del>[].FPEN of
            when 'x0' disabled = TRUE;
            when '01' disabled = (el == </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>);
            when '11' disabled = FALSE;
        if disabled then return FALSE;

    // Check if access disabled in CPTR_EL2
    if el IN {</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>, </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>, </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>} &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() then
        if </del><a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><del>HaveVirtHostExt</del></a><del>() &amp;&amp; HCR_EL2.E2H == '1' then
            if CPTR_EL2.FPEN == 'x0' then return FALSE;
        else
            if CPTR_EL2.TFP == '1' then return FALSE;

    // Check if access disabled in CPTR_EL3
    if </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>(F);
    return sign : exp : frac;</ins><del>) then
        if CPTR_EL3.TFP == '1' then return FALSE;

    return TRUE;</del></p></div><div class="ps" psname="aarch64.functions.sve.FPPointFive"><a id="aarch64.functions.sve.FPPointFive" name="aarch64.functions.sve.FPPointFive"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>FPPointFive</ins><del>CeilPow2</del></h3><p class="pseudocode"><ins>// FPPointFive()
// =============
</ins><del>// CeilPow2()
// ==========
</del>
<ins>bits(N)</ins><del>// For a positive integer X, return the smallest power of 2 >= X

integer</del> <a id="impl-aarch64.FPPointFive.1" name="impl-aarch64.FPPointFive.1"></a><ins>FPPointFive(bit sign)
    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp = '0':</ins><del>CeilPow2(integer x)
    if x == 0 then return 0;
    if x == 1 then return 2;
    return</del><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><a href="shared_pseudocode.html#impl-aarch64.FloorPow2.1" title="function: integer FloorPow2(integer x)"><del>FloorPow2</del></a><ins>(E-2):'0';
    frac = </ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(F);
    return sign : exp : frac;</ins><del>(x - 1) * 2;</del></p></div><div class="ps" psname="aarch64.functions.sve.FPProcess"><a id="aarch64.functions.sve.FPProcess" name="aarch64.functions.sve.FPProcess"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>FPProcess</ins><del>CheckSVEEnabled</del></h3><p class="pseudocode"><ins>// FPProcess()
// ===========

bits(N)</ins><del>// CheckSVEEnabled()
// =================</del> <a id="impl-aarch64.FPProcess.1" name="impl-aarch64.FPProcess.1"></a><ins>FPProcess(bits(N) input)
    bits(N) result;
    assert N IN {16,32,64};
    (type,sign,value) =</ins><del>CheckSVEEnabled()
    // Check if access disabled in CPACR_EL1
    if PSTATE.EL IN {</del> <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>(input, FPCR);
    if type ==</ins><del>,</del> <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a> <ins>|| type ==</ins><del>} then
        // Check SVE at EL0/EL1
        case</del> <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><a href="shared_pseudocode.html#impl-aarch64.CPACR.read.0" title="accessor: CPACRType CPACR[]"><del>CPACR</del></a> <ins>then
        result =</ins><del>[].ZEN of
            when 'x0'  disabled = TRUE;
            when '01'  disabled = PSTATE.EL ==</del> <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><ins>FPProcessNaN</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>(type, input, FPCR);
    elsif type ==</ins><del>;
            when '11'  disabled = FALSE;
        if disabled then</del> <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><a href="shared_pseudocode.html#impl-aarch64.SVEAccessTrap.1" title="function: SVEAccessTrap(bits(2) target_el)"><del>SVEAccessTrap</del></a> <ins>then
        result =</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><ins>FPInfinity</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>(sign);
    elsif type ==</ins><del>);

        // Check FP&amp;SIMD at EL0/EL1
        case</del> <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><a href="shared_pseudocode.html#impl-aarch64.CPACR.read.0" title="accessor: CPACRType CPACR[]"><del>CPACR</del></a> <ins>then
        result =</ins><del>[].FPEN of
            when 'x0'  disabled = TRUE;
            when '01'  disabled = PSTATE.EL ==</del> <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><ins>FPZero</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>(sign);
    else
        result =</ins><del>;
            when '11'  disabled = FALSE;
        if disabled then</del> <del>(</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>);

    if PSTATE.EL IN {</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>, </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>, </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>} &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() then
        if </del><a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><del>HaveVirtHostExt</del></a><del>() &amp;&amp; HCR_EL2.E2H == '1' then
            if CPTR_EL2.ZEN == 'x0' then </del><a href="shared_pseudocode.html#impl-aarch64.SVEAccessTrap.1" title="function: SVEAccessTrap(bits(2) target_el)"><del>SVEAccessTrap</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>);
            if CPTR_EL2.FPEN == 'x0' then </del><a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)"><del>AArch64.AdvSIMDFPAccessTrap</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>);
        else
            if CPTR_EL2.TZ == '1' then </del><a href="shared_pseudocode.html#impl-aarch64.SVEAccessTrap.1" title="function: SVEAccessTrap(bits(2) target_el)"><del>SVEAccessTrap</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>);
            if CPTR_EL2.TFP == '1' then </del><a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)"><del>AArch64.AdvSIMDFPAccessTrap</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>);

    // Check if access disabled in CPTR_EL3
    if </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) then
        if CPTR_EL3.EZ == '0' then </del><a href="shared_pseudocode.html#impl-aarch64.SVEAccessTrap.1" title="function: SVEAccessTrap(bits(2) target_el)"><del>SVEAccessTrap</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>);
        if CPTR_EL3.TFP == '1' then </del><a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)"><del>AArch64.AdvSIMDFPAccessTrap</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><a href="shared_pseudocode.html#impl-shared.FPRound.2" title="function: bits(N) FPRound(real op, FPCRType fpcr)"><ins>FPRound</ins></a><a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)"><del>AArch64.AdvSIMDFPAccessTrap</del></a><ins>(value, FPCR);
    return result;</ins><del>);</del></p></div><div class="ps" psname="aarch64.functions.sve.FPScale"><a id="aarch64.functions.sve.FPScale" name="aarch64.functions.sve.FPScale"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>FPScale</ins><del>DecodePredCount</del></h3><p class="pseudocode"><ins>// FPScale()
// =========
</ins><del>// DecodePredCount()
// =================
</del>
<ins>bits(N)</ins><del>integer</del> <a id="impl-aarch64.FPScale.3" name="impl-aarch64.FPScale.3"></a><ins>FPScale(bits (N) op, integer scale,</ins><del>DecodePredCount(bits(5) pattern, integer esize)
    integer elements = VL DIV esize;
    integer numElem;
    case pattern of
        when '00000' numElem =</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><ins>FPCRType</ins></a><a href="shared_pseudocode.html#impl-aarch64.FloorPow2.1" title="function: integer FloorPow2(integer x)"><del>FloorPow2</del></a><ins> fpcr)
    assert N IN {16,32,64};
    (type,sign,value) = </ins><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><ins>(op, fpcr);
    if type == </ins><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><ins> || type == </ins><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><ins> then
        result = </ins><a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><ins>FPProcessNaN</ins></a><ins>(type, op, fpcr);
    elsif type == </ins><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><ins> then
        result = </ins><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><ins>FPZero</ins></a><ins>(sign);
    elsif type == </ins><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><ins> then
        result = </ins><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><ins>FPInfinity</ins></a><ins>(sign);
    else
        result = </ins><a href="shared_pseudocode.html#impl-shared.FPRound.2" title="function: bits(N) FPRound(real op, FPCRType fpcr)"><ins>FPRound</ins></a><ins>(value * (2.0^scale), fpcr);
    return result;</ins><del>(elements);
        when '00001' numElem = if elements >= 1 then 1 else 0;
        when '00010' numElem = if elements >= 2 then 2 else 0;
        when '00011' numElem = if elements >= 3 then 3 else 0;
        when '00100' numElem = if elements >= 4 then 4 else 0;
        when '00101' numElem = if elements >= 5 then 5 else 0;
        when '00110' numElem = if elements >= 6 then 6 else 0;
        when '00111' numElem = if elements >= 7 then 7 else 0;
        when '01000' numElem = if elements >= 8 then 8 else 0;
        when '01001' numElem = if elements >= 16 then 16 else 0;
        when '01010' numElem = if elements >= 32 then 32 else 0;
        when '01011' numElem = if elements >= 64 then 64 else 0;
        when '01100' numElem = if elements >= 128 then 128 else 0;
        when '01101' numElem = if elements >= 256 then 256 else 0;
        when '11101' numElem = elements - (elements MOD 4);
        when '11110' numElem = elements - (elements MOD 3);
        when '11111' numElem = elements;
        otherwise    numElem = 0;
    return numElem;</del></p></div><div class="ps" psname="aarch64.functions.sve.FPTrigMAdd"><a id="aarch64.functions.sve.FPTrigMAdd" name="aarch64.functions.sve.FPTrigMAdd"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>FPTrigMAdd</ins><del>ElemFFR</del></h3><p class="pseudocode"><ins>// FPTrigMAdd()
// ============
</ins><del>// ElemFFR[] - non-assignment form
// ===============================
</del>
<ins>bits(N)</ins><del>bit</del> <a id="impl-aarch64.FPTrigMAdd.4" name="impl-aarch64.FPTrigMAdd.4"></a><ins>FPTrigMAdd(integer x, bits(N) op1, bits(N) op2,</ins><del>ElemFFR[integer e, integer esize]
    return</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><ins>FPCRType</ins></a><a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]"><del>ElemP</del></a> <ins>fpcr)
    assert N IN {16,32,64};
    assert x >= 0;
    assert x &lt; 8;
    bits(N) coeff;
</ins><del>[_FFR, e, esize];
</del>
<ins>    if op2&lt;N-1> == '1' then
        x = x + 8;
    op2&lt;N-1> = '0';

    coeff =</ins><del>// ElemFFR[] - assignment form
// ===========================</del> <a href="shared_pseudocode.html#impl-aarch64.FPTrigMAddCoefficient.read.1" title="accessor: bits(N) FPTrigMAddCoefficient[integer index]"><ins>FPTrigMAddCoefficient</ins></a><ins>[x];
    result =</ins><del>ElemFFR[integer e, integer esize] = bit value
    integer psize = esize DIV 8;
    integer n = e * psize;
    assert n >= 0 &amp;&amp; (n + psize) &lt;= PL;
    _FFR&lt;n+psize-1:n> =</del> <a href="shared_pseudocode.html#impl-shared.FPMulAdd.4" title="function: bits(N) FPMulAdd(bits(N) addend, bits(N) op1, bits(N) op2, FPCRType fpcr)"><ins>FPMulAdd</ins></a><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><del>ZeroExtend</del></a><ins>(coeff, op1, op2, fpcr);

    return result;</ins><del>(value, psize);
    return;</del></p></div><div class="ps" psname="aarch64.functions.sve.FPTrigMAddCoefficient"><a id="aarch64.functions.sve.FPTrigMAddCoefficient" name="aarch64.functions.sve.FPTrigMAddCoefficient"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>FPTrigMAddCoefficient</ins><del>ElemP</del></h3><p class="pseudocode"><ins>// FPTrigMAddCoefficient()
// =======================
</ins><del>// ElemP[] - non-assignment form
// =============================
</del>
<ins>bits(N)</ins><del>bit</del> <a id="impl-aarch64.FPTrigMAddCoefficient.read.1" name="impl-aarch64.FPTrigMAddCoefficient.read.1"></a><ins>FPTrigMAddCoefficient[integer index]
    assert N IN {16,32,64};
    integer result;
</ins><del>ElemP[bits(N) pred, integer e, integer esize]
    integer n = e * (esize DIV 8);
    assert n >= 0 &amp;&amp; n &lt; N;
    return pred&lt;n>;
</del>
<ins>    if N == 16 then
        case index of
            when  0 result = 0x3c00;
            when  1 result = 0xb155;
            when  2 result = 0x2030;
            when  3 result = 0x0000;
            when  4 result = 0x0000;
            when  5 result = 0x0000;
            when  6 result = 0x0000;
            when  7 result = 0x0000;
            when  8 result = 0x3c00;
            when  9 result = 0xb800;
            when 10 result = 0x293a;
            when 11 result = 0x0000;
            when 12 result = 0x0000;
            when 13 result = 0x0000;
            when 14 result = 0x0000;
            when 15 result = 0x0000;
    elsif N == 32 then
        case index of
            when  0 result = 0x3f800000;
            when  1 result = 0xbe2aaaab;
            when  2 result = 0x3c088886;
            when  3 result = 0xb95008b9;
            when  4 result = 0x36369d6d;
            when  5 result = 0x00000000;
            when  6 result = 0x00000000;
            when  7 result = 0x00000000;
            when  8 result = 0x3f800000;
            when  9 result = 0xbf000000;
            when 10 result = 0x3d2aaaa6;
            when 11 result = 0xbab60705;
            when 12 result = 0x37cd37cc;
            when 13 result = 0x00000000;
            when 14 result = 0x00000000;
            when 15 result = 0x00000000;
    else // N == 64
        case index of
            when  0 result = 0x3ff0000000000000;
            when  1 result = 0xbfc5555555555543;
            when  2 result = 0x3f8111111110f30c;
            when  3 result = 0xbf2a01a019b92fc6;
            when  4 result = 0x3ec71de351f3d22b;
            when  5 result = 0xbe5ae5e2b60f7b91;
            when  6 result = 0x3de5d8408868552f;
            when  7 result = 0x0000000000000000;
            when  8 result = 0x3ff0000000000000;
            when  9 result = 0xbfe0000000000000;
            when 10 result = 0x3fa5555555555536;
            when 11 result = 0xbf56c16c16c13a0b;
            when 12 result = 0x3efa01a019b1e8d8;
            when 13 result = 0xbe927e4f7282f468;
            when 14 result = 0x3e21ee96d2641b13;
            when 15 result = 0xbda8f76380fbb401;

    return result&lt;N-1:0>;</ins><del>// ElemP[] - assignment form
// =========================</del><a id="impl-aarch64.ElemP.write.3" name="impl-aarch64.ElemP.write.3"></a><del>ElemP[bits(N) &amp;pred, integer e, integer esize] = bit value
    integer psize = esize DIV 8;
    integer n = e * psize;
    assert n >= 0 &amp;&amp; (n + psize) &lt;= N;
    pred&lt;n+psize-1:n> = </del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><del>ZeroExtend</del></a><del>(value, psize);
    return;</del></p></div><div class="ps" psname="aarch64.functions.sve.FPTrigSMul"><a id="aarch64.functions.sve.FPTrigSMul" name="aarch64.functions.sve.FPTrigSMul"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>FPTrigSMul</ins><del>FFR</del></h3><p class="pseudocode"><ins>// FPTrigSMul()
// ============
</ins><del>// FFR[] - non-assignment form
// ===========================
</del>
<ins>bits(N)</ins><del>bits(width)</del> <a id="impl-aarch64.FPTrigSMul.3" name="impl-aarch64.FPTrigSMul.3"></a><ins>FPTrigSMul(bits(N) op1, bits(N) op2,</ins><del>FFR[]
    assert width == PL;
    return _FFR&lt;width-1:0>;

// FFR[] - assignment form
// =======================</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><ins>FPCRType</ins></a> <ins>fpcr)
    assert N IN {16,32,64};
    result =</ins><del>FFR[] = bits(width) value
    assert width == PL;
    if</del> <a href="shared_pseudocode.html#impl-shared.FPMul.3" title="function: bits(N) FPMul(bits(N) op1, bits(N) op2, FPCRType fpcr)"><ins>FPMul</ins></a><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><del>ConstrainUnpredictableBool</del></a><ins>(op1, op1, fpcr);
    (type, sign, value) =</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><a href="shared_pseudocode.html#Unpredictable_SVEZEROUPPER" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_SVEZEROUPPER</del></a><ins>(result, fpcr);
    if (type !=</ins><del>) then
        _FFR =</del> <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><ins>) &amp;&amp; (type != </ins><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><ins>) then
        result&lt;N-1> = op2&lt;0>;

    return result;</ins><del>(value);
    else
        _FFR&lt;width-1:0> = value;</del></p></div><div class="ps" psname="aarch64.functions.sve.FPTrigSSel"><a id="aarch64.functions.sve.FPTrigSSel" name="aarch64.functions.sve.FPTrigSSel"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>FPTrigSSel</ins><del>FPCompareNE</del></h3><p class="pseudocode"><ins>// FPTrigSSel()
// ============
</ins><del>// FPCompareNE()
// =============
</del>
<ins>bits(N)</ins><del>boolean</del> <a id="impl-aarch64.FPTrigSSel.2" name="impl-aarch64.FPTrigSSel.2"></a><ins>FPTrigSSel(bits(N) op1, bits(N) op2)
    assert N IN {16,32,64};
    bits(N) result;

    if op2&lt;0> == '1' then
        result =</ins><del>FPCompareNE(bits(N) op1, bits(N) op2,</del> <del> fpcr)
    assert N IN {16,32,64};
    (type1,sign1,value1) = </del><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a><del>(op1, fpcr);
    (type2,sign2,value2) = </del><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a><del>(op2, fpcr);
    if type1==</del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><del> || type1==</del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><del> || type2==</del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><del> || type2==</del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><del> then
        result = TRUE;
        if type1==</del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><del> || type2==</del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><del> then
            </del><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a><del>(</del><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_InvalidOp</del></a><a href="shared_pseudocode.html#impl-aarch64.FPOne.1" title="function: bits(N) FPOne(bit sign)"><ins>FPOne</ins></a><a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><del>FPCRType</del></a><ins>(op2&lt;1>);
    else
        result = op1;
        result&lt;N-1> = result&lt;N-1> EOR op2&lt;1>;

</ins><del>, fpcr);
    else // All non-NaN cases can be evaluated on the values produced by FPUnpack()
        result = (value1 != value2);
</del>    return result;</p></div><div class="ps" psname="aarch64.functions.sve.FirstActive"><a id="aarch64.functions.sve.FirstActive" name="aarch64.functions.sve.FirstActive"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>FirstActive</ins><del>FPCompareUN</del></h3><p class="pseudocode"><ins>// FirstActive()
</ins><del>// FPCompareUN()
</del>// =============

<ins>bit</ins><del>boolean</del> <a id="impl-aarch64.FirstActive.3" name="impl-aarch64.FirstActive.3"></a><ins>FirstActive(bits(N) mask, bits(N) x, integer esize)
    integer elements = N DIV (esize DIV 8);
    for e = 0 to elements-1
        if</ins><del>FPCompareUN(bits(N) op1, bits(N) op2,</del> <a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]"><ins>ElemP</ins></a><a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><del>FPCRType</del></a><ins>[mask, e, esize] == '1' then return</ins><del>fpcr)
    assert N IN {16,32,64};
    (type1,sign1,value1) =</del> <del>(op1, fpcr);
    (type2,sign2,value2) = </del><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a><del>(op2, fpcr);
    if type1==</del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><del> || type2==</del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><del> then
        </del><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a><del>(</del><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_InvalidOp</del></a><del>, fpcr);
    return (type1==</del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><del> || type1==</del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><del> || type2==</del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><del> || type2==</del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]"><ins>ElemP</ins></a><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a><ins>[x, e, esize];
    return '0';</ins><del>);</del></p></div><div class="ps" psname="aarch64.functions.sve.FloorPow2"><a id="aarch64.functions.sve.FloorPow2" name="aarch64.functions.sve.FloorPow2"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>FloorPow2</ins><del>FPConvertSVE</del></h3><p class="pseudocode"><ins>// FloorPow2()
// ===========
// For a positive integer X, return the largest power of 2 &lt;= X
</ins><del>// FPConvertSVE()
// ==============
</del>
<ins>integer</ins><del>bits(M)</del> <a id="impl-aarch64.FloorPow2.1" name="impl-aarch64.FloorPow2.1"></a><ins>FloorPow2(integer x)
    assert x >= 0;
    integer n = 1;
    if x == 0 then return 0;
    while x >= 2^n do
        n = n + 1;
    return 2^(n - 1);</ins><del>FPConvertSVE(bits(N) op,</del><a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><del>FPCRType</del></a><del> fpcr, </del><a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding</del></a><del> rounding)
    fpcr.AHP = '0';
    return </del><a href="shared_pseudocode.html#impl-shared.FPConvert.3" title="function: bits(M) FPConvert(bits(N) op, FPCRType fpcr, FPRounding rounding)"><del>FPConvert</del></a><del>(op, fpcr, rounding);

// FPConvertSVE()
// ==============

bits(M) </del><a id="impl-aarch64.FPConvertSVE.2" name="impl-aarch64.FPConvertSVE.2"></a><del>FPConvertSVE(bits(N) op, </del><a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><del>FPCRType</del></a><del> fpcr)
    fpcr.AHP = '0';
    return </del><a href="shared_pseudocode.html#impl-shared.FPConvert.3" title="function: bits(M) FPConvert(bits(N) op, FPCRType fpcr, FPRounding rounding)"><del>FPConvert</del></a><del>(op, fpcr, </del><a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)"><del>FPRoundingMode</del></a><del>(fpcr));</del></p></div><div class="ps" psname="aarch64.functions.sve.HaveSVE"><a id="aarch64.functions.sve.HaveSVE" name="aarch64.functions.sve.HaveSVE"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>HaveSVE</ins><del>FPExpA</del></h3><p class="pseudocode"><ins>// HaveSVE()
// =========
</ins><del>// FPExpA()
// ========
</del>
<ins>boolean</ins><del>bits(N)</del> <a id="impl-aarch64.HaveSVE.0" name="impl-aarch64.HaveSVE.0"></a><ins>HaveSVE()
    return</ins><del>FPExpA(bits(N) op,</del> <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><ins>HasArchVersion</ins></a><a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><del>FPCRType</del></a><ins>(</ins><del>fpcr)
    assert N IN {16,32,64};
    bits(N) result;
    bits(N) coeff;
    integer idx = if N == 16 then</del><del>(op&lt;4:0>) else </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(op&lt;5:0>);
    coeff = </del><a href="shared_pseudocode.html#impl-aarch64.FPExpCoefficient.read.1" title="accessor: bits(N) FPExpCoefficient[integer index]"><del>FPExpCoefficient</del></a><a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p2</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>) &amp;&amp; boolean IMPLEMENTATION_DEFINED "Have SVE ISA";</ins><del>[idx];
    if N == 16 then
        result&lt;15:0> = '0':op&lt;9:5>:coeff&lt;9:0>;
    elsif N == 32 then
        result&lt;31:0> = '0':op&lt;13:6>:coeff&lt;22:0>;
    else // N == 64
        result&lt;63:0> = '0':op&lt;16:6>:coeff&lt;51:0>;

    return result;</del></p></div><div class="ps" psname="aarch64.functions.sve.ImplementedSVEVectorLength"><a id="aarch64.functions.sve.ImplementedSVEVectorLength" name="aarch64.functions.sve.ImplementedSVEVectorLength"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>ImplementedSVEVectorLength</ins><del>FPExpCoefficient</del></h3><p class="pseudocode"><ins>// ImplementedSVEVectorLength()
// ============================
// Reduce SVE vector length to a supported value (e.g. power of two)
</ins><del>// FPExpCoefficient()
// ==================
</del>
<ins>integer</ins><del>bits(N)</del> <a id="impl-aarch64.ImplementedSVEVectorLength.1" name="impl-aarch64.ImplementedSVEVectorLength.1"></a><ins>ImplementedSVEVectorLength(integer nbits)
    return integer IMPLEMENTATION_DEFINED;</ins><del>FPExpCoefficient[integer index]
    assert N IN {16,32,64};
    integer result;

    if N == 16 then
        case index of
            when  0 result = 0x0000;
            when  1 result = 0x0016;
            when  2 result = 0x002d;
            when  3 result = 0x0045;
            when  4 result = 0x005d;
            when  5 result = 0x0075;
            when  6 result = 0x008e;
            when  7 result = 0x00a8;
            when  8 result = 0x00c2;
            when  9 result = 0x00dc;
            when 10 result = 0x00f8;
            when 11 result = 0x0114;
            when 12 result = 0x0130;
            when 13 result = 0x014d;
            when 14 result = 0x016b;
            when 15 result = 0x0189;
            when 16 result = 0x01a8;
            when 17 result = 0x01c8;
            when 18 result = 0x01e8;
            when 19 result = 0x0209;
            when 20 result = 0x022b;
            when 21 result = 0x024e;
            when 22 result = 0x0271;
            when 23 result = 0x0295;
            when 24 result = 0x02ba;
            when 25 result = 0x02e0;
            when 26 result = 0x0306;
            when 27 result = 0x032e;
            when 28 result = 0x0356;
            when 29 result = 0x037f;
            when 30 result = 0x03a9;
            when 31 result = 0x03d4;

    elsif N == 32 then
        case index of
            when  0 result = 0x000000;
            when  1 result = 0x0164d2;
            when  2 result = 0x02cd87;
            when  3 result = 0x043a29;
            when  4 result = 0x05aac3;
            when  5 result = 0x071f62;
            when  6 result = 0x08980f;
            when  7 result = 0x0a14d5;
            when  8 result = 0x0b95c2;
            when  9 result = 0x0d1adf;
            when 10 result = 0x0ea43a;
            when 11 result = 0x1031dc;
            when 12 result = 0x11c3d3;
            when 13 result = 0x135a2b;
            when 14 result = 0x14f4f0;
            when 15 result = 0x16942d;
            when 16 result = 0x1837f0;
            when 17 result = 0x19e046;
            when 18 result = 0x1b8d3a;
            when 19 result = 0x1d3eda;
            when 20 result = 0x1ef532;
            when 21 result = 0x20b051;
            when 22 result = 0x227043;
            when 23 result = 0x243516;
            when 24 result = 0x25fed7;
            when 25 result = 0x27cd94;
            when 26 result = 0x29a15b;
            when 27 result = 0x2b7a3a;
            when 28 result = 0x2d583f;
            when 29 result = 0x2f3b79;
            when 30 result = 0x3123f6;
            when 31 result = 0x3311c4;
            when 32 result = 0x3504f3;
            when 33 result = 0x36fd92;
            when 34 result = 0x38fbaf;
            when 35 result = 0x3aff5b;
            when 36 result = 0x3d08a4;
            when 37 result = 0x3f179a;
            when 38 result = 0x412c4d;
            when 39 result = 0x4346cd;
            when 40 result = 0x45672a;
            when 41 result = 0x478d75;
            when 42 result = 0x49b9be;
            when 43 result = 0x4bec15;
            when 44 result = 0x4e248c;
            when 45 result = 0x506334;
            when 46 result = 0x52a81e;
            when 47 result = 0x54f35b;
            when 48 result = 0x5744fd;
            when 49 result = 0x599d16;
            when 50 result = 0x5bfbb8;
            when 51 result = 0x5e60f5;
            when 52 result = 0x60ccdf;
            when 53 result = 0x633f89;
            when 54 result = 0x65b907;
            when 55 result = 0x68396a;
            when 56 result = 0x6ac0c7;
            when 57 result = 0x6d4f30;
            when 58 result = 0x6fe4ba;
            when 59 result = 0x728177;
            when 60 result = 0x75257d;
            when 61 result = 0x77d0df;
            when 62 result = 0x7a83b3;
            when 63 result = 0x7d3e0c;

    else // N == 64
        case index of
            when  0 result = 0x0000000000000;
            when  1 result = 0x02C9A3E778061;
            when  2 result = 0x059B0D3158574;
            when  3 result = 0x0874518759BC8;
            when  4 result = 0x0B5586CF9890F;
            when  5 result = 0x0E3EC32D3D1A2;
            when  6 result = 0x11301D0125B51;
            when  7 result = 0x1429AAEA92DE0;
            when  8 result = 0x172B83C7D517B;
            when  9 result = 0x1A35BEB6FCB75;
            when 10 result = 0x1D4873168B9AA;
            when 11 result = 0x2063B88628CD6;
            when 12 result = 0x2387A6E756238;
            when 13 result = 0x26B4565E27CDD;
            when 14 result = 0x29E9DF51FDEE1;
            when 15 result = 0x2D285A6E4030B;
            when 16 result = 0x306FE0A31B715;
            when 17 result = 0x33C08B26416FF;
            when 18 result = 0x371A7373AA9CB;
            when 19 result = 0x3A7DB34E59FF7;
            when 20 result = 0x3DEA64C123422;
            when 21 result = 0x4160A21F72E2A;
            when 22 result = 0x44E086061892D;
            when 23 result = 0x486A2B5C13CD0;
            when 24 result = 0x4BFDAD5362A27;
            when 25 result = 0x4F9B2769D2CA7;
            when 26 result = 0x5342B569D4F82;
            when 27 result = 0x56F4736B527DA;
            when 28 result = 0x5AB07DD485429;
            when 29 result = 0x5E76F15AD2148;
            when 30 result = 0x6247EB03A5585;
            when 31 result = 0x6623882552225;
            when 32 result = 0x6A09E667F3BCD;
            when 33 result = 0x6DFB23C651A2F;
            when 34 result = 0x71F75E8EC5F74;
            when 35 result = 0x75FEB564267C9;
            when 36 result = 0x7A11473EB0187;
            when 37 result = 0x7E2F336CF4E62;
            when 38 result = 0x82589994CCE13;
            when 39 result = 0x868D99B4492ED;
            when 40 result = 0x8ACE5422AA0DB;
            when 41 result = 0x8F1AE99157736;
            when 42 result = 0x93737B0CDC5E5;
            when 43 result = 0x97D829FDE4E50;
            when 44 result = 0x9C49182A3F090;
            when 45 result = 0xA0C667B5DE565;
            when 46 result = 0xA5503B23E255D;
            when 47 result = 0xA9E6B5579FDBF;
            when 48 result = 0xAE89F995AD3AD;
            when 49 result = 0xB33A2B84F15FB;
            when 50 result = 0xB7F76F2FB5E47;
            when 51 result = 0xBCC1E904BC1D2;
            when 52 result = 0xC199BDD85529C;
            when 53 result = 0xC67F12E57D14B;
            when 54 result = 0xCB720DCEF9069;
            when 55 result = 0xD072D4A07897C;
            when 56 result = 0xD5818DCFBA487;
            when 57 result = 0xDA9E603DB3285;
            when 58 result = 0xDFC97337B9B5F;
            when 59 result = 0xE502EE78B3FF6;
            when 60 result = 0xEA4AFA2A490DA;
            when 61 result = 0xEFA1BEE615A27;
            when 62 result = 0xF50765B6E4540;
            when 63 result = 0xFA7C1819E90D8;

    return result&lt;N-1:0>;</del></p></div><div class="ps" psname="aarch64.functions.sve.IsEven"><a id="aarch64.functions.sve.IsEven" name="aarch64.functions.sve.IsEven"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>IsEven</ins><del>FPMinNormal</del></h3><p class="pseudocode"><ins>// IsEven()
// ========
</ins><del>// FPMinNormal()
// =============
</del>
<ins>boolean</ins><del>bits(N)</del> <a id="impl-aarch64.IsEven.1" name="impl-aarch64.IsEven.1"></a><ins>IsEven(integer val)
    return val MOD 2 == 0;</ins><del>FPMinNormal(bit sign)
    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp =</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(E-1):'1';
    frac = </del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(F);
    return sign : exp : frac;</del></p></div><div class="ps" psname="aarch64.functions.sve.IsFPEnabled"><a id="aarch64.functions.sve.IsFPEnabled" name="aarch64.functions.sve.IsFPEnabled"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>IsFPEnabled</ins><del>FPOne</del></h3><p class="pseudocode"><ins>// IsFPEnabled()
// =============
</ins><del>// FPOne()
// =======
</del>
<ins>boolean</ins><del>bits(N)</del> <a id="impl-aarch64.IsFPEnabled.1" name="impl-aarch64.IsFPEnabled.1"></a><ins>IsFPEnabled(bits(2) el)
    if</ins><del>FPOne(bit sign)
    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp = '0':</del> <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a><ins>(el) then
        return</ins><del>(E-1);
    frac =</del> <a href="shared_pseudocode.html#AArch32.IsFPEnabled.1" title="function: boolean AArch32.IsFPEnabled(bits(2) el)"><ins>AArch32.IsFPEnabled</ins></a><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><ins>(el);
    else
        return </ins><a href="shared_pseudocode.html#AArch64.IsFPEnabled.1" title="function: boolean AArch64.IsFPEnabled(bits(2) el)"><ins>AArch64.IsFPEnabled</ins></a><ins>(el);</ins><del>(F);
    return sign : exp : frac;</del></p></div><div class="ps" psname="aarch64.functions.sve.IsSVEEnabled"><a id="aarch64.functions.sve.IsSVEEnabled" name="aarch64.functions.sve.IsSVEEnabled"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>IsSVEEnabled</ins><del>FPPointFive</del></h3><p class="pseudocode"><ins>// IsSVEEnabled()
// ==============
</ins><del>// FPPointFive()
// =============
</del>
<ins>boolean</ins><del>bits(N)</del> <a id="impl-aarch64.IsSVEEnabled.1" name="impl-aarch64.IsSVEEnabled.1"></a><ins>IsSVEEnabled(bits(2) el)
    if</ins><del>FPPointFive(bit sign)
    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp = '0':</del> <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a><ins>(el) then
        return FALSE;

    // Check if access disabled in CPACR_EL1
    if el IN {</ins><del>(E-2):'0';
    frac =</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><ins>, </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>} then
        // Check SVE at EL0/EL1
        case </ins><a href="shared_pseudocode.html#impl-aarch64.CPACR.read.0" title="accessor: CPACRType CPACR[]"><ins>CPACR</ins></a><ins>[].ZEN of
            when 'x0'  disabled = TRUE;
            when '01'  disabled = (el == </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>);
            when '11'  disabled = FALSE;
        if disabled then return FALSE;

    // Check if access disabled in CPTR_EL2
    if el IN {</ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>, </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>, </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>} &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>() then
        if </ins><a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><ins>HaveVirtHostExt</ins></a><ins>() &amp;&amp; HCR_EL2.E2H == '1' then
            if CPTR_EL2.ZEN == 'x0' then return FALSE;
        else
            if CPTR_EL2.TZ == '1' then return FALSE;

    // Check if access disabled in CPTR_EL3
    if </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) then
        if CPTR_EL3.EZ == '0' then return FALSE;

    return TRUE;</ins><del>(F);
    return sign : exp : frac;</del></p></div><div class="ps" psname="aarch64.functions.sve.LastActive"><a id="aarch64.functions.sve.LastActive" name="aarch64.functions.sve.LastActive"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>LastActive</ins><del>FPProcess</del></h3><p class="pseudocode"><ins>// LastActive()
// ============
</ins><del>// FPProcess()
// ===========
</del>
<ins>bit</ins><del>bits(N)</del> <a id="impl-aarch64.LastActive.3" name="impl-aarch64.LastActive.3"></a><ins>LastActive(bits(N) mask, bits(N) x, integer esize)
    integer elements = N DIV (esize DIV 8);
    for e = elements-1 downto 0
        if</ins><del>FPProcess(bits(N) input)
    bits(N) result;
    assert N IN {16,32,64};
    (type,sign,value) =</del> <a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]"><ins>ElemP</ins></a><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a><ins>[mask, e, esize] == '1' then return</ins><del>(input, FPCR);
    if type ==</del> <del> || type == </del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><del> then
        result = </del><a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><del>FPProcessNaN</del></a><del>(type, input, FPCR);
    elsif type == </del><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a><del> then
        result = </del><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><del>FPInfinity</del></a><del>(sign);
    elsif type == </del><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a><del> then
        result = </del><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><del>FPZero</del></a><del>(sign);
    else
        result = </del><a href="shared_pseudocode.html#impl-shared.FPRound.2" title="function: bits(N) FPRound(real op, FPCRType fpcr)"><del>FPRound</del></a><a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]"><ins>ElemP</ins></a><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><ins>[x, e, esize];
    return '0';</ins><del>(value, FPCR);
    return result;</del></p></div><div class="ps" psname="aarch64.functions.sve.LastActiveElement"><a id="aarch64.functions.sve.LastActiveElement" name="aarch64.functions.sve.LastActiveElement"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>LastActiveElement</ins><del>FPScale</del></h3><p class="pseudocode"><ins>// LastActiveElement()
// ===================
</ins><del>// FPScale()
// =========
</del>
<ins>integer</ins><del>bits(N)</del> <a id="impl-aarch64.LastActiveElement.2" name="impl-aarch64.LastActiveElement.2"></a><ins>LastActiveElement(bits(N) mask, integer esize)
    assert esize IN {8, 16, 32, 64};
    integer elements = VL DIV esize;
    for e = elements-1 downto 0
        if</ins><del>FPScale(bits (N) op, integer scale,</del> <del> fpcr)
    assert N IN {16,32,64};
    (type,sign,value) = </del><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a><del>(op, fpcr);
    if type == </del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><del> || type == </del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><del> then
        result = </del><a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><del>FPProcessNaN</del></a><del>(type, op, fpcr);
    elsif type == </del><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a><del> then
        result = </del><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><del>FPZero</del></a><del>(sign);
    elsif type == </del><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a><del> then
        result = </del><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><del>FPInfinity</del></a><del>(sign);
    else
        result = </del><a href="shared_pseudocode.html#impl-shared.FPRound.2" title="function: bits(N) FPRound(real op, FPCRType fpcr)"><del>FPRound</del></a><a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]"><ins>ElemP</ins></a><a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><del>FPCRType</del></a><ins>[mask, e, esize] == '1' then return e;
    return -1;</ins><del>(value * (2.0^scale), fpcr);
    return result;</del></p></div><div class="ps" psname="aarch64.functions.sve.MAX_PL"><a id="aarch64.functions.sve.MAX_PL" name="aarch64.functions.sve.MAX_PL"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>MAX_PL</ins><del>FPTrigMAdd</del></h3><p class="pseudocode"><ins>constant integer</ins><del>// FPTrigMAdd()
// ============

bits(N)</del> <a id="MAX_PL" name="MAX_PL"></a><ins>MAX_PL = 256;</ins><del>FPTrigMAdd(integer x, bits(N) op1, bits(N) op2,</del><a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><del>FPCRType</del></a><del> fpcr)
    assert N IN {16,32,64};
    assert x >= 0;
    assert x &lt; 8;
    bits(N) coeff;

    if op2&lt;N-1> == '1' then
        x = x + 8;
    op2&lt;N-1> = '0';

    coeff = </del><a href="shared_pseudocode.html#impl-aarch64.FPTrigMAddCoefficient.read.1" title="accessor: bits(N) FPTrigMAddCoefficient[integer index]"><del>FPTrigMAddCoefficient</del></a><del>[x];
    result = </del><a href="shared_pseudocode.html#impl-shared.FPMulAdd.4" title="function: bits(N) FPMulAdd(bits(N) addend, bits(N) op1, bits(N) op2, FPCRType fpcr)"><del>FPMulAdd</del></a><del>(coeff, op1, op2, fpcr);

    return result;</del></p></div><div class="ps" psname="aarch64.functions.sve.MAX_VL"><a id="aarch64.functions.sve.MAX_VL" name="aarch64.functions.sve.MAX_VL"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>MAX_VL</ins><del>FPTrigMAddCoefficient</del></h3><p class="pseudocode"><ins>constant integer</ins><del>// FPTrigMAddCoefficient()
// =======================

bits(N)</del> <a id="MAX_VL" name="MAX_VL"></a><ins>MAX_VL = 2048;</ins><del>FPTrigMAddCoefficient[integer index]
    assert N IN {16,32,64};
    integer result;

    if N == 16 then
        case index of
            when  0 result = 0x3c00;
            when  1 result = 0xb155;
            when  2 result = 0x2030;
            when  3 result = 0x0000;
            when  4 result = 0x0000;
            when  5 result = 0x0000;
            when  6 result = 0x0000;
            when  7 result = 0x0000;
            when  8 result = 0x3c00;
            when  9 result = 0xb800;
            when 10 result = 0x293a;
            when 11 result = 0x0000;
            when 12 result = 0x0000;
            when 13 result = 0x0000;
            when 14 result = 0x0000;
            when 15 result = 0x0000;
    elsif N == 32 then
        case index of
            when  0 result = 0x3f800000;
            when  1 result = 0xbe2aaaab;
            when  2 result = 0x3c088886;
            when  3 result = 0xb95008b9;
            when  4 result = 0x36369d6d;
            when  5 result = 0x00000000;
            when  6 result = 0x00000000;
            when  7 result = 0x00000000;
            when  8 result = 0x3f800000;
            when  9 result = 0xbf000000;
            when 10 result = 0x3d2aaaa6;
            when 11 result = 0xbab60705;
            when 12 result = 0x37cd37cc;
            when 13 result = 0x00000000;
            when 14 result = 0x00000000;
            when 15 result = 0x00000000;
    else // N == 64
        case index of
            when  0 result = 0x3ff0000000000000;
            when  1 result = 0xbfc5555555555543;
            when  2 result = 0x3f8111111110f30c;
            when  3 result = 0xbf2a01a019b92fc6;
            when  4 result = 0x3ec71de351f3d22b;
            when  5 result = 0xbe5ae5e2b60f7b91;
            when  6 result = 0x3de5d8408868552f;
            when  7 result = 0x0000000000000000;
            when  8 result = 0x3ff0000000000000;
            when  9 result = 0xbfe0000000000000;
            when 10 result = 0x3fa5555555555536;
            when 11 result = 0xbf56c16c16c13a0b;
            when 12 result = 0x3efa01a019b1e8d8;
            when 13 result = 0xbe927e4f7282f468;
            when 14 result = 0x3e21ee96d2641b13;
            when 15 result = 0xbda8f76380fbb401;

    return result&lt;N-1:0>;</del></p></div><div class="ps" psname="aarch64.functions.sve.MaybeZeroSVEUppers"><a id="aarch64.functions.sve.MaybeZeroSVEUppers" name="aarch64.functions.sve.MaybeZeroSVEUppers"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>MaybeZeroSVEUppers</ins><del>FPTrigSMul</del></h3><p class="pseudocode"><ins>// MaybeZeroSVEUppers()
// ====================</ins><del>// FPTrigSMul()
// ============

bits(N)</del>

<a id="impl-aarch64.MaybeZeroSVEUppers.1" name="impl-aarch64.MaybeZeroSVEUppers.1"></a><ins>MaybeZeroSVEUppers(bits(2) target_el)
    boolean lower_enabled;

    if</ins><del>FPTrigSMul(bits(N) op1, bits(N) op2,</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><del>FPCRType</del></a><ins>(target_el) &lt;=</ins><del>fpcr)
    assert N IN {16,32,64};
    result =</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#impl-shared.FPMul.3" title="function: bits(N) FPMul(bits(N) op1, bits(N) op2, FPCRType fpcr)"><del>FPMul</del></a><ins>(PSTATE.EL) || !</ins><del>(op1, op1, fpcr);
    (type, sign, value) =</del><a href="shared_pseudocode.html#impl-aarch64.IsSVEEnabled.1" title="function: boolean IsSVEEnabled(bits(2) el)"><ins>IsSVEEnabled</ins></a><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a><ins>(target_el) then
        return;

    if target_el ==</ins><del>(result, fpcr);
    if (type !=</del> <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a> <ins>then
        if</ins><del>) &amp;&amp; (type !=</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><ins>() then
            lower_enabled = </ins><a href="shared_pseudocode.html#impl-aarch64.IsFPEnabled.1" title="function: boolean IsFPEnabled(bits(2) el)"><ins>IsFPEnabled</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>);
        else
            lower_enabled = </ins><a href="shared_pseudocode.html#impl-aarch64.IsFPEnabled.1" title="function: boolean IsFPEnabled(bits(2) el)"><ins>IsFPEnabled</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>);
    else
        lower_enabled = </ins><a href="shared_pseudocode.html#impl-aarch64.IsFPEnabled.1" title="function: boolean IsFPEnabled(bits(2) el)"><ins>IsFPEnabled</ins></a><ins>(target_el - 1);

    if lower_enabled then
        integer vl = if </ins><a href="shared_pseudocode.html#impl-aarch64.IsSVEEnabled.1" title="function: boolean IsSVEEnabled(bits(2) el)"><ins>IsSVEEnabled</ins></a><ins>(PSTATE.EL) then VL else 128;
        integer pl = vl DIV 8;
        for n = 0 to 31
            if </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><ins>ConstrainUnpredictableBool</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_SVEZEROUPPER" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_SVEZEROUPPER</ins></a><ins>) then
                _Z[n] = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(_Z[n]&lt;vl-1:0>);
        for n = 0 to 15
            if </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><ins>ConstrainUnpredictableBool</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_SVEZEROUPPER" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_SVEZEROUPPER</ins></a><ins>) then
                _P[n] = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(_P[n]&lt;pl-1:0>);
        if </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><ins>ConstrainUnpredictableBool</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_SVEZEROUPPER" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_SVEZEROUPPER</ins></a><ins>) then
            _FFR = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(_FFR&lt;pl-1:0>);</ins><del>) then
        result&lt;N-1> = op2&lt;0>;

    return result;</del></p></div><div class="ps" psname="aarch64.functions.sve.MemNF"><a id="aarch64.functions.sve.MemNF" name="aarch64.functions.sve.MemNF"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>MemNF</ins><del>FPTrigSSel</del></h3><p class="pseudocode"><ins>// MemNF[] - non-assignment form
// =============================
</ins><del>// FPTrigSSel()
// ============
</del>
<ins>(bits(8*size), boolean) MemNF[bits(64) address, integer size,</ins><del>bits(N)</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a> <ins>acctype]
    assert size IN {1, 2, 4, 8, 16};
    bits(8*size) value;
</ins><del>FPTrigSSel(bits(N) op1, bits(N) op2)
    assert N IN {16,32,64};
    bits(N) result;
</del>
<ins>    aligned = (address ==</ins><del>    if op2&lt;0> == '1' then
        result =</del> <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)"><ins>Align</ins></a><a href="shared_pseudocode.html#impl-aarch64.FPOne.1" title="function: bits(N) FPOne(bit sign)"><del>FPOne</del></a><ins>(address, size));
    A = </ins><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><ins>SCTLR</ins></a><ins>[].A;

    if !aligned &amp;&amp; (A == '1') then
        return (bits(8*size) UNKNOWN, TRUE);

    atomic = aligned || size == 1;

    if !atomic then
        (value&lt;7:0>, bad) = MemSingleNF[address, 1, acctype, aligned];

        if bad then
            return (bits(8*size) UNKNOWN, TRUE);

        // For subsequent bytes it is CONSTRAINED UNPREDICTABLE whether an unaligned Device memory
        // access will generate an Alignment Fault, as to get this far means the first byte did
        // not, so we must be changing to a new translation page.
        if !aligned then
            c = </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><ins>ConstrainUnpredictable</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_DEVPAGE2" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_DEVPAGE2</ins></a><ins>);
            assert c IN {</ins><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FAULT</ins></a><ins>, </ins><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_NONE</ins></a><ins>};
            if c == </ins><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_NONE</ins></a><ins> then aligned = TRUE;

        for i = 1 to size-1
            (value&lt;8*i+7:8*i>, bad) = MemSingleNF[address+i, 1, acctype, aligned];

            if bad then
                return (bits(8*size) UNKNOWN, TRUE);
    else
        (value, bad) = MemSingleNF[address, size, acctype, aligned];
        if bad then
            return (bits(8*size) UNKNOWN, TRUE);

    if </ins><a href="shared_pseudocode.html#impl-shared.BigEndian.0" title="function: boolean BigEndian()"><ins>BigEndian</ins></a><ins>() then
        value = </ins><a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)"><ins>BigEndianReverse</ins></a><ins>(value);
</ins><del>(op2&lt;1>);
    else
        result = op1;
        result&lt;N-1> = result&lt;N-1> EOR op2&lt;1>;
</del>
<ins>    return (value, FALSE);</ins><del>    return result;</del></p></div><div class="ps" psname="aarch64.functions.sve.MemSingleNF"><a id="aarch64.functions.sve.MemSingleNF" name="aarch64.functions.sve.MemSingleNF"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>MemSingleNF</ins><del>FirstActive</del></h3><p class="pseudocode"><ins>// MemSingleNF[] - non-assignment form
// ===================================
</ins><del>// FirstActive()
// =============
</del>
<ins>(bits(8*size), boolean) MemSingleNF[bits(64) address, integer size,</ins><del>bit</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a> <ins>acctype, boolean wasaligned]
    bits(8*size) value;
    boolean iswrite = FALSE;</ins><del>FirstActive(bits(N) mask, bits(N) x, integer esize)
    integer elements = N DIV (esize DIV 8);
    for e = 0 to elements-1
        if</del>
    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><ins>AddressDescriptor</ins></a><a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]"><del>ElemP</del></a> <ins>memaddrdesc;

    // Implementation may suppress NF load for any reason
    if</ins><del>[mask, e, esize] == '1' then return</del> <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><ins>ConstrainUnpredictableBool</ins></a><a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]"><del>ElemP</del></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_NONFAULT" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_NONFAULT</ins></a><ins>) then
        return (bits(8*size) UNKNOWN, TRUE);

    // MMU or MPU
    memaddrdesc = </ins><a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><ins>AArch64.TranslateAddress</ins></a><ins>(address, acctype, iswrite, wasaligned, size);

    // Non-fault load from Device memory must not be performed externally
    if memaddrdesc.memattrs.type == </ins><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Device</ins></a><ins> then
        return (bits(8*size) UNKNOWN, TRUE);

    // Check for aborts or debug exceptions
    if </ins><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><ins>(memaddrdesc) then
        return (bits(8*size) UNKNOWN, TRUE);

    // Memory array access
    accdesc = CreateAccessDescriptor(acctype);

    if </ins><a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()"><ins>HaveMTEExt</ins></a><ins>() then
        if </ins><a href="shared_pseudocode.html#impl-aarch64.AccessIsTagChecked.2" title="function: boolean AccessIsTagChecked(bits(64) vaddr, AccType acctype)"><ins>AccessIsTagChecked</ins></a><ins>(address, acctype) then
            bits(4) ptag = </ins><a href="shared_pseudocode.html#impl-aarch64.TransformTag.1" title="function: bits(4) TransformTag(bits(64) vaddr)"><ins>TransformTag</ins></a><ins>(address);
            if !</ins><a href="shared_pseudocode.html#impl-aarch64.CheckTag.3" title="function: boolean CheckTag(AddressDescriptor memaddrdesc, bits(4) ptag, boolean write)"><ins>CheckTag</ins></a><ins>(memaddrdesc, ptag, iswrite) then
                return (bits(8*size) UNKNOWN, TRUE);
    value = _Mem[memaddrdesc, size, accdesc];

    return (value, FALSE);</ins><del>[x, e, esize];
    return '0';</del></p></div><div class="ps" psname="aarch64.functions.sve.NoneActive"><a id="aarch64.functions.sve.NoneActive" name="aarch64.functions.sve.NoneActive"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>NoneActive</ins><del>FloorPow2</del></h3><p class="pseudocode"><ins>// NoneActive()
// ============
</ins><del>// FloorPow2()
// ===========
// For a positive integer X, return the largest power of 2 &lt;= X
</del>
<ins>bit</ins><del>integer</del> <a id="impl-aarch64.NoneActive.3" name="impl-aarch64.NoneActive.3"></a><ins>NoneActive(bits(N) mask, bits(N) x, integer esize)
    integer elements = N DIV (esize DIV 8);
    for e = 0 to elements-1
        if</ins><del>FloorPow2(integer x)
    assert x >= 0;
    integer n = 1;
    if x == 0 then return 0;
    while x >= 2^n do
        n = n + 1;
    return 2^(n - 1);</del> <a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]"><ins>ElemP</ins></a><ins>[mask, e, esize] == '1' &amp;&amp; </ins><a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]"><ins>ElemP</ins></a><ins>[x, e, esize] == '1' then return '0';
    return '1';</ins></p></div><div class="ps" psname="aarch64.functions.sve.P"><a id="aarch64.functions.sve.P" name="aarch64.functions.sve.P"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>P</ins><del>HaveSVE</del></h3><p class="pseudocode"><ins>// P[] - non-assignment form
// =========================
</ins><del>// HaveSVE()
// =========
</del>
<ins>bits(width)</ins><del>boolean</del> <a id="impl-aarch64.P.read.1" name="impl-aarch64.P.read.1"></a><ins>P[integer n]
    assert n >= 0 &amp;&amp; n &lt;= 31;
    assert width == PL;
    return _P[n]&lt;width-1:0>;

// P[] - assignment form
// =====================</ins><del>HaveSVE()
    return</del>

<a id="impl-aarch64.P.write.1" name="impl-aarch64.P.write.1"></a><ins>P[integer n] = bits(width) value
    assert n >= 0 &amp;&amp; n &lt;= 31;
    assert width == PL;
    if</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><ins>ConstrainUnpredictableBool</ins></a><a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p2</del></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_SVEZEROUPPER" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_SVEZEROUPPER</ins></a><ins>) then
        _P[n] = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(value);
    else
        _P[n]&lt;width-1:0> = value;</ins><del>) &amp;&amp; boolean IMPLEMENTATION_DEFINED "Have SVE ISA";</del></p></div><div class="ps" psname="aarch64.functions.sve.PL"><a id="aarch64.functions.sve.PL" name="aarch64.functions.sve.PL"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>PL</ins><del>ImplementedSVEVectorLength</del></h3><p class="pseudocode"><ins>// PL - non-assignment form
// ========================
</ins><del>// ImplementedSVEVectorLength()
// ============================
// Reduce SVE vector length to a supported value (e.g. power of two)
</del>
<ins>integer PL
    return VL DIV 8;</ins><del>integer</del><a id="impl-aarch64.ImplementedSVEVectorLength.1" name="impl-aarch64.ImplementedSVEVectorLength.1"></a><del>ImplementedSVEVectorLength(integer nbits)
    return integer IMPLEMENTATION_DEFINED;</del></p></div><div class="ps" psname="aarch64.functions.sve.PredTest"><a id="aarch64.functions.sve.PredTest" name="aarch64.functions.sve.PredTest"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>PredTest</ins><del>IsEven</del></h3><p class="pseudocode"><ins>// PredTest()
// ==========
</ins><del>// IsEven()
// ========
</del>
<ins>bits(4)</ins><del>boolean</del> <a id="impl-aarch64.PredTest.3" name="impl-aarch64.PredTest.3"></a><ins>PredTest(bits(N) mask, bits(N) result, integer esize)
    bit n =</ins><del>IsEven(integer val)
    return val MOD 2 == 0;</del> <a href="shared_pseudocode.html#impl-aarch64.FirstActive.3" title="function: bit FirstActive(bits(N) mask, bits(N) x, integer esize)"><ins>FirstActive</ins></a><ins>(mask, result, esize);
    bit z = </ins><a href="shared_pseudocode.html#impl-aarch64.NoneActive.3" title="function: bit NoneActive(bits(N) mask, bits(N) x, integer esize)"><ins>NoneActive</ins></a><ins>(mask, result, esize);
    bit c = NOT </ins><a href="shared_pseudocode.html#impl-aarch64.LastActive.3" title="function: bit LastActive(bits(N) mask, bits(N) x, integer esize)"><ins>LastActive</ins></a><ins>(mask, result, esize);
    bit v = '0';
    return n:z:c:v;</ins></p></div><div class="ps" psname="aarch64.functions.sve.ReducePredicated"><a id="aarch64.functions.sve.ReducePredicated" name="aarch64.functions.sve.ReducePredicated"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>ReducePredicated</ins><del>IsFPEnabled</del></h3><p class="pseudocode"><ins>// ReducePredicated()
// ==================
</ins><del>// IsFPEnabled()
// =============
</del>
<ins>bits(esize)</ins><del>boolean</del> <a id="impl-aarch64.ReducePredicated.4" name="impl-aarch64.ReducePredicated.4"></a><ins>ReducePredicated(</ins><del>IsFPEnabled(bits(2) el)
    if</del><a href="shared_pseudocode.html#ReduceOp" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM, ReduceOp_FMIN, ReduceOp_FMAX, ReduceOp_FADD, ReduceOp_ADD}"><ins>ReduceOp</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a> <ins>op, bits(N) input, bits(M) mask, bits(esize) identity)
    assert(N == M * 8);
    integer p2bits =</ins><del>(el) then
        return</del> <a href="shared_pseudocode.html#impl-aarch64.CeilPow2.1" title="function: integer CeilPow2(integer x)"><ins>CeilPow2</ins></a><a href="shared_pseudocode.html#AArch32.IsFPEnabled.1" title="function: boolean AArch32.IsFPEnabled(bits(2) el)"><del>AArch32.IsFPEnabled</del></a><ins>(N);
    bits(p2bits) operand;
    integer elements = p2bits DIV esize;

    for e = 0 to elements-1
        if e * esize &lt; N &amp;&amp;</ins><del>(el);
    else
        return</del> <a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]"><ins>ElemP</ins></a><a href="shared_pseudocode.html#AArch64.IsFPEnabled.1" title="function: boolean AArch64.IsFPEnabled(bits(2) el)"><del>AArch64.IsFPEnabled</del></a><ins>[mask, e, esize] == '1' then
            </ins><a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value"><ins>Elem</ins></a><ins>[operand, e, esize] = </ins><a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]"><ins>Elem</ins></a><ins>[input, e, esize];
        else
            </ins><a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value"><ins>Elem</ins></a><ins>[operand, e, esize] = identity;

    return </ins><a href="shared_pseudocode.html#impl-aarch64.Reduce.3" title="function: bits(esize) Reduce(ReduceOp op, bits(N) input, integer esize)"><ins>Reduce</ins></a><ins>(op, operand, esize);</ins><del>(el);</del></p></div><div class="ps" psname="aarch64.functions.sve.Reverse"><a id="aarch64.functions.sve.Reverse" name="aarch64.functions.sve.Reverse"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>Reverse</ins><del>IsSVEEnabled</del></h3><p class="pseudocode"><ins>// Reverse()
// =========
// Reverse subwords of M bits in an N-bit word
</ins><del>// IsSVEEnabled()
// ==============
</del>
<ins>bits(N)</ins><del>boolean</del> <a id="impl-aarch64.Reverse.2" name="impl-aarch64.Reverse.2"></a><ins>Reverse(bits(N) word, integer M)
    bits(N) result;
    integer sw = N DIV M;
    assert N == sw * M;
    for s = 0 to sw-1</ins><del>IsSVEEnabled(bits(2) el)
    if</del>
        <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value"><ins>Elem</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><ins>[result, sw - 1 - s, M] =</ins><del>(el) then
        return FALSE;

    // Check if access disabled in CPACR_EL1
    if el IN {</del> <del>, </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>} then
        // Check SVE at EL0/EL1
        case </del><a href="shared_pseudocode.html#impl-aarch64.CPACR.read.0" title="accessor: CPACRType CPACR[]"><del>CPACR</del></a><del>[].ZEN of
            when 'x0'  disabled = TRUE;
            when '01'  disabled = (el == </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>);
            when '11'  disabled = FALSE;
        if disabled then return FALSE;

    // Check if access disabled in CPTR_EL2
    if el IN {</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>, </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>, </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>} &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() then
        if </del><a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><del>HaveVirtHostExt</del></a><del>() &amp;&amp; HCR_EL2.E2H == '1' then
            if CPTR_EL2.ZEN == 'x0' then return FALSE;
        else
            if CPTR_EL2.TZ == '1' then return FALSE;

    // Check if access disabled in CPTR_EL3
    if </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]"><ins>Elem</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>[word, s, M];
    return result;</ins><del>) then
        if CPTR_EL3.EZ == '0' then return FALSE;

    return TRUE;</del></p></div><div class="ps" psname="aarch64.functions.sve.SVEAccessTrap"><a id="aarch64.functions.sve.SVEAccessTrap" name="aarch64.functions.sve.SVEAccessTrap"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>SVEAccessTrap</ins><del>LastActive</del></h3><p class="pseudocode"><ins>// SVEAccessTrap()
// ===============
// Trapped access to SVE registers due to CPACR_EL1, CPTR_EL2, or CPTR_EL3.</ins><del>// LastActive()
// ============

bit</del>

<a id="impl-aarch64.SVEAccessTrap.1" name="impl-aarch64.SVEAccessTrap.1"></a><ins>SVEAccessTrap(bits(2) target_el)
    assert</ins><del>LastActive(bits(N) mask, bits(N) x, integer esize)
    integer elements = N DIV (esize DIV 8);
    for e = elements-1 downto 0
        if</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]"><del>ElemP</del></a><ins>(target_el) >=</ins><del>[mask, e, esize] == '1' then return</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]"><del>ElemP</del></a><ins>(PSTATE.EL) &amp;&amp; target_el != </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins> &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(target_el);
    route_to_el2 = target_el == </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins> &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>() &amp;&amp; HCR_EL2.TGE == '1';

    exception = </ins><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><ins>ExceptionSyndrome</ins></a><ins>(</ins><a href="shared_pseudocode.html#Exception_SVEAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception_SVEAccessTrap</ins></a><ins>);
    bits(64) preferred_exception_return = </ins><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><ins>ThisInstrAddr</ins></a><ins>();
    vect_offset = 0x0;

    if route_to_el2 then
        </ins><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>, exception, preferred_exception_return, vect_offset);
    else
        </ins><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><ins>AArch64.TakeException</ins></a><ins>(target_el, exception, preferred_exception_return, vect_offset);</ins><del>[x, e, esize];
    return '0';</del></p></div><div class="ps" psname="aarch64.functions.sve.SVECmp"><a id="aarch64.functions.sve.SVECmp" name="aarch64.functions.sve.SVECmp"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>SVECmp</ins><del>LastActiveElement</del></h3><p class="pseudocode"><ins>enumeration</ins><del>// LastActiveElement()
// ===================

integer</del> <a id="SVECmp" name="SVECmp"></a><ins>SVECmp {</ins><del>LastActiveElement(bits(N) mask, integer esize)
    assert esize IN {8, 16, 32, 64};
    integer elements = VL DIV esize;
    for e = elements-1 downto 0
        if</del> <a id="Cmp_EQ" name="Cmp_EQ"></a><ins>Cmp_EQ, </ins><a id="Cmp_NE" name="Cmp_NE"></a><ins>Cmp_NE, </ins><a id="Cmp_GE" name="Cmp_GE"></a><ins>Cmp_GE, </ins><a id="Cmp_GT" name="Cmp_GT"></a><ins>Cmp_GT, </ins><a id="Cmp_LT" name="Cmp_LT"></a><ins>Cmp_LT, </ins><a id="Cmp_LE" name="Cmp_LE"></a><ins>Cmp_LE, </ins><a id="Cmp_UN" name="Cmp_UN"></a><ins>Cmp_UN };</ins><del>[mask, e, esize] == '1' then return e;
    return -1;</del></p></div><div class="ps" psname="aarch64.functions.sve.SVEMoveMaskPreferred"><a id="aarch64.functions.sve.SVEMoveMaskPreferred" name="aarch64.functions.sve.SVEMoveMaskPreferred"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>SVEMoveMaskPreferred</ins><del>MAX_PL</del></h3><p class="pseudocode"><ins>// SVEMoveMaskPreferred()
// ======================
// Return FALSE if a bitmask immediate encoding would generate an immediate
// value that could also be represented by a single DUP instruction.
// Used as a condition for the preferred MOV&lt;-DUPM alias.

boolean</ins><del>constant integer</del> <a id="impl-aarch64.SVEMoveMaskPreferred.1" name="impl-aarch64.SVEMoveMaskPreferred.1"></a><ins>SVEMoveMaskPreferred(bits(13) imm13)
    bits(64) imm;
    (imm, -) =</ins><del>MAX_PL = 256;</del> <a href="shared_pseudocode.html#impl-aarch64.DecodeBitMasks.4" title="function: (bits(M), bits(M)) DecodeBitMasks(bit immN, bits(6) imms, bits(6) immr, boolean immediate)"><ins>DecodeBitMasks</ins></a><ins>(imm13&lt;12>, imm13&lt;5:0>, imm13&lt;11:6>, TRUE);

    // Check for 8 bit immediates
    if !</ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(imm&lt;7:0>) then
        // Check for 'ffffffffffffffxy' or '00000000000000xy'
        if </ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(imm&lt;63:7>) || </ins><a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)"><ins>IsOnes</ins></a><ins>(imm&lt;63:7>) then
            return FALSE;

        // Check for 'ffffffxyffffffxy' or '000000xy000000xy'
        if imm&lt;63:32> == imm&lt;31:0> &amp;&amp; (</ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(imm&lt;31:7>) || </ins><a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)"><ins>IsOnes</ins></a><ins>(imm&lt;31:7>)) then
            return FALSE;

        // Check for 'ffxyffxyffxyffxy' or '00xy00xy00xy00xy'
        if imm&lt;63:32> == imm&lt;31:0> &amp;&amp; imm&lt;31:16> == imm&lt;15:0> &amp;&amp; (</ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(imm&lt;15:7>) || </ins><a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)"><ins>IsOnes</ins></a><ins>(imm&lt;15:7>)) then
            return FALSE;

        // Check for 'xyxyxyxyxyxyxyxy'
        if imm&lt;63:32> == imm&lt;31:0> &amp;&amp; imm&lt;31:16> == imm&lt;15:0> &amp;&amp; (imm&lt;15:8> == imm&lt;7:0>) then
            return FALSE;

    // Check for 16 bit immediates
    else
        // Check for 'ffffffffffffxy00' or '000000000000xy00'
        if </ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(imm&lt;63:15>) || </ins><a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)"><ins>IsOnes</ins></a><ins>(imm&lt;63:15>) then
            return FALSE;

        // Check for 'ffffxy00ffffxy00' or '0000xy000000xy00'
        if imm&lt;63:32> == imm&lt;31:0> &amp;&amp; (</ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(imm&lt;31:7>) || </ins><a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)"><ins>IsOnes</ins></a><ins>(imm&lt;31:7>)) then
            return FALSE;

        // Check for 'xy00xy00xy00xy00'
        if imm&lt;63:32> == imm&lt;31:0> &amp;&amp; imm&lt;31:16> == imm&lt;15:0> then
            return FALSE;

    return TRUE;</ins></p></div><div class="ps" psname="aarch64.functions.sve.System"><a id="aarch64.functions.sve.System" name="aarch64.functions.sve.System"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>System</ins><del>MAX_VL</del></h3><p class="pseudocode"><ins>array bits(</ins><del>constant integer</del><a href="shared_pseudocode.html#MAX_VL" title="constant integer MAX_VL = 2048"><ins>MAX_VL</ins></a><ins>) _Z[0..31];
array bits(</ins><a href="shared_pseudocode.html#MAX_PL" title="constant integer MAX_PL = 256"><ins>MAX_PL</ins></a><ins>) _P[0..15];
bits(</ins><a href="shared_pseudocode.html#MAX_PL" title="constant integer MAX_PL = 256"><ins>MAX_PL</ins></a><ins>) _FFR;</ins><del>MAX_VL = 2048;</del></p></div><div class="ps" psname="aarch64.functions.sve.VL"><a id="aarch64.functions.sve.VL" name="aarch64.functions.sve.VL"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>VL</ins><del>MaybeZeroSVEUppers</del></h3><p class="pseudocode"><ins>// VL - non-assignment form
// ========================

integer VL
    integer vl;

    if PSTATE.EL ==</ins><del>// MaybeZeroSVEUppers()
// ====================</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a> <ins>|| (PSTATE.EL ==</ins><del>MaybeZeroSVEUppers(bits(2) target_el)
    boolean lower_enabled;

    if</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a> <ins>&amp;&amp; !</ins><del>(target_el) &lt;=</del><a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><ins>IsInHost</ins></a><ins>()) then
        vl = </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a><ins>(ZCR_EL1.LEN);

    if PSTATE.EL ==</ins><del>(PSTATE.EL) || !</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-aarch64.IsSVEEnabled.1" title="function: boolean IsSVEEnabled(bits(2) el)"><del>IsSVEEnabled</del></a> <ins>|| (PSTATE.EL ==</ins><del>(target_el) then
        return;

    if target_el ==</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a> <ins>&amp;&amp;</ins><del>then
        if</del> <a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><ins>IsInHost</ins></a><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><ins>()) then
        vl =</ins><del>() then
            lower_enabled =</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#impl-aarch64.IsFPEnabled.1" title="function: boolean IsFPEnabled(bits(2) el)"><del>IsFPEnabled</del></a><ins>(ZCR_EL2.LEN);
    elsif</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>() &amp;&amp; PSTATE.EL IN {</ins><del>);
        else
            lower_enabled =</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#impl-aarch64.IsFPEnabled.1" title="function: boolean IsFPEnabled(bits(2) el)"><del>IsFPEnabled</del></a><ins>,</ins><del>(</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a><ins>} then
        vl =</ins><del>);
    else
        lower_enabled =</del> <a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)"><ins>Min</ins></a><a href="shared_pseudocode.html#impl-aarch64.IsFPEnabled.1" title="function: boolean IsFPEnabled(bits(2) el)"><del>IsFPEnabled</del></a><ins>(vl,</ins><del>(target_el - 1);

    if lower_enabled then
        integer vl = if</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#impl-aarch64.IsSVEEnabled.1" title="function: boolean IsSVEEnabled(bits(2) el)"><del>IsSVEEnabled</del></a><ins>(ZCR_EL2.LEN));

    if PSTATE.EL ==</ins><del>(PSTATE.EL) then VL else 128;
        integer pl = vl DIV 8;
        for n = 0 to 31
            if</del> <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><del>ConstrainUnpredictableBool</del></a> <ins>then
        vl =</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#Unpredictable_SVEZEROUPPER" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_SVEZEROUPPER</del></a><ins>(ZCR_EL3.LEN);
    elsif</ins><del>) then
                _Z[n] =</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><ins>(</ins><del>(_Z[n]&lt;vl-1:0>);
        for n = 0 to 15
            if</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><del>ConstrainUnpredictableBool</del></a><ins>) then
        vl =</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)"><ins>Min</ins></a><a href="shared_pseudocode.html#Unpredictable_SVEZEROUPPER" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_SVEZEROUPPER</del></a><ins>(vl,</ins><del>) then
                _P[n] =</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><ins>(ZCR_EL3.LEN));

    vl = (vl + 1) * 128;
    vl =</ins><del>(_P[n]&lt;pl-1:0>);
        if</del> <del>(</del><a href="shared_pseudocode.html#Unpredictable_SVEZEROUPPER" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_SVEZEROUPPER</del></a><del>) then
            _FFR = </del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><a href="shared_pseudocode.html#impl-aarch64.ImplementedSVEVectorLength.1" title="function: integer ImplementedSVEVectorLength(integer nbits)"><ins>ImplementedSVEVectorLength</ins></a><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><del>ConstrainUnpredictableBool</del></a><ins>(vl);

    return vl;</ins><del>(_FFR&lt;pl-1:0>);</del></p></div><div class="ps" psname="aarch64.functions.sve.Z"><a id="aarch64.functions.sve.Z" name="aarch64.functions.sve.Z"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/<ins>Z</ins><del>MemNF</del></h3><p class="pseudocode"><ins>// Z[] - non-assignment form
// =========================
</ins><del>// MemNF[] - non-assignment form
// =============================
</del>
<ins>bits(width)</ins><del>(bits(8*size), boolean) MemNF[bits(64) address, integer size,</del> <a id="impl-aarch64.Z.read.1" name="impl-aarch64.Z.read.1"></a><ins>Z[integer n]
    assert n >= 0 &amp;&amp; n &lt;= 31;
    assert width == VL;
    return _Z[n]&lt;width-1:0>;
</ins><del>acctype]
    assert size IN {1, 2, 4, 8, 16};
    bits(8*size) value;
</del>
<ins>// Z[] - assignment form
// =====================</ins><del>    aligned = (address ==</del>

<a id="impl-aarch64.Z.write.1" name="impl-aarch64.Z.write.1"></a><ins>Z[integer n] = bits(width) value
    assert n >= 0 &amp;&amp; n &lt;= 31;
    assert width == VL;
    if</ins><del>(address, size));
    A =</del> <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><ins>ConstrainUnpredictableBool</ins></a><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><del>SCTLR</del></a><ins>(</ins><del>[].A;

    if !aligned &amp;&amp; (A == '1') then
        return (bits(8*size) UNKNOWN, TRUE);

    atomic = aligned || size == 1;

    if !atomic then
        (value&lt;7:0>, bad) = MemSingleNF[address, 1, acctype, aligned];

        if bad then
            return (bits(8*size) UNKNOWN, TRUE);

        // For subsequent bytes it is CONSTRAINED UNPREDICTABLE whether an unaligned Device memory
        // access will generate an Alignment Fault, as to get this far means the first byte did
        // not, so we must be changing to a new translation page.
        if !aligned then
            c =</del><a href="shared_pseudocode.html#Unpredictable_SVEZEROUPPER" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_SVEZEROUPPER</ins></a><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><del>ConstrainUnpredictable</del></a><ins>) then
        _Z[n] =</ins><del>(</del> <del>);
            assert c IN {</del><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FAULT</del></a><del>, </del><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_NONE</del></a><del>};
            if c == </del><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_NONE</del></a><del> then aligned = TRUE;

        for i = 1 to size-1
            (value&lt;8*i+7:8*i>, bad) = MemSingleNF[address+i, 1, acctype, aligned];

            if bad then
                return (bits(8*size) UNKNOWN, TRUE);
    else
        (value, bad) = MemSingleNF[address, size, acctype, aligned];
        if bad then
            return (bits(8*size) UNKNOWN, TRUE);

    if </del><a href="shared_pseudocode.html#impl-shared.BigEndian.0" title="function: boolean BigEndian()"><del>BigEndian</del></a><del>() then
        value = </del><a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)"><del>BigEndianReverse</del></a><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><a href="shared_pseudocode.html#Unpredictable_DEVPAGE2" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_DEVPAGE2</del></a>(value);
<ins>    else
        _Z[n]&lt;width-1:0> = value;</ins><del>
    return (value, FALSE);</del></p></div><div class="ps" psname="aarch64.functions.sysregisters.CNTKCTL"><a id="aarch64.functions.sysregisters.CNTKCTL" name="aarch64.functions.sysregisters.CNTKCTL"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>sysregisters</ins><del>sve</del>/<ins>CNTKCTL</ins><del>MemSingleNF</del></h3><p class="pseudocode"><ins>// CNTKCTL[] - non-assignment form
// ===============================
</ins><del>// MemSingleNF[] - non-assignment form
// ===================================
</del>
<ins>CNTKCTLType</ins><del>(bits(8*size), boolean) MemSingleNF[bits(64) address, integer size,</del> <a id="impl-aarch64.CNTKCTL.read.0" name="impl-aarch64.CNTKCTL.read.0"></a><ins>CNTKCTL[]
    bits(32) r;
    if</ins><del>acctype, boolean wasaligned]
    bits(8*size) value;
    boolean iswrite = FALSE;</del> <del> memaddrdesc;

    // Implementation may suppress NF load for any reason
    if </del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><del>ConstrainUnpredictableBool</del></a><del>(</del><a href="shared_pseudocode.html#Unpredictable_NONFAULT" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_NONFAULT</del></a><del>) then
        return (bits(8*size) UNKNOWN, TRUE);

    // MMU or MPU
    memaddrdesc = </del><a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><del>AArch64.TranslateAddress</del></a><del>(address, acctype, iswrite, wasaligned, size);

    // Non-fault load from Device memory must not be performed externally
    if memaddrdesc.memattrs.type == </del><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Device</del></a><del> then
        return (bits(8*size) UNKNOWN, TRUE);

    // Check for aborts or debug exceptions
    if </del><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><del>(memaddrdesc) then
        return (bits(8*size) UNKNOWN, TRUE);

    // Memory array access
    accdesc = CreateAccessDescriptor(acctype);

    if </del><a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()"><del>HaveMTEExt</del></a><del>() then
        if </del><a href="shared_pseudocode.html#impl-aarch64.AccessIsTagChecked.2" title="function: boolean AccessIsTagChecked(bits(64) vaddr, AccType acctype)"><del>AccessIsTagChecked</del></a><del>(address, acctype) then
            bits(4) ptag = </del><a href="shared_pseudocode.html#impl-aarch64.TransformTag.1" title="function: bits(4) TransformTag(bits(64) vaddr)"><del>TransformTag</del></a><del>(address);
            if !</del><a href="shared_pseudocode.html#impl-aarch64.CheckTag.3" title="function: boolean CheckTag(AddressDescriptor memaddrdesc, bits(4) ptag, boolean write)"><del>CheckTag</del></a><a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><ins>IsInHost</ins></a><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><del>AddressDescriptor</del></a><ins>() then
        r = CNTHCTL_EL2;
        return r;
    r = CNTKCTL_EL1;
    return r;</ins><del>(memaddrdesc, ptag, iswrite) then
                return (bits(8*size) UNKNOWN, TRUE);
    value = _Mem[memaddrdesc, size, accdesc];

    return (value, FALSE);</del></p></div><div class="ps" psname="aarch64.functions.sysregisters.CNTKCTLType"><a id="aarch64.functions.sysregisters.CNTKCTLType" name="aarch64.functions.sysregisters.CNTKCTLType"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>sysregisters</ins><del>sve</del>/<ins>CNTKCTLType</ins><del>NoneActive</del></h3><p class="pseudocode"><ins>type</ins><del>// NoneActive()
// ============

bit</del> <a id="CNTKCTLType" name="CNTKCTLType"></a><ins>CNTKCTLType;</ins><del>NoneActive(bits(N) mask, bits(N) x, integer esize)
    integer elements = N DIV (esize DIV 8);
    for e = 0 to elements-1
        if</del><a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]"><del>ElemP</del></a><del>[mask, e, esize] == '1' &amp;&amp; </del><a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]"><del>ElemP</del></a><del>[x, e, esize] == '1' then return '0';
    return '1';</del></p></div><div class="ps" psname="aarch64.functions.sysregisters.CPACR"><a id="aarch64.functions.sysregisters.CPACR" name="aarch64.functions.sysregisters.CPACR"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>sysregisters</ins><del>sve</del>/<ins>CPACR</ins><del>P</del></h3><p class="pseudocode"><ins>// CPACR[] - non-assignment form
// =============================
</ins><del>// P[] - non-assignment form
// =========================
</del>
<ins>CPACRType</ins><del>bits(width)</del> <a id="impl-aarch64.CPACR.read.0" name="impl-aarch64.CPACR.read.0"></a><ins>CPACR[]
    bits(32) r;
    if</ins><del>P[integer n]
    assert n >= 0 &amp;&amp; n &lt;= 31;
    assert width == PL;
    return _P[n]&lt;width-1:0>;

// P[] - assignment form
// =====================</del> <del>P[integer n] = bits(width) value
    assert n >= 0 &amp;&amp; n &lt;= 31;
    assert width == PL;
    if </del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><del>ConstrainUnpredictableBool</del></a><del>(</del><a href="shared_pseudocode.html#Unpredictable_SVEZEROUPPER" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_SVEZEROUPPER</del></a><del>) then
        _P[n] = </del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><ins>IsInHost</ins></a><ins>() then
        r = CPTR_EL2;
        return r;
    r = CPACR_EL1;
    return r;</ins><del>(value);
    else
        _P[n]&lt;width-1:0> = value;</del></p></div><div class="ps" psname="aarch64.functions.sysregisters.CPACRType"><a id="aarch64.functions.sysregisters.CPACRType" name="aarch64.functions.sysregisters.CPACRType"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>sysregisters</ins><del>sve</del>/<ins>CPACRType</ins><del>PL</del></h3><p class="pseudocode"><ins>type</ins><del>// PL - non-assignment form
// ========================

integer PL
    return VL DIV 8;</del> <a id="CPACRType" name="CPACRType"></a><ins>CPACRType;</ins></p></div><div class="ps" psname="aarch64.functions.sysregisters.ELR"><a id="aarch64.functions.sysregisters.ELR" name="aarch64.functions.sysregisters.ELR"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>sysregisters</ins><del>sve</del>/<ins>ELR</ins><del>PredTest</del></h3><p class="pseudocode"><ins>// ELR[] - non-assignment form
// ===========================
</ins><del>// PredTest()
// ==========
</del>
<ins>bits(64)</ins><del>bits(4)</del> <a id="impl-aarch64.ELR.read.1" name="impl-aarch64.ELR.read.1"></a><ins>ELR[bits(2) el]
    bits(64) r;
    case el of
        when</ins><del>PredTest(bits(N) mask, bits(N) result, integer esize)
    bit n =</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#impl-aarch64.FirstActive.3" title="function: bit FirstActive(bits(N) mask, bits(N) x, integer esize)"><del>FirstActive</del></a>  <ins>r = ELR_EL1;
        when</ins><del>(mask, result, esize);
    bit z =</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-aarch64.NoneActive.3" title="function: bit NoneActive(bits(N) mask, bits(N) x, integer esize)"><del>NoneActive</del></a>  <ins>r = ELR_EL2;
        when</ins><del>(mask, result, esize);
    bit c = NOT</del> <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-aarch64.LastActive.3" title="function: bit LastActive(bits(N) mask, bits(N) x, integer esize)"><del>LastActive</del></a><ins>  r = ELR_EL3;
        otherwise </ins><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><ins>Unreachable</ins></a><ins>();
    return r;

// ELR[] - non-assignment form
// ===========================

bits(64) </ins><a id="impl-aarch64.ELR.read.0" name="impl-aarch64.ELR.read.0"></a><ins>ELR[]
    assert PSTATE.EL != </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>;
    return </ins><a href="shared_pseudocode.html#impl-aarch64.ELR.read.1" title="accessor: bits(64) ELR[bits(2) el]"><ins>ELR</ins></a><ins>[PSTATE.EL];

// ELR[] - assignment form
// =======================

</ins><a id="impl-aarch64.ELR.write.1" name="impl-aarch64.ELR.write.1"></a><ins>ELR[bits(2) el] = bits(64) value
    bits(64) r = value;
    case el of
        when </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>  ELR_EL1 = r;
        when </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>  ELR_EL2 = r;
        when </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>  ELR_EL3 = r;
        otherwise </ins><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><ins>Unreachable</ins></a><ins>();
    return;

// ELR[] - assignment form
// =======================

</ins><a id="impl-aarch64.ELR.write.0" name="impl-aarch64.ELR.write.0"></a><ins>ELR[] = bits(64) value
    assert PSTATE.EL != </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>;
    </ins><a href="shared_pseudocode.html#impl-aarch64.ELR.write.1" title="accessor: ELR[bits(2) el] = bits(64) value"><ins>ELR</ins></a><ins>[PSTATE.EL] = value;
    return;</ins><del>(mask, result, esize);
    bit v = '0';
    return n:z:c:v;</del></p></div><div class="ps" psname="aarch64.functions.sysregisters.ESR"><a id="aarch64.functions.sysregisters.ESR" name="aarch64.functions.sysregisters.ESR"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>sysregisters</ins><del>sve</del>/<ins>ESR</ins><del>ReducePredicated</del></h3><p class="pseudocode"><ins>// ESR[] - non-assignment form
// ===========================
</ins><del>// ReducePredicated()
// ==================
</del>
<ins>ESRType</ins><del>bits(esize)</del> <a id="impl-aarch64.ESR.read.1" name="impl-aarch64.ESR.read.1"></a><ins>ESR[bits(2) regime]
    bits(32) r;
    case regime of
        when</ins><del>ReducePredicated(</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#ReduceOp" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM, ReduceOp_FMIN, ReduceOp_FMAX, ReduceOp_FADD, ReduceOp_ADD}"><del>ReduceOp</del></a>  <ins>r = ESR_EL1;
        when</ins><del>op, bits(N) input, bits(M) mask, bits(esize) identity)
    assert(N == M * 8);
    integer p2bits =</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-aarch64.CeilPow2.1" title="function: integer CeilPow2(integer x)"><del>CeilPow2</del></a>  <ins>r = ESR_EL2;
        when</ins><del>(N);
    bits(p2bits) operand;
    integer elements = p2bits DIV esize;

    for e = 0 to elements-1
        if e * esize &lt; N &amp;&amp;</del> <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]"><del>ElemP</del></a>  <ins>r = ESR_EL3;
        otherwise</ins><del>[mask, e, esize] == '1' then</del> <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><ins>Unreachable</ins></a><a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value"><del>Elem</del></a><ins>();
    return r;

// ESR[] - non-assignment form
// ===========================

ESRType</ins><del>[operand, e, esize] =</del> <a id="impl-aarch64.ESR.read.0" name="impl-aarch64.ESR.read.0"></a><ins>ESR[]
    return</ins><del>[input, e, esize];
        else</del> <a href="shared_pseudocode.html#impl-aarch64.ESR.read.1" title="accessor: ESRType ESR[bits(2) regime]"><ins>ESR</ins></a><a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value"><del>Elem</del></a><ins>[</ins><del>[operand, e, esize] = identity;

    return</del><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><a href="shared_pseudocode.html#impl-aarch64.Reduce.3" title="function: bits(esize) Reduce(ReduceOp op, bits(N) input, integer esize)"><del>Reduce</del></a><ins>()];

// ESR[] - assignment form
// =======================

</ins><a id="impl-aarch64.ESR.write.1" name="impl-aarch64.ESR.write.1"></a><ins>ESR[bits(2) regime] = </ins><a href="shared_pseudocode.html#ESRType" title="type ESRType"><ins>ESRType</ins></a><ins> value
    bits(32) r = value;
    case regime of
        when </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>  ESR_EL1 = r;
        when </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>  ESR_EL2 = r;
        when </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>  ESR_EL3 = r;
        otherwise </ins><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><ins>Unreachable</ins></a><ins>();
    return;

// ESR[] - assignment form
// =======================

</ins><a id="impl-aarch64.ESR.write.0" name="impl-aarch64.ESR.write.0"></a><ins>ESR[] = </ins><a href="shared_pseudocode.html#ESRType" title="type ESRType"><ins>ESRType</ins></a><ins> value
    </ins><a href="shared_pseudocode.html#impl-aarch64.ESR.write.1" title="accessor: ESR[bits(2) regime] = ESRType value"><ins>ESR</ins></a><ins>[</ins><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><ins>()] = value;</ins><del>(op, operand, esize);</del></p></div><div class="ps" psname="aarch64.functions.sysregisters.ESRType"><a id="aarch64.functions.sysregisters.ESRType" name="aarch64.functions.sysregisters.ESRType"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>sysregisters</ins><del>sve</del>/<ins>ESRType</ins><del>Reverse</del></h3><p class="pseudocode"><ins>type</ins><del>// Reverse()
// =========
// Reverse subwords of M bits in an N-bit word

bits(N)</del> <a id="ESRType" name="ESRType"></a><ins>ESRType;</ins><del>Reverse(bits(N) word, integer M)
    bits(N) result;
    integer sw = N DIV M;
    assert N == sw * M;
    for s = 0 to sw-1</del><a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value"><del>Elem</del></a><del>[result, sw - 1 - s, M] = </del><a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]"><del>Elem</del></a><del>[word, s, M];
    return result;</del></p></div><div class="ps" psname="aarch64.functions.sysregisters.FAR"><a id="aarch64.functions.sysregisters.FAR" name="aarch64.functions.sysregisters.FAR"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>sysregisters</ins><del>sve</del>/<ins>FAR</ins><del>SVEAccessTrap</del></h3><p class="pseudocode"><ins>// FAR[] - non-assignment form
// ===========================

bits(64)</ins><del>// SVEAccessTrap()
// ===============
// Trapped access to SVE registers due to CPACR_EL1, CPTR_EL2, or CPTR_EL3.</del> <a id="impl-aarch64.FAR.read.1" name="impl-aarch64.FAR.read.1"></a><ins>FAR[bits(2) regime]
    bits(64) r;
    case regime of
        when</ins><del>SVEAccessTrap(bits(2) target_el)
    assert</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a>  <ins>r = FAR_EL1;
        when</ins><del>(target_el) >=</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a>  <ins>r = FAR_EL2;
        when</ins><del>(PSTATE.EL) &amp;&amp; target_el !=</del> <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a>  <ins>r = FAR_EL3;
        otherwise</ins><del>&amp;&amp;</del> <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><ins>Unreachable</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>();
    return r;

// FAR[] - non-assignment form
// ===========================

bits(64)</ins><del>(target_el);
    route_to_el2 = target_el ==</del> <a id="impl-aarch64.FAR.read.0" name="impl-aarch64.FAR.read.0"></a><ins>FAR[]
    return</ins><del>&amp;&amp;</del> <a href="shared_pseudocode.html#impl-aarch64.FAR.read.1" title="accessor: bits(64) FAR[bits(2) regime]"><ins>FAR</ins></a><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><ins>[</ins><del>() &amp;&amp; HCR_EL2.TGE == '1';

    exception =</del><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception type)"><del>ExceptionSyndrome</del></a><ins>()];

// FAR[] - assignment form
// =======================</ins><del>(</del>

<a id="impl-aarch64.FAR.write.1" name="impl-aarch64.FAR.write.1"></a><ins>FAR[bits(2) regime] = bits(64) value
    bits(64) r = value;
    case regime of
        when</ins><del>);
    bits(64) preferred_exception_return =</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><del>ThisInstrAddr</del></a>  <ins>FAR_EL1 = r;
        when</ins><del>();
    vect_offset = 0x0;

    if route_to_el2 then</del> <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  <ins>FAR_EL2 = r;
        when</ins><del>, exception, preferred_exception_return, vect_offset);
    else</del> <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception, bits(64) preferred_exception_return, integer vect_offset)"><del>AArch64.TakeException</del></a><ins>  FAR_EL3 = r;
        otherwise </ins><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><ins>Unreachable</ins></a><ins>();
    return;

// FAR[] - assignment form
// =======================

</ins><a id="impl-aarch64.FAR.write.0" name="impl-aarch64.FAR.write.0"></a><ins>FAR[] = bits(64) value
    </ins><a href="shared_pseudocode.html#impl-aarch64.FAR.write.1" title="accessor: FAR[bits(2) regime] = bits(64) value"><ins>FAR</ins></a><ins>[</ins><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><ins>()] = value;
    return;</ins><del>(target_el, exception, preferred_exception_return, vect_offset);</del></p></div><div class="ps" psname="aarch64.functions.sysregisters.MAIR"><a id="aarch64.functions.sysregisters.MAIR" name="aarch64.functions.sysregisters.MAIR"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>sysregisters</ins><del>sve</del>/<ins>MAIR</ins><del>SVECmp</del></h3><p class="pseudocode"><ins>// MAIR[] - non-assignment form
// ============================

MAIRType</ins><del>enumeration</del> <a id="impl-aarch64.MAIR.read.1" name="impl-aarch64.MAIR.read.1"></a><ins>MAIR[bits(2) regime]
    bits(64) r;
    case regime of
        when</ins><del>SVECmp {</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a>  <ins>r = MAIR_EL1;
        when</ins><del>Cmp_EQ,</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a>  <ins>r = MAIR_EL2;
        when</ins><del>Cmp_NE,</del> <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a>  <ins>r = MAIR_EL3;
        otherwise</ins><del>Cmp_GE,</del> <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><ins>Unreachable</ins></a><ins>();
    return r;

// MAIR[] - non-assignment form
// ============================

MAIRType</ins><del>Cmp_GT,</del> <a id="impl-aarch64.MAIR.read.0" name="impl-aarch64.MAIR.read.0"></a><ins>MAIR[]
    return</ins><del>Cmp_LT,</del> <a href="shared_pseudocode.html#impl-aarch64.MAIR.read.1" title="accessor: MAIRType MAIR[bits(2) regime]"><ins>MAIR</ins></a><ins>[</ins><del>Cmp_LE,</del><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><ins>()];</ins><del>Cmp_UN };</del></p></div><div class="ps" psname="aarch64.functions.sysregisters.MAIRType"><a id="aarch64.functions.sysregisters.MAIRType" name="aarch64.functions.sysregisters.MAIRType"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>sysregisters</ins><del>sve</del>/<ins>MAIRType</ins><del>SVEMoveMaskPreferred</del></h3><p class="pseudocode"><ins>type</ins><del>// SVEMoveMaskPreferred()
// ======================
// Return FALSE if a bitmask immediate encoding would generate an immediate
// value that could also be represented by a single DUP instruction.
// Used as a condition for the preferred MOV&lt;-DUPM alias.

boolean</del> <a id="MAIRType" name="MAIRType"></a><ins>MAIRType;</ins><del>SVEMoveMaskPreferred(bits(13) imm13)
    bits(64) imm;
    (imm, -) =</del><a href="shared_pseudocode.html#impl-aarch64.DecodeBitMasks.4" title="function: (bits(M), bits(M)) DecodeBitMasks(bit immN, bits(6) imms, bits(6) immr, boolean immediate)"><del>DecodeBitMasks</del></a><del>(imm13&lt;12>, imm13&lt;5:0>, imm13&lt;11:6>, TRUE);

    // Check for 8 bit immediates
    if !</del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(imm&lt;7:0>) then
        // Check for 'ffffffffffffffxy' or '00000000000000xy'
        if </del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(imm&lt;63:7>) || </del><a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)"><del>IsOnes</del></a><del>(imm&lt;63:7>) then
            return FALSE;

        // Check for 'ffffffxyffffffxy' or '000000xy000000xy'
        if imm&lt;63:32> == imm&lt;31:0> &amp;&amp; (</del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(imm&lt;31:7>) || </del><a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)"><del>IsOnes</del></a><del>(imm&lt;31:7>)) then
            return FALSE;

        // Check for 'ffxyffxyffxyffxy' or '00xy00xy00xy00xy'
        if imm&lt;63:32> == imm&lt;31:0> &amp;&amp; imm&lt;31:16> == imm&lt;15:0> &amp;&amp; (</del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(imm&lt;15:7>) || </del><a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)"><del>IsOnes</del></a><del>(imm&lt;15:7>)) then
            return FALSE;

        // Check for 'xyxyxyxyxyxyxyxy'
        if imm&lt;63:32> == imm&lt;31:0> &amp;&amp; imm&lt;31:16> == imm&lt;15:0> &amp;&amp; (imm&lt;15:8> == imm&lt;7:0>) then
            return FALSE;

    // Check for 16 bit immediates
    else
        // Check for 'ffffffffffffxy00' or '000000000000xy00'
        if </del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(imm&lt;63:15>) || </del><a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)"><del>IsOnes</del></a><del>(imm&lt;63:15>) then
            return FALSE;

        // Check for 'ffffxy00ffffxy00' or '0000xy000000xy00'
        if imm&lt;63:32> == imm&lt;31:0> &amp;&amp; (</del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(imm&lt;31:7>) || </del><a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)"><del>IsOnes</del></a><del>(imm&lt;31:7>)) then
            return FALSE;

        // Check for 'xy00xy00xy00xy00'
        if imm&lt;63:32> == imm&lt;31:0> &amp;&amp; imm&lt;31:16> == imm&lt;15:0> then
            return FALSE;

    return TRUE;</del></p></div><div class="ps" psname="aarch64.functions.sysregisters.SCTLR"><a id="aarch64.functions.sysregisters.SCTLR" name="aarch64.functions.sysregisters.SCTLR"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>sysregisters</ins><del>sve</del>/<ins>SCTLR</ins><del>System</del></h3><p class="pseudocode"><ins>// SCTLR[] - non-assignment form
// =============================

SCTLRType</ins><del>array bits(</del> <a id="impl-aarch64.SCTLR.read.1" name="impl-aarch64.SCTLR.read.1"></a><ins>SCTLR[bits(2) regime]
    bits(64) r;
    case regime of
        when</ins><del>) _Z[0..31];
array bits(</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#MAX_PL" title="constant integer MAX_PL = 256"><del>MAX_PL</del></a>  <ins>r = SCTLR_EL1;
        when</ins><del>) _P[0..15];
bits(</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#MAX_PL" title="constant integer MAX_PL = 256"><del>MAX_PL</del></a><ins>  r = SCTLR_EL2;
        when </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>  r = SCTLR_EL3;
        otherwise </ins><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><ins>Unreachable</ins></a><ins>();
    return r;

// SCTLR[] - non-assignment form
// =============================

SCTLRType </ins><a id="impl-aarch64.SCTLR.read.0" name="impl-aarch64.SCTLR.read.0"></a><ins>SCTLR[]
    return </ins><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.1" title="accessor: SCTLRType SCTLR[bits(2) regime]"><ins>SCTLR</ins></a><ins>[</ins><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><ins>()];</ins><del>) _FFR;</del></p></div><div class="ps" psname="aarch64.functions.sysregisters.SCTLRType"><a id="aarch64.functions.sysregisters.SCTLRType" name="aarch64.functions.sysregisters.SCTLRType"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>sysregisters</ins><del>sve</del>/<ins>SCTLRType</ins><del>VL</del></h3><p class="pseudocode"><ins>type</ins><del>// VL - non-assignment form
// ========================

integer VL
    integer vl;

    if PSTATE.EL ==</del> <del> || (PSTATE.EL == </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del> &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><del>IsInHost</del></a><del>()) then
        vl = </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(ZCR_EL1.LEN);

    if PSTATE.EL == </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del> || (PSTATE.EL == </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del> &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><del>IsInHost</del></a><del>()) then
        vl = </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(ZCR_EL2.LEN);
    elsif </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; PSTATE.EL IN {</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>,</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>} then
        vl = </del><a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)"><del>Min</del></a><del>(vl, </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(ZCR_EL2.LEN));

    if PSTATE.EL == </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del> then
        vl = </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(ZCR_EL3.LEN);
    elsif </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) then
        vl = </del><a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)"><del>Min</del></a><del>(vl, </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(ZCR_EL3.LEN));

    vl = (vl + 1) * 128;
    vl = </del><a href="shared_pseudocode.html#impl-aarch64.ImplementedSVEVectorLength.1" title="function: integer ImplementedSVEVectorLength(integer nbits)"><del>ImplementedSVEVectorLength</del></a><a id="SCTLRType" name="SCTLRType"></a><ins>SCTLRType;</ins><del>(vl);

    return vl;</del></p></div><div class="ps" psname="aarch64.functions.sysregisters.VBAR"><a id="aarch64.functions.sysregisters.VBAR" name="aarch64.functions.sysregisters.VBAR"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>sysregisters</ins><del>sve</del>/<ins>VBAR</ins><del>Z</del></h3><p class="pseudocode"><ins>// VBAR[] - non-assignment form
// ============================
</ins><del>// Z[] - non-assignment form
// =========================
</del>
<ins>bits(64)</ins><del>bits(width)</del> <a id="impl-aarch64.VBAR.read.1" name="impl-aarch64.VBAR.read.1"></a><ins>VBAR[bits(2) regime]
    bits(64) r;
    case regime of
        when</ins><del>Z[integer n]
    assert n >= 0 &amp;&amp; n &lt;= 31;
    assert width == VL;
    return _Z[n]&lt;width-1:0>;

// Z[] - assignment form
// =====================</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a>  <ins>r = VBAR_EL1;
        when</ins><del>Z[integer n] = bits(width) value
    assert n >= 0 &amp;&amp; n &lt;= 31;
    assert width == VL;
    if</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><del>ConstrainUnpredictableBool</del></a>  <ins>r = VBAR_EL2;
        when</ins><del>(</del> <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#Unpredictable_SVEZEROUPPER" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_SVEZEROUPPER</del></a>  <ins>r = VBAR_EL3;
        otherwise</ins><del>) then
        _Z[n] =</del> <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><ins>Unreachable</ins></a><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><ins>();
    return r;

// VBAR[] - non-assignment form
// ============================

bits(64) </ins><a id="impl-aarch64.VBAR.read.0" name="impl-aarch64.VBAR.read.0"></a><ins>VBAR[]
    return </ins><a href="shared_pseudocode.html#impl-aarch64.VBAR.read.1" title="accessor: bits(64) VBAR[bits(2) regime]"><ins>VBAR</ins></a><ins>[</ins><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><ins>()];</ins><del>(value);
    else
        _Z[n]&lt;width-1:0> = value;</del></p></div><div class="ps" psname="aarch64.functions.system.AArch64.CheckSystemAccess"><a id="aarch64.functions.system.AArch64.CheckSystemAccess" name="aarch64.functions.system.AArch64.CheckSystemAccess"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>system</ins><del>sysregisters</del>/<ins>AArch64.CheckSystemAccess</ins><del>CNTKCTL</del></h3><p class="pseudocode"><ins>// AArch64.CheckSystemAccess()
// ===========================
// Checks if an AArch64 MSR, MRS or SYS instruction is allowed from the current exception level and security state.
// Also checks for traps by TIDCP and NV access.</ins><del>// CNTKCTL[] - non-assignment form
// ===============================

CNTKCTLType</del>

<a id="AArch64.CheckSystemAccess.7" name="AArch64.CheckSystemAccess.7"></a><ins>AArch64.CheckSystemAccess(bits(2) op0, bits(3) op1, bits(4) crn, bits(4) crm, bits(3) op2, bits(5) rt, bit read)
    boolean unallocated = FALSE;
    boolean need_secure = FALSE;
    bits(2) min_EL;

    // Check for traps by HCR_EL2.TIDCP
    if PSTATE.EL IN {</ins><del>CNTKCTL[]
    bits(32) r;
    if</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><del>IsInHost</del></a><ins>,</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>} &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>() &amp;&amp; HCR_EL2.TIDCP == 1 &amp;&amp; op0 == 'x1' &amp;&amp; crn == '1x11' then
        // At EL0, it is IMPLEMENTATION_DEFINED whether attempts to execute system
        // register access instructions with reserved encodings are trapped to EL2 or UNDEFINED
        rcs_el0_trap = boolean IMPLEMENTATION_DEFINED "Reserved Control Space </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins> Trapped";
        if PSTATE.EL == </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins> || rcs_el0_trap then
            </ins><a href="shared_pseudocode.html#AArch64.SystemAccessTrap.2" title="function: AArch64.SystemAccessTrap(bits(2) target_el, integer ec)"><ins>AArch64.SystemAccessTrap</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>, 0x18);    // Exception_SystemRegisterTrap

    // Check for unallocated encodings
    case op1 of
        when '00x', '010'
            min_EL = </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>;
        when '011'
            min_EL = </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>;
        when '100'
            min_EL = </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>;
        when '101'
            if !</ins><a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><ins>HaveVirtHostExt</ins></a><ins>() then UNDEFINED;
            min_EL = </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>;
        when '110'
            min_EL = </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>;
        when '111'
            min_EL = </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>;
            need_secure = TRUE;

    if </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(PSTATE.EL) &lt; </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(min_EL) then
        // Check for traps on read/write access to registers named _EL2, _EL02, _EL12 from non-secure EL1 when HCR_EL2.NV bit is set
        nv_access = </ins><a href="shared_pseudocode.html#impl-shared.HaveNVExt.0" title="function: boolean HaveNVExt()"><ins>HaveNVExt</ins></a><ins>() &amp;&amp; min_EL == </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins> &amp;&amp; PSTATE.EL == </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins> &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>() &amp;&amp; HCR_EL2.NV == '1';
        if !nv_access then
            UNDEFINED;
    elsif need_secure &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a>() then
<ins>        UNDEFINED;</ins><del>        r = CNTHCTL_EL2;
        return r;
    r = CNTKCTL_EL1;
    return r;</del></p></div><div class="ps" psname="aarch64.functions.system.AArch64.ExecutingATS1xPInstr"><a id="aarch64.functions.system.AArch64.ExecutingATS1xPInstr" name="aarch64.functions.system.AArch64.ExecutingATS1xPInstr"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>system</ins><del>sysregisters</del>/<ins>AArch64.ExecutingATS1xPInstr</ins><del>CNTKCTLType</del></h3><p class="pseudocode"><ins>// AArch64.ExecutingATS1xPInstr()
// ==============================
// Return TRUE if current instruction is AT S1E1R/WP

boolean</ins><del>type</del> <a id="AArch64.ExecutingATS1xPInstr.0" name="AArch64.ExecutingATS1xPInstr.0"></a><ins>AArch64.ExecutingATS1xPInstr()
    if !</ins><del>CNTKCTLType;</del><a href="shared_pseudocode.html#impl-shared.HavePrivATExt.0" title="function: boolean HavePrivATExt()"><ins>HavePrivATExt</ins></a><ins>() then return FALSE;

    instr = </ins><a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()"><ins>ThisInstr</ins></a><ins>();
    if instr&lt;22+:10> == '1101010100' then
        op1  = instr&lt;16+:3>;
        CRn  = instr&lt;12+:4>;
        CRm  = instr&lt;8+:4>;
        op2  = instr&lt;5+:3>;
        return op1 == '000' &amp;&amp; CRn == '0111' &amp;&amp; CRm == '1001' &amp;&amp; op2 IN {'000','001'};
    else
        return FALSE;</ins></p></div><div class="ps" psname="aarch64.functions.system.AArch64.ExecutingBROrBLROrRetInstr"><a id="aarch64.functions.system.AArch64.ExecutingBROrBLROrRetInstr" name="aarch64.functions.system.AArch64.ExecutingBROrBLROrRetInstr"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>system</ins><del>sysregisters</del>/<ins>AArch64.ExecutingBROrBLROrRetInstr</ins><del>CPACR</del></h3><p class="pseudocode"><ins>// AArch64.ExecutingBROrBLROrRetInstr()
// ====================================
// Returns TRUE if current instruction is a BR, BLR, RET, B[L]RA[B][Z], or RETA[B].
</ins><del>// CPACR[] - non-assignment form
// =============================
</del>
<ins>boolean</ins><del>CPACRType</del> <a id="AArch64.ExecutingBROrBLROrRetInstr.0" name="AArch64.ExecutingBROrBLROrRetInstr.0"></a><ins>AArch64.ExecutingBROrBLROrRetInstr()
    if !</ins><del>CPACR[]
    bits(32) r;
    if</del><a href="shared_pseudocode.html#impl-shared.HaveBTIExt.0" title="function: boolean HaveBTIExt()"><ins>HaveBTIExt</ins></a><a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><del>IsInHost</del></a><ins>() then return FALSE;

    instr = </ins><a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()"><ins>ThisInstr</ins></a><ins>();
    if instr&lt;31:25> == '1101011' &amp;&amp; instr&lt;20:16> == '11111' then
        opc = instr&lt;24:21>;
        return opc != '0101';
    else
        return FALSE;</ins><del>() then
        r = CPTR_EL2;
        return r;
    r = CPACR_EL1;
    return r;</del></p></div><div class="ps" psname="aarch64.functions.system.AArch64.ExecutingBTIInstr"><a id="aarch64.functions.system.AArch64.ExecutingBTIInstr" name="aarch64.functions.system.AArch64.ExecutingBTIInstr"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>system</ins><del>sysregisters</del>/<ins>AArch64.ExecutingBTIInstr</ins><del>CPACRType</del></h3><p class="pseudocode"><ins>// AArch64.ExecutingBTIInstr()
// ===========================
// Returns TRUE if current instruction is a BTI.

boolean</ins><del>type</del> <a id="AArch64.ExecutingBTIInstr.0" name="AArch64.ExecutingBTIInstr.0"></a><ins>AArch64.ExecutingBTIInstr()
    if !</ins><del>CPACRType;</del><a href="shared_pseudocode.html#impl-shared.HaveBTIExt.0" title="function: boolean HaveBTIExt()"><ins>HaveBTIExt</ins></a><ins>() then return FALSE;

    instr = </ins><a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()"><ins>ThisInstr</ins></a><ins>();
    if instr&lt;31:22> == '1101010100' &amp;&amp; instr&lt;21:12> == '0000110010' &amp;&amp; instr&lt;4:0> == '11111' then
        CRm  = instr&lt;11:8>;
        op2  = instr&lt;7:5>;
        return (CRm == '0100' &amp;&amp; op2&lt;0> == '0');
    else
        return FALSE;</ins></p></div><div class="ps" psname="aarch64.functions.system.AArch64.SysInstr"><a id="aarch64.functions.system.AArch64.SysInstr" name="aarch64.functions.system.AArch64.SysInstr"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>system</ins><del>sysregisters</del>/<ins>AArch64.SysInstr</ins><del>ELR</del></h3><p class="pseudocode"><ins>// Execute a system instruction with write (source operand).</ins><del>// ELR[] - non-assignment form
// ===========================

bits(64)</del>
<a id="AArch64.SysInstr.6" name="AArch64.SysInstr.6"></a><ins>AArch64.SysInstr(integer op0, integer op1, integer crn, integer crm, integer op2, bits(64) val);</ins><del>ELR[bits(2) el]
    bits(64) r;
    case el of
        when</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>  r = ELR_EL1;
        when </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>  r = ELR_EL2;
        when </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>  r = ELR_EL3;
        otherwise </del><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><del>Unreachable</del></a><del>();
    return r;

// ELR[] - non-assignment form
// ===========================

bits(64) </del><a id="impl-aarch64.ELR.read.0" name="impl-aarch64.ELR.read.0"></a><del>ELR[]
    assert PSTATE.EL != </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>;
    return </del><a href="shared_pseudocode.html#impl-aarch64.ELR.read.1" title="accessor: bits(64) ELR[bits(2) el]"><del>ELR</del></a><del>[PSTATE.EL];

// ELR[] - assignment form
// =======================

</del><a id="impl-aarch64.ELR.write.1" name="impl-aarch64.ELR.write.1"></a><del>ELR[bits(2) el] = bits(64) value
    bits(64) r = value;
    case el of
        when </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>  ELR_EL1 = r;
        when </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>  ELR_EL2 = r;
        when </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>  ELR_EL3 = r;
        otherwise </del><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><del>Unreachable</del></a><del>();
    return;

// ELR[] - assignment form
// =======================

</del><a id="impl-aarch64.ELR.write.0" name="impl-aarch64.ELR.write.0"></a><del>ELR[] = bits(64) value
    assert PSTATE.EL != </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>;
    </del><a href="shared_pseudocode.html#impl-aarch64.ELR.write.1" title="accessor: ELR[bits(2) el] = bits(64) value"><del>ELR</del></a><del>[PSTATE.EL] = value;
    return;</del></p></div><div class="ps" psname="aarch64.functions.system.AArch64.SysInstrWithResult"><a id="aarch64.functions.system.AArch64.SysInstrWithResult" name="aarch64.functions.system.AArch64.SysInstrWithResult"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>system</ins><del>sysregisters</del>/<ins>AArch64.SysInstrWithResult</ins><del>ESR</del></h3><p class="pseudocode"><ins>// Execute a system instruction with read (result operand).
// Returns the result of the instruction.
bits(64)</ins><del>// ESR[] - non-assignment form
// ===========================

ESRType</del> <a id="AArch64.SysInstrWithResult.5" name="AArch64.SysInstrWithResult.5"></a><ins>AArch64.SysInstrWithResult(integer op0, integer op1, integer crn, integer crm, integer op2);</ins><del>ESR[bits(2) regime]
    bits(32) r;
    case regime of
        when</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>  r = ESR_EL1;
        when </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>  r = ESR_EL2;
        when </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>  r = ESR_EL3;
        otherwise </del><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><del>Unreachable</del></a><del>();
    return r;

// ESR[] - non-assignment form
// ===========================

ESRType </del><a id="impl-aarch64.ESR.read.0" name="impl-aarch64.ESR.read.0"></a><del>ESR[]
    return </del><a href="shared_pseudocode.html#impl-aarch64.ESR.read.1" title="accessor: ESRType ESR[bits(2) regime]"><del>ESR</del></a><del>[</del><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><del>()];

// ESR[] - assignment form
// =======================

</del><a id="impl-aarch64.ESR.write.1" name="impl-aarch64.ESR.write.1"></a><del>ESR[bits(2) regime] = </del><a href="shared_pseudocode.html#ESRType" title="type ESRType"><del>ESRType</del></a><del> value
    bits(32) r = value;
    case regime of
        when </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>  ESR_EL1 = r;
        when </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>  ESR_EL2 = r;
        when </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>  ESR_EL3 = r;
        otherwise </del><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><del>Unreachable</del></a><del>();
    return;

// ESR[] - assignment form
// =======================

</del><a id="impl-aarch64.ESR.write.0" name="impl-aarch64.ESR.write.0"></a><del>ESR[] = </del><a href="shared_pseudocode.html#ESRType" title="type ESRType"><del>ESRType</del></a><del> value
    </del><a href="shared_pseudocode.html#impl-aarch64.ESR.write.1" title="accessor: ESR[bits(2) regime] = ESRType value"><del>ESR</del></a><del>[</del><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><del>()] = value;</del></p></div><div class="ps" psname="aarch64.functions.system.AArch64.SysRegRead"><a id="aarch64.functions.system.AArch64.SysRegRead" name="aarch64.functions.system.AArch64.SysRegRead"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>system</ins><del>sysregisters</del>/<ins>AArch64.SysRegRead</ins><del>ESRType</del></h3><p class="pseudocode"><ins>// Read from a system register and return the contents of the register.
bits(64)</ins><del>type</del> <a id="AArch64.SysRegRead.5" name="AArch64.SysRegRead.5"></a><ins>AArch64.SysRegRead(integer op0, integer op1, integer crn, integer crm, integer op2);</ins><del>ESRType;</del></p></div><div class="ps" psname="aarch64.functions.system.AArch64.SysRegWrite"><a id="aarch64.functions.system.AArch64.SysRegWrite" name="aarch64.functions.system.AArch64.SysRegWrite"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>system</ins><del>sysregisters</del>/<ins>AArch64.SysRegWrite</ins><del>FAR</del></h3><p class="pseudocode"><ins>// Write to a system register.</ins><del>// FAR[] - non-assignment form
// ===========================

bits(64)</del>
<a id="AArch64.SysRegWrite.6" name="AArch64.SysRegWrite.6"></a><ins>AArch64.SysRegWrite(integer op0, integer op1, integer crn, integer crm, integer op2, bits(64) val);</ins><del>FAR[bits(2) regime]
    bits(64) r;
    case regime of
        when</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>  r = FAR_EL1;
        when </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>  r = FAR_EL2;
        when </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>  r = FAR_EL3;
        otherwise </del><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><del>Unreachable</del></a><del>();
    return r;

// FAR[] - non-assignment form
// ===========================

bits(64) </del><a id="impl-aarch64.FAR.read.0" name="impl-aarch64.FAR.read.0"></a><del>FAR[]
    return </del><a href="shared_pseudocode.html#impl-aarch64.FAR.read.1" title="accessor: bits(64) FAR[bits(2) regime]"><del>FAR</del></a><del>[</del><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><del>()];

// FAR[] - assignment form
// =======================

</del><a id="impl-aarch64.FAR.write.1" name="impl-aarch64.FAR.write.1"></a><del>FAR[bits(2) regime] = bits(64) value
    bits(64) r = value;
    case regime of
        when </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>  FAR_EL1 = r;
        when </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>  FAR_EL2 = r;
        when </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>  FAR_EL3 = r;
        otherwise </del><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><del>Unreachable</del></a><del>();
    return;

// FAR[] - assignment form
// =======================

</del><a id="impl-aarch64.FAR.write.0" name="impl-aarch64.FAR.write.0"></a><del>FAR[] = bits(64) value
    </del><a href="shared_pseudocode.html#impl-aarch64.FAR.write.1" title="accessor: FAR[bits(2) regime] = bits(64) value"><del>FAR</del></a><del>[</del><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><del>()] = value;
    return;</del></p></div><div class="ps" psname="aarch64.functions.system.BTypeCompatible"><a id="aarch64.functions.system.BTypeCompatible" name="aarch64.functions.system.BTypeCompatible"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>system</ins><del>sysregisters</del>/<ins>BTypeCompatible</ins><del>MAIR</del></h3><p class="pseudocode"><ins>boolean BTypeCompatible;</ins><del>// MAIR[] - non-assignment form
// ============================

MAIRType</del><a id="impl-aarch64.MAIR.read.1" name="impl-aarch64.MAIR.read.1"></a><del>MAIR[bits(2) regime]
    bits(64) r;
    case regime of
        when </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>  r = MAIR_EL1;
        when </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>  r = MAIR_EL2;
        when </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>  r = MAIR_EL3;
        otherwise </del><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><del>Unreachable</del></a><del>();
    return r;

// MAIR[] - non-assignment form
// ============================

MAIRType </del><a id="impl-aarch64.MAIR.read.0" name="impl-aarch64.MAIR.read.0"></a><del>MAIR[]
    return </del><a href="shared_pseudocode.html#impl-aarch64.MAIR.read.1" title="accessor: MAIRType MAIR[bits(2) regime]"><del>MAIR</del></a><del>[</del><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><del>()];</del></p></div><div class="ps" psname="aarch64.functions.system.BTypeCompatible_BTI"><a id="aarch64.functions.system.BTypeCompatible_BTI" name="aarch64.functions.system.BTypeCompatible_BTI"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>system</ins><del>sysregisters</del>/<ins>BTypeCompatible_BTI</ins><del>MAIRType</del></h3><p class="pseudocode"><ins>// BTypeCompatible_BTI
// ===================
// This function determines whether a given hint encoding is compatible with the current value of
// PSTATE.BTYPE. A value of TRUE here indicates a valid Branch Target Identification instruction.

boolean</ins><del>type</del> <a id="impl-aarch64.BTypeCompatible_BTI.1" name="impl-aarch64.BTypeCompatible_BTI.1"></a><ins>BTypeCompatible_BTI(bits(2) hintcode)
    case hintcode of
        when '00'
            return FALSE;
        when '01'
            return PSTATE.BTYPE != '11';
        when '10'
            return PSTATE.BTYPE != '10';
        when '11'
            return TRUE;</ins><del>MAIRType;</del></p></div><div class="ps" psname="aarch64.functions.system.BTypeCompatible_PACIXSP"><a id="aarch64.functions.system.BTypeCompatible_PACIXSP" name="aarch64.functions.system.BTypeCompatible_PACIXSP"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>system</ins><del>sysregisters</del>/<ins>BTypeCompatible_PACIXSP</ins><del>SCTLR</del></h3><p class="pseudocode"><ins>// BTypeCompatible_PACIXSP()
// =========================
// Returns TRUE if PACIASP, PACIBSP instruction is implicit compatible with PSTATE.BTYPE,
// FALSE otherwise.
</ins><del>// SCTLR[] - non-assignment form
// =============================
</del>
<ins>boolean</ins><del>SCTLRType</del> <a id="impl-aarch64.BTypeCompatible_PACIXSP.0" name="impl-aarch64.BTypeCompatible_PACIXSP.0"></a><ins>BTypeCompatible_PACIXSP()
    if PSTATE.BTYPE IN {'01', '10'} then
        return TRUE;
    elsif PSTATE.BTYPE == '11' then
        index = if PSTATE.EL ==</ins><del>SCTLR[bits(2) regime]
    bits(64) r;
    case regime of
        when</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a> <ins>then 35 else 36;
        return</ins><del>r = SCTLR_EL1;
        when</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>  r = SCTLR_EL2;
        when </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>  r = SCTLR_EL3;
        otherwise </del><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><del>Unreachable</del></a><del>();
    return r;

// SCTLR[] - non-assignment form
// =============================

SCTLRType </del><a id="impl-aarch64.SCTLR.read.0" name="impl-aarch64.SCTLR.read.0"></a><del>SCTLR[]
    return </del><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a><del>[</del><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><ins>[]&lt;index> == '0';
    else
        return FALSE;</ins><del>()];</del></p></div><div class="ps" psname="aarch64.functions.system.BTypeNext"><a id="aarch64.functions.system.BTypeNext" name="aarch64.functions.system.BTypeNext"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>system</ins><del>sysregisters</del>/<ins>BTypeNext</ins><del>SCTLRType</del></h3><p class="pseudocode"><ins>bits(2) BTypeNext;</ins><del>type</del><a id="SCTLRType" name="SCTLRType"></a><del>SCTLRType;</del></p></div><div class="ps" psname="aarch64.functions.system.InGuardedPage"><a id="aarch64.functions.system.InGuardedPage" name="aarch64.functions.system.InGuardedPage"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/<ins>system</ins><del>sysregisters</del>/<ins>InGuardedPage</ins><del>VBAR</del></h3><p class="pseudocode"><ins>boolean InGuardedPage;</ins><del>// VBAR[] - non-assignment form
// ============================

bits(64)</del><a id="impl-aarch64.VBAR.read.1" name="impl-aarch64.VBAR.read.1"></a><del>VBAR[bits(2) regime]
    bits(64) r;
    case regime of
        when </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>  r = VBAR_EL1;
        when </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>  r = VBAR_EL2;
        when </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>  r = VBAR_EL3;
        otherwise </del><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><del>Unreachable</del></a><del>();
    return r;

// VBAR[] - non-assignment form
// ============================

bits(64) </del><a id="impl-aarch64.VBAR.read.0" name="impl-aarch64.VBAR.read.0"></a><del>VBAR[]
    return </del><a href="shared_pseudocode.html#impl-aarch64.VBAR.read.1" title="accessor: bits(64) VBAR[bits(2) regime]"><del>VBAR</del></a><del>[</del><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><del>()];</del></p></div><div class="ps" psname="aarch64.instrs.branch.eret.AArch64.ExceptionReturn"><a id="aarch64.instrs.branch.eret.AArch64.ExceptionReturn" name="aarch64.instrs.branch.eret.AArch64.ExceptionReturn"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>instrs</ins><del>functions</del>/<ins>branch</ins><del>system</del>/<ins>eret/AArch64.ExceptionReturn</ins><del>AArch64.CheckAdvSIMDFPSystemRegisterTraps</del></h3><p class="pseudocode"><ins>// AArch64.ExceptionReturn()
// =========================</ins><del>// Checks if an AArch64 MSR, MRS or SYS instruction on a SIMD or floating-point
// register is trapped under the current configuration. Returns a boolean which
// is TRUE if trapping occurs, plus a binary value that specifies the Exception
// level trapped to.
(boolean, bits(2))</del>

<a id="AArch64.ExceptionReturn.2" name="AArch64.ExceptionReturn.2"></a><ins>AArch64.ExceptionReturn(bits(64) new_pc, bits(32) spsr)</ins><del>AArch64.CheckAdvSIMDFPSystemRegisterTraps(bits(2) op0, bits(3) op1, bits(4) crn, bits(4) crm, bits(3) op2, bit read);</del>

    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()"><ins>SynchronizeContext</ins></a><ins>();

    sync_errors = </ins><a href="shared_pseudocode.html#impl-shared.HaveIESB.0" title="function: boolean HaveIESB()"><ins>HaveIESB</ins></a><ins>() &amp;&amp; </ins><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><ins>SCTLR</ins></a><ins>[].IESB == '1';
    if </ins><a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()"><ins>HaveDoubleFaultExt</ins></a><ins>() then
        sync_errors = sync_errors || (SCR_EL3.EA == '1' &amp;&amp; SCR_EL3.NMEA == '1' &amp;&amp; PSTATE.EL == </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>);
    if sync_errors then
        </ins><a href="shared_pseudocode.html#impl-shared.SynchronizeErrors.0" title="function: SynchronizeErrors()"><ins>SynchronizeErrors</ins></a><ins>();
        iesb_req = TRUE;
        </ins><a href="shared_pseudocode.html#impl-shared.TakeUnmaskedPhysicalSErrorInterrupts.1" title="function: TakeUnmaskedPhysicalSErrorInterrupts(boolean iesb_req)"><ins>TakeUnmaskedPhysicalSErrorInterrupts</ins></a><ins>(iesb_req);
    // Attempts to change to an illegal state will invoke the Illegal Execution state mechanism
    </ins><a href="shared_pseudocode.html#impl-shared.SetPSTATEFromPSR.1" title="function: SetPSTATEFromPSR(bits(32) spsr)"><ins>SetPSTATEFromPSR</ins></a><ins>(spsr);
    </ins><a href="shared_pseudocode.html#impl-shared.ClearExclusiveLocal.1" title="function: ClearExclusiveLocal(integer processorid)"><ins>ClearExclusiveLocal</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><ins>ProcessorID</ins></a><ins>());
    </ins><a href="shared_pseudocode.html#impl-shared.SendEventLocal.0" title="function: SendEventLocal()"><ins>SendEventLocal</ins></a><ins>();

    if PSTATE.IL == '1' &amp;&amp; spsr&lt;4> == '1' &amp;&amp; spsr&lt;20> == '0' then
        // If the exception return is illegal, PC[63:32,1:0] are UNKNOWN
        new_pc&lt;63:32> = bits(32) UNKNOWN;
        new_pc&lt;1:0> = bits(2) UNKNOWN;
    elsif </ins><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>() then                // Return to AArch32
        // ELR_ELx[1:0] or ELR_ELx[0] are treated as being 0, depending on the target instruction set state
        if PSTATE.T == '1' then
            new_pc&lt;0> = '0';                 // T32
        else
            new_pc&lt;1:0> = '00';              // A32
    else                                     // Return to AArch64
        // ELR_ELx[63:56] might include a tag
        new_pc = </ins><a href="shared_pseudocode.html#AArch64.BranchAddr.1" title="function: bits(64) AArch64.BranchAddr(bits(64) vaddress)"><ins>AArch64.BranchAddr</ins></a><ins>(new_pc);

    if </ins><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>() then
        // 32 most significant bits are ignored.
        </ins><a href="shared_pseudocode.html#impl-shared.BranchTo.2" title="function: BranchTo(bits(N) target, BranchType branch_type)"><ins>BranchTo</ins></a><ins>(new_pc&lt;31:0>, </ins><a href="shared_pseudocode.html#BranchType_ERET" title="enumeration BranchType { BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}"><ins>BranchType_ERET</ins></a><ins>);
    else
        </ins><a href="shared_pseudocode.html#impl-shared.BranchToAddr.2" title="function: BranchToAddr(bits(N) target, BranchType branch_type)"><ins>BranchToAddr</ins></a><ins>(new_pc, </ins><a href="shared_pseudocode.html#BranchType_ERET" title="enumeration BranchType { BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}"><ins>BranchType_ERET</ins></a><ins>);</ins></p></div><div class="ps" psname="aarch64.instrs.countop.CountOp"><a id="aarch64.instrs.countop.CountOp" name="aarch64.instrs.countop.CountOp"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>instrs</ins><del>functions</del>/<ins>countop</ins><del>system</del>/<ins>CountOp</ins><del>AArch64.CheckSVESystemRegisterTraps</del></h3><p class="pseudocode"><ins>enumeration</ins><del>// Checks if an AArch64 MSR/MRS/SYS instruction on a Scalable Vector
// register is trapped under the current configuration
(boolean, bits(2))</del> <a id="CountOp" name="CountOp"></a><ins>CountOp     {</ins><del>AArch64.CheckSVESystemRegisterTraps(bits(2) op0, bits(3) op1, bits(4) crn, bits(4) crm, bits(3) op2, bit read);</del><a id="CountOp_CLZ" name="CountOp_CLZ"></a><ins>CountOp_CLZ, </ins><a id="CountOp_CLS" name="CountOp_CLS"></a><ins>CountOp_CLS, </ins><a id="CountOp_CNT" name="CountOp_CNT"></a><ins>CountOp_CNT};</ins></p></div><div class="ps" psname="aarch64.instrs.extendreg.DecodeRegExtend"><a id="aarch64.instrs.extendreg.DecodeRegExtend" name="aarch64.instrs.extendreg.DecodeRegExtend"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>instrs</ins><del>functions</del>/<ins>extendreg</ins><del>system</del>/<ins>DecodeRegExtend</ins><del>AArch64.CheckSystemAccess</del></h3><p class="pseudocode"><ins>// DecodeRegExtend()
// =================
// Decode a register extension option

ExtendType</ins><del>// AArch64.CheckSystemAccess()
// ===========================</del> <a id="impl-aarch64.DecodeRegExtend.1" name="impl-aarch64.DecodeRegExtend.1"></a><ins>DecodeRegExtend(bits(3) op)
    case op of
        when '000' return</ins><del>AArch64.CheckSystemAccess(bits(2) op0, bits(3) op1, bits(4) crn, bits(4) crm, bits(3) op2, bits(5) rt, bit read)
    // Checks if an AArch64 MSR, MRS or SYS instruction is UNALLOCATED or trapped at the current
    // exception level, security state and configuration, based on the opcode's encoding.
    boolean unallocated = FALSE;
    boolean need_secure = FALSE;
    bits(2) min_EL;

    // Check for traps by HCR_EL2.TIDCP
    if PSTATE.EL IN {</del> <a href="shared_pseudocode.html#ExtendType_UXTB" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX, ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}"><ins>ExtendType_UXTB</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>;
        when '001' return</ins><del>,</del> <a href="shared_pseudocode.html#ExtendType_UXTH" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX, ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}"><ins>ExtendType_UXTH</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>;
        when '010' return</ins><del>} &amp;&amp;</del> <a href="shared_pseudocode.html#ExtendType_UXTW" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX, ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}"><ins>ExtendType_UXTW</ins></a><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><ins>;
        when '011' return</ins><del>() &amp;&amp; HCR_EL2.TIDCP == 1 &amp;&amp; op0 == 'x1' &amp;&amp; crn == '1x11' then
        // At EL0, it is IMPLEMENTATION_DEFINED whether attempts to execute system
        // register access instructions with reserved encodings are trapped to EL2 or UNDEFINED
        rcs_el0_trap = boolean IMPLEMENTATION_DEFINED "Reserved Control Space</del> <a href="shared_pseudocode.html#ExtendType_UXTX" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX, ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}"><ins>ExtendType_UXTX</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>;
        when '100' return</ins><del>Trapped";
        if PSTATE.EL ==</del> <a href="shared_pseudocode.html#ExtendType_SXTB" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX, ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}"><ins>ExtendType_SXTB</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>;
        when '101' return</ins><del>|| rcs_el0_trap then</del> <a href="shared_pseudocode.html#ExtendType_SXTH" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX, ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}"><ins>ExtendType_SXTH</ins></a><a href="shared_pseudocode.html#AArch64.SystemRegisterTrap.8" title="function: AArch64.SystemRegisterTrap(bits(2) target_el, bits(2) op0, bits(3) op2, bits(3) op1, bits(4) crn, bits(5) rt, bits(4) crm, bit dir)"><del>AArch64.SystemRegisterTrap</del></a><ins>;
        when '110' return</ins><del>(</del> <a href="shared_pseudocode.html#ExtendType_SXTW" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX, ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}"><ins>ExtendType_SXTW</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>;
        when '111' return</ins><del>, op0, op2, op1, crn, rt, crm, read);

    // Check for unallocated encodings
    case op1 of
        when '00x', '010'
            min_EL =</del> <del>;
        when '011'
            min_EL = </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>;
        when '100'
            min_EL = </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>;
        when '101'
            if !</del><a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><del>HaveVirtHostExt</del></a><del>() then UNDEFINED;
            min_EL = </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>;
        when '110'
            min_EL = </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>;
        when '111'
            min_EL = </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>;
            need_secure = TRUE;

    if </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(PSTATE.EL) &lt; </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(min_EL) then
        // Check for traps on read/write access to registers named _EL2, _EL02, _EL12 from non-secure EL1 when HCR_EL2.NV bit is set
        nv_access = </del><a href="shared_pseudocode.html#impl-shared.HaveNVExt.0" title="function: boolean HaveNVExt()"><del>HaveNVExt</del></a><del>() &amp;&amp; min_EL == </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del> &amp;&amp; PSTATE.EL == </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del> &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; HCR_EL2.NV == '1';
        if !nv_access then
            UNDEFINED;
    elsif need_secure &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>() then
        UNDEFINED;
    elsif AArch64.CheckUnallocatedSystemAccess(PSTATE.EL, op0, op1, crn, crm, op2, read) then
        UNDEFINED;

    // Check for traps on accesses to SIMD or floating-point registers
    (take_trap, target_el) = </del><a href="shared_pseudocode.html#AArch64.CheckAdvSIMDFPSystemRegisterTraps.6" title="function: (boolean, bits(2)) AArch64.CheckAdvSIMDFPSystemRegisterTraps(bits(2) op0, bits(3) op1, bits(4) crn, bits(4) crm, bits(3) op2, bit read)"><del>AArch64.CheckAdvSIMDFPSystemRegisterTraps</del></a><del>(op0, op1, crn, crm, op2, read);
    if take_trap then
        </del><a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)"><del>AArch64.AdvSIMDFPAccessTrap</del></a><del>(target_el);

    // Check for traps on accesses to Scalable Vector registers
    (take_trap, target_el) = AArch64.CheckSVESystemRegisterTraps(op0, op1, crn, crm, op2);
    if take_trap then
        </del><a href="shared_pseudocode.html#impl-aarch64.SVEAccessTrap.1" title="function: SVEAccessTrap(bits(2) target_el)"><del>SVEAccessTrap</del></a><del>(target_el);

    // Check for traps on access to all other system registers
    (take_trap, target_el) = </del><a href="shared_pseudocode.html#AArch64.CheckSystemRegisterTraps.6" title="function: (boolean, bits(2)) AArch64.CheckSystemRegisterTraps(bits(2) op0, bits(3) op1, bits(4) crn, bits(4) crm, bits(3) op2, bit read)"><del>AArch64.CheckSystemRegisterTraps</del></a><del>(op0, op1, crn, crm, op2, read);

    if take_trap then
        </del><a href="shared_pseudocode.html#AArch64.SystemRegisterTrap.8" title="function: AArch64.SystemRegisterTrap(bits(2) target_el, bits(2) op0, bits(3) op2, bits(3) op1, bits(4) crn, bits(5) rt, bits(4) crm, bit dir)"><del>AArch64.SystemRegisterTrap</del></a><a href="shared_pseudocode.html#ExtendType_SXTX" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX, ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}"><ins>ExtendType_SXTX</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>;</ins><del>(target_el, op0, op2, op1, crn, rt, crm, read);</del></p></div><div class="ps" psname="aarch64.instrs.extendreg.ExtendReg"><a id="aarch64.instrs.extendreg.ExtendReg" name="aarch64.instrs.extendreg.ExtendReg"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>instrs</ins><del>functions</del>/<ins>extendreg</ins><del>system</del>/<ins>ExtendReg</ins><del>AArch64.CheckSystemRegisterTraps</del></h3><p class="pseudocode"><ins>// ExtendReg()
// ===========
// Perform a register extension and shift

bits(N)</ins><del>// Checks if an AArch64 MSR, MRS or SYS instruction on a system register is trapped
// under the current configuration. Returns a boolean which is TRUE if trapping
// occurs, plus a binary value that specifies the Exception level trapped to.
(boolean, bits(2))</del> <a id="impl-aarch64.ExtendReg.3" name="impl-aarch64.ExtendReg.3"></a><ins>ExtendReg(integer reg,</ins><del>AArch64.CheckSystemRegisterTraps(bits(2) op0, bits(3) op1, bits(4) crn, bits(4) crm, bits(3) op2, bit read);</del> <a href="shared_pseudocode.html#ExtendType" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX, ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}"><ins>ExtendType</ins></a><ins> type, integer shift)
    assert shift >= 0 &amp;&amp; shift &lt;= 4;
    bits(N) val = </ins><a href="shared_pseudocode.html#impl-aarch64.X.read.1" title="accessor: bits(width) X[integer n]"><ins>X</ins></a><ins>[reg];
    boolean unsigned;
    integer len;

    case type of
        when </ins><a href="shared_pseudocode.html#ExtendType_SXTB" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX, ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}"><ins>ExtendType_SXTB</ins></a><ins> unsigned = FALSE; len = 8;
        when </ins><a href="shared_pseudocode.html#ExtendType_SXTH" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX, ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}"><ins>ExtendType_SXTH</ins></a><ins> unsigned = FALSE; len = 16;
        when </ins><a href="shared_pseudocode.html#ExtendType_SXTW" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX, ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}"><ins>ExtendType_SXTW</ins></a><ins> unsigned = FALSE; len = 32;
        when </ins><a href="shared_pseudocode.html#ExtendType_SXTX" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX, ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}"><ins>ExtendType_SXTX</ins></a><ins> unsigned = FALSE; len = 64;
        when </ins><a href="shared_pseudocode.html#ExtendType_UXTB" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX, ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}"><ins>ExtendType_UXTB</ins></a><ins> unsigned = TRUE;  len = 8;
        when </ins><a href="shared_pseudocode.html#ExtendType_UXTH" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX, ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}"><ins>ExtendType_UXTH</ins></a><ins> unsigned = TRUE;  len = 16;
        when </ins><a href="shared_pseudocode.html#ExtendType_UXTW" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX, ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}"><ins>ExtendType_UXTW</ins></a><ins> unsigned = TRUE;  len = 32;
        when </ins><a href="shared_pseudocode.html#ExtendType_UXTX" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX, ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}"><ins>ExtendType_UXTX</ins></a><ins> unsigned = TRUE;  len = 64;

    // Note the extended width of the intermediate value and
    // that sign extension occurs from bit &lt;len+shift-1>, not
    // from bit &lt;len-1>. This is equivalent to the instruction
    //   [SU]BFIZ Rtmp, Rreg, #shift, #len
    // It may also be seen as a sign/zero extend followed by a shift:
    //   LSL(Extend(val&lt;len-1:0>, N, unsigned), shift);

    len = </ins><a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)"><ins>Min</ins></a><ins>(len, N - shift);
    return </ins><a href="shared_pseudocode.html#impl-shared.Extend.3" title="function: bits(N) Extend(bits(M) x, integer N, boolean unsigned)"><ins>Extend</ins></a><ins>(val&lt;len-1:0> : </ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(shift), N, unsigned);</ins></p></div><div class="ps" psname="aarch64.instrs.extendreg.ExtendType"><a id="aarch64.instrs.extendreg.ExtendType" name="aarch64.instrs.extendreg.ExtendType"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>instrs</ins><del>functions</del>/<ins>extendreg</ins><del>system</del>/<ins>ExtendType</ins><del>AArch64.CheckUnallocatedSystemAccess</del></h3><p class="pseudocode"><ins>enumeration</ins><del>// Checks if an AArch64 MSR, MRS or SYS instruction is unallocated under the current
// configuration.
boolean</del> <a id="ExtendType" name="ExtendType"></a><ins>ExtendType  {</ins><del>AArch64.CheckUnallocatedSystemAccess(bits(2) op0, bits(3) op1, bits(4) crn, bits(4) crm, bits(3) op2, bit read);</del><a id="ExtendType_SXTB" name="ExtendType_SXTB"></a><ins>ExtendType_SXTB, </ins><a id="ExtendType_SXTH" name="ExtendType_SXTH"></a><ins>ExtendType_SXTH, </ins><a id="ExtendType_SXTW" name="ExtendType_SXTW"></a><ins>ExtendType_SXTW, </ins><a id="ExtendType_SXTX" name="ExtendType_SXTX"></a><ins>ExtendType_SXTX,
                         </ins><a id="ExtendType_UXTB" name="ExtendType_UXTB"></a><ins>ExtendType_UXTB, </ins><a id="ExtendType_UXTH" name="ExtendType_UXTH"></a><ins>ExtendType_UXTH, </ins><a id="ExtendType_UXTW" name="ExtendType_UXTW"></a><ins>ExtendType_UXTW, </ins><a id="ExtendType_UXTX" name="ExtendType_UXTX"></a><ins>ExtendType_UXTX};</ins></p></div><div class="ps" psname="aarch64.instrs.float.arithmetic.max-min.fpmaxminop.FPMaxMinOp"><a id="aarch64.instrs.float.arithmetic.max-min.fpmaxminop.FPMaxMinOp" name="aarch64.instrs.float.arithmetic.max-min.fpmaxminop.FPMaxMinOp"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>instrs</ins><del>functions</del>/<ins>float</ins><del>system</del>/<ins>arithmetic/max-min/fpmaxminop/FPMaxMinOp</ins><del>AArch64.ExecutingATS1xPInstr</del></h3><p class="pseudocode"><ins>enumeration</ins><del>// AArch64.ExecutingATS1xPInstr()
// ==============================
// Return TRUE if current instruction is AT S1E1R/WP

boolean</del> <a id="FPMaxMinOp" name="FPMaxMinOp"></a><ins>FPMaxMinOp  {</ins><del>AArch64.ExecutingATS1xPInstr()
    if !</del><a id="FPMaxMinOp_MAX" name="FPMaxMinOp_MAX"></a><ins>FPMaxMinOp_MAX,</ins><del>() then return FALSE;

    instr =</del> <a id="FPMaxMinOp_MIN" name="FPMaxMinOp_MIN"></a><ins>FPMaxMinOp_MIN,
                         </ins><a id="FPMaxMinOp_MAXNUM" name="FPMaxMinOp_MAXNUM"></a><ins>FPMaxMinOp_MAXNUM, </ins><a id="FPMaxMinOp_MINNUM" name="FPMaxMinOp_MINNUM"></a><ins>FPMaxMinOp_MINNUM};</ins><del>();
    if instr&lt;22+:10> == '1101010100' then
        op1  = instr&lt;16+:3>;
        CRn  = instr&lt;12+:4>;
        CRm  = instr&lt;8+:4>;
        op2  = instr&lt;5+:3>;
        return op1 == '000' &amp;&amp; CRn == '0111' &amp;&amp; CRm == '1001' &amp;&amp; op2 IN {'000','001'};
    else
        return FALSE;</del></p></div><div class="ps" psname="aarch64.instrs.float.arithmetic.unary.fpunaryop.FPUnaryOp"><a id="aarch64.instrs.float.arithmetic.unary.fpunaryop.FPUnaryOp" name="aarch64.instrs.float.arithmetic.unary.fpunaryop.FPUnaryOp"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>instrs</ins><del>functions</del>/<ins>float</ins><del>system</del>/<ins>arithmetic/unary/fpunaryop/FPUnaryOp</ins><del>AArch64.ExecutingBROrBLROrRetInstr</del></h3><p class="pseudocode"><ins>enumeration</ins><del>// AArch64.ExecutingBROrBLROrRetInstr()
// ====================================
// Returns TRUE if current instruction is a BR, BLR, RET, B[L]RA[B][Z], or RETA[B].

boolean</del> <a id="FPUnaryOp" name="FPUnaryOp"></a><ins>FPUnaryOp   {</ins><del>AArch64.ExecutingBROrBLROrRetInstr()
    if !</del><a id="FPUnaryOp_ABS" name="FPUnaryOp_ABS"></a><ins>FPUnaryOp_ABS,</ins><del>() then return FALSE;

    instr =</del> <a id="FPUnaryOp_MOV" name="FPUnaryOp_MOV"></a><ins>FPUnaryOp_MOV,
                         </ins><a id="FPUnaryOp_NEG" name="FPUnaryOp_NEG"></a><ins>FPUnaryOp_NEG, </ins><a id="FPUnaryOp_SQRT" name="FPUnaryOp_SQRT"></a><ins>FPUnaryOp_SQRT};</ins><del>();
    if instr&lt;31:25> == '1101011' &amp;&amp; instr&lt;20:16> == '11111' then
        opc = instr&lt;24:21>;
        return opc != '0101';
    else
        return FALSE;</del></p></div><div class="ps" psname="aarch64.instrs.float.convert.fpconvop.FPConvOp"><a id="aarch64.instrs.float.convert.fpconvop.FPConvOp" name="aarch64.instrs.float.convert.fpconvop.FPConvOp"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>instrs</ins><del>functions</del>/<ins>float</ins><del>system</del>/<ins>convert/fpconvop/FPConvOp</ins><del>AArch64.ExecutingBTIInstr</del></h3><p class="pseudocode"><ins>enumeration</ins><del>// AArch64.ExecutingBTIInstr()
// ===========================
// Returns TRUE if current instruction is a BTI.

boolean</del> <a id="FPConvOp" name="FPConvOp"></a><ins>FPConvOp    {</ins><del>AArch64.ExecutingBTIInstr()
    if !</del><a id="FPConvOp_CVT_FtoI" name="FPConvOp_CVT_FtoI"></a><ins>FPConvOp_CVT_FtoI,</ins><del>() then return FALSE;

    instr =</del> <a id="FPConvOp_CVT_ItoF" name="FPConvOp_CVT_ItoF"></a><ins>FPConvOp_CVT_ItoF,
                         </ins><a id="FPConvOp_MOV_FtoI" name="FPConvOp_MOV_FtoI"></a><ins>FPConvOp_MOV_FtoI, </ins><a id="FPConvOp_MOV_ItoF" name="FPConvOp_MOV_ItoF"></a><ins>FPConvOp_MOV_ItoF
                         , </ins><a id="FPConvOp_CVT_FtoI_JS" name="FPConvOp_CVT_FtoI_JS"></a><ins>FPConvOp_CVT_FtoI_JS
};</ins><del>();
    if instr&lt;31:22> == '1101010100' &amp;&amp; instr&lt;21:12> == '0000110010' &amp;&amp; instr&lt;4:0> == '11111' then
        CRm  = instr&lt;11:8>;
        op2  = instr&lt;7:5>;
        return (CRm == '0100' &amp;&amp; op2&lt;0> == '0');
    else
        return FALSE;</del></p></div><div class="ps" psname="aarch64.instrs.integer.bitfield.bfxpreferred.BFXPreferred"><a id="aarch64.instrs.integer.bitfield.bfxpreferred.BFXPreferred" name="aarch64.instrs.integer.bitfield.bfxpreferred.BFXPreferred"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>instrs</ins><del>functions</del>/<ins>integer</ins><del>system</del>/<ins>bitfield/bfxpreferred/BFXPreferred</ins><del>AArch64.SysInstr</del></h3><p class="pseudocode"><ins>// BFXPreferred()
// ==============
//
// Return TRUE if UBFX or SBFX is the preferred disassembly of a
// UBFM or SBFM bitfield instruction. Must exclude more specific
// aliases UBFIZ, SBFIZ, UXT[BH], SXT[BHW], LSL, LSR and ASR.

boolean</ins><del>// Execute a system instruction with write (source operand).</del> <a id="impl-aarch64.BFXPreferred.4" name="impl-aarch64.BFXPreferred.4"></a><ins>BFXPreferred(bit sf, bit uns, bits(6) imms, bits(6) immr)
    integer S =</ins><del>AArch64.SysInstr(integer op0, integer op1, integer crn, integer crm, integer op2, bits(64) val);</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(imms);
    integer R = </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(immr);

    // must not match UBFIZ/SBFIX alias
    if </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(imms) &lt; </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(immr) then
        return FALSE;

    // must not match LSR/ASR/LSL alias (imms == 31 or 63)
    if imms == sf:'11111' then
        return FALSE;

    // must not match UXTx/SXTx alias
    if immr == '000000' then
        // must not match 32-bit UXT[BH] or SXT[BH]
        if sf == '0' &amp;&amp; imms IN {'000111', '001111'} then
            return FALSE;
        // must not match 64-bit SXT[BHW]
        if sf:uns == '10' &amp;&amp; imms IN {'000111', '001111', '011111'} then
            return FALSE;

    // must be UBFX/SBFX alias
    return TRUE;</ins></p></div><div class="ps" psname="aarch64.instrs.integer.bitmasks.DecodeBitMasks"><a id="aarch64.instrs.integer.bitmasks.DecodeBitMasks" name="aarch64.instrs.integer.bitmasks.DecodeBitMasks"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>instrs</ins><del>functions</del>/<ins>integer</ins><del>system</del>/<ins>bitmasks/DecodeBitMasks</ins><del>AArch64.SysInstrWithResult</del></h3><p class="pseudocode"><ins>// DecodeBitMasks()
// ================

// Decode AArch64 bitfield and logical immediate masks which use a similar encoding structure

(bits(M), bits(M))</ins><del>// Execute a system instruction with read (result operand).
// Returns the result of the instruction.
bits(64)</del> <a id="impl-aarch64.DecodeBitMasks.4" name="impl-aarch64.DecodeBitMasks.4"></a><ins>DecodeBitMasks(bit immN, bits(6) imms, bits(6) immr, boolean immediate)
    bits(64) tmask, wmask;
    bits(6) tmask_and, wmask_and;
    bits(6) tmask_or, wmask_or;
    bits(6) levels;

    // Compute log2 of element size
    // 2^len must be in range [2, M]
    len =</ins><del>AArch64.SysInstrWithResult(integer op0, integer op1, integer crn, integer crm, integer op2);</del> <a href="shared_pseudocode.html#impl-shared.HighestSetBit.1" title="function: integer HighestSetBit(bits(N) x)"><ins>HighestSetBit</ins></a><ins>(immN:NOT(imms));
    if len &lt; 1 then UNDEFINED;
    assert M >= (1 &lt;&lt; len);

    // Determine S, R and S - R parameters
    levels = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><ins>ZeroExtend</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><ins>(len), 6);

    // For logical immediates an all-ones value of S is reserved
    // since it would generate a useless all-ones result (many times)
    if immediate &amp;&amp; (imms AND levels) == levels then
        UNDEFINED;

    S = </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(imms AND levels);
    R = </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(immr AND levels);
    diff = S - R;    // 6-bit subtract with borrow

    // From a software perspective, the remaining code is equivalant to:
    //   esize = 1 &lt;&lt; len;
    //   d = UInt(diff&lt;len-1:0>);
    //   welem = ZeroExtend(Ones(S + 1), esize);
    //   telem = ZeroExtend(Ones(d + 1), esize);
    //   wmask = Replicate(ROR(welem, R));
    //   tmask = Replicate(telem);
    //   return (wmask, tmask);

    // Compute "top mask"
    tmask_and = diff&lt;5:0> OR NOT(levels);
    tmask_or  = diff&lt;5:0> AND levels;

    tmask = </ins><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><ins>(64);
    tmask = ((tmask
              AND </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(tmask_and&lt;0>, 1) : </ins><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><ins>(1), 32))
               OR  </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(1) : </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(tmask_or&lt;0>, 1), 32));
    // optimization of first step:
    // tmask = Replicate(tmask_and&lt;0> : '1', 32);
    tmask = ((tmask
              AND </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(tmask_and&lt;1>, 2) : </ins><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><ins>(2), 16))
               OR  </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(2) : </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(tmask_or&lt;1>, 2), 16));
    tmask = ((tmask
              AND </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(tmask_and&lt;2>, 4) : </ins><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><ins>(4), 8))
               OR  </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(4) : </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(tmask_or&lt;2>, 4), 8));
    tmask = ((tmask
              AND </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(tmask_and&lt;3>, 8) : </ins><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><ins>(8), 4))
               OR  </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(8) : </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(tmask_or&lt;3>, 8), 4));
    tmask = ((tmask
              AND </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(tmask_and&lt;4>, 16) : </ins><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><ins>(16), 2))
               OR  </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(16) : </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(tmask_or&lt;4>, 16), 2));
    tmask = ((tmask
              AND </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(tmask_and&lt;5>, 32) : </ins><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><ins>(32), 1))
               OR  </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(32) : </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(tmask_or&lt;5>, 32), 1));

    // Compute "wraparound mask"
    wmask_and = immr OR NOT(levels);
    wmask_or  = immr AND levels;

    wmask = </ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(64);
    wmask = ((wmask
              AND </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><ins>(1) : </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(wmask_and&lt;0>, 1), 32))
               OR  </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(wmask_or&lt;0>, 1) : </ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(1), 32));
    // optimization of first step:
    // wmask = Replicate(wmask_or&lt;0> : '0', 32);
    wmask = ((wmask
              AND </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><ins>(2) : </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(wmask_and&lt;1>, 2), 16))
               OR  </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(wmask_or&lt;1>, 2) : </ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(2), 16));
    wmask = ((wmask
              AND </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><ins>(4) : </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(wmask_and&lt;2>, 4), 8))
               OR  </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(wmask_or&lt;2>, 4) : </ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(4), 8));
    wmask = ((wmask
              AND </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><ins>(8) : </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(wmask_and&lt;3>, 8), 4))
               OR  </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(wmask_or&lt;3>, 8) : </ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(8), 4));
    wmask = ((wmask
              AND </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><ins>(16) : </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(wmask_and&lt;4>, 16), 2))
               OR  </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(wmask_or&lt;4>, 16) : </ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(16), 2));
    wmask = ((wmask
              AND </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><ins>(32) : </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(wmask_and&lt;5>, 32), 1))
               OR  </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(wmask_or&lt;5>, 32) : </ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(32), 1));

    if diff&lt;6> != '0' then // borrow from S - R
        wmask = wmask AND tmask;
    else
        wmask = wmask OR tmask;

    return (wmask&lt;M-1:0>, tmask&lt;M-1:0>);</ins></p></div><div class="ps" psname="aarch64.instrs.integer.ins-ext.insert.movewide.movewideop.MoveWideOp"><a id="aarch64.instrs.integer.ins-ext.insert.movewide.movewideop.MoveWideOp" name="aarch64.instrs.integer.ins-ext.insert.movewide.movewideop.MoveWideOp"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>instrs</ins><del>functions</del>/<ins>integer</ins><del>system</del>/<ins>ins-ext/insert/movewide/movewideop/MoveWideOp</ins><del>AArch64.SysRegRead</del></h3><p class="pseudocode"><ins>enumeration</ins><del>// Read from a system register and return the contents of the register.
bits(64)</del> <a id="MoveWideOp" name="MoveWideOp"></a><ins>MoveWideOp  {</ins><del>AArch64.SysRegRead(integer op0, integer op1, integer crn, integer crm, integer op2);</del><a id="MoveWideOp_N" name="MoveWideOp_N"></a><ins>MoveWideOp_N, </ins><a id="MoveWideOp_Z" name="MoveWideOp_Z"></a><ins>MoveWideOp_Z, </ins><a id="MoveWideOp_K" name="MoveWideOp_K"></a><ins>MoveWideOp_K};</ins></p></div><div class="ps" psname="aarch64.instrs.integer.logical.movwpreferred.MoveWidePreferred"><a id="aarch64.instrs.integer.logical.movwpreferred.MoveWidePreferred" name="aarch64.instrs.integer.logical.movwpreferred.MoveWidePreferred"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>instrs</ins><del>functions</del>/<ins>integer</ins><del>system</del>/<ins>logical/movwpreferred/MoveWidePreferred</ins><del>AArch64.SysRegWrite</del></h3><p class="pseudocode"><ins>// MoveWidePreferred()
// ===================
//
// Return TRUE if a bitmask immediate encoding would generate an immediate
// value that could also be represented by a single MOVZ or MOVN instruction.
// Used as a condition for the preferred MOV&lt;-ORR alias.

boolean</ins><del>// Write to a system register.</del> <a id="impl-aarch64.MoveWidePreferred.4" name="impl-aarch64.MoveWidePreferred.4"></a><ins>MoveWidePreferred(bit sf, bit immN, bits(6) imms, bits(6) immr)
    integer S =</ins><del>AArch64.SysRegWrite(integer op0, integer op1, integer crn, integer crm, integer op2, bits(64) val);</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(imms);
    integer R = </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(immr);
    integer width = if sf == '1' then 64 else 32;

    // element size must equal total immediate size
    if sf == '1' &amp;&amp; immN:imms != '1xxxxxx' then
        return FALSE;
    if sf == '0' &amp;&amp; immN:imms != '00xxxxx' then
        return FALSE;

    // for MOVZ must contain no more than 16 ones
    if S &lt; 16 then
        // ones must not span halfword boundary when rotated
        return (-R MOD 16) &lt;= (15 - S);

    // for MOVN must contain no more than 16 zeros
    if S >= width - 15 then
        // zeros must not span halfword boundary when rotated
        return (R MOD 16) &lt;= (S - (width - 15));

    return FALSE;</ins></p></div><div class="ps" psname="aarch64.instrs.integer.shiftreg.DecodeShift"><a id="aarch64.instrs.integer.shiftreg.DecodeShift" name="aarch64.instrs.integer.shiftreg.DecodeShift"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>instrs</ins><del>functions</del>/<ins>integer</ins><del>system</del>/<ins>shiftreg/DecodeShift</ins><del>BTypeCompatible</del></h3><p class="pseudocode"><ins>// DecodeShift()
// =============
// Decode shift encodings

ShiftType</ins><del>boolean BTypeCompatible;</del> <a id="impl-aarch64.DecodeShift.1" name="impl-aarch64.DecodeShift.1"></a><ins>DecodeShift(bits(2) op)
    case op of
        when '00'  return </ins><a href="shared_pseudocode.html#ShiftType_LSL" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}"><ins>ShiftType_LSL</ins></a><ins>;
        when '01'  return </ins><a href="shared_pseudocode.html#ShiftType_LSR" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}"><ins>ShiftType_LSR</ins></a><ins>;
        when '10'  return </ins><a href="shared_pseudocode.html#ShiftType_ASR" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}"><ins>ShiftType_ASR</ins></a><ins>;
        when '11'  return </ins><a href="shared_pseudocode.html#ShiftType_ROR" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}"><ins>ShiftType_ROR</ins></a><ins>;</ins></p></div><div class="ps" psname="aarch64.instrs.integer.shiftreg.ShiftReg"><a id="aarch64.instrs.integer.shiftreg.ShiftReg" name="aarch64.instrs.integer.shiftreg.ShiftReg"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>instrs</ins><del>functions</del>/<ins>integer</ins><del>system</del>/<ins>shiftreg/ShiftReg</ins><del>BTypeCompatible_BTI</del></h3><p class="pseudocode"><ins>// ShiftReg()
// ==========
// Perform shift of a register operand
</ins><del>// BTypeCompatible_BTI
// ===================
// This function determines whether a given hint encoding is compatible with the current value of
// PSTATE.BTYPE. A value of TRUE here indicates a valid Branch Target Identification instruction.
</del>
<ins>bits(N)</ins><del>boolean</del> <a id="impl-aarch64.ShiftReg.3" name="impl-aarch64.ShiftReg.3"></a><ins>ShiftReg(integer reg,</ins><del>BTypeCompatible_BTI(bits(2) hintcode)
    case hintcode of
        when '00'
            return FALSE;
        when '01'
            return PSTATE.BTYPE != '11';
        when '10'
            return PSTATE.BTYPE != '10';
        when '11'
            return TRUE;</del> <a href="shared_pseudocode.html#ShiftType" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}"><ins>ShiftType</ins></a><ins> type, integer amount)
    bits(N) result = </ins><a href="shared_pseudocode.html#impl-aarch64.X.read.1" title="accessor: bits(width) X[integer n]"><ins>X</ins></a><ins>[reg];
    case type of
        when </ins><a href="shared_pseudocode.html#ShiftType_LSL" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}"><ins>ShiftType_LSL</ins></a><ins> result = </ins><a href="shared_pseudocode.html#impl-shared.LSL.2" title="function: bits(N) LSL(bits(N) x, integer shift)"><ins>LSL</ins></a><ins>(result, amount);
        when </ins><a href="shared_pseudocode.html#ShiftType_LSR" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}"><ins>ShiftType_LSR</ins></a><ins> result = </ins><a href="shared_pseudocode.html#impl-shared.LSR.2" title="function: bits(N) LSR(bits(N) x, integer shift)"><ins>LSR</ins></a><ins>(result, amount);
        when </ins><a href="shared_pseudocode.html#ShiftType_ASR" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}"><ins>ShiftType_ASR</ins></a><ins> result = </ins><a href="shared_pseudocode.html#impl-shared.ASR.2" title="function: bits(N) ASR(bits(N) x, integer shift)"><ins>ASR</ins></a><ins>(result, amount);
        when </ins><a href="shared_pseudocode.html#ShiftType_ROR" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}"><ins>ShiftType_ROR</ins></a><ins> result = </ins><a href="shared_pseudocode.html#impl-shared.ROR.2" title="function: bits(N) ROR(bits(N) x, integer shift)"><ins>ROR</ins></a><ins>(result, amount);
    return result;</ins></p></div><div class="ps" psname="aarch64.instrs.integer.shiftreg.ShiftType"><a id="aarch64.instrs.integer.shiftreg.ShiftType" name="aarch64.instrs.integer.shiftreg.ShiftType"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>instrs</ins><del>functions</del>/<ins>integer</ins><del>system</del>/<ins>shiftreg/ShiftType</ins><del>BTypeCompatible_PACIXSP</del></h3><p class="pseudocode"><ins>enumeration</ins><del>// BTypeCompatible_PACIXSP()
// =========================
// Returns TRUE if PACIASP, PACIBSP instruction is implicit compatible with PSTATE.BTYPE,
// FALSE otherwise.

boolean</del> <a id="ShiftType" name="ShiftType"></a><ins>ShiftType   {</ins><del>BTypeCompatible_PACIXSP()
    if PSTATE.BTYPE IN {'01', '10'} then
        return TRUE;
    elsif PSTATE.BTYPE == '11' then
        index = if PSTATE.EL ==</del><a id="ShiftType_LSL" name="ShiftType_LSL"></a><ins>ShiftType_LSL,</ins><del>then 35 else 36;
        return</del> <a id="ShiftType_LSR" name="ShiftType_LSR"></a><ins>ShiftType_LSR, </ins><a id="ShiftType_ASR" name="ShiftType_ASR"></a><ins>ShiftType_ASR, </ins><a id="ShiftType_ROR" name="ShiftType_ROR"></a><ins>ShiftType_ROR};</ins><del>[]&lt;index> == '0';
    else
        return FALSE;</del></p></div><div class="ps" psname="aarch64.instrs.logicalop.LogicalOp"><a id="aarch64.instrs.logicalop.LogicalOp" name="aarch64.instrs.logicalop.LogicalOp"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>instrs</ins><del>functions</del>/<ins>logicalop</ins><del>system</del>/<ins>LogicalOp</ins><del>BTypeNext</del></h3><p class="pseudocode"><ins>enumeration</ins><del>bits(2) BTypeNext;</del> <a id="LogicalOp" name="LogicalOp"></a><ins>LogicalOp   {</ins><a id="LogicalOp_AND" name="LogicalOp_AND"></a><ins>LogicalOp_AND, </ins><a id="LogicalOp_EOR" name="LogicalOp_EOR"></a><ins>LogicalOp_EOR, </ins><a id="LogicalOp_ORR" name="LogicalOp_ORR"></a><ins>LogicalOp_ORR};</ins></p></div><div class="ps" psname="aarch64.instrs.memory.memop.MemAtomicOp"><a id="aarch64.instrs.memory.memop.MemAtomicOp" name="aarch64.instrs.memory.memop.MemAtomicOp"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>instrs</ins><del>functions</del>/<ins>memory</ins><del>system</del>/<ins>memop/MemAtomicOp</ins><del>InGuardedPage</del></h3><p class="pseudocode"><ins>enumeration</ins><del>boolean InGuardedPage;</del> <a id="MemAtomicOp" name="MemAtomicOp"></a><ins>MemAtomicOp {</ins><a id="MemAtomicOp_ADD" name="MemAtomicOp_ADD"></a><ins>MemAtomicOp_ADD,
                         </ins><a id="MemAtomicOp_BIC" name="MemAtomicOp_BIC"></a><ins>MemAtomicOp_BIC,
                         </ins><a id="MemAtomicOp_EOR" name="MemAtomicOp_EOR"></a><ins>MemAtomicOp_EOR,
                         </ins><a id="MemAtomicOp_ORR" name="MemAtomicOp_ORR"></a><ins>MemAtomicOp_ORR,
                         </ins><a id="MemAtomicOp_SMAX" name="MemAtomicOp_SMAX"></a><ins>MemAtomicOp_SMAX,
                         </ins><a id="MemAtomicOp_SMIN" name="MemAtomicOp_SMIN"></a><ins>MemAtomicOp_SMIN,
                         </ins><a id="MemAtomicOp_UMAX" name="MemAtomicOp_UMAX"></a><ins>MemAtomicOp_UMAX,
                         </ins><a id="MemAtomicOp_UMIN" name="MemAtomicOp_UMIN"></a><ins>MemAtomicOp_UMIN,
                         </ins><a id="MemAtomicOp_SWP" name="MemAtomicOp_SWP"></a><ins>MemAtomicOp_SWP};</ins></p></div><div class="ps" psname="aarch64.instrs.memory.memop.MemOp"><a id="aarch64.instrs.memory.memop.MemOp" name="aarch64.instrs.memory.memop.MemOp"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/<ins>memory</ins><del>branch</del>/<ins>memop</ins><del>eret</del>/<ins>MemOp</ins><del>AArch64.ExceptionReturn</del></h3><p class="pseudocode"><ins>enumeration</ins><del>// AArch64.ExceptionReturn()
// =========================</del> <a id="MemOp" name="MemOp"></a><ins>MemOp {</ins><del>AArch64.ExceptionReturn(bits(64) new_pc, bits(32) spsr)</del><a id="MemOp_LOAD" name="MemOp_LOAD"></a><ins>MemOp_LOAD,</ins><del>();

    sync_errors =</del> <a id="MemOp_STORE" name="MemOp_STORE"></a><ins>MemOp_STORE,</ins><del>() &amp;&amp;</del> <del>[].IESB == '1';
    if </del><a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()"><del>HaveDoubleFaultExt</del></a><del>() then
        sync_errors = sync_errors || (SCR_EL3.EA == '1' &amp;&amp; SCR_EL3.NMEA == '1' &amp;&amp; PSTATE.EL == </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>);
    if sync_errors then
        </del><a href="shared_pseudocode.html#impl-shared.SynchronizeErrors.0" title="function: SynchronizeErrors()"><del>SynchronizeErrors</del></a><del>();
        iesb_req = TRUE;
        </del><a href="shared_pseudocode.html#impl-shared.TakeUnmaskedPhysicalSErrorInterrupts.1" title="function: TakeUnmaskedPhysicalSErrorInterrupts(boolean iesb_req)"><del>TakeUnmaskedPhysicalSErrorInterrupts</del></a><del>(iesb_req);
    // Attempts to change to an illegal state will invoke the Illegal Execution state mechanism
    </del><a href="shared_pseudocode.html#impl-shared.SetPSTATEFromPSR.1" title="function: SetPSTATEFromPSR(bits(32) spsr)"><del>SetPSTATEFromPSR</del></a><del>(spsr);
    </del><a href="shared_pseudocode.html#impl-shared.ClearExclusiveLocal.1" title="function: ClearExclusiveLocal(integer processorid)"><del>ClearExclusiveLocal</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><del>ProcessorID</del></a><del>());
    </del><a href="shared_pseudocode.html#impl-shared.SendEventLocal.0" title="function: SendEventLocal()"><del>SendEventLocal</del></a><del>();

    if PSTATE.IL == '1' &amp;&amp; spsr&lt;4> == '1' &amp;&amp; spsr&lt;20> == '0' then
        // If the exception return is illegal, PC[63:32,1:0] are UNKNOWN
        new_pc&lt;63:32> = bits(32) UNKNOWN;
        new_pc&lt;1:0> = bits(2) UNKNOWN;
    elsif </del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>() then                // Return to AArch32
        // ELR_ELx[1:0] or ELR_ELx[0] are treated as being 0, depending on the target instruction set state
        if PSTATE.T == '1' then
            new_pc&lt;0> = '0';                 // T32
        else
            new_pc&lt;1:0> = '00';              // A32
    else                                     // Return to AArch64
        // ELR_ELx[63:56] might include a tag
        new_pc = </del><a href="shared_pseudocode.html#AArch64.BranchAddr.1" title="function: bits(64) AArch64.BranchAddr(bits(64) vaddress)"><del>AArch64.BranchAddr</del></a><del>(new_pc);

    if </del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>() then
        // 32 most significant bits are ignored.
        </del><a href="shared_pseudocode.html#impl-shared.BranchTo.2" title="function: BranchTo(bits(N) target, BranchType branch_type)"><del>BranchTo</del></a><del>(new_pc&lt;31:0>, </del><a href="shared_pseudocode.html#BranchType_ERET" title="enumeration BranchType { BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}"><del>BranchType_ERET</del></a><del>);
    else
        </del><a href="shared_pseudocode.html#impl-shared.BranchToAddr.2" title="function: BranchToAddr(bits(N) target, BranchType branch_type)"><del>BranchToAddr</del></a><del>(new_pc, </del><a href="shared_pseudocode.html#BranchType_ERET" title="enumeration BranchType { BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}"><del>BranchType_ERET</del></a><a id="MemOp_PREFETCH" name="MemOp_PREFETCH"></a><ins>MemOp_PREFETCH};</ins><del>);</del></p></div><div class="ps" psname="aarch64.instrs.memory.prefetch.Prefetch"><a id="aarch64.instrs.memory.prefetch.Prefetch" name="aarch64.instrs.memory.prefetch.Prefetch"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/<ins>memory</ins><del>countop</del>/<ins>prefetch/Prefetch</ins><del>CountOp</del></h3><p class="pseudocode"><ins>// Prefetch()
// ==========

// Decode and execute the prefetch hint on ADDRESS specified by PRFOP</ins><del>enumeration</del>

<a id="impl-aarch64.Prefetch.2" name="impl-aarch64.Prefetch.2"></a><ins>Prefetch(bits(64) address, bits(5) prfop)</ins><del>CountOp     {</del>
    <a href="shared_pseudocode.html#PrefetchHint" title="enumeration PrefetchHint {Prefetch_READ, Prefetch_WRITE, Prefetch_EXEC}"><ins>PrefetchHint</ins></a> <ins>hint;
    integer target;
    boolean stream;

    case prfop&lt;4:3> of
        when '00' hint =</ins><del>CountOp_CLZ,</del> <a href="shared_pseudocode.html#Prefetch_READ" title="enumeration PrefetchHint {Prefetch_READ, Prefetch_WRITE, Prefetch_EXEC}"><ins>Prefetch_READ</ins></a><ins>;         // PLD: prefetch for load
        when '01' hint =</ins><del>CountOp_CLS,</del> <a href="shared_pseudocode.html#Prefetch_EXEC" title="enumeration PrefetchHint {Prefetch_READ, Prefetch_WRITE, Prefetch_EXEC}"><ins>Prefetch_EXEC</ins></a><ins>;         // PLI: preload instructions
        when '10' hint = </ins><a href="shared_pseudocode.html#Prefetch_WRITE" title="enumeration PrefetchHint {Prefetch_READ, Prefetch_WRITE, Prefetch_EXEC}"><ins>Prefetch_WRITE</ins></a><ins>;        // PST: prepare for store
        when '11' return;                       // unallocated hint
    target = </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(prfop&lt;2:1>);                  // target cache level
    stream = (prfop&lt;0> != '0');                 // streaming (non-temporal)
    </ins><a href="shared_pseudocode.html#impl-shared.Hint_Prefetch.4" title="function: Hint_Prefetch(bits(64) address, PrefetchHint hint, integer target, boolean stream)"><ins>Hint_Prefetch</ins></a><ins>(address, hint, target, stream);
    return;</ins><del>CountOp_CNT};</del></p></div><div class="ps" psname="aarch64.instrs.system.barriers.barrierop.MemBarrierOp"><a id="aarch64.instrs.system.barriers.barrierop.MemBarrierOp" name="aarch64.instrs.system.barriers.barrierop.MemBarrierOp"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/<ins>system</ins><del>extendreg</del>/<ins>barriers/barrierop/MemBarrierOp</ins><del>DecodeRegExtend</del></h3><p class="pseudocode"><ins>enumeration</ins><del>// DecodeRegExtend()
// =================
// Decode a register extension option

ExtendType</del> <a id="MemBarrierOp" name="MemBarrierOp"></a><ins>MemBarrierOp   {</ins><del>DecodeRegExtend(bits(3) op)
    case op of
        when '000' return</del>  <a id="MemBarrierOp_DSB" name="MemBarrierOp_DSB"></a><ins>MemBarrierOp_DSB         // Data Synchronization Barrier
                            ,</ins><del>;
        when '001' return</del> <a id="MemBarrierOp_DMB" name="MemBarrierOp_DMB"></a><ins>MemBarrierOp_DMB         // Data Memory Barrier
                            ,</ins><del>;
        when '010' return</del> <a id="MemBarrierOp_ISB" name="MemBarrierOp_ISB"></a><ins>MemBarrierOp_ISB         // Instruction Synchronization Barrier
                            ,</ins><del>;
        when '011' return</del> <a id="MemBarrierOp_SSBB" name="MemBarrierOp_SSBB"></a><ins>MemBarrierOp_SSBB        // Speculative Synchronization Barrier to VA
                            ,</ins><del>;
        when '100' return</del> <a id="MemBarrierOp_PSSBB" name="MemBarrierOp_PSSBB"></a><ins>MemBarrierOp_PSSBB       // Speculative Synchronization Barrier to PA
                            ,</ins><del>;
        when '101' return</del> <del>;
        when '110' return </del><a href="shared_pseudocode.html#ExtendType_SXTW" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX, ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}"><del>ExtendType_SXTW</del></a><del>;
        when '111' return </del><a href="shared_pseudocode.html#ExtendType_SXTX" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX, ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}"><del>ExtendType_SXTX</del></a><a id="MemBarrierOp_SB" name="MemBarrierOp_SB"></a><ins>MemBarrierOp_SB          // Speculation Barrier
                           };</ins><del>;</del></p></div><div class="ps" psname="aarch64.instrs.system.hints.syshintop.SystemHintOp"><a id="aarch64.instrs.system.hints.syshintop.SystemHintOp" name="aarch64.instrs.system.hints.syshintop.SystemHintOp"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/<ins>system</ins><del>extendreg</del>/<ins>hints/syshintop/SystemHintOp</ins><del>ExtendReg</del></h3><p class="pseudocode"><ins>enumeration</ins><del>// ExtendReg()
// ===========
// Perform a register extension and shift

bits(N)</del> <a id="SystemHintOp" name="SystemHintOp"></a><ins>SystemHintOp {</ins><del>ExtendReg(integer reg,</del>
    <a id="SystemHintOp_NOP" name="SystemHintOp_NOP"></a><ins>SystemHintOp_NOP,</ins><del>type, integer shift)
    assert shift >= 0 &amp;&amp; shift &lt;= 4;
    bits(N) val =</del>
    <a id="SystemHintOp_YIELD" name="SystemHintOp_YIELD"></a><ins>SystemHintOp_YIELD,</ins><del>[reg];
    boolean unsigned;
    integer len;

    case type of
        when</del>
    <a id="SystemHintOp_WFE" name="SystemHintOp_WFE"></a><ins>SystemHintOp_WFE,</ins><del>unsigned = FALSE; len = 8;
        when</del>
    <a id="SystemHintOp_WFI" name="SystemHintOp_WFI"></a><ins>SystemHintOp_WFI,</ins><del>unsigned = FALSE; len = 16;
        when</del>
    <a id="SystemHintOp_SEV" name="SystemHintOp_SEV"></a><ins>SystemHintOp_SEV,</ins><del>unsigned = FALSE; len = 32;
        when</del>
    <a id="SystemHintOp_SEVL" name="SystemHintOp_SEVL"></a><ins>SystemHintOp_SEVL,</ins><del>unsigned = FALSE; len = 64;
        when</del>
    <a id="SystemHintOp_ESB" name="SystemHintOp_ESB"></a><ins>SystemHintOp_ESB,</ins><del>unsigned = TRUE;  len = 8;
        when</del>
    <a id="SystemHintOp_PSB" name="SystemHintOp_PSB"></a><ins>SystemHintOp_PSB,</ins><del>unsigned = TRUE;  len = 16;
        when</del>
    <a id="SystemHintOp_TSB" name="SystemHintOp_TSB"></a><ins>SystemHintOp_TSB,</ins><del>unsigned = TRUE;  len = 32;
        when</del>
    <a id="SystemHintOp_BTI" name="SystemHintOp_BTI"></a><ins>SystemHintOp_BTI,</ins><del>unsigned = TRUE;  len = 64;

    // Note the extended width of the intermediate value and
    // that sign extension occurs from bit &lt;len+shift-1>, not
    // from bit &lt;len-1>. This is equivalent to the instruction
    //   [SU]BFIZ Rtmp, Rreg, #shift, #len
    // It may also be seen as a sign/zero extend followed by a shift:
    //   LSL(Extend(val&lt;len-1:0>, N, unsigned), shift);

    len =</del>
    <del>(len, N - shift);
    return </del><a href="shared_pseudocode.html#impl-shared.Extend.3" title="function: bits(N) Extend(bits(M) x, integer N, boolean unsigned)"><del>Extend</del></a><del>(val&lt;len-1:0> : </del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><a id="SystemHintOp_CSDB" name="SystemHintOp_CSDB"></a><ins>SystemHintOp_CSDB
};</ins><del>(shift), N, unsigned);</del></p></div><div class="ps" psname="aarch64.instrs.system.register.cpsr.pstatefield.PSTATEField"><a id="aarch64.instrs.system.register.cpsr.pstatefield.PSTATEField" name="aarch64.instrs.system.register.cpsr.pstatefield.PSTATEField"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/<ins>system</ins><del>extendreg</del>/<ins>register/cpsr/pstatefield/PSTATEField</ins><del>ExtendType</del></h3><p class="pseudocode">enumeration <a id="PSTATEField" name="PSTATEField"></a><ins>PSTATEField {</ins><del>ExtendType  {</del><a id="PSTATEField_DAIFSet" name="PSTATEField_DAIFSet"></a><ins>PSTATEField_DAIFSet,</ins><del>ExtendType_SXTB,</del> <a id="PSTATEField_DAIFClr" name="PSTATEField_DAIFClr"></a><ins>PSTATEField_DAIFClr,</ins><del>ExtendType_SXTH,</del>
                         <a id="PSTATEField_PAN" name="PSTATEField_PAN"></a><ins>PSTATEField_PAN, // Armv8.1</ins><del>ExtendType_SXTW,</del>
                         <a id="PSTATEField_UAO" name="PSTATEField_UAO"></a><ins>PSTATEField_UAO, // Armv8.2</ins><del>ExtendType_SXTX,</del>
                         <a id="PSTATEField_DIT" name="PSTATEField_DIT"></a><ins>PSTATEField_DIT, // Armv8.4</ins><del>ExtendType_UXTB,</del>
                         <a id="PSTATEField_SSBS" name="PSTATEField_SSBS"></a><ins>PSTATEField_SSBS,</ins><del>ExtendType_UXTH,</del>
                         <a id="PSTATEField_SP" name="PSTATEField_SP"></a><ins>PSTATEField_SP
                         };</ins><del>ExtendType_UXTW,</del><a id="ExtendType_UXTX" name="ExtendType_UXTX"></a><del>ExtendType_UXTX};</del></p></div><div class="ps" psname="aarch64.instrs.system.sysops.sysop.SysOp"><a id="aarch64.instrs.system.sysops.sysop.SysOp" name="aarch64.instrs.system.sysops.sysop.SysOp"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/<ins>system</ins><del>float</del>/<ins>sysops</ins><del>arithmetic</del>/<ins>sysop</ins><del>max-min</del>/<ins>SysOp</ins><del>fpmaxminop/FPMaxMinOp</del></h3><p class="pseudocode"><ins>// SysOp()
// =======

SystemOp</ins><del>enumeration</del> <a id="impl-aarch64.SysOp.4" name="impl-aarch64.SysOp.4"></a><ins>SysOp(bits(3) op1, bits(4) CRn, bits(4) CRm, bits(3) op2)
    case op1:CRn:CRm:op2 of
        when '000 0111 1000 000' return</ins><del>FPMaxMinOp  {</del> <a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_AT</ins></a><ins>;   // S1E1R
        when '100 0111 1000 000' return</ins><del>FPMaxMinOp_MAX,</del> <a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_AT</ins></a><ins>;   // S1E2R
        when '110 0111 1000 000' return</ins><del>FPMaxMinOp_MIN,</del> <a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_AT</ins></a><ins>;   // S1E3R
        when '000 0111 1000 001' return</ins><del>FPMaxMinOp_MAXNUM,</del> <a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_AT</ins></a><ins>;   // S1E1W
        when '100 0111 1000 001' return </ins><a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_AT</ins></a><ins>;   // S1E2W
        when '110 0111 1000 001' return </ins><a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_AT</ins></a><ins>;   // S1E3W
        when '000 0111 1000 010' return </ins><a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_AT</ins></a><ins>;   // S1E0R
        when '000 0111 1000 011' return </ins><a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_AT</ins></a><ins>;   // S1E0W
        when '100 0111 1000 100' return </ins><a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_AT</ins></a><ins>;   // S12E1R
        when '100 0111 1000 101' return </ins><a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_AT</ins></a><ins>;   // S12E1W
        when '100 0111 1000 110' return </ins><a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_AT</ins></a><ins>;   // S12E0R
        when '100 0111 1000 111' return </ins><a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_AT</ins></a><ins>;   // S12E0W
        when '011 0111 0100 001' return </ins><a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_DC</ins></a><ins>;   // ZVA
        when '000 0111 0110 001' return </ins><a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_DC</ins></a><ins>;   // IVAC
        when '000 0111 0110 010' return </ins><a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_DC</ins></a><ins>;   // ISW
        when '011 0111 1010 001' return </ins><a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_DC</ins></a><ins>;   // CVAC
        when '000 0111 1010 010' return </ins><a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_DC</ins></a><ins>;   // CSW
        when '011 0111 1011 001' return </ins><a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_DC</ins></a><ins>;   // CVAU
        when '011 0111 1110 001' return </ins><a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_DC</ins></a><ins>;   // CIVAC
        when '000 0111 1110 010' return </ins><a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_DC</ins></a><ins>;   // CISW
        when '011 0111 1101 001' return </ins><a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_DC</ins></a><ins>;   // CVADP
        when '000 0111 0001 000' return </ins><a href="shared_pseudocode.html#Sys_IC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_IC</ins></a><ins>;   // IALLUIS
        when '000 0111 0101 000' return </ins><a href="shared_pseudocode.html#Sys_IC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_IC</ins></a><ins>;   // IALLU
        when '011 0111 0101 001' return </ins><a href="shared_pseudocode.html#Sys_IC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_IC</ins></a><ins>;   // IVAU
        when '100 1000 0000 001' return </ins><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_TLBI</ins></a><ins>; // IPAS2E1IS
        when '100 1000 0000 101' return </ins><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_TLBI</ins></a><ins>; // IPAS2LE1IS
        when '000 1000 0011 000' return </ins><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_TLBI</ins></a><ins>; // VMALLE1IS
        when '100 1000 0011 000' return </ins><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_TLBI</ins></a><ins>; // ALLE2IS
        when '110 1000 0011 000' return </ins><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_TLBI</ins></a><ins>; // ALLE3IS
        when '000 1000 0011 001' return </ins><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_TLBI</ins></a><ins>; // VAE1IS
        when '100 1000 0011 001' return </ins><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_TLBI</ins></a><ins>; // VAE2IS
        when '110 1000 0011 001' return </ins><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_TLBI</ins></a><ins>; // VAE3IS
        when '000 1000 0011 010' return </ins><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_TLBI</ins></a><ins>; // ASIDE1IS
        when '000 1000 0011 011' return </ins><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_TLBI</ins></a><ins>; // VAAE1IS
        when '100 1000 0011 100' return </ins><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_TLBI</ins></a><ins>; // ALLE1IS
        when '000 1000 0011 101' return </ins><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_TLBI</ins></a><ins>; // VALE1IS
        when '100 1000 0011 101' return </ins><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_TLBI</ins></a><ins>; // VALE2IS
        when '110 1000 0011 101' return </ins><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_TLBI</ins></a><ins>; // VALE3IS
        when '100 1000 0011 110' return </ins><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_TLBI</ins></a><ins>; // VMALLS12E1IS
        when '000 1000 0011 111' return </ins><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_TLBI</ins></a><ins>; // VAALE1IS
        when '100 1000 0100 001' return </ins><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_TLBI</ins></a><ins>; // IPAS2E1
        when '100 1000 0100 101' return </ins><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_TLBI</ins></a><ins>; // IPAS2LE1
        when '000 1000 0111 000' return </ins><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_TLBI</ins></a><ins>; // VMALLE1
        when '100 1000 0111 000' return </ins><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_TLBI</ins></a><ins>; // ALLE2
        when '110 1000 0111 000' return </ins><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_TLBI</ins></a><ins>; // ALLE3
        when '000 1000 0111 001' return </ins><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_TLBI</ins></a><ins>; // VAE1
        when '100 1000 0111 001' return </ins><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_TLBI</ins></a><ins>; // VAE2
        when '110 1000 0111 001' return </ins><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_TLBI</ins></a><ins>; // VAE3
        when '000 1000 0111 010' return </ins><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_TLBI</ins></a><ins>; // ASIDE1
        when '000 1000 0111 011' return </ins><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_TLBI</ins></a><ins>; // VAAE1
        when '100 1000 0111 100' return </ins><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_TLBI</ins></a><ins>; // ALLE1
        when '000 1000 0111 101' return </ins><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_TLBI</ins></a><ins>; // VALE1
        when '100 1000 0111 101' return </ins><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_TLBI</ins></a><ins>; // VALE2
        when '110 1000 0111 101' return </ins><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_TLBI</ins></a><ins>; // VALE3
        when '100 1000 0111 110' return </ins><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_TLBI</ins></a><ins>; // VMALLS12E1
        when '000 1000 0111 111' return </ins><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_TLBI</ins></a><ins>; // VAALE1
    return </ins><a href="shared_pseudocode.html#Sys_SYS" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><ins>Sys_SYS</ins></a><ins>;</ins><del>FPMaxMinOp_MINNUM};</del></p></div><div class="ps" psname="aarch64.instrs.system.sysops.sysop.SystemOp"><a id="aarch64.instrs.system.sysops.sysop.SystemOp" name="aarch64.instrs.system.sysops.sysop.SystemOp"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/<ins>system</ins><del>float</del>/<ins>sysops</ins><del>arithmetic</del>/<ins>sysop</ins><del>unary</del>/<ins>SystemOp</ins><del>fpunaryop/FPUnaryOp</del></h3><p class="pseudocode">enumeration <a id="SystemOp" name="SystemOp"></a><ins>SystemOp {</ins><del>FPUnaryOp   {</del><a id="Sys_AT" name="Sys_AT"></a><ins>Sys_AT,</ins><del>FPUnaryOp_ABS,</del> <a id="Sys_DC" name="Sys_DC"></a><ins>Sys_DC,</ins><del>FPUnaryOp_MOV,</del> <a id="Sys_IC" name="Sys_IC"></a><ins>Sys_IC,</ins><del>FPUnaryOp_NEG,</del> <a id="Sys_TLBI" name="Sys_TLBI"></a><ins>Sys_TLBI,</ins><del>FPUnaryOp_SQRT};</del> <a id="Sys_SYS" name="Sys_SYS"></a><ins>Sys_SYS};</ins></p></div><div class="ps" psname="aarch64.instrs.vector.arithmetic.binary.uniform.logical.bsl-eor.vbitop.VBitOp"><a id="aarch64.instrs.vector.arithmetic.binary.uniform.logical.bsl-eor.vbitop.VBitOp" name="aarch64.instrs.vector.arithmetic.binary.uniform.logical.bsl-eor.vbitop.VBitOp"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/<ins>vector</ins><del>float</del>/<ins>arithmetic</ins><del>convert</del>/<ins>binary</ins><del>fpconvop</del>/<ins>uniform/logical/bsl-eor/vbitop/VBitOp</ins><del>FPConvOp</del></h3><p class="pseudocode">enumeration <a id="VBitOp" name="VBitOp"></a><ins>VBitOp      {</ins><del>FPConvOp    {</del><a id="VBitOp_VBIF" name="VBitOp_VBIF"></a><ins>VBitOp_VBIF,</ins><del>FPConvOp_CVT_FtoI,</del> <a id="VBitOp_VBIT" name="VBitOp_VBIT"></a><ins>VBitOp_VBIT,</ins><del>FPConvOp_CVT_ItoF,</del> <a id="VBitOp_VBSL" name="VBitOp_VBSL"></a><ins>VBitOp_VBSL,</ins><del>FPConvOp_MOV_FtoI,</del> <a id="VBitOp_VEOR" name="VBitOp_VEOR"></a><ins>VBitOp_VEOR};</ins><del>FPConvOp_MOV_ItoF
                         ,</del><a id="FPConvOp_CVT_FtoI_JS" name="FPConvOp_CVT_FtoI_JS"></a><del>FPConvOp_CVT_FtoI_JS
};</del></p></div><div class="ps" psname="aarch64.instrs.vector.arithmetic.unary.cmp.compareop.CompareOp"><a id="aarch64.instrs.vector.arithmetic.unary.cmp.compareop.CompareOp" name="aarch64.instrs.vector.arithmetic.unary.cmp.compareop.CompareOp"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/<ins>vector</ins><del>integer</del>/<ins>arithmetic</ins><del>bitfield</del>/<ins>unary</ins><del>bfxpreferred</del>/<ins>cmp/compareop/CompareOp</ins><del>BFXPreferred</del></h3><p class="pseudocode"><ins>enumeration</ins><del>// BFXPreferred()
// ==============
//
// Return TRUE if UBFX or SBFX is the preferred disassembly of a
// UBFM or SBFM bitfield instruction. Must exclude more specific
// aliases UBFIZ, SBFIZ, UXT[BH], SXT[BHW], LSL, LSR and ASR.

boolean</del> <a id="CompareOp" name="CompareOp"></a><ins>CompareOp   {</ins><del>BFXPreferred(bit sf, bit uns, bits(6) imms, bits(6) immr)
    integer S =</del><a id="CompareOp_GT" name="CompareOp_GT"></a><ins>CompareOp_GT,</ins><del>(imms);
    integer R =</del> <a id="CompareOp_GE" name="CompareOp_GE"></a><ins>CompareOp_GE,</ins><del>(immr);

    // must not match UBFIZ/SBFIX alias
    if</del> <a id="CompareOp_EQ" name="CompareOp_EQ"></a><ins>CompareOp_EQ,</ins><del>(imms) &lt;</del>
                         <a id="CompareOp_LE" name="CompareOp_LE"></a><ins>CompareOp_LE, </ins><a id="CompareOp_LT" name="CompareOp_LT"></a><ins>CompareOp_LT};</ins><del>(immr) then
        return FALSE;

    // must not match LSR/ASR/LSL alias (imms == 31 or 63)
    if imms == sf:'11111' then
        return FALSE;

    // must not match UXTx/SXTx alias
    if immr == '000000' then
        // must not match 32-bit UXT[BH] or SXT[BH]
        if sf == '0' &amp;&amp; imms IN {'000111', '001111'} then
            return FALSE;
        // must not match 64-bit SXT[BHW]
        if sf:uns == '10' &amp;&amp; imms IN {'000111', '001111', '011111'} then
            return FALSE;

    // must be UBFX/SBFX alias
    return TRUE;</del></p></div><div class="ps" psname="aarch64.instrs.vector.logical.immediateop.ImmediateOp"><a id="aarch64.instrs.vector.logical.immediateop.ImmediateOp" name="aarch64.instrs.vector.logical.immediateop.ImmediateOp"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/<ins>vector</ins><del>integer</del>/<ins>logical</ins><del>bitmasks</del>/<ins>immediateop/ImmediateOp</ins><del>DecodeBitMasks</del></h3><p class="pseudocode"><ins>enumeration</ins><del>// DecodeBitMasks()
// ================

// Decode AArch64 bitfield and logical immediate masks which use a similar encoding structure

(bits(M), bits(M))</del> <a id="ImmediateOp" name="ImmediateOp"></a><ins>ImmediateOp {</ins><del>DecodeBitMasks(bit immN, bits(6) imms, bits(6) immr, boolean immediate)
    bits(64) tmask, wmask;
    bits(6) tmask_and, wmask_and;
    bits(6) tmask_or, wmask_or;
    bits(6) levels;

    // Compute log2 of element size
    // 2^len must be in range [2, M]
    len =</del><a id="ImmediateOp_MOVI" name="ImmediateOp_MOVI"></a><ins>ImmediateOp_MOVI,</ins><del>(immN:NOT(imms));
    if len &lt; 1 then UNDEFINED;
    assert M >= (1 &lt;&lt; len);

    // Determine S, R and S - R parameters
    levels =</del> <a id="ImmediateOp_MVNI" name="ImmediateOp_MVNI"></a><ins>ImmediateOp_MVNI,</ins><del>(</del>
                         <a id="ImmediateOp_ORR" name="ImmediateOp_ORR"></a><ins>ImmediateOp_ORR,</ins><del>(len), 6);

    // For logical immediates an all-ones value of S is reserved
    // since it would generate a useless all-ones result (many times)
    if immediate &amp;&amp; (imms AND levels) == levels then
        UNDEFINED;

    S =</del> <del>(imms AND levels);
    R = </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(immr AND levels);
    diff = S - R;    // 6-bit subtract with borrow

    // From a software perspective, the remaining code is equivalant to:
    //   esize = 1 &lt;&lt; len;
    //   d = UInt(diff&lt;len-1:0>);
    //   welem = ZeroExtend(Ones(S + 1), esize);
    //   telem = ZeroExtend(Ones(d + 1), esize);
    //   wmask = Replicate(ROR(welem, R));
    //   tmask = Replicate(telem);
    //   return (wmask, tmask);

    // Compute "top mask"
    tmask_and = diff&lt;5:0> OR NOT(levels);
    tmask_or  = diff&lt;5:0> AND levels;

    tmask = </del><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a><del>(64);
    tmask = ((tmask
              AND </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(tmask_and&lt;0>, 1) : </del><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a><del>(1), 32))
               OR  </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(1) : </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(tmask_or&lt;0>, 1), 32));
    // optimization of first step:
    // tmask = Replicate(tmask_and&lt;0> : '1', 32);
    tmask = ((tmask
              AND </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(tmask_and&lt;1>, 2) : </del><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a><del>(2), 16))
               OR  </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(2) : </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(tmask_or&lt;1>, 2), 16));
    tmask = ((tmask
              AND </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(tmask_and&lt;2>, 4) : </del><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a><del>(4), 8))
               OR  </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(4) : </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(tmask_or&lt;2>, 4), 8));
    tmask = ((tmask
              AND </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(tmask_and&lt;3>, 8) : </del><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a><del>(8), 4))
               OR  </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(8) : </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(tmask_or&lt;3>, 8), 4));
    tmask = ((tmask
              AND </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(tmask_and&lt;4>, 16) : </del><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a><del>(16), 2))
               OR  </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(16) : </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(tmask_or&lt;4>, 16), 2));
    tmask = ((tmask
              AND </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(tmask_and&lt;5>, 32) : </del><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a><del>(32), 1))
               OR  </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(32) : </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(tmask_or&lt;5>, 32), 1));

    // Compute "wraparound mask"
    wmask_and = immr OR NOT(levels);
    wmask_or  = immr AND levels;

    wmask = </del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(64);
    wmask = ((wmask
              AND </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a><del>(1) : </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(wmask_and&lt;0>, 1), 32))
               OR  </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(wmask_or&lt;0>, 1) : </del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(1), 32));
    // optimization of first step:
    // wmask = Replicate(wmask_or&lt;0> : '0', 32);
    wmask = ((wmask
              AND </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a><del>(2) : </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(wmask_and&lt;1>, 2), 16))
               OR  </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(wmask_or&lt;1>, 2) : </del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(2), 16));
    wmask = ((wmask
              AND </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a><del>(4) : </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(wmask_and&lt;2>, 4), 8))
               OR  </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(wmask_or&lt;2>, 4) : </del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(4), 8));
    wmask = ((wmask
              AND </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a><del>(8) : </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(wmask_and&lt;3>, 8), 4))
               OR  </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(wmask_or&lt;3>, 8) : </del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(8), 4));
    wmask = ((wmask
              AND </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a><del>(16) : </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(wmask_and&lt;4>, 16), 2))
               OR  </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(wmask_or&lt;4>, 16) : </del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(16), 2));
    wmask = ((wmask
              AND </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a><del>(32) : </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(wmask_and&lt;5>, 32), 1))
               OR  </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(wmask_or&lt;5>, 32) : </del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><a id="ImmediateOp_BIC" name="ImmediateOp_BIC"></a><ins>ImmediateOp_BIC};</ins><del>(32), 1));

    if diff&lt;6> != '0' then // borrow from S - R
        wmask = wmask AND tmask;
    else
        wmask = wmask OR tmask;

    return (wmask&lt;M-1:0>, tmask&lt;M-1:0>);</del></p></div><div class="ps" psname="aarch64.instrs.vector.reduce.reduceop.Reduce"><a id="aarch64.instrs.vector.reduce.reduceop.Reduce" name="aarch64.instrs.vector.reduce.reduceop.Reduce"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/<ins>vector</ins><del>integer</del>/<ins>reduce</ins><del>ins-ext</del>/<ins>reduceop</ins><del>insert</del>/<ins>Reduce</ins><del>movewide/movewideop/MoveWideOp</del></h3><p class="pseudocode"><ins>// Reduce()
// ========

bits(esize)</ins><del>enumeration</del> <a id="impl-aarch64.Reduce.3" name="impl-aarch64.Reduce.3"></a><ins>Reduce(</ins><del>MoveWideOp  {</del><a href="shared_pseudocode.html#ReduceOp" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM, ReduceOp_FMIN, ReduceOp_FMAX, ReduceOp_FADD, ReduceOp_ADD}"><ins>ReduceOp</ins></a> <ins>op, bits(N) input, integer esize)
    integer half;
    bits(esize) hi;
    bits(esize) lo;
    bits(esize) result;

    if N == esize then
        return input&lt;esize-1:0>;

    half = N DIV 2;
    hi =</ins><del>MoveWideOp_N,</del> <a href="shared_pseudocode.html#impl-aarch64.Reduce.3" title="function: bits(esize) Reduce(ReduceOp op, bits(N) input, integer esize)"><ins>Reduce</ins></a><ins>(op, input&lt;N-1:half>, esize);
    lo =</ins><del>MoveWideOp_Z,</del> <a href="shared_pseudocode.html#impl-aarch64.Reduce.3" title="function: bits(esize) Reduce(ReduceOp op, bits(N) input, integer esize)"><ins>Reduce</ins></a><ins>(op, input&lt;half-1:0>, esize);

    case op of
        when </ins><a href="shared_pseudocode.html#ReduceOp_FMINNUM" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM, ReduceOp_FMIN, ReduceOp_FMAX, ReduceOp_FADD, ReduceOp_ADD}"><ins>ReduceOp_FMINNUM</ins></a><ins>
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPMinNum.3" title="function: bits(N) FPMinNum(bits(N) op1, bits(N) op2, FPCRType fpcr)"><ins>FPMinNum</ins></a><ins>(lo, hi, FPCR);
        when </ins><a href="shared_pseudocode.html#ReduceOp_FMAXNUM" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM, ReduceOp_FMIN, ReduceOp_FMAX, ReduceOp_FADD, ReduceOp_ADD}"><ins>ReduceOp_FMAXNUM</ins></a><ins>
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPMaxNum.3" title="function: bits(N) FPMaxNum(bits(N) op1, bits(N) op2, FPCRType fpcr)"><ins>FPMaxNum</ins></a><ins>(lo, hi, FPCR);
        when </ins><a href="shared_pseudocode.html#ReduceOp_FMIN" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM, ReduceOp_FMIN, ReduceOp_FMAX, ReduceOp_FADD, ReduceOp_ADD}"><ins>ReduceOp_FMIN</ins></a><ins>
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPMin.3" title="function: bits(N) FPMin(bits(N) op1, bits(N) op2, FPCRType fpcr)"><ins>FPMin</ins></a><ins>(lo, hi, FPCR);
        when </ins><a href="shared_pseudocode.html#ReduceOp_FMAX" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM, ReduceOp_FMIN, ReduceOp_FMAX, ReduceOp_FADD, ReduceOp_ADD}"><ins>ReduceOp_FMAX</ins></a><ins>
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPMax.3" title="function: bits(N) FPMax(bits(N) op1, bits(N) op2, FPCRType fpcr)"><ins>FPMax</ins></a><ins>(lo, hi, FPCR);
        when </ins><a href="shared_pseudocode.html#ReduceOp_FADD" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM, ReduceOp_FMIN, ReduceOp_FMAX, ReduceOp_FADD, ReduceOp_ADD}"><ins>ReduceOp_FADD</ins></a><ins>
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPAdd.3" title="function: bits(N) FPAdd(bits(N) op1, bits(N) op2, FPCRType fpcr)"><ins>FPAdd</ins></a><ins>(lo, hi, FPCR);
        when </ins><a href="shared_pseudocode.html#ReduceOp_ADD" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM, ReduceOp_FMIN, ReduceOp_FMAX, ReduceOp_FADD, ReduceOp_ADD}"><ins>ReduceOp_ADD</ins></a>
            <ins>result = lo + hi;

    return result;</ins><del>MoveWideOp_K};</del></p></div><div class="ps" psname="aarch64.instrs.vector.reduce.reduceop.ReduceOp"><a id="aarch64.instrs.vector.reduce.reduceop.ReduceOp" name="aarch64.instrs.vector.reduce.reduceop.ReduceOp"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/<ins>vector</ins><del>integer</del>/<ins>reduce</ins><del>logical</del>/<ins>reduceop</ins><del>movwpreferred</del>/<ins>ReduceOp</ins><del>MoveWidePreferred</del></h3><p class="pseudocode"><ins>enumeration</ins><del>// MoveWidePreferred()
// ===================
//
// Return TRUE if a bitmask immediate encoding would generate an immediate
// value that could also be represented by a single MOVZ or MOVN instruction.
// Used as a condition for the preferred MOV&lt;-ORR alias.

boolean</del> <a id="ReduceOp" name="ReduceOp"></a><ins>ReduceOp {</ins><del>MoveWidePreferred(bit sf, bit immN, bits(6) imms, bits(6) immr)
    integer S =</del><a id="ReduceOp_FMINNUM" name="ReduceOp_FMINNUM"></a><ins>ReduceOp_FMINNUM,</ins><del>(imms);
    integer R =</del> <a id="ReduceOp_FMAXNUM" name="ReduceOp_FMAXNUM"></a><ins>ReduceOp_FMAXNUM,
                      </ins><a id="ReduceOp_FMIN" name="ReduceOp_FMIN"></a><ins>ReduceOp_FMIN, </ins><a id="ReduceOp_FMAX" name="ReduceOp_FMAX"></a><ins>ReduceOp_FMAX,
                      </ins><a id="ReduceOp_FADD" name="ReduceOp_FADD"></a><ins>ReduceOp_FADD, </ins><a id="ReduceOp_ADD" name="ReduceOp_ADD"></a><ins>ReduceOp_ADD};</ins><del>(immr);
    integer width = if sf == '1' then 64 else 32;

    // element size must equal total immediate size
    if sf == '1' &amp;&amp; immN:imms != '1xxxxxx' then
        return FALSE;
    if sf == '0' &amp;&amp; immN:imms != '00xxxxx' then
        return FALSE;

    // for MOVZ must contain no more than 16 ones
    if S &lt; 16 then
        // ones must not span halfword boundary when rotated
        return (-R MOD 16) &lt;= (15 - S);

    // for MOVN must contain no more than 16 zeros
    if S >= width - 15 then
        // zeros must not span halfword boundary when rotated
        return (R MOD 16) &lt;= (S - (width - 15));

    return FALSE;</del></p></div><div class="ps" psname="aarch64.translation.attrs.AArch64.InstructionDevice"><a id="aarch64.translation.attrs.AArch64.InstructionDevice" name="aarch64.translation.attrs.AArch64.InstructionDevice"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>translation</ins><del>instrs</del>/<ins>attrs</ins><del>integer</del>/<ins>AArch64.InstructionDevice</ins><del>shiftreg/DecodeShift</del></h3><p class="pseudocode"><ins>// AArch64.InstructionDevice()
// ===========================
// Instruction fetches from memory marked as Device but not execute-never might generate a
// Permission Fault but are otherwise treated as if from Normal Non-cacheable memory.
</ins><del>// DecodeShift()
// =============
// Decode shift encodings
</del>
<ins>AddressDescriptor</ins><del>ShiftType</del> <a id="AArch64.InstructionDevice.8" name="AArch64.InstructionDevice.8"></a><ins>AArch64.InstructionDevice(</ins><del>DecodeShift(bits(2) op)
    case op of
        when '00'  return</del><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><ins>AddressDescriptor</ins></a><a href="shared_pseudocode.html#ShiftType_LSL" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}"><del>ShiftType_LSL</del></a> <ins>addrdesc, bits(64) vaddress,
                                            bits(52) ipaddress, integer level,</ins><del>;
        when '01'  return</del>
                                            <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><a href="shared_pseudocode.html#ShiftType_LSR" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}"><del>ShiftType_LSR</del></a> <ins>acctype, boolean iswrite, boolean secondstage,
                                            boolean s2fs1walk)

    c =</ins><del>;
        when '10'  return</del> <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><ins>ConstrainUnpredictable</ins></a><a href="shared_pseudocode.html#ShiftType_ASR" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}"><del>ShiftType_ASR</del></a><ins>(</ins><del>;
        when '11'  return</del><a href="shared_pseudocode.html#Unpredictable_INSTRDEVICE" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_INSTRDEVICE</ins></a><a href="shared_pseudocode.html#ShiftType_ROR" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}"><del>ShiftType_ROR</del></a><ins>);
    assert c IN {</ins><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_NONE</ins></a><ins>, </ins><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FAULT</ins></a><ins>};

    if c == </ins><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FAULT</ins></a><ins> then
        addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch64.PermissionFault.7" title="function: FaultRecord AArch64.PermissionFault(bits(52) ipaddress,bit NS, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><ins>AArch64.PermissionFault</ins></a><ins>(ipaddress,bit UNKNOWN,  level, acctype, iswrite,
                                                 secondstage, s2fs1walk);
    else
        addrdesc.memattrs.type = </ins><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Normal</ins></a><ins>;
        addrdesc.memattrs.inner.attrs = </ins><a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'"><ins>MemAttr_NC</ins></a><ins>;
        addrdesc.memattrs.inner.hints = </ins><a href="shared_pseudocode.html#MemHint_No" title="constant bits(2) MemHint_No = '00'"><ins>MemHint_No</ins></a><ins>;
        addrdesc.memattrs.outer = addrdesc.memattrs.inner;
        addrdesc.memattrs.tagged = FALSE;
        addrdesc.memattrs = </ins><a href="shared_pseudocode.html#impl-shared.MemAttrDefaults.1" title="function: MemoryAttributes MemAttrDefaults(MemoryAttributes memattrs)"><ins>MemAttrDefaults</ins></a><ins>(addrdesc.memattrs);

    return addrdesc;</ins><del>;</del></p></div><div class="ps" psname="aarch64.translation.attrs.AArch64.S1AttrDecode"><a id="aarch64.translation.attrs.AArch64.S1AttrDecode" name="aarch64.translation.attrs.AArch64.S1AttrDecode"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>translation</ins><del>instrs</del>/<ins>attrs</ins><del>integer</del>/<ins>AArch64.S1AttrDecode</ins><del>shiftreg/ShiftReg</del></h3><p class="pseudocode"><ins>// AArch64.S1AttrDecode()
// ======================
// Converts the Stage 1 attribute fields, using the MAIR, to orthogonal
// attributes and hints.
</ins><del>// ShiftReg()
// ==========
// Perform shift of a register operand
</del>
<ins>MemoryAttributes</ins><del>bits(N)</del> <a id="AArch64.S1AttrDecode.3" name="AArch64.S1AttrDecode.3"></a><ins>AArch64.S1AttrDecode(bits(2) SH, bits(3) attr,</ins><del>ShiftReg(integer reg,</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><a href="shared_pseudocode.html#ShiftType" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}"><del>ShiftType</del></a> <ins>acctype)</ins><del>type, integer amount)
    bits(N) result =</del>

    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType type, DeviceType device, MemAttrHints inner, MemAttrHints outer, boolean tagged, boolean shareable, boolean outershareable )"><ins>MemoryAttributes</ins></a><a href="shared_pseudocode.html#impl-aarch64.X.read.1" title="accessor: bits(width) X[integer n]"><del>X</del></a> <ins>memattrs;

    mair =</ins><del>[reg];
    case type of
        when</del> <a href="shared_pseudocode.html#impl-aarch64.MAIR.read.0" title="accessor: MAIRType MAIR[]"><ins>MAIR</ins></a><a href="shared_pseudocode.html#ShiftType_LSL" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}"><del>ShiftType_LSL</del></a><ins>[];
    index = 8 *</ins><del>result =</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#impl-shared.LSL.2" title="function: bits(N) LSL(bits(N) x, integer shift)"><del>LSL</del></a><ins>(attr);
    attrfield = mair&lt;index+7:index>;

    memattrs.tagged = FALSE;
    if ((attrfield&lt;7:4> != '0000' &amp;&amp; attrfield&lt;7:4> != '1111' &amp;&amp; attrfield&lt;3:0> == '0000') ||
        (attrfield&lt;7:4> == '0000' &amp;&amp; attrfield&lt;3:0> != 'xx00')) then
        // Reserved, maps to an allocated value
        (-, attrfield) =</ins><del>(result, amount);
        when</del> <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)"><ins>ConstrainUnpredictableBits</ins></a><a href="shared_pseudocode.html#ShiftType_LSR" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}"><del>ShiftType_LSR</del></a><ins>(</ins><del>result =</del><a href="shared_pseudocode.html#Unpredictable_RESMAIR" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESMAIR</ins></a><a href="shared_pseudocode.html#impl-shared.LSR.2" title="function: bits(N) LSR(bits(N) x, integer shift)"><del>LSR</del></a><ins>);
    if !</ins><del>(result, amount);
        when</del><a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()"><ins>HaveMTEExt</ins></a><a href="shared_pseudocode.html#ShiftType_ASR" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}"><del>ShiftType_ASR</del></a><ins>() &amp;&amp; attrfield&lt;7:4> == '1111' &amp;&amp; attrfield&lt;3:0> == '0000' then
        // Reserved, maps to an allocated value
        (-, attrfield) =</ins><del>result =</del> <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)"><ins>ConstrainUnpredictableBits</ins></a><a href="shared_pseudocode.html#impl-shared.ASR.2" title="function: bits(N) ASR(bits(N) x, integer shift)"><del>ASR</del></a><ins>(</ins><del>(result, amount);
        when</del><a href="shared_pseudocode.html#Unpredictable_RESMAIR" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESMAIR</ins></a><a href="shared_pseudocode.html#ShiftType_ROR" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}"><del>ShiftType_ROR</del></a><ins>);

    if attrfield&lt;7:4> == '0000' then            // Device
        memattrs.type =</ins><del>result =</del> <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Device</ins></a><a href="shared_pseudocode.html#impl-shared.ROR.2" title="function: bits(N) ROR(bits(N) x, integer shift)"><del>ROR</del></a><ins>;
        case attrfield&lt;3:0> of
            when '0000'  memattrs.device = </ins><a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType_nGnRnE</ins></a><ins>;
            when '0100'  memattrs.device = </ins><a href="shared_pseudocode.html#DeviceType_nGnRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType_nGnRE</ins></a><ins>;
            when '1000'  memattrs.device = </ins><a href="shared_pseudocode.html#DeviceType_nGRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType_nGRE</ins></a><ins>;
            when '1100'  memattrs.device = </ins><a href="shared_pseudocode.html#DeviceType_GRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType_GRE</ins></a><ins>;
            otherwise    </ins><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><ins>Unreachable</ins></a><ins>();         // Reserved, handled above

    elsif attrfield&lt;3:0> != '0000'  then        // Normal
        memattrs.type = </ins><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Normal</ins></a><ins>;
        memattrs.outer = </ins><a href="shared_pseudocode.html#impl-shared.LongConvertAttrsHints.2" title="function: MemAttrHints LongConvertAttrsHints(bits(4) attrfield, AccType acctype)"><ins>LongConvertAttrsHints</ins></a><ins>(attrfield&lt;7:4>, acctype);
        memattrs.inner = </ins><a href="shared_pseudocode.html#impl-shared.LongConvertAttrsHints.2" title="function: MemAttrHints LongConvertAttrsHints(bits(4) attrfield, AccType acctype)"><ins>LongConvertAttrsHints</ins></a><ins>(attrfield&lt;3:0>, acctype);
        memattrs.shareable = SH&lt;1> == '1';
        memattrs.outershareable = SH == '10';
    elsif </ins><a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()"><ins>HaveMTEExt</ins></a><ins>() &amp;&amp; attrfield == '11110000' then // Tagged, Normal
        memattrs.tagged = TRUE;
        memattrs.type = </ins><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Normal</ins></a><ins>;
        memattrs.outer.attrs = </ins><a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'"><ins>MemAttr_WB</ins></a><ins>;
        memattrs.inner.attrs = </ins><a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'"><ins>MemAttr_WB</ins></a><ins>;
        memattrs.outer.hints = </ins><a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'"><ins>MemHint_RWA</ins></a><ins>;
        memattrs.inner.hints = </ins><a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'"><ins>MemHint_RWA</ins></a><ins>;
        memattrs.shareable = SH&lt;1> == '1';
        memattrs.outershareable = SH == '10';
    else
        </ins><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><ins>Unreachable</ins></a><ins>();                          // Reserved, handled above

    return </ins><a href="shared_pseudocode.html#impl-shared.MemAttrDefaults.1" title="function: MemoryAttributes MemAttrDefaults(MemoryAttributes memattrs)"><ins>MemAttrDefaults</ins></a><ins>(memattrs);</ins><del>(result, amount);
    return result;</del></p></div><div class="ps" psname="aarch64.translation.attrs.AArch64.TranslateAddressS1Off"><a id="aarch64.translation.attrs.AArch64.TranslateAddressS1Off" name="aarch64.translation.attrs.AArch64.TranslateAddressS1Off"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>translation</ins><del>instrs</del>/<ins>attrs</ins><del>integer</del>/<ins>AArch64.TranslateAddressS1Off</ins><del>shiftreg/ShiftType</del></h3><p class="pseudocode"><ins>// AArch64.TranslateAddressS1Off()
// ===============================
// Called for stage 1 translations when translation is disabled to supply a default translation.
// Note that there are additional constraints on instruction prefetching that are not described in
// this pseudocode.

TLBRecord</ins><del>enumeration</del> <a id="AArch64.TranslateAddressS1Off.3" name="AArch64.TranslateAddressS1Off.3"></a><ins>AArch64.TranslateAddressS1Off(bits(64) vaddress,</ins><del>ShiftType   {</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a> <ins>acctype, boolean iswrite)
    assert !</ins><del>ShiftType_LSL,</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><del>ShiftType_LSR,</del><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><ins>());</ins><del>ShiftType_ASR,</del>

    <a href="shared_pseudocode.html#TLBRecord" title="type TLBRecord is ( Permissions perms, bit nG, bits(4) domain, bit GP, boolean contiguous, integer level, integer blocksize, DescriptorUpdate descupdate, bit CnP, AddressDescriptor addrdesc )"><ins>TLBRecord</ins></a><ins> result;

    Top = </ins><a href="shared_pseudocode.html#impl-shared.AddrTop.3" title="function: integer AddrTop(bits(64) address, boolean IsInstr, bits(2) el)"><ins>AddrTop</ins></a><ins>(vaddress, (acctype == </ins><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><ins>), PSTATE.EL);
    if !</ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(vaddress&lt;Top:</ins><a href="shared_pseudocode.html#impl-shared.PAMax.0" title="function: integer PAMax()"><ins>PAMax</ins></a><ins>()>) then
        level = 0;
        ipaddress = bits(52) UNKNOWN;
        secondstage = FALSE;
        s2fs1walk = FALSE;
        result.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch64.AddressSizeFault.7" title="function: FaultRecord AArch64.AddressSizeFault(bits(52) ipaddress,bit NS, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><ins>AArch64.AddressSizeFault</ins></a><ins>(ipaddress,bit UNKNOWN,  level, acctype,
                                                         iswrite, secondstage, s2fs1walk);
        return result;

    default_cacheable = (</ins><a href="shared_pseudocode.html#impl-shared.HasS2Translation.0" title="function: boolean HasS2Translation()"><ins>HasS2Translation</ins></a><ins>() &amp;&amp; HCR_EL2.DC == '1');

    if default_cacheable then
        // Use default cacheable settings
        result.addrdesc.memattrs.type = </ins><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Normal</ins></a><ins>;
        result.addrdesc.memattrs.inner.attrs = </ins><a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'"><ins>MemAttr_WB</ins></a><ins>;      // Write-back
        result.addrdesc.memattrs.inner.hints = </ins><a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'"><ins>MemHint_RWA</ins></a><ins>;
        result.addrdesc.memattrs.shareable = FALSE;
        result.addrdesc.memattrs.outershareable = FALSE;
        result.addrdesc.memattrs.tagged = HCR_EL2.DCT == '1';
    elsif acctype != </ins><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><ins> then
        // Treat data as Device
        result.addrdesc.memattrs.type = </ins><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Device</ins></a><ins>;
        result.addrdesc.memattrs.device = </ins><a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType_nGnRnE</ins></a><ins>;
        result.addrdesc.memattrs.inner = </ins><a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )"><ins>MemAttrHints</ins></a><ins> UNKNOWN;
        result.addrdesc.memattrs.tagged = FALSE;
    else
        // Instruction cacheability controlled by SCTLR_ELx.I
        cacheable = </ins><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><ins>SCTLR</ins></a><ins>[].I == '1';
        result.addrdesc.memattrs.type = </ins><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Normal</ins></a><ins>;
        if cacheable then
            result.addrdesc.memattrs.inner.attrs = </ins><a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'"><ins>MemAttr_WT</ins></a><ins>;
            result.addrdesc.memattrs.inner.hints = </ins><a href="shared_pseudocode.html#MemHint_RA" title="constant bits(2) MemHint_RA = '10'"><ins>MemHint_RA</ins></a><ins>;
        else
            result.addrdesc.memattrs.inner.attrs = </ins><a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'"><ins>MemAttr_NC</ins></a><ins>;
            result.addrdesc.memattrs.inner.hints = </ins><a href="shared_pseudocode.html#MemHint_No" title="constant bits(2) MemHint_No = '00'"><ins>MemHint_No</ins></a><ins>;
        result.addrdesc.memattrs.shareable = TRUE;
        result.addrdesc.memattrs.outershareable = TRUE;
        result.addrdesc.memattrs.tagged = FALSE;

    result.addrdesc.memattrs.outer = result.addrdesc.memattrs.inner;

    result.addrdesc.memattrs = </ins><a href="shared_pseudocode.html#impl-shared.MemAttrDefaults.1" title="function: MemoryAttributes MemAttrDefaults(MemoryAttributes memattrs)"><ins>MemAttrDefaults</ins></a><ins>(result.addrdesc.memattrs);

    result.perms.ap = bits(3) UNKNOWN;
    result.perms.xn = '0';
    result.perms.pxn = '0';

    result.nG = bit UNKNOWN;
    result.contiguous = boolean UNKNOWN;
    result.domain = bits(4) UNKNOWN;
    result.level = integer UNKNOWN;
    result.blocksize = integer UNKNOWN;
    result.addrdesc.paddress.address = vaddress&lt;51:0>;
    result.addrdesc.paddress.NS = if </ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>() then '0' else '1';
    result.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch64.NoFault.0" title="function: FaultRecord AArch64.NoFault()"><ins>AArch64.NoFault</ins></a><ins>();
    return result;</ins><del>ShiftType_ROR};</del></p></div><div class="ps" psname="aarch64.translation.checks.AArch64.AccessIsPrivileged"><a id="aarch64.translation.checks.AArch64.AccessIsPrivileged" name="aarch64.translation.checks.AArch64.AccessIsPrivileged"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>translation</ins><del>instrs</del>/<ins>checks</ins><del>logicalop</del>/<ins>AArch64.AccessIsPrivileged</ins><del>LogicalOp</del></h3><p class="pseudocode"><ins>// AArch64.AccessIsPrivileged()
// ============================

boolean</ins><del>enumeration</del> <a id="AArch64.AccessIsPrivileged.1" name="AArch64.AccessIsPrivileged.1"></a><ins>AArch64.AccessIsPrivileged(</ins><del>LogicalOp   {</del><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a> <ins>acctype)

    el =</ins><del>LogicalOp_AND,</del> <a href="shared_pseudocode.html#AArch64.AccessUsesEL.1" title="function: bits(2) AArch64.AccessUsesEL(AccType acctype)"><ins>AArch64.AccessUsesEL</ins></a><ins>(acctype);

    if el ==</ins><del>LogicalOp_EOR,</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins> then
        ispriv = FALSE;
    elsif el == </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins> then
        ispriv = TRUE;
    elsif el == </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins> &amp;&amp; (!</ins><a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><ins>IsInHost</ins></a><ins>() || HCR_EL2.TGE == '0') then
        ispriv = TRUE;
    elsif </ins><a href="shared_pseudocode.html#impl-shared.HaveUAOExt.0" title="function: boolean HaveUAOExt()"><ins>HaveUAOExt</ins></a><ins>() &amp;&amp; PSTATE.UAO == '1' then
        ispriv = TRUE;
    else
        ispriv = (acctype != </ins><a href="shared_pseudocode.html#AccType_UNPRIV" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_UNPRIV</ins></a><ins>);

    return ispriv;</ins><del>LogicalOp_ORR};</del></p></div><div class="ps" psname="aarch64.translation.checks.AArch64.AccessUsesEL"><a id="aarch64.translation.checks.AArch64.AccessUsesEL" name="aarch64.translation.checks.AArch64.AccessUsesEL"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>translation</ins><del>instrs</del>/<ins>checks</ins><del>memory</del>/<ins>AArch64.AccessUsesEL</ins><del>memop/MemAtomicOp</del></h3><p class="pseudocode"><ins>// AArch64.AccessUsesEL()
// ======================
// Returns the Exception Level of the regime that will manage the translation for a given access type.

bits(2)</ins><del>enumeration</del> <a id="AArch64.AccessUsesEL.1" name="AArch64.AccessUsesEL.1"></a><ins>AArch64.AccessUsesEL(</ins><del>MemAtomicOp {</del><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a> <ins>acctype)
    if acctype ==</ins><del>MemAtomicOp_ADD,</del> <a href="shared_pseudocode.html#AccType_UNPRIV" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_UNPRIV</ins></a> <ins>then
        return</ins><del>MemAtomicOp_BIC,</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>;
    elsif acctype ==</ins><del>MemAtomicOp_EOR,</del> <a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NV2REGISTER</ins></a> <ins>then
        return</ins><del>MemAtomicOp_ORR,</del> <del>MemAtomicOp_SMAX,
                         </del><a id="MemAtomicOp_SMIN" name="MemAtomicOp_SMIN"></a><del>MemAtomicOp_SMIN,
                         </del><a id="MemAtomicOp_UMAX" name="MemAtomicOp_UMAX"></a><del>MemAtomicOp_UMAX,
                         </del><a id="MemAtomicOp_UMIN" name="MemAtomicOp_UMIN"></a><del>MemAtomicOp_UMIN,
                         </del><a id="MemAtomicOp_SWP" name="MemAtomicOp_SWP"></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>;
    else
        return PSTATE.EL;</ins><del>MemAtomicOp_SWP};</del></p></div><div class="ps" psname="aarch64.translation.checks.AArch64.CheckPermission"><a id="aarch64.translation.checks.AArch64.CheckPermission" name="aarch64.translation.checks.AArch64.CheckPermission"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>translation</ins><del>instrs</del>/<ins>checks</ins><del>memory</del>/<ins>AArch64.CheckPermission</ins><del>memop/MemOp</del></h3><p class="pseudocode"><ins>// AArch64.CheckPermission()
// =========================
// Function used for permission checking from AArch64 stage 1 translations

FaultRecord</ins><del>enumeration</del> <a id="AArch64.CheckPermission.6" name="AArch64.CheckPermission.6"></a><ins>AArch64.CheckPermission(</ins><del>MemOp {</del><a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(3) ap, bit xn, bit xxn, bit pxn )"><ins>Permissions</ins></a> <ins>perms, bits(64) vaddress, integer level,
                                    bit NS,</ins><del>MemOp_LOAD,</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a> <ins>acctype, boolean iswrite)
    assert !</ins><del>MemOp_STORE,</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><ins>());

    wxn = </ins><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><ins>SCTLR</ins></a><ins>[].WXN == '1';

    if (PSTATE.EL == </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins> ||
        </ins><a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><ins>IsInHost</ins></a><ins>() ||
        (PSTATE.EL == </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins> &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()"><ins>HaveNV2Ext</ins></a><ins>()) ||
        (PSTATE.EL == </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins> &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()"><ins>HaveNV2Ext</ins></a><ins>() &amp;&amp; (acctype != </ins><a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NV2REGISTER</ins></a><ins> || !</ins><a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)"><ins>ELIsInHost</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>)))) then
        priv_r = TRUE;
        priv_w = perms.ap&lt;2> == '0';
        user_r = perms.ap&lt;1> == '1';
        user_w = perms.ap&lt;2:1> == '01';

        ispriv = </ins><a href="shared_pseudocode.html#AArch64.AccessIsPrivileged.1" title="function: boolean AArch64.AccessIsPrivileged(AccType acctype)"><ins>AArch64.AccessIsPrivileged</ins></a><ins>(acctype);

        pan = if </ins><a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()"><ins>HavePANExt</ins></a><ins>() then PSTATE.PAN else '0';
        if (</ins><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>() &amp;&amp; ((PSTATE.EL == </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins> &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.HaveNVExt.0" title="function: boolean HaveNVExt()"><ins>HaveNVExt</ins></a><ins>() &amp;&amp; HCR_EL2.&lt;NV, NV1> == '11') ||
            (</ins><a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()"><ins>HaveNV2Ext</ins></a><ins>() &amp;&amp; acctype == </ins><a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NV2REGISTER</ins></a><ins> &amp;&amp; HCR_EL2.NV2 == '1'))) then
            pan = '0';
        is_ldst   = !(acctype IN {</ins><a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_DC</ins></a><ins>, </ins><a href="shared_pseudocode.html#AccType_DC_UNPRIV" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_DC_UNPRIV</ins></a><ins>, </ins><a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_AT</ins></a><ins>, </ins><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><ins>});
        is_ats1xp = (acctype == </ins><a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_AT</ins></a><ins> &amp;&amp; </ins><a href="shared_pseudocode.html#AArch64.ExecutingATS1xPInstr.0" title="function: boolean AArch64.ExecutingATS1xPInstr()"><ins>AArch64.ExecutingATS1xPInstr</ins></a><ins>());
        if pan == '1' &amp;&amp; user_r &amp;&amp; ispriv &amp;&amp; (is_ldst || is_ats1xp) then
            priv_r = FALSE;
            priv_w = FALSE;

        user_xn = perms.xn == '1' || (user_w &amp;&amp; wxn);
        priv_xn = perms.pxn == '1' || (priv_w &amp;&amp; wxn) || user_w;

        if ispriv then
            (r, w, xn) = (priv_r, priv_w, priv_xn);
        else
            (r, w, xn) = (user_r, user_w, user_xn);
    else
        // Access from EL2 or EL3
        r = TRUE;
        w = perms.ap&lt;2> == '0';
        xn = perms.xn == '1' || (w &amp;&amp; wxn);

    // Restriction on Secure instruction fetch
    if </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>() &amp;&amp; NS == '1' &amp;&amp; SCR_EL3.SIF == '1' then
        xn = TRUE;

    if acctype == </ins><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><ins> then
        fail = xn;
        failedread = TRUE;
    elsif acctype IN { </ins><a href="shared_pseudocode.html#AccType_ATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ATOMICRW</ins></a><ins>, </ins><a href="shared_pseudocode.html#AccType_ORDEREDRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ORDEREDRW</ins></a><ins>, </ins><a href="shared_pseudocode.html#AccType_ORDEREDATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ORDEREDATOMICRW</ins></a><ins> } then
        fail = !r || !w;
        failedread = !r;
    elsif iswrite then
        fail = !w;
        failedread = FALSE;
    elsif acctype == </ins><a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_DC</ins></a><ins> &amp;&amp; PSTATE.EL != </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins> then
        // DC maintenance instructions operating by VA, cannot fault from stage 1 translation,
        // other than DC IVAC, which requires write permission, and operations executed at EL0,
        // which require read permission.
        fail = FALSE;
    else
        fail = !r;
        failedread = TRUE;

    if fail then
        secondstage = FALSE;
        s2fs1walk = FALSE;
        ipaddress = bits(52) UNKNOWN;
        return </ins><a href="shared_pseudocode.html#AArch64.PermissionFault.7" title="function: FaultRecord AArch64.PermissionFault(bits(52) ipaddress,bit NS, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><ins>AArch64.PermissionFault</ins></a><ins>(ipaddress,bit UNKNOWN,  level, acctype,
                                       !failedread, secondstage, s2fs1walk);
    else
        return </ins><a href="shared_pseudocode.html#AArch64.NoFault.0" title="function: FaultRecord AArch64.NoFault()"><ins>AArch64.NoFault</ins></a><ins>();</ins><del>MemOp_PREFETCH};</del></p></div><div class="ps" psname="aarch64.translation.checks.AArch64.CheckS2Permission"><a id="aarch64.translation.checks.AArch64.CheckS2Permission" name="aarch64.translation.checks.AArch64.CheckS2Permission"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>translation</ins><del>instrs</del>/<ins>checks</ins><del>memory</del>/<ins>AArch64.CheckS2Permission</ins><del>prefetch/Prefetch</del></h3><p class="pseudocode"><ins>// AArch64.CheckS2Permission()
// ===========================
// Function used for permission checking from AArch64 stage 2 translations
</ins><del>// Prefetch()
// ==========
</del>
<ins>FaultRecord</ins><del>// Decode and execute the prefetch hint on ADDRESS specified by PRFOP</del> <a id="AArch64.CheckS2Permission.9" name="AArch64.CheckS2Permission.9"></a><ins>AArch64.CheckS2Permission(</ins><del>Prefetch(bits(64) address, bits(5) prfop)</del><a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(3) ap, bit xn, bit xxn, bit pxn )"><ins>Permissions</ins></a><a href="shared_pseudocode.html#PrefetchHint" title="enumeration PrefetchHint {Prefetch_READ, Prefetch_WRITE, Prefetch_EXEC}"><del>PrefetchHint</del></a> <ins>perms, bits(64) vaddress, bits(52) ipaddress,
                                      integer level,</ins><del>hint;
    integer target;
    boolean stream;

    case prfop&lt;4:3> of
        when '00' hint =</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><a href="shared_pseudocode.html#Prefetch_READ" title="enumeration PrefetchHint {Prefetch_READ, Prefetch_WRITE, Prefetch_EXEC}"><del>Prefetch_READ</del></a> <ins>acctype, boolean iswrite, bit NS,
                                      boolean s2fs1walk, boolean hwupdatewalk)

    assert</ins><del>;         // PLD: prefetch for load
        when '01' hint =</del> <a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()"><ins>IsSecureEL2Enabled</ins></a><a href="shared_pseudocode.html#Prefetch_EXEC" title="enumeration PrefetchHint {Prefetch_READ, Prefetch_WRITE, Prefetch_EXEC}"><del>Prefetch_EXEC</del></a><ins>() || (</ins><del>;         // PLI: preload instructions
        when '10' hint =</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#Prefetch_WRITE" title="enumeration PrefetchHint {Prefetch_READ, Prefetch_WRITE, Prefetch_EXEC}"><del>Prefetch_WRITE</del></a><ins>(</ins><del>;        // PST: prepare for store
        when '11' return;                       // unallocated hint
    target =</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>) &amp;&amp; !</ins><del>(prfop&lt;2:1>);                  // target cache level
    stream = (prfop&lt;0> != '0');                 // streaming (non-temporal)</del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><a href="shared_pseudocode.html#impl-shared.Hint_Prefetch.4" title="function: Hint_Prefetch(bits(64) address, PrefetchHint hint, integer target, boolean stream)"><del>Hint_Prefetch</del></a><ins>() &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) ) &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.HasS2Translation.0" title="function: boolean HasS2Translation()"><ins>HasS2Translation</ins></a><ins>();

    r = perms.ap&lt;1> == '1';
    w = perms.ap&lt;2> == '1';
    if </ins><a href="shared_pseudocode.html#impl-shared.HaveExtendedExecuteNeverExt.0" title="function: boolean HaveExtendedExecuteNeverExt()"><ins>HaveExtendedExecuteNeverExt</ins></a><ins>() then
        case perms.xn:perms.xxn of
            when '00'  xn = FALSE;
            when '01'  xn = PSTATE.EL == </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>;
            when '10'  xn = TRUE;
            when '11'  xn = PSTATE.EL == </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>;
    else
        xn = perms.xn == '1';
    // Stage 1 walk is checked as a read, regardless of the original type
    if acctype == </ins><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><ins> &amp;&amp; !s2fs1walk then
        fail = xn;
        failedread = TRUE;
    elsif (acctype IN { </ins><a href="shared_pseudocode.html#AccType_ATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ATOMICRW</ins></a><ins>, </ins><a href="shared_pseudocode.html#AccType_ORDEREDRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ORDEREDRW</ins></a><ins>, </ins><a href="shared_pseudocode.html#AccType_ORDEREDATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ORDEREDATOMICRW</ins></a><ins> }) &amp;&amp; !s2fs1walk then
        fail = !r || !w;
        failedread = !r;
    elsif iswrite &amp;&amp; !s2fs1walk then
        fail = !w;
        failedread = FALSE;
    elsif acctype == </ins><a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_DC</ins></a><ins> &amp;&amp; PSTATE.EL != </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins> &amp;&amp; !s2fs1walk then
        // DC maintenance instructions operating by VA, with the exception of DC IVAC, do
        // not generate Permission faults from stage 2 translation, other than when
        // performing a stage 1 translation table walk.
        fail = FALSE;
    elsif hwupdatewalk then
        fail = !w;
        failedread = !iswrite;
    else
        fail = !r;
        failedread = !iswrite;

    if fail then
        domain = bits(4) UNKNOWN;
        secondstage = TRUE;
        return </ins><a href="shared_pseudocode.html#AArch64.PermissionFault.7" title="function: FaultRecord AArch64.PermissionFault(bits(52) ipaddress,bit NS, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><ins>AArch64.PermissionFault</ins></a><ins>(ipaddress,NS,  level, acctype,
                                       !failedread, secondstage, s2fs1walk);
    else
        return </ins><a href="shared_pseudocode.html#AArch64.NoFault.0" title="function: FaultRecord AArch64.NoFault()"><ins>AArch64.NoFault</ins></a><ins>();</ins><del>(address, hint, target, stream);
    return;</del></p></div><div class="ps" psname="aarch64.translation.debug.AArch64.CheckBreakpoint"><a id="aarch64.translation.debug.AArch64.CheckBreakpoint" name="aarch64.translation.debug.AArch64.CheckBreakpoint"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>translation</ins><del>instrs</del>/<ins>debug</ins><del>system</del>/<ins>AArch64.CheckBreakpoint</ins><del>barriers/barrierop/MemBarrierOp</del></h3><p class="pseudocode"><ins>// AArch64.CheckBreakpoint()
// =========================
// Called before executing the instruction of length "size" bytes at "vaddress" in an AArch64
// translation regime.
// The breakpoint can in fact be evaluated well ahead of execution, for example, at instruction
// fetch. This is the simple sequential execution of the program.

FaultRecord</ins><del>enumeration</del> <a id="AArch64.CheckBreakpoint.3" name="AArch64.CheckBreakpoint.3"></a><ins>AArch64.CheckBreakpoint(bits(64) vaddress,</ins><del>MemBarrierOp   {</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a> <ins>acctype, integer size)
    assert !</ins><del>MemBarrierOp_DSB         // Data Synchronization Barrier
                            ,</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><del>MemBarrierOp_DMB         // Data Memory Barrier
                            ,</del><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><ins>());
    assert (</ins><del>MemBarrierOp_ISB         // Instruction Synchronization Barrier
                            ,</del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>() &amp;&amp; size IN {2,4}) || size == 4;

    match = FALSE;

    for i = 0 to</ins><del>MemBarrierOp_SSBB        // Speculative Synchronization Barrier to VA
                            ,</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(ID_AA64DFR0_EL1.BRPs)
        match_i =</ins><del>MemBarrierOp_PSSBB       // Speculative Synchronization Barrier to PA
                            ,</del> <a href="shared_pseudocode.html#AArch64.BreakpointMatch.4" title="function: boolean AArch64.BreakpointMatch(integer n, bits(64) vaddress, AccType acctype, integer size)"><ins>AArch64.BreakpointMatch</ins></a><ins>(i, vaddress, acctype, size);
        match = match || match_i;

    if match &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.HaltOnBreakpointOrWatchpoint.0" title="function: boolean HaltOnBreakpointOrWatchpoint()"><ins>HaltOnBreakpointOrWatchpoint</ins></a><ins>() then
        reason = </ins><a href="shared_pseudocode.html#DebugHalt_Breakpoint" title="constant bits(6) DebugHalt_Breakpoint = '000111'"><ins>DebugHalt_Breakpoint</ins></a><ins>;
        </ins><a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)"><ins>Halt</ins></a><ins>(reason);
    elsif match &amp;&amp; MDSCR_EL1.MDE == '1' &amp;&amp; </ins><a href="shared_pseudocode.html#AArch64.GenerateDebugExceptions.0" title="function: boolean AArch64.GenerateDebugExceptions()"><ins>AArch64.GenerateDebugExceptions</ins></a><ins>() then
        acctype = </ins><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><ins>;
        iswrite = FALSE;
        return </ins><a href="shared_pseudocode.html#AArch64.DebugFault.2" title="function: FaultRecord AArch64.DebugFault(AccType acctype, boolean iswrite)"><ins>AArch64.DebugFault</ins></a><ins>(acctype, iswrite);
    else
        return </ins><a href="shared_pseudocode.html#AArch64.NoFault.0" title="function: FaultRecord AArch64.NoFault()"><ins>AArch64.NoFault</ins></a><ins>();</ins><del>MemBarrierOp_SB          // Speculation Barrier
                           };</del></p></div><div class="ps" psname="aarch64.translation.debug.AArch64.CheckDebug"><a id="aarch64.translation.debug.AArch64.CheckDebug" name="aarch64.translation.debug.AArch64.CheckDebug"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>translation</ins><del>instrs</del>/<ins>debug</ins><del>system</del>/<ins>AArch64.CheckDebug</ins><del>hints/syshintop/SystemHintOp</del></h3><p class="pseudocode"><ins>// AArch64.CheckDebug()
// ====================
// Called on each access to check for a debug exception or entry to Debug state.

FaultRecord</ins><del>enumeration</del> <a id="AArch64.CheckDebug.4" name="AArch64.CheckDebug.4"></a><ins>AArch64.CheckDebug(bits(64) vaddress,</ins><del>SystemHintOp {</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a> <ins>acctype, boolean iswrite, integer size)</ins><del>SystemHintOp_NOP,</del>

    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><ins>FaultRecord</ins></a> <ins>fault =</ins><del>SystemHintOp_YIELD,</del> <a href="shared_pseudocode.html#AArch64.NoFault.0" title="function: FaultRecord AArch64.NoFault()"><ins>AArch64.NoFault</ins></a><ins>();

    d_side = (acctype !=</ins><del>SystemHintOp_WFE,</del> <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><ins>);
    generate_exception =</ins><del>SystemHintOp_WFI,</del> <a href="shared_pseudocode.html#AArch64.GenerateDebugExceptions.0" title="function: boolean AArch64.GenerateDebugExceptions()"><ins>AArch64.GenerateDebugExceptions</ins></a><ins>() &amp;&amp; MDSCR_EL1.MDE == '1';
    halt =</ins><del>SystemHintOp_SEV,</del> <a href="shared_pseudocode.html#impl-shared.HaltOnBreakpointOrWatchpoint.0" title="function: boolean HaltOnBreakpointOrWatchpoint()"><ins>HaltOnBreakpointOrWatchpoint</ins></a><ins>();

    if generate_exception || halt then
        if d_side then
            fault =</ins><del>SystemHintOp_SEVL,</del> <a href="shared_pseudocode.html#AArch64.CheckWatchpoint.4" title="function: FaultRecord AArch64.CheckWatchpoint(bits(64) vaddress, AccType acctype, boolean iswrite, integer size)"><ins>AArch64.CheckWatchpoint</ins></a><ins>(vaddress, acctype, iswrite, size);
        else
            fault =</ins><del>SystemHintOp_ESB,</del> <del>SystemHintOp_PSB,
    </del><a id="SystemHintOp_TSB" name="SystemHintOp_TSB"></a><del>SystemHintOp_TSB,
    </del><a id="SystemHintOp_BTI" name="SystemHintOp_BTI"></a><del>SystemHintOp_BTI,
    </del><a id="SystemHintOp_CSDB" name="SystemHintOp_CSDB"></a><a href="shared_pseudocode.html#AArch64.CheckBreakpoint.3" title="function: FaultRecord AArch64.CheckBreakpoint(bits(64) vaddress, AccType acctype, integer size)"><ins>AArch64.CheckBreakpoint</ins></a><ins>(vaddress, acctype, size);

    return fault;</ins><del>SystemHintOp_CSDB
};</del></p></div><div class="ps" psname="aarch64.translation.debug.AArch64.CheckWatchpoint"><a id="aarch64.translation.debug.AArch64.CheckWatchpoint" name="aarch64.translation.debug.AArch64.CheckWatchpoint"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>translation</ins><del>instrs</del>/<ins>debug</ins><del>system</del>/<ins>AArch64.CheckWatchpoint</ins><del>register/cpsr/pstatefield/PSTATEField</del></h3><p class="pseudocode"><ins>// AArch64.CheckWatchpoint()
// =========================
// Called before accessing the memory location of "size" bytes at "address".

FaultRecord</ins><del>enumeration</del> <a id="AArch64.CheckWatchpoint.4" name="AArch64.CheckWatchpoint.4"></a><ins>AArch64.CheckWatchpoint(bits(64) vaddress,</ins><del>PSTATEField {</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a> <ins>acctype,
                                    boolean iswrite, integer size)
    assert !</ins><del>PSTATEField_DAIFSet,</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><del>PSTATEField_DAIFClr,</del><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><ins>());

    match = FALSE;
    ispriv =</ins><del>PSTATEField_PAN, // ARMv8.1</del> <a href="shared_pseudocode.html#AArch64.AccessIsPrivileged.1" title="function: boolean AArch64.AccessIsPrivileged(AccType acctype)"><ins>AArch64.AccessIsPrivileged</ins></a><ins>(acctype);

    for i = 0 to</ins><del>PSTATEField_UAO, // ARMv8.2</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(ID_AA64DFR0_EL1.WRPs)
        match = match ||</ins><del>PSTATEField_DIT, // ARMv8.4</del> <a href="shared_pseudocode.html#AArch64.WatchpointMatch.6" title="function: boolean AArch64.WatchpointMatch(integer n, bits(64) vaddress, integer size, boolean ispriv, AccType acctype, boolean iswrite)"><ins>AArch64.WatchpointMatch</ins></a><ins>(i, vaddress, size, ispriv, acctype, iswrite);

    if match &amp;&amp;</ins><del>PSTATEField_SP,</del> <a href="shared_pseudocode.html#impl-shared.HaltOnBreakpointOrWatchpoint.0" title="function: boolean HaltOnBreakpointOrWatchpoint()"><ins>HaltOnBreakpointOrWatchpoint</ins></a><ins>() then
        if acctype != </ins><a href="shared_pseudocode.html#AccType_NONFAULT" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NONFAULT</ins></a><ins> &amp;&amp; acctype != </ins><a href="shared_pseudocode.html#AccType_CNOTFIRST" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_CNOTFIRST</ins></a><ins> then
            reason = </ins><a href="shared_pseudocode.html#DebugHalt_Watchpoint" title="constant bits(6) DebugHalt_Watchpoint = '101011'"><ins>DebugHalt_Watchpoint</ins></a><ins>;
            </ins><a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)"><ins>Halt</ins></a><ins>(reason);
        else
            // Fault will be reported and cancelled
            return </ins><a href="shared_pseudocode.html#AArch64.DebugFault.2" title="function: FaultRecord AArch64.DebugFault(AccType acctype, boolean iswrite)"><ins>AArch64.DebugFault</ins></a><ins>(acctype, iswrite);
    elsif match &amp;&amp; MDSCR_EL1.MDE == '1' &amp;&amp; </ins><a href="shared_pseudocode.html#AArch64.GenerateDebugExceptions.0" title="function: boolean AArch64.GenerateDebugExceptions()"><ins>AArch64.GenerateDebugExceptions</ins></a><ins>() then
        return </ins><a href="shared_pseudocode.html#AArch64.DebugFault.2" title="function: FaultRecord AArch64.DebugFault(AccType acctype, boolean iswrite)"><ins>AArch64.DebugFault</ins></a><ins>(acctype, iswrite);
    else
        return </ins><a href="shared_pseudocode.html#AArch64.NoFault.0" title="function: FaultRecord AArch64.NoFault()"><ins>AArch64.NoFault</ins></a><ins>();</ins><del>PSTATEField_SSBS
                         };</del></p></div><div class="ps" psname="aarch64.translation.faults.AArch64.AccessFlagFault"><a id="aarch64.translation.faults.AArch64.AccessFlagFault" name="aarch64.translation.faults.AArch64.AccessFlagFault"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>translation</ins><del>instrs</del>/<ins>faults</ins><del>system</del>/<ins>AArch64.AccessFlagFault</ins><del>sysops/sysop/SysOp</del></h3><p class="pseudocode"><ins>// AArch64.AccessFlagFault()
// =========================
</ins><del>// SysOp()
// =======
</del>
<ins>FaultRecord</ins><del>SystemOp</del> <a id="AArch64.AccessFlagFault.7" name="AArch64.AccessFlagFault.7"></a><ins>AArch64.AccessFlagFault(bits(52) ipaddress,bit NS, integer level,</ins><del>SysOp(bits(3) op1, bits(4) CRn, bits(4) CRm, bits(3) op2)
    case op1:CRn:CRm:op2 of
        when '000 0111 1000 000' return</del>
                                    <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_AT</del></a> <ins>acctype, boolean iswrite, boolean secondstage,
                                    boolean s2fs1walk)

    extflag = bit UNKNOWN;
    errortype = bits(2) UNKNOWN;
    return</ins><del>;   // S1E1R
        when '100 0111 1000 000' return</del> <a href="shared_pseudocode.html#AArch64.CreateFaultRecord.10" title="function: FaultRecord AArch64.CreateFaultRecord(Fault type, bits(52) ipaddress, bit NS, integer level, AccType acctype, boolean write, bit extflag, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><ins>AArch64.CreateFaultRecord</ins></a><a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_AT</del></a><ins>(</ins><del>;   // S1E2R
        when '110 0111 1000 000' return</del><del>;   // S1E3R
        when '000 0111 1000 001' return </del><a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_AT</del></a><del>;   // S1E1W
        when '100 0111 1000 001' return </del><a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_AT</del></a><del>;   // S1E2W
        when '110 0111 1000 001' return </del><a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_AT</del></a><del>;   // S1E3W
        when '000 0111 1000 010' return </del><a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_AT</del></a><del>;   // S1E0R
        when '000 0111 1000 011' return </del><a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_AT</del></a><del>;   // S1E0W
        when '100 0111 1000 100' return </del><a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_AT</del></a><del>;   // S12E1R
        when '100 0111 1000 101' return </del><a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_AT</del></a><del>;   // S12E1W
        when '100 0111 1000 110' return </del><a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_AT</del></a><del>;   // S12E0R
        when '100 0111 1000 111' return </del><a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_AT</del></a><del>;   // S12E0W
        when '011 0111 0100 001' return </del><a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_DC</del></a><del>;   // ZVA
        when '000 0111 0110 001' return </del><a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_DC</del></a><del>;   // IVAC
        when '000 0111 0110 010' return </del><a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_DC</del></a><del>;   // ISW
        when '011 0111 1010 001' return </del><a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_DC</del></a><del>;   // CVAC
        when '000 0111 1010 010' return </del><a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_DC</del></a><del>;   // CSW
        when '011 0111 1011 001' return </del><a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_DC</del></a><del>;   // CVAU
        when '011 0111 1110 001' return </del><a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_DC</del></a><del>;   // CIVAC
        when '000 0111 1110 010' return </del><a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_DC</del></a><del>;   // CISW
        when '000 0111 0001 000' return </del><a href="shared_pseudocode.html#Sys_IC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_IC</del></a><del>;   // IALLUIS
        when '000 0111 0101 000' return </del><a href="shared_pseudocode.html#Sys_IC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_IC</del></a><del>;   // IALLU
        when '011 0111 0101 001' return </del><a href="shared_pseudocode.html#Sys_IC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_IC</del></a><del>;   // IVAU
        when '100 1000 0000 001' return </del><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_TLBI</del></a><del>; // IPAS2E1IS
        when '100 1000 0000 101' return </del><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_TLBI</del></a><del>; // IPAS2LE1IS
        when '000 1000 0011 000' return </del><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_TLBI</del></a><del>; // VMALLE1IS
        when '100 1000 0011 000' return </del><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_TLBI</del></a><del>; // ALLE2IS
        when '110 1000 0011 000' return </del><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_TLBI</del></a><del>; // ALLE3IS
        when '000 1000 0011 001' return </del><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_TLBI</del></a><del>; // VAE1IS
        when '100 1000 0011 001' return </del><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_TLBI</del></a><del>; // VAE2IS
        when '110 1000 0011 001' return </del><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_TLBI</del></a><del>; // VAE3IS
        when '000 1000 0011 010' return </del><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_TLBI</del></a><del>; // ASIDE1IS
        when '000 1000 0011 011' return </del><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_TLBI</del></a><del>; // VAAE1IS
        when '100 1000 0011 100' return </del><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_TLBI</del></a><del>; // ALLE1IS
        when '000 1000 0011 101' return </del><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_TLBI</del></a><del>; // VALE1IS
        when '100 1000 0011 101' return </del><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_TLBI</del></a><del>; // VALE2IS
        when '110 1000 0011 101' return </del><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_TLBI</del></a><del>; // VALE3IS
        when '100 1000 0011 110' return </del><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_TLBI</del></a><del>; // VMALLS12E1IS
        when '000 1000 0011 111' return </del><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_TLBI</del></a><del>; // VAALE1IS
        when '100 1000 0100 001' return </del><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_TLBI</del></a><del>; // IPAS2E1
        when '100 1000 0100 101' return </del><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_TLBI</del></a><del>; // IPAS2LE1
        when '000 1000 0111 000' return </del><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_TLBI</del></a><del>; // VMALLE1
        when '100 1000 0111 000' return </del><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_TLBI</del></a><del>; // ALLE2
        when '110 1000 0111 000' return </del><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_TLBI</del></a><del>; // ALLE3
        when '000 1000 0111 001' return </del><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_TLBI</del></a><del>; // VAE1
        when '100 1000 0111 001' return </del><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_TLBI</del></a><del>; // VAE2
        when '110 1000 0111 001' return </del><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_TLBI</del></a><del>; // VAE3
        when '000 1000 0111 010' return </del><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_TLBI</del></a><del>; // ASIDE1
        when '000 1000 0111 011' return </del><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_TLBI</del></a><del>; // VAAE1
        when '100 1000 0111 100' return </del><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_TLBI</del></a><del>; // ALLE1
        when '000 1000 0111 101' return </del><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_TLBI</del></a><del>; // VALE1
        when '100 1000 0111 101' return </del><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_TLBI</del></a><del>; // VALE2
        when '110 1000 0111 101' return </del><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_TLBI</del></a><del>; // VALE3
        when '100 1000 0111 110' return </del><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_TLBI</del></a><del>; // VMALLS12E1
        when '000 1000 0111 111' return </del><a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_TLBI</del></a><del>; // VAALE1
    return </del><a href="shared_pseudocode.html#Sys_SYS" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_SYS</del></a><a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_AccessFlag</ins></a><a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}"><del>Sys_AT</del></a><ins>, ipaddress, NS, level, acctype, iswrite,
                                     extflag, errortype, secondstage, s2fs1walk);</ins><del>;</del></p></div><div class="ps" psname="aarch64.translation.faults.AArch64.AddressSizeFault"><a id="aarch64.translation.faults.AArch64.AddressSizeFault" name="aarch64.translation.faults.AArch64.AddressSizeFault"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>translation</ins><del>instrs</del>/<ins>faults</ins><del>system</del>/<ins>AArch64.AddressSizeFault</ins><del>sysops/sysop/SystemOp</del></h3><p class="pseudocode"><ins>// AArch64.AddressSizeFault()
// ==========================

FaultRecord</ins><del>enumeration</del> <a id="AArch64.AddressSizeFault.7" name="AArch64.AddressSizeFault.7"></a><ins>AArch64.AddressSizeFault(bits(52) ipaddress,bit NS, integer level,</ins><del>SystemOp {</del>
                                     <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a> <ins>acctype, boolean iswrite, boolean secondstage,
                                     boolean s2fs1walk)

    extflag = bit UNKNOWN;
    errortype = bits(2) UNKNOWN;
    return</ins><del>Sys_AT,</del> <a href="shared_pseudocode.html#AArch64.CreateFaultRecord.10" title="function: FaultRecord AArch64.CreateFaultRecord(Fault type, bits(52) ipaddress, bit NS, integer level, AccType acctype, boolean write, bit extflag, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><ins>AArch64.CreateFaultRecord</ins></a><ins>(</ins><del>Sys_DC,</del><del>Sys_IC, </del><a id="Sys_TLBI" name="Sys_TLBI"></a><del>Sys_TLBI, </del><a id="Sys_SYS" name="Sys_SYS"></a><a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_AddressSize</ins></a><ins>, ipaddress, NS, level, acctype, iswrite,
                                     extflag, errortype, secondstage, s2fs1walk);</ins><del>Sys_SYS};</del></p></div><div class="ps" psname="aarch64.translation.faults.AArch64.AlignmentFault"><a id="aarch64.translation.faults.AArch64.AlignmentFault" name="aarch64.translation.faults.AArch64.AlignmentFault"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>translation</ins><del>instrs</del>/<ins>faults</ins><del>vector</del>/<ins>AArch64.AlignmentFault</ins><del>arithmetic/binary/uniform/logical/bsl-eor/vbitop/VBitOp</del></h3><p class="pseudocode"><ins>// AArch64.AlignmentFault()
// ========================

FaultRecord</ins><del>enumeration</del> <a id="AArch64.AlignmentFault.3" name="AArch64.AlignmentFault.3"></a><ins>AArch64.AlignmentFault(</ins><del>VBitOp      {</del><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a> <ins>acctype, boolean iswrite, boolean secondstage)

    ipaddress = bits(52) UNKNOWN;
    level = integer UNKNOWN;
    extflag = bit UNKNOWN;
    errortype = bits(2) UNKNOWN;
    s2fs1walk = boolean UNKNOWN;

    return</ins><del>VBitOp_VBIF,</del> <a href="shared_pseudocode.html#AArch64.CreateFaultRecord.10" title="function: FaultRecord AArch64.CreateFaultRecord(Fault type, bits(52) ipaddress, bit NS, integer level, AccType acctype, boolean write, bit extflag, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><ins>AArch64.CreateFaultRecord</ins></a><ins>(</ins><del>VBitOp_VBIT,</del><del>VBitOp_VBSL, </del><a id="VBitOp_VEOR" name="VBitOp_VEOR"></a><a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_Alignment</ins></a><ins>, ipaddress, bit UNKNOWN, level, acctype, iswrite,
                                     extflag, errortype, secondstage, s2fs1walk);</ins><del>VBitOp_VEOR};</del></p></div><div class="ps" psname="aarch64.translation.faults.AArch64.AsynchExternalAbort"><a id="aarch64.translation.faults.AArch64.AsynchExternalAbort" name="aarch64.translation.faults.AArch64.AsynchExternalAbort"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>translation</ins><del>instrs</del>/<ins>faults</ins><del>vector</del>/<ins>AArch64.AsynchExternalAbort</ins><del>arithmetic/unary/cmp/compareop/CompareOp</del></h3><p class="pseudocode"><ins>// AArch64.AsynchExternalAbort()
// =============================
// Wrapper function for asynchronous external aborts

FaultRecord</ins><del>enumeration</del> <a id="AArch64.AsynchExternalAbort.3" name="AArch64.AsynchExternalAbort.3"></a><ins>AArch64.AsynchExternalAbort(boolean parity, bits(2) errortype, bit extflag)

    type = if parity then</ins><del>CompareOp   {</del> <a href="shared_pseudocode.html#Fault_AsyncParity" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_AsyncParity</ins></a> <ins>else</ins><del>CompareOp_GT,</del> <a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_AsyncExternal</ins></a><ins>;
    ipaddress = bits(52) UNKNOWN;
    level = integer UNKNOWN;
    acctype =</ins><del>CompareOp_GE,</del> <a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NORMAL</ins></a><ins>;
    iswrite = boolean UNKNOWN;
    secondstage = FALSE;
    s2fs1walk = FALSE;

    return</ins><del>CompareOp_EQ,</del> <del>CompareOp_LE, </del><a id="CompareOp_LT" name="CompareOp_LT"></a><a href="shared_pseudocode.html#AArch64.CreateFaultRecord.10" title="function: FaultRecord AArch64.CreateFaultRecord(Fault type, bits(52) ipaddress, bit NS, integer level, AccType acctype, boolean write, bit extflag, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><ins>AArch64.CreateFaultRecord</ins></a><ins>(type, ipaddress, bit UNKNOWN, level, acctype, iswrite, extflag,
                                      errortype, secondstage, s2fs1walk);</ins><del>CompareOp_LT};</del></p></div><div class="ps" psname="aarch64.translation.faults.AArch64.DebugFault"><a id="aarch64.translation.faults.AArch64.DebugFault" name="aarch64.translation.faults.AArch64.DebugFault"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>translation</ins><del>instrs</del>/<ins>faults</ins><del>vector</del>/<ins>AArch64.DebugFault</ins><del>logical/immediateop/ImmediateOp</del></h3><p class="pseudocode"><ins>// AArch64.DebugFault()
// ====================

FaultRecord</ins><del>enumeration</del> <a id="AArch64.DebugFault.2" name="AArch64.DebugFault.2"></a><ins>AArch64.DebugFault(</ins><del>ImmediateOp {</del><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a> <ins>acctype, boolean iswrite)

    ipaddress = bits(52) UNKNOWN;
    errortype = bits(2) UNKNOWN;
    level = integer UNKNOWN;
    extflag = bit UNKNOWN;
    secondstage = FALSE;
    s2fs1walk = FALSE;

    return</ins><del>ImmediateOp_MOVI,</del> <a href="shared_pseudocode.html#AArch64.CreateFaultRecord.10" title="function: FaultRecord AArch64.CreateFaultRecord(Fault type, bits(52) ipaddress, bit NS, integer level, AccType acctype, boolean write, bit extflag, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><ins>AArch64.CreateFaultRecord</ins></a><ins>(</ins><del>ImmediateOp_MVNI,</del><del>ImmediateOp_ORR, </del><a id="ImmediateOp_BIC" name="ImmediateOp_BIC"></a><a href="shared_pseudocode.html#Fault_Debug" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_Debug</ins></a><ins>, ipaddress, bit UNKNOWN, level, acctype, iswrite,
                                     extflag, errortype, secondstage, s2fs1walk);</ins><del>ImmediateOp_BIC};</del></p></div><div class="ps" psname="aarch64.translation.faults.AArch64.NoFault"><a id="aarch64.translation.faults.AArch64.NoFault" name="aarch64.translation.faults.AArch64.NoFault"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>translation</ins><del>instrs</del>/<ins>faults</ins><del>vector</del>/<ins>AArch64.NoFault</ins><del>reduce/reduceop/Reduce</del></h3><p class="pseudocode"><ins>// AArch64.NoFault()
// =================
</ins><del>// Reduce()
// ========
</del>
<ins>FaultRecord</ins><del>bits(esize)</del> <a id="AArch64.NoFault.0" name="AArch64.NoFault.0"></a><ins>AArch64.NoFault()

    ipaddress = bits(52) UNKNOWN;
    level = integer UNKNOWN;
    acctype =</ins><del>Reduce(</del> <a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NORMAL</ins></a><a href="shared_pseudocode.html#ReduceOp" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM, ReduceOp_FMIN, ReduceOp_FMAX, ReduceOp_FADD, ReduceOp_ADD}"><del>ReduceOp</del></a><ins>;
    iswrite = boolean UNKNOWN;
    extflag = bit UNKNOWN;
    errortype = bits(2) UNKNOWN;
    secondstage = FALSE;
    s2fs1walk = FALSE;
</ins><del>op, bits(N) input, integer esize)
    integer half;
    bits(esize) hi;
    bits(esize) lo;
    bits(esize) result;
</del>
<ins>    return</ins><del>    if N == esize then
        return input&lt;esize-1:0>;

    half = N DIV 2;
    hi =</del> <a href="shared_pseudocode.html#AArch64.CreateFaultRecord.10" title="function: FaultRecord AArch64.CreateFaultRecord(Fault type, bits(52) ipaddress, bit NS, integer level, AccType acctype, boolean write, bit extflag, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><ins>AArch64.CreateFaultRecord</ins></a><a href="shared_pseudocode.html#impl-aarch64.Reduce.3" title="function: bits(esize) Reduce(ReduceOp op, bits(N) input, integer esize)"><del>Reduce</del></a><ins>(</ins><del>(op, input&lt;N-1:half>, esize);
    lo =</del><del>(op, input&lt;half-1:0>, esize);

    case op of
        when </del><a href="shared_pseudocode.html#ReduceOp_FMINNUM" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM, ReduceOp_FMIN, ReduceOp_FMAX, ReduceOp_FADD, ReduceOp_ADD}"><del>ReduceOp_FMINNUM</del></a><del>
            result = </del><a href="shared_pseudocode.html#impl-shared.FPMinNum.3" title="function: bits(N) FPMinNum(bits(N) op1, bits(N) op2, FPCRType fpcr)"><del>FPMinNum</del></a><del>(lo, hi, FPCR);
        when </del><a href="shared_pseudocode.html#ReduceOp_FMAXNUM" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM, ReduceOp_FMIN, ReduceOp_FMAX, ReduceOp_FADD, ReduceOp_ADD}"><del>ReduceOp_FMAXNUM</del></a><del>
            result = </del><a href="shared_pseudocode.html#impl-shared.FPMaxNum.3" title="function: bits(N) FPMaxNum(bits(N) op1, bits(N) op2, FPCRType fpcr)"><del>FPMaxNum</del></a><del>(lo, hi, FPCR);
        when </del><a href="shared_pseudocode.html#ReduceOp_FMIN" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM, ReduceOp_FMIN, ReduceOp_FMAX, ReduceOp_FADD, ReduceOp_ADD}"><del>ReduceOp_FMIN</del></a><del>
            result = </del><a href="shared_pseudocode.html#impl-shared.FPMin.3" title="function: bits(N) FPMin(bits(N) op1, bits(N) op2, FPCRType fpcr)"><del>FPMin</del></a><del>(lo, hi, FPCR);
        when </del><a href="shared_pseudocode.html#ReduceOp_FMAX" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM, ReduceOp_FMIN, ReduceOp_FMAX, ReduceOp_FADD, ReduceOp_ADD}"><del>ReduceOp_FMAX</del></a><del>
            result = </del><a href="shared_pseudocode.html#impl-shared.FPMax.3" title="function: bits(N) FPMax(bits(N) op1, bits(N) op2, FPCRType fpcr)"><del>FPMax</del></a><del>(lo, hi, FPCR);
        when </del><a href="shared_pseudocode.html#ReduceOp_FADD" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM, ReduceOp_FMIN, ReduceOp_FMAX, ReduceOp_FADD, ReduceOp_ADD}"><del>ReduceOp_FADD</del></a><del>
            result = </del><a href="shared_pseudocode.html#impl-shared.FPAdd.3" title="function: bits(N) FPAdd(bits(N) op1, bits(N) op2, FPCRType fpcr)"><del>FPAdd</del></a><del>(lo, hi, FPCR);
        when </del><a href="shared_pseudocode.html#ReduceOp_ADD" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM, ReduceOp_FMIN, ReduceOp_FMAX, ReduceOp_FADD, ReduceOp_ADD}"><del>ReduceOp_ADD</del></a><a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_None</ins></a><a href="shared_pseudocode.html#impl-aarch64.Reduce.3" title="function: bits(esize) Reduce(ReduceOp op, bits(N) input, integer esize)"><del>Reduce</del></a><ins>, ipaddress, bit UNKNOWN, level, acctype, iswrite,
                                     extflag, errortype, secondstage, s2fs1walk);</ins><del>result = lo + hi;

    return result;</del></p></div><div class="ps" psname="aarch64.translation.faults.AArch64.PermissionFault"><a id="aarch64.translation.faults.AArch64.PermissionFault" name="aarch64.translation.faults.AArch64.PermissionFault"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/<ins>translation</ins><del>instrs</del>/<ins>faults</ins><del>vector</del>/<ins>AArch64.PermissionFault</ins><del>reduce/reduceop/ReduceOp</del></h3><p class="pseudocode"><ins>// AArch64.PermissionFault()
// =========================

FaultRecord</ins><del>enumeration</del> <a id="AArch64.PermissionFault.7" name="AArch64.PermissionFault.7"></a><ins>AArch64.PermissionFault(bits(52) ipaddress,bit NS, integer level,</ins><del>ReduceOp {</del>
                                    <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a> <ins>acctype, boolean iswrite, boolean secondstage,
                                    boolean s2fs1walk)

    extflag = bit UNKNOWN;
    errortype = bits(2) UNKNOWN;
    return</ins><del>ReduceOp_FMINNUM,</del> <a href="shared_pseudocode.html#AArch64.CreateFaultRecord.10" title="function: FaultRecord AArch64.CreateFaultRecord(Fault type, bits(52) ipaddress, bit NS, integer level, AccType acctype, boolean write, bit extflag, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><ins>AArch64.CreateFaultRecord</ins></a><ins>(</ins><del>ReduceOp_FMAXNUM,</del><del>ReduceOp_FMIN, </del><a id="ReduceOp_FMAX" name="ReduceOp_FMAX"></a><del>ReduceOp_FMAX,
                      </del><a id="ReduceOp_FADD" name="ReduceOp_FADD"></a><del>ReduceOp_FADD, </del><a id="ReduceOp_ADD" name="ReduceOp_ADD"></a><a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_Permission</ins></a><ins>, ipaddress, NS, level, acctype, iswrite,
                                     extflag, errortype, secondstage, s2fs1walk);</ins><del>ReduceOp_ADD};</del></p></div><div class="ps" psname="aarch64.translation.faults.AArch64.TranslationFault"><a id="aarch64.translation.faults.AArch64.TranslationFault" name="aarch64.translation.faults.AArch64.TranslationFault"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/<ins>faults</ins><del>attrs</del>/<ins>AArch64.TranslationFault</ins><del>AArch64.InstructionDevice</del></h3><p class="pseudocode"><ins>// AArch64.TranslationFault()
// ==========================
</ins><del>// AArch64.InstructionDevice()
// ===========================
// Instruction fetches from memory marked as Device but not execute-never might generate a
// Permission Fault but are otherwise treated as if from Normal Non-cacheable memory.
</del>
<ins>FaultRecord</ins><del>AddressDescriptor</del> <a id="AArch64.TranslationFault.7" name="AArch64.TranslationFault.7"></a><ins>AArch64.TranslationFault(bits(52) ipaddress, bit NS, integer level,</ins><del>AArch64.InstructionDevice(</del>
                                     <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><del>AddressDescriptor</del></a><del> addrdesc, bits(64) vaddress,
                                            bits(52) ipaddress, integer level,
                                            </del><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType</a> acctype, boolean iswrite, boolean secondstage,
<ins>                                     boolean s2fs1walk)
</ins><del>                                            boolean s2fs1walk)
</del>
<ins>    extflag = bit UNKNOWN;
    errortype = bits(2) UNKNOWN;
    return</ins><del>    c =</del> <a href="shared_pseudocode.html#AArch64.CreateFaultRecord.10" title="function: FaultRecord AArch64.CreateFaultRecord(Fault type, bits(52) ipaddress, bit NS, integer level, AccType acctype, boolean write, bit extflag, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><ins>AArch64.CreateFaultRecord</ins></a><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><del>ConstrainUnpredictable</del></a>(<del>);
    assert c IN {</del><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_NONE</del></a><del>, </del><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FAULT</del></a><del>};

    if c == </del><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FAULT</del></a><del> then
        addrdesc.fault = </del><a href="shared_pseudocode.html#AArch64.PermissionFault.7" title="function: FaultRecord AArch64.PermissionFault(bits(52) ipaddress,bit NS, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><del>AArch64.PermissionFault</del></a><del>(ipaddress,bit UNKNOWN,  level, acctype, iswrite,
                                                 secondstage, s2fs1walk);
    else
        addrdesc.memattrs.type = </del><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Normal</del></a><del>;
        addrdesc.memattrs.inner.attrs = </del><a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'"><del>MemAttr_NC</del></a><del>;
        addrdesc.memattrs.inner.hints = </del><a href="shared_pseudocode.html#MemHint_No" title="constant bits(2) MemHint_No = '00'"><del>MemHint_No</del></a><del>;
        addrdesc.memattrs.outer = addrdesc.memattrs.inner;
        addrdesc.memattrs.tagged = FALSE;
        addrdesc.memattrs = </del><a href="shared_pseudocode.html#impl-shared.MemAttrDefaults.1" title="function: MemoryAttributes MemAttrDefaults(MemoryAttributes memattrs)"><del>MemAttrDefaults</del></a><a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_Translation</ins></a><a href="shared_pseudocode.html#Unpredictable_INSTRDEVICE" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_INSTRDEVICE</del></a><ins>, ipaddress, NS, level, acctype, iswrite,
                                     extflag, errortype, secondstage, s2fs1walk);</ins><del>(addrdesc.memattrs);

    return addrdesc;</del></p></div><div class="ps" psname="aarch64.translation.translation.AArch64.CheckAndUpdateDescriptor"><a id="aarch64.translation.translation.AArch64.CheckAndUpdateDescriptor" name="aarch64.translation.translation.AArch64.CheckAndUpdateDescriptor"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/<ins>translation</ins><del>attrs</del>/<ins>AArch64.CheckAndUpdateDescriptor</ins><del>AArch64.S1AttrDecode</del></h3><p class="pseudocode"><ins>// AArch64.CheckAndUpdateDescriptor()
// ==================================
// Check and update translation table descriptor if hardware update is configured
</ins><del>// AArch64.S1AttrDecode()
// ======================
// Converts the Stage 1 attribute fields, using the MAIR, to orthogonal
// attributes and hints.
</del>
<ins>FaultRecord</ins><del>MemoryAttributes</del> <a id="AArch64.CheckAndUpdateDescriptor.8" name="AArch64.CheckAndUpdateDescriptor.8"></a><ins>AArch64.CheckAndUpdateDescriptor(</ins><del>AArch64.S1AttrDecode(bits(2) SH, bits(3) attr,</del><a href="shared_pseudocode.html#DescriptorUpdate" title="type DescriptorUpdate is ( boolean AF, boolean AP, AddressDescriptor descaddr )"><ins>DescriptorUpdate</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a> <ins>result,</ins><del>acctype)</del> <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><ins>FaultRecord</ins></a><a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType type, DeviceType device, MemAttrHints inner, MemAttrHints outer, boolean tagged, boolean shareable, boolean outershareable )"><del>MemoryAttributes</del></a> <ins>fault,
                                             boolean secondstage, bits(64) vaddress,</ins><del>memattrs;

    mair =</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><a href="shared_pseudocode.html#impl-aarch64.MAIR.read.0" title="accessor: MAIRType MAIR[]"><del>MAIR</del></a> <ins>acctype,
                                             boolean iswrite, boolean s2fs1walk, boolean hwupdatewalk)

    // Check if access flag can be updated
    // Address translation instructions are permitted to update AF but not required
    if result.AF then
        if fault.type ==</ins><del>[];
    index = 8 *</del> <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_None</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a> <ins>then
            hw_update_AF = TRUE;
        elsif</ins><del>(attr);
    attrfield = mair&lt;index+7:index>;

    memattrs.tagged = FALSE;
    if ((attrfield&lt;7:4> != '0000' &amp;&amp; attrfield&lt;7:4> != '1111' &amp;&amp; attrfield&lt;3:0> == '0000') ||
        (attrfield&lt;7:4> == '0000' &amp;&amp; attrfield&lt;3:0> != 'xx00')) then
        // Reserved, maps to an allocated value
        (-, attrfield) =</del> <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><ins>ConstrainUnpredictable</ins></a><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)"><del>ConstrainUnpredictableBits</del></a>(<a href="shared_pseudocode.html#Unpredictable_AFUPDATE" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_AFUPDATE</ins></a><a href="shared_pseudocode.html#Unpredictable_RESMAIR" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESMAIR</del></a><ins>) ==</ins><del>);
    if !</del> <a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_TRUE</ins></a><a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()"><del>HaveMTEExt</del></a> <ins>then
            hw_update_AF = TRUE;
        else
            hw_update_AF = FALSE;

    if result.AP &amp;&amp; fault.type ==</ins><del>() &amp;&amp; attrfield&lt;7:4> == '1111' &amp;&amp; attrfield&lt;3:0> == '0000' then
        // Reserved, maps to an allocated value
        (-, attrfield) =</del> <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_None</ins></a><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)"><del>ConstrainUnpredictableBits</del></a> <ins>then
        write_perm_req = (iswrite || acctype IN {</ins><del>(</del><a href="shared_pseudocode.html#AccType_ATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ATOMICRW</ins></a><a href="shared_pseudocode.html#Unpredictable_RESMAIR" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESMAIR</del></a><ins>,</ins><del>);

    if attrfield&lt;7:4> == '0000' then            // Device
        memattrs.type =</del><a href="shared_pseudocode.html#AccType_ORDEREDRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ORDEREDRW</ins></a><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Device</del></a><ins>,</ins><del>;
        case attrfield&lt;3:0> of
            when '0000'  memattrs.device =</del> <a href="shared_pseudocode.html#AccType_ORDEREDATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ORDEREDATOMICRW</ins></a><a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType_nGnRnE</del></a> <ins>}) &amp;&amp; !s2fs1walk;
        hw_update_AP = (write_perm_req &amp;&amp; !(acctype IN {</ins><del>;
            when '0100'  memattrs.device =</del><a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_AT</ins></a><a href="shared_pseudocode.html#DeviceType_nGnRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType_nGnRE</del></a><ins>,</ins><del>;
            when '1000'  memattrs.device =</del> <a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_DC</ins></a><a href="shared_pseudocode.html#DeviceType_nGRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType_nGRE</del></a><ins>,</ins><del>;
            when '1100'  memattrs.device =</del> <a href="shared_pseudocode.html#AccType_DC_UNPRIV" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_DC_UNPRIV</ins></a><a href="shared_pseudocode.html#DeviceType_GRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType_GRE</del></a><ins>})) || hwupdatewalk;
    else
        hw_update_AP = FALSE;

    if hw_update_AF || hw_update_AP then
        if secondstage || !</ins><del>;
            otherwise</del><a href="shared_pseudocode.html#impl-shared.HasS2Translation.0" title="function: boolean HasS2Translation()"><ins>HasS2Translation</ins></a><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><del>Unreachable</del></a><ins>() then
            descaddr2 = result.descaddr;
        else
            hwupdatewalk = TRUE;
            descaddr2 =</ins><del>();         // Reserved, handled above

    elsif attrfield&lt;3:0> != '0000'  then        // Normal
        memattrs.type =</del> <a href="shared_pseudocode.html#AArch64.SecondStageWalk.6" title="function: AddressDescriptor AArch64.SecondStageWalk(AddressDescriptor S1, bits(64) vaddress, AccType acctype, boolean iswrite, integer size, boolean hwupdatewalk)"><ins>AArch64.SecondStageWalk</ins></a><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Normal</del></a><ins>(result.descaddr, vaddress, acctype, iswrite, 8, hwupdatewalk);
            if</ins><del>;
        memattrs.outer =</del> <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><a href="shared_pseudocode.html#impl-shared.LongConvertAttrsHints.2" title="function: MemAttrHints LongConvertAttrsHints(bits(4) attrfield, AccType acctype)"><del>LongConvertAttrsHints</del></a><ins>(descaddr2) then
                return descaddr2.fault;

        accdesc = CreateAccessDescriptor(</ins><del>(attrfield&lt;7:4>, acctype);
        memattrs.inner =</del><a href="shared_pseudocode.html#AccType_ATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_ATOMICRW</ins></a><a href="shared_pseudocode.html#impl-shared.LongConvertAttrsHints.2" title="function: MemAttrHints LongConvertAttrsHints(bits(4) attrfield, AccType acctype)"><del>LongConvertAttrsHints</del></a><ins>);
        desc = _Mem[descaddr2, 8, accdesc];
        el =</ins><del>(attrfield&lt;3:0>, acctype);
        memattrs.shareable = SH&lt;1> == '1';
        memattrs.outershareable = SH == '10';
    elsif</del> <a href="shared_pseudocode.html#AArch64.AccessUsesEL.1" title="function: bits(2) AArch64.AccessUsesEL(AccType acctype)"><ins>AArch64.AccessUsesEL</ins></a><a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()"><del>HaveMTEExt</del></a><ins>(acctype);
        case el of
            when</ins><del>() &amp;&amp; attrfield == '11110000' then // Tagged, Normal
        memattrs.tagged = TRUE;
        memattrs.type =</del> <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Normal</del></a>
                <ins>reversedescriptors = SCTLR_EL3.EE == '1';
            when</ins><del>;
        memattrs.outer.attrs =</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'"><del>MemAttr_WB</del></a>
                <ins>reversedescriptors = SCTLR_EL2.EE == '1';
            otherwise
                reversedescriptors = SCTLR_EL1.EE == '1';
        if reversedescriptors then
            desc =</ins><del>;
        memattrs.inner.attrs =</del> <a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)"><ins>BigEndianReverse</ins></a><a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'"><del>MemAttr_WB</del></a><ins>(desc);

        if hw_update_AF then
            desc&lt;10> = '1';
        if hw_update_AP then
            desc&lt;7> = (if secondstage then '1' else '0');

        _Mem[descaddr2,8,accdesc] = if reversedescriptors then</ins><del>;
        memattrs.outer.hints =</del> <del>;
        memattrs.inner.hints = </del><a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'"><del>MemHint_RWA</del></a><del>;
        memattrs.shareable = SH&lt;1> == '1';
        memattrs.outershareable = SH == '10';
    else
        </del><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><del>Unreachable</del></a><del>();                          // Reserved, handled above

    return </del><a href="shared_pseudocode.html#impl-shared.MemAttrDefaults.1" title="function: MemoryAttributes MemAttrDefaults(MemoryAttributes memattrs)"><del>MemAttrDefaults</del></a><a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)"><ins>BigEndianReverse</ins></a><a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'"><del>MemHint_RWA</del></a><ins>(desc) else desc;

    return fault;</ins><del>(memattrs);</del></p></div><div class="ps" psname="aarch64.translation.translation.AArch64.FirstStageTranslate"><a id="aarch64.translation.translation.AArch64.FirstStageTranslate" name="aarch64.translation.translation.AArch64.FirstStageTranslate"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/<ins>translation</ins><del>attrs</del>/<ins>AArch64.FirstStageTranslate</ins><del>AArch64.TranslateAddressS1Off</del></h3><p class="pseudocode"><ins>// AArch64.FirstStageTranslate()
// =============================
// Perform a stage 1 translation walk. The function used by Address Translation operations is
// similar except it uses the translation regime specified for the instruction.
</ins><del>// AArch64.TranslateAddressS1Off()
// ===============================
// Called for stage 1 translations when translation is disabled to supply a default translation.
// Note that there are additional constraints on instruction prefetching that are not described in
// this pseudocode.
</del>
<ins>AddressDescriptor</ins><del>TLBRecord</del> <a id="AArch64.FirstStageTranslate.5" name="AArch64.FirstStageTranslate.5"></a><ins>AArch64.FirstStageTranslate(bits(64) vaddress,</ins><del>AArch64.TranslateAddressS1Off(bits(64) vaddress,</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType</a> <ins>acctype, boolean iswrite,
                                              boolean wasaligned, integer size)

    if</ins><del>acctype, boolean iswrite)
    assert !</del> <a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()"><ins>HaveNV2Ext</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><ins>() &amp;&amp; acctype ==</ins><del>(</del> <a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NV2REGISTER</ins></a><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a> <ins>then
        s1_enabled = SCTLR_EL2.M == '1';
    elsif</ins><del>());</del> <a href="shared_pseudocode.html#impl-shared.HasS2Translation.0" title="function: boolean HasS2Translation()"><ins>HasS2Translation</ins></a><a href="shared_pseudocode.html#TLBRecord" title="type TLBRecord is ( Permissions perms, bit nG, bits(4) domain, bit GP, boolean contiguous, integer level, integer blocksize, DescriptorUpdate descupdate, bit CnP, AddressDescriptor addrdesc )"><del>TLBRecord</del></a><ins>() then
        s1_enabled = HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.DC == '0' &amp;&amp; SCTLR_EL1.M == '1';
    else
        s1_enabled =</ins><del>result;

    Top =</del> <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><ins>SCTLR</ins></a><a href="shared_pseudocode.html#impl-shared.AddrTop.3" title="function: integer AddrTop(bits(64) address, boolean IsInstr, bits(2) el)"><del>AddrTop</del></a><ins>[].M == '1';

    ipaddress = bits(52) UNKNOWN;
    secondstage = FALSE;
    s2fs1walk = FALSE;

    if s1_enabled then                         // First stage enabled
        S1 =</ins><del>(vaddress, (acctype ==</del> <a href="shared_pseudocode.html#AArch64.TranslationTableWalk.8" title="function: TLBRecord AArch64.TranslationTableWalk(bits(52) ipaddress, bit s1_nonsecure, bits(64) vaddress, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk, integer size)"><ins>AArch64.TranslationTableWalk</ins></a><ins>(ipaddress, '1', vaddress, acctype, iswrite, secondstage,
                                            s2fs1walk, size);
        permissioncheck = TRUE;
        if acctype == </ins><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType_IFETCH</a> <ins>then
            InGuardedPage = S1.GP == '1';      // Global state updated on instruction fetch that denotes
                                               // if the fetched instruction is from a guarded page.
    else
        S1 =</ins><del>), PSTATE.EL);
    if !</del> <a href="shared_pseudocode.html#AArch64.TranslateAddressS1Off.3" title="function: TLBRecord AArch64.TranslateAddressS1Off(bits(64) vaddress, AccType acctype, boolean iswrite)"><ins>AArch64.TranslateAddressS1Off</ins></a><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><ins>(vaddress, acctype, iswrite);
        permissioncheck = FALSE;
        if</ins><del>(vaddress&lt;Top:</del> <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><a href="shared_pseudocode.html#impl-shared.PAMax.0" title="function: integer PAMax()"><del>PAMax</del></a><ins>() &amp;&amp;</ins><del>()>) then
        level = 0;
        ipaddress = bits(52) UNKNOWN;
        secondstage = FALSE;
        s2fs1walk = FALSE;
        result.addrdesc.fault =</del> <a href="shared_pseudocode.html#impl-shared.HaveTrapLoadStoreMultipleDeviceExt.0" title="function: boolean HaveTrapLoadStoreMultipleDeviceExt()"><ins>HaveTrapLoadStoreMultipleDeviceExt</ins></a><a href="shared_pseudocode.html#AArch64.AddressSizeFault.7" title="function: FaultRecord AArch64.AddressSizeFault(bits(52) ipaddress,bit NS, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><del>AArch64.AddressSizeFault</del></a><ins>() &amp;&amp;</ins><del>(ipaddress,bit UNKNOWN,  level, acctype,
                                                         iswrite, secondstage, s2fs1walk);
        return result;

    default_cacheable = (</del> <a href="shared_pseudocode.html#AArch32.ExecutingLSMInstr.0" title="function: boolean AArch32.ExecutingLSMInstr()"><ins>AArch32.ExecutingLSMInstr</ins></a><a href="shared_pseudocode.html#impl-shared.HasS2Translation.0" title="function: boolean HasS2Translation()"><del>HasS2Translation</del></a><ins>() then
            if S1.addrdesc.memattrs.type ==</ins><del>() &amp;&amp; HCR_EL2.DC == '1');

    if default_cacheable then
        // Use default cacheable settings
        result.addrdesc.memattrs.type =</del> <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Device</ins></a><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Normal</del></a> <ins>&amp;&amp; S1.addrdesc.memattrs.device !=</ins><del>;
        result.addrdesc.memattrs.inner.attrs =</del> <a href="shared_pseudocode.html#DeviceType_GRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType_GRE</ins></a><a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'"><del>MemAttr_WB</del></a> <ins>then
                nTLSMD = if</ins><del>;      // Write-back
        result.addrdesc.memattrs.inner.hints =</del> <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'"><del>MemHint_RWA</del></a><ins>() ==</ins><del>;
        result.addrdesc.memattrs.shareable = FALSE;
        result.addrdesc.memattrs.outershareable = FALSE;
        result.addrdesc.memattrs.tagged = HCR_EL2.DCT == '1';
    elsif acctype !=</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IFETCH</del></a> <ins>then SCTLR_EL2.nTLSMD else SCTLR_EL1.nTLSMD;
                if nTLSMD == '0' then
                    S1.addrdesc.fault =</ins><del>then
        // Treat data as Device
        result.addrdesc.memattrs.type =</del> <a href="shared_pseudocode.html#AArch64.AlignmentFault.3" title="function: FaultRecord AArch64.AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)"><ins>AArch64.AlignmentFault</ins></a><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Device</del></a><ins>(acctype, iswrite, secondstage);

    // Check for unaligned data accesses to Device memory
    if ((!wasaligned &amp;&amp; acctype !=</ins><del>;
        result.addrdesc.memattrs.device =</del> <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType_nGnRnE</del></a><ins>) || (acctype ==</ins><del>;
        result.addrdesc.memattrs.inner =</del> <a href="shared_pseudocode.html#AccType_DCZVA" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_DCZVA</ins></a><a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )"><del>MemAttrHints</del></a><ins>))
        &amp;&amp; S1.addrdesc.memattrs.type ==</ins><del>UNKNOWN;
        result.addrdesc.memattrs.tagged = FALSE;
    else
        // Instruction cacheability controlled by SCTLR_ELx.I
        cacheable =</del> <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Device</ins></a><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><del>SCTLR</del></a> <ins>&amp;&amp; !</ins><del>[].I == '1';
        result.addrdesc.memattrs.type =</del><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Normal</del></a><ins>(S1.addrdesc) then
        S1.addrdesc.fault =</ins><del>;
        if cacheable then
            result.addrdesc.memattrs.inner.attrs =</del> <a href="shared_pseudocode.html#AArch64.AlignmentFault.3" title="function: FaultRecord AArch64.AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)"><ins>AArch64.AlignmentFault</ins></a><a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'"><del>MemAttr_WT</del></a><ins>(acctype, iswrite, secondstage);
    if !</ins><del>;
            result.addrdesc.memattrs.inner.hints =</del><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><a href="shared_pseudocode.html#MemHint_RA" title="constant bits(2) MemHint_RA = '10'"><del>MemHint_RA</del></a><ins>(S1.addrdesc) &amp;&amp; permissioncheck then
        S1.addrdesc.fault =</ins><del>;
        else
            result.addrdesc.memattrs.inner.attrs =</del> <a href="shared_pseudocode.html#AArch64.CheckPermission.6" title="function: FaultRecord AArch64.CheckPermission(Permissions perms, bits(64) vaddress, integer level, bit NS, AccType acctype, boolean iswrite)"><ins>AArch64.CheckPermission</ins></a><a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'"><del>MemAttr_NC</del></a><ins>(S1.perms, vaddress, S1.level,
                                                    S1.addrdesc.paddress.NS,
                                                    acctype, iswrite);

    // Check for instruction fetches from Device memory not marked as execute-never. If there has
    // not been a Permission Fault then the memory is not marked execute-never.
    if (!</ins><del>;
            result.addrdesc.memattrs.inner.hints =</del><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><a href="shared_pseudocode.html#MemHint_No" title="constant bits(2) MemHint_No = '00'"><del>MemHint_No</del></a><ins>(S1.addrdesc) &amp;&amp; S1.addrdesc.memattrs.type ==</ins><del>;
        result.addrdesc.memattrs.shareable = TRUE;
        result.addrdesc.memattrs.outershareable = TRUE;
        result.addrdesc.memattrs.tagged = FALSE;

    result.addrdesc.memattrs.outer = result.addrdesc.memattrs.inner;

    result.addrdesc.memattrs =</del> <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Device</ins></a><a href="shared_pseudocode.html#impl-shared.MemAttrDefaults.1" title="function: MemoryAttributes MemAttrDefaults(MemoryAttributes memattrs)"><del>MemAttrDefaults</del></a> <ins>&amp;&amp;
        acctype ==</ins><del>(result.addrdesc.memattrs);

    result.perms.ap = bits(3) UNKNOWN;
    result.perms.xn = '0';
    result.perms.pxn = '0';

    result.nG = bit UNKNOWN;
    result.contiguous = boolean UNKNOWN;
    result.domain = bits(4) UNKNOWN;
    result.level = integer UNKNOWN;
    result.blocksize = integer UNKNOWN;
    result.addrdesc.paddress.address = vaddress&lt;51:0>;
    result.addrdesc.paddress.NS = if</del> <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><ins>) then
        S1.addrdesc =</ins><del>() then '0' else '1';
    result.addrdesc.fault =</del> <a href="shared_pseudocode.html#AArch64.InstructionDevice.8" title="function: AddressDescriptor AArch64.InstructionDevice(AddressDescriptor addrdesc, bits(64) vaddress, bits(52) ipaddress, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><ins>AArch64.InstructionDevice</ins></a><a href="shared_pseudocode.html#AArch64.NoFault.0" title="function: FaultRecord AArch64.NoFault()"><del>AArch64.NoFault</del></a><ins>(S1.addrdesc, vaddress, ipaddress, S1.level,
                                                acctype, iswrite,
                                                secondstage, s2fs1walk);
    // Check and update translation table descriptor if required
    hwupdatewalk = FALSE;
    s2fs1walk = FALSE;
    S1.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch64.CheckAndUpdateDescriptor.8" title="function: FaultRecord AArch64.CheckAndUpdateDescriptor(DescriptorUpdate result, FaultRecord fault, boolean secondstage, bits(64) vaddress, AccType acctype, boolean iswrite, boolean s2fs1walk, boolean hwupdatewalk)"><ins>AArch64.CheckAndUpdateDescriptor</ins></a><ins>(S1.descupdate, S1.addrdesc.fault,
                                                         secondstage, vaddress, acctype,
                                                         iswrite, s2fs1walk, hwupdatewalk);

    return S1.addrdesc;</ins><del>();
    return result;</del></p></div><div class="ps" psname="aarch64.translation.translation.AArch64.FullTranslate"><a id="aarch64.translation.translation.AArch64.FullTranslate" name="aarch64.translation.translation.AArch64.FullTranslate"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/<ins>translation</ins><del>checks</del>/<ins>AArch64.FullTranslate</ins><del>AArch64.AccessIsPrivileged</del></h3><p class="pseudocode"><ins>// AArch64.FullTranslate()
// =======================
// Perform both stage 1 and stage 2 translation walks for the current translation regime. The
// function used by Address Translation operations is similar except it uses the translation
// regime specified for the instruction.
</ins><del>// AArch64.AccessIsPrivileged()
// ============================
</del>
<ins>AddressDescriptor</ins><del>boolean</del> <a id="AArch64.FullTranslate.5" name="AArch64.FullTranslate.5"></a><ins>AArch64.FullTranslate(bits(64) vaddress,</ins><del>AArch64.AccessIsPrivileged(</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType</a> <ins>acctype, boolean iswrite,
                                        boolean wasaligned, integer size)
</ins><del>acctype)
</del>
<ins>    // First Stage Translation
    S1 =</ins><del>    el =</del> <a href="shared_pseudocode.html#AArch64.FirstStageTranslate.5" title="function: AddressDescriptor AArch64.FirstStageTranslate(bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><ins>AArch64.FirstStageTranslate</ins></a><a href="shared_pseudocode.html#AArch64.AccessUsesEL.1" title="function: bits(2) AArch64.AccessUsesEL(AccType acctype)"><del>AArch64.AccessUsesEL</del></a><ins>(vaddress, acctype, iswrite, wasaligned, size);
    if !</ins><del>(acctype);

    if el ==</del><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>(S1) &amp;&amp; !(</ins><del>then
        ispriv = FALSE;
    elsif el ==</del><a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()"><ins>HaveNV2Ext</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><ins>() &amp;&amp; acctype ==</ins><del>then
        ispriv = TRUE;
    elsif el ==</del> <a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NV2REGISTER</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>) &amp;&amp;</ins><del>&amp;&amp; (!</del> <a href="shared_pseudocode.html#impl-shared.HasS2Translation.0" title="function: boolean HasS2Translation()"><ins>HasS2Translation</ins></a><a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><del>IsInHost</del></a><ins>() then
        s2fs1walk = FALSE;
        hwupdatewalk = FALSE;
        result =</ins><del>() || HCR_EL2.TGE == '0') then
        ispriv = TRUE;
    elsif</del> <del>() &amp;&amp; PSTATE.UAO == '1' then
        ispriv = TRUE;
    else
        ispriv = (acctype != </del><a href="shared_pseudocode.html#AccType_UNPRIV" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_UNPRIV</del></a><a href="shared_pseudocode.html#AArch64.SecondStageTranslate.8" title="function: AddressDescriptor AArch64.SecondStageTranslate(AddressDescriptor S1, bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, boolean s2fs1walk, integer size, boolean hwupdatewalk)"><ins>AArch64.SecondStageTranslate</ins></a><a href="shared_pseudocode.html#impl-shared.HaveUAOExt.0" title="function: boolean HaveUAOExt()"><del>HaveUAOExt</del></a><ins>(S1, vaddress, acctype, iswrite, wasaligned, s2fs1walk,
                                              size, hwupdatewalk);
    else
        result = S1;
</ins><del>);
</del>
<ins>    return result;</ins><del>    return ispriv;</del></p></div><div class="ps" psname="aarch64.translation.translation.AArch64.SecondStageTranslate"><a id="aarch64.translation.translation.AArch64.SecondStageTranslate" name="aarch64.translation.translation.AArch64.SecondStageTranslate"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/<ins>translation</ins><del>checks</del>/<ins>AArch64.SecondStageTranslate</ins><del>AArch64.AccessUsesEL</del></h3><p class="pseudocode"><ins>// AArch64.SecondStageTranslate()
// ==============================
// Perform a stage 2 translation walk. The function used by Address Translation operations is
// similar except it uses the translation regime specified for the instruction.
</ins><del>// AArch64.AccessUsesEL()
// ======================
// Returns the Exception Level of the regime that will manage the translation for a given access type.
</del>
<ins>AddressDescriptor</ins><del>bits(2)</del> <a id="AArch64.SecondStageTranslate.8" name="AArch64.SecondStageTranslate.8"></a><ins>AArch64.SecondStageTranslate(</ins><del>AArch64.AccessUsesEL(</del><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><ins>AddressDescriptor</ins></a><ins> S1, bits(64) vaddress,
                                               </ins><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType</a> <ins>acctype, boolean iswrite, boolean wasaligned,
                                               boolean s2fs1walk, integer size, boolean hwupdatewalk)
    assert</ins><del>acctype)
    if acctype ==</del> <a href="shared_pseudocode.html#impl-shared.HasS2Translation.0" title="function: boolean HasS2Translation()"><ins>HasS2Translation</ins></a><a href="shared_pseudocode.html#AccType_UNPRIV" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_UNPRIV</del></a><ins>();

    s2_enabled = HCR_EL2.VM == '1' || HCR_EL2.DC == '1';
    secondstage = TRUE;

    if s2_enabled then                        // Second stage enabled
        ipaddress = S1.paddress.address&lt;51:0>;
        NS = S1.paddress.NS;
        S2 =</ins><del>then
        return</del> <a href="shared_pseudocode.html#AArch64.TranslationTableWalk.8" title="function: TLBRecord AArch64.TranslationTableWalk(bits(52) ipaddress, bit s1_nonsecure, bits(64) vaddress, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk, integer size)"><ins>AArch64.TranslationTableWalk</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>(ipaddress, NS, vaddress, acctype, iswrite, secondstage,
                                            s2fs1walk, size);

        // Check for unaligned data accesses to Device memory
        if ((!wasaligned &amp;&amp; acctype !=</ins><del>;
    elsif acctype ==</del> <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NV2REGISTER</del></a><ins>) || (acctype ==</ins><del>then
        return</del> <a href="shared_pseudocode.html#AccType_DCZVA" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_DCZVA</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>))
            &amp;&amp; S2.addrdesc.memattrs.type == </ins><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Device</ins></a><ins> &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><ins>(S2.addrdesc) then
            S2.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch64.AlignmentFault.3" title="function: FaultRecord AArch64.AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)"><ins>AArch64.AlignmentFault</ins></a><ins>(acctype, iswrite, secondstage);

        // Check for permissions on Stage2 translations
        if !</ins><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><ins>(S2.addrdesc) then
            S2.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch64.CheckS2Permission.9" title="function: FaultRecord AArch64.CheckS2Permission(Permissions perms, bits(64) vaddress, bits(52) ipaddress, integer level, AccType acctype, boolean iswrite, bit NS, boolean s2fs1walk, boolean hwupdatewalk)"><ins>AArch64.CheckS2Permission</ins></a><ins>(S2.perms, vaddress, ipaddress, S2.level,
                                                          acctype, iswrite, NS,s2fs1walk, hwupdatewalk);

        // Check for instruction fetches from Device memory not marked as execute-never. As there
        // has not been a Permission Fault then the memory is not marked execute-never.
        if (!s2fs1walk &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><ins>(S2.addrdesc) &amp;&amp; S2.addrdesc.memattrs.type == </ins><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Device</ins></a><ins> &amp;&amp;
            acctype == </ins><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><ins>) then
            S2.addrdesc = </ins><a href="shared_pseudocode.html#AArch64.InstructionDevice.8" title="function: AddressDescriptor AArch64.InstructionDevice(AddressDescriptor addrdesc, bits(64) vaddress, bits(52) ipaddress, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><ins>AArch64.InstructionDevice</ins></a><ins>(S2.addrdesc, vaddress, ipaddress, S2.level,
                                                    acctype, iswrite,
                                                    secondstage, s2fs1walk);

        // Check for protected table walk
        if (s2fs1walk &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><ins>(S2.addrdesc) &amp;&amp; HCR_EL2.PTW == '1' &amp;&amp;
            S2.addrdesc.memattrs.type == </ins><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Device</ins></a><ins>) then
            S2.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch64.PermissionFault.7" title="function: FaultRecord AArch64.PermissionFault(bits(52) ipaddress,bit NS, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><ins>AArch64.PermissionFault</ins></a><ins>(ipaddress, S1.paddress.NS,  S2.level, acctype,
                                                        iswrite, secondstage, s2fs1walk);

        // Check and update translation table descriptor if required
        S2.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch64.CheckAndUpdateDescriptor.8" title="function: FaultRecord AArch64.CheckAndUpdateDescriptor(DescriptorUpdate result, FaultRecord fault, boolean secondstage, bits(64) vaddress, AccType acctype, boolean iswrite, boolean s2fs1walk, boolean hwupdatewalk)"><ins>AArch64.CheckAndUpdateDescriptor</ins></a><ins>(S2.descupdate, S2.addrdesc.fault,
                                                             secondstage, vaddress, acctype,
                                                             iswrite, s2fs1walk, hwupdatewalk);
        result = </ins><a href="shared_pseudocode.html#impl-shared.CombineS1S2Desc.2" title="function: AddressDescriptor CombineS1S2Desc(AddressDescriptor s1desc, AddressDescriptor s2desc)"><ins>CombineS1S2Desc</ins></a><ins>(S1, S2.addrdesc);
</ins><del>;
</del>    else
<ins>        result = S1;

    return result;</ins><del>        return PSTATE.EL;</del></p></div><div class="ps" psname="aarch64.translation.translation.AArch64.SecondStageWalk"><a id="aarch64.translation.translation.AArch64.SecondStageWalk" name="aarch64.translation.translation.AArch64.SecondStageWalk"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/<ins>translation</ins><del>checks</del>/<ins>AArch64.SecondStageWalk</ins><del>AArch64.CheckPermission</del></h3><p class="pseudocode"><ins>// AArch64.SecondStageWalk()
</ins><del>// AArch64.CheckPermission()
</del>// =========================
<ins>// Perform a stage 2 translation on a stage 1 translation page table walk access.
</ins><del>// Function used for permission checking from AArch64 stage 1 translations
</del>
<ins>AddressDescriptor</ins><del>FaultRecord</del> <a id="AArch64.SecondStageWalk.6" name="AArch64.SecondStageWalk.6"></a><ins>AArch64.SecondStageWalk(</ins><del>AArch64.CheckPermission(</del><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><ins>AddressDescriptor</ins></a><a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(3) ap, bit xn, bit xxn, bit pxn )"><del>Permissions</del></a> <ins>S1, bits(64) vaddress,</ins><del>perms, bits(64) vaddress, integer level,
                                    bit NS,</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType</a> <ins>acctype,
                                          boolean iswrite, integer size, boolean hwupdatewalk)

    assert</ins><del>acctype, boolean iswrite)
    assert !</del> <a href="shared_pseudocode.html#impl-shared.HasS2Translation.0" title="function: boolean HasS2Translation()"><ins>HasS2Translation</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><ins>();

    s2fs1walk = TRUE;
    wasaligned = TRUE;
    return</ins><del>(</del> <del>());

    wxn = </del><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><del>SCTLR</del></a><del>[].WXN == '1';

    if (PSTATE.EL == </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del> ||
        </del><a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><del>IsInHost</del></a><del>() ||
        (PSTATE.EL == </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del> &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()"><del>HaveNV2Ext</del></a><del>()) ||
        (PSTATE.EL == </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del> &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()"><del>HaveNV2Ext</del></a><del>() &amp;&amp; (acctype != </del><a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NV2REGISTER</del></a><del> || !</del><a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)"><del>ELIsInHost</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>)))) then
        priv_r = TRUE;
        priv_w = perms.ap&lt;2> == '0';
        user_r = perms.ap&lt;1> == '1';
        user_w = perms.ap&lt;2:1> == '01';

        ispriv = </del><a href="shared_pseudocode.html#AArch64.AccessIsPrivileged.1" title="function: boolean AArch64.AccessIsPrivileged(AccType acctype)"><del>AArch64.AccessIsPrivileged</del></a><del>(acctype);

        pan = if </del><a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()"><del>HavePANExt</del></a><del>() then PSTATE.PAN else '0';
        if (</del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; ((PSTATE.EL == </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del> &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.HaveNVExt.0" title="function: boolean HaveNVExt()"><del>HaveNVExt</del></a><del>() &amp;&amp; HCR_EL2.&lt;NV, NV1> == '11') ||
            (</del><a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()"><del>HaveNV2Ext</del></a><del>() &amp;&amp; acctype == </del><a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NV2REGISTER</del></a><del> &amp;&amp; HCR_EL2.NV2 == '1'))) then
            pan = '0';
        is_ldst   = !(acctype IN {</del><a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_DC</del></a><del>, </del><a href="shared_pseudocode.html#AccType_DC_UNPRIV" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_DC_UNPRIV</del></a><del>, </del><a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_AT</del></a><del>, </del><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IFETCH</del></a><del>});
        is_ats1xp = (acctype == </del><a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_AT</del></a><del> &amp;&amp; </del><a href="shared_pseudocode.html#AArch64.ExecutingATS1xPInstr.0" title="function: boolean AArch64.ExecutingATS1xPInstr()"><del>AArch64.ExecutingATS1xPInstr</del></a><del>());
        if pan == '1' &amp;&amp; user_r &amp;&amp; ispriv &amp;&amp; (is_ldst || is_ats1xp) then
            priv_r = FALSE;
            priv_w = FALSE;

        user_xn = perms.xn == '1' || (user_w &amp;&amp; wxn);
        priv_xn = perms.pxn == '1' || (priv_w &amp;&amp; wxn) || user_w;

        if ispriv then
            (r, w, xn) = (priv_r, priv_w, priv_xn);
        else
            (r, w, xn) = (user_r, user_w, user_xn);
    else
        // Access from EL2 or EL3
        r = TRUE;
        w = perms.ap&lt;2> == '0';
        xn = perms.xn == '1' || (w &amp;&amp; wxn);

    // Restriction on Secure instruction fetch
    if </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>() &amp;&amp; NS == '1' &amp;&amp; SCR_EL3.SIF == '1' then
        xn = TRUE;

    if acctype == </del><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IFETCH</del></a><del> then
        fail = xn;
        failedread = TRUE;
    elsif acctype IN { </del><a href="shared_pseudocode.html#AccType_ATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ATOMICRW</del></a><del>, </del><a href="shared_pseudocode.html#AccType_ORDEREDRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ORDEREDRW</del></a><del>, </del><a href="shared_pseudocode.html#AccType_ORDEREDATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ORDEREDATOMICRW</del></a><del> } then
        fail = !r || !w;
        failedread = !r;
    elsif iswrite then
        fail = !w;
        failedread = FALSE;
    elsif acctype == </del><a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_DC</del></a><del> &amp;&amp; PSTATE.EL != </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del> then
        // DC maintenance instructions operating by VA, cannot fault from stage 1 translation,
        // other than DC IVAC, which requires write permission, and operations executed at EL0,
        // which require read permission.
        fail = FALSE;
    else
        fail = !r;
        failedread = TRUE;

    if fail then
        secondstage = FALSE;
        s2fs1walk = FALSE;
        ipaddress = bits(52) UNKNOWN;
        return </del><a href="shared_pseudocode.html#AArch64.PermissionFault.7" title="function: FaultRecord AArch64.PermissionFault(bits(52) ipaddress,bit NS, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><del>AArch64.PermissionFault</del></a><del>(ipaddress,bit UNKNOWN,  level, acctype,
                                       !failedread, secondstage, s2fs1walk);
    else
        return </del><a href="shared_pseudocode.html#AArch64.NoFault.0" title="function: FaultRecord AArch64.NoFault()"><del>AArch64.NoFault</del></a><a href="shared_pseudocode.html#AArch64.SecondStageTranslate.8" title="function: AddressDescriptor AArch64.SecondStageTranslate(AddressDescriptor S1, bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, boolean s2fs1walk, integer size, boolean hwupdatewalk)"><ins>AArch64.SecondStageTranslate</ins></a><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><ins>(S1, vaddress, acctype, iswrite, wasaligned, s2fs1walk,
                                        size, hwupdatewalk);</ins><del>();</del></p></div><div class="ps" psname="aarch64.translation.translation.AArch64.TranslateAddress"><a id="aarch64.translation.translation.AArch64.TranslateAddress" name="aarch64.translation.translation.AArch64.TranslateAddress"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/<ins>translation</ins><del>checks</del>/<ins>AArch64.TranslateAddress</ins><del>AArch64.CheckS2Permission</del></h3><p class="pseudocode"><ins>// AArch64.TranslateAddress()
// ==========================
// Main entry point for translating an address
</ins><del>// AArch64.CheckS2Permission()
// ===========================
// Function used for permission checking from AArch64 stage 2 translations
</del>
<ins>AddressDescriptor</ins><del>FaultRecord</del> <a id="AArch64.TranslateAddress.5" name="AArch64.TranslateAddress.5"></a><ins>AArch64.TranslateAddress(bits(64) vaddress,</ins><del>AArch64.CheckS2Permission(</del> <a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(3) ap, bit xn, bit xxn, bit pxn )"><del>Permissions</del></a><del> perms, bits(64) vaddress, bits(52) ipaddress,
                                      integer level, </del><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType</a> <ins>acctype, boolean iswrite,
                                           boolean wasaligned, integer size)
</ins><del>acctype, boolean iswrite, bit NS,
                                      boolean s2fs1walk, boolean hwupdatewalk)
</del>
<ins>    result =</ins><del>    assert</del> <a href="shared_pseudocode.html#AArch64.FullTranslate.5" title="function: AddressDescriptor AArch64.FullTranslate(bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><ins>AArch64.FullTranslate</ins></a><a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()"><del>IsSecureEL2Enabled</del></a><ins>(vaddress, acctype, iswrite, wasaligned, size);

    if !(acctype IN {</ins><del>() || (</del><a href="shared_pseudocode.html#AccType_PTW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_PTW</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>,</ins><del>(</del> <a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IC</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>,</ins><del>) &amp;&amp; !</del> <a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_AT</ins></a><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><ins>}) &amp;&amp; !</ins><del>() &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><ins>(result) then
        result.fault =</ins><del>(</del> <a href="shared_pseudocode.html#AArch64.CheckDebug.4" title="function: FaultRecord AArch64.CheckDebug(bits(64) vaddress, AccType acctype, boolean iswrite, integer size)"><ins>AArch64.CheckDebug</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>(vaddress, acctype, iswrite, size);

    // Update virtual address for abort functions
    result.vaddress =</ins><del>) ) &amp;&amp;</del> <del>();

    r = perms.ap&lt;1> == '1';
    w = perms.ap&lt;2> == '1';
    if </del><a href="shared_pseudocode.html#impl-shared.HaveExtendedExecuteNeverExt.0" title="function: boolean HaveExtendedExecuteNeverExt()"><del>HaveExtendedExecuteNeverExt</del></a><del>() then
        case perms.xn:perms.xxn of
            when '00'  xn = FALSE;
            when '01'  xn = PSTATE.EL == </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>;
            when '10'  xn = TRUE;
            when '11'  xn = PSTATE.EL == </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>;
    else
        xn = perms.xn == '1';
    // Stage 1 walk is checked as a read, regardless of the original type
    if acctype == </del><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IFETCH</del></a><del> &amp;&amp; !s2fs1walk then
        fail = xn;
        failedread = TRUE;
    elsif (acctype IN { </del><a href="shared_pseudocode.html#AccType_ATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ATOMICRW</del></a><del>, </del><a href="shared_pseudocode.html#AccType_ORDEREDRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ORDEREDRW</del></a><del>, </del><a href="shared_pseudocode.html#AccType_ORDEREDATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ORDEREDATOMICRW</del></a><del> }) &amp;&amp; !s2fs1walk then
        fail = !r || !w;
        failedread = !r;
    elsif iswrite &amp;&amp; !s2fs1walk then
        fail = !w;
        failedread = FALSE;
    elsif acctype == </del><a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_DC</del></a><del> &amp;&amp; PSTATE.EL != </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del> &amp;&amp; !s2fs1walk then
        // DC maintenance instructions operating by VA, with the exception of DC IVAC, do
        // not generate Permission faults from stage 2 translation, other than when
        // performing a stage 1 translation table walk.
        fail = FALSE;
    elsif hwupdatewalk then
        fail = !w;
        failedread = !iswrite;
    else
        fail = !r;
        failedread = !iswrite;

    if fail then
        domain = bits(4) UNKNOWN;
        secondstage = TRUE;
        return </del><a href="shared_pseudocode.html#AArch64.PermissionFault.7" title="function: FaultRecord AArch64.PermissionFault(bits(52) ipaddress,bit NS, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><del>AArch64.PermissionFault</del></a><del>(ipaddress,NS,  level, acctype,
                                       !failedread, secondstage, s2fs1walk);
    else
        return </del><a href="shared_pseudocode.html#AArch64.NoFault.0" title="function: FaultRecord AArch64.NoFault()"><del>AArch64.NoFault</del></a><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><a href="shared_pseudocode.html#impl-shared.HasS2Translation.0" title="function: boolean HasS2Translation()"><del>HasS2Translation</del></a><ins>(vaddress);

    return result;</ins><del>();</del></p></div><div class="ps" psname="aarch64.translation.walk.AArch64.TranslationTableWalk"><a id="aarch64.translation.walk.AArch64.TranslationTableWalk" name="aarch64.translation.walk.AArch64.TranslationTableWalk"></a><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/<ins>walk</ins><del>debug</del>/<ins>AArch64.TranslationTableWalk</ins><del>AArch64.CheckBreakpoint</del></h3><p class="pseudocode"><ins>// AArch64.TranslationTableWalk()
// ==============================
// Returns a result of a translation table walk
//
// Implementations might cache information from memory in any number of non-coherent TLB
// caching structures, and so avoid memory accesses that have been expressed in this
// pseudocode. The use of such TLBs is not expressed in this pseudocode.
</ins><del>// AArch64.CheckBreakpoint()
// =========================
// Called before executing the instruction of length "size" bytes at "vaddress" in an AArch64
// translation regime.
// The breakpoint can in fact be evaluated well ahead of execution, for example, at instruction
// fetch. This is the simple sequential execution of the program.
</del>
<ins>TLBRecord</ins><del>FaultRecord</del> <a id="AArch64.TranslationTableWalk.8" name="AArch64.TranslationTableWalk.8"></a><ins>AArch64.TranslationTableWalk(bits(52) ipaddress, bit s1_nonsecure, bits(64) vaddress,</ins><del>AArch64.CheckBreakpoint(bits(64) vaddress,</del>
                                       <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType</a> <ins>acctype, boolean iswrite, boolean secondstage,
                                       boolean s2fs1walk, integer size)
    if !secondstage then
        assert !</ins><del>acctype, integer size)
    assert !</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>());
<ins>    else
        assert</ins><del>    assert (</del> <a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()"><ins>IsSecureEL2Enabled</ins></a><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><ins>() || (</ins><del>() &amp;&amp; size IN {2,4}) || size == 4;

    match = FALSE;

    for i = 0 to</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>(</ins><del>(ID_AA64DFR0_EL1.BRPs)
        match_i =</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#AArch64.BreakpointMatch.4" title="function: boolean AArch64.BreakpointMatch(integer n, bits(64) vaddress, AccType acctype, integer size)"><del>AArch64.BreakpointMatch</del></a><ins>) &amp;&amp; !</ins><del>(i, vaddress, acctype, size);
        match = match || match_i;

    if match &amp;&amp;</del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><a href="shared_pseudocode.html#impl-shared.HaltOnBreakpointOrWatchpoint.0" title="function: boolean HaltOnBreakpointOrWatchpoint()"><del>HaltOnBreakpointOrWatchpoint</del></a><ins>() &amp;&amp; !</ins><del>() then
        reason =</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><a href="shared_pseudocode.html#DebugHalt_Breakpoint" title="constant bits(6) DebugHalt_Breakpoint = '000111'"><del>DebugHalt_Breakpoint</del></a><ins>(</ins><del>;</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)"><del>Halt</del></a><ins>) ) &amp;&amp;</ins><del>(reason);
    elsif match &amp;&amp; MDSCR_EL1.MDE == '1' &amp;&amp;</del> <a href="shared_pseudocode.html#impl-shared.HasS2Translation.0" title="function: boolean HasS2Translation()"><ins>HasS2Translation</ins></a><a href="shared_pseudocode.html#AArch64.GenerateDebugExceptions.0" title="function: boolean AArch64.GenerateDebugExceptions()"><del>AArch64.GenerateDebugExceptions</del></a><ins>();</ins><del>() then
        acctype =</del>

    <a href="shared_pseudocode.html#TLBRecord" title="type TLBRecord is ( Permissions perms, bit nG, bits(4) domain, bit GP, boolean contiguous, integer level, integer blocksize, DescriptorUpdate descupdate, bit CnP, AddressDescriptor addrdesc )"><ins>TLBRecord</ins></a><ins> result;
    </ins><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><ins>AddressDescriptor</ins></a><ins> descaddr;
    bits(64) baseregister;
    bits(64) inputaddr;        // Input Address is 'vaddress' for stage 1, 'ipaddress' for stage 2

    descaddr.memattrs.type = </ins><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Normal</ins></a><ins>;

    // Derived parameters for the page table walk:
    //  grainsize = Log2(Size of Table)         - Size of Table is 4KB, 16KB or 64KB in AArch64
    //  stride = Log2(Address per Level)        - Bits of address consumed at each level
    //  firstblocklevel = First level where a block entry is allowed
    //  ps = Physical Address size as encoded in TCR_EL1.IPS or TCR_ELx/VTCR_EL2.PS
    //  inputsize = Log2(Size of Input Address) - Input Address size in bits
    //  level = Level to start walk from
    // This means that the number of levels after start level = 3-level

    if !secondstage then
        // First stage translation
        inputaddr = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(vaddress);
        el = </ins><a href="shared_pseudocode.html#AArch64.AccessUsesEL.1" title="function: bits(2) AArch64.AccessUsesEL(AccType acctype)"><ins>AArch64.AccessUsesEL</ins></a><ins>(acctype);
        top = </ins><a href="shared_pseudocode.html#impl-shared.AddrTop.3" title="function: integer AddrTop(bits(64) address, boolean IsInstr, bits(2) el)"><ins>AddrTop</ins></a><ins>(inputaddr, (acctype == </ins><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType_IFETCH</a><ins>), el);
        if el ==</ins><del>;
        iswrite = FALSE;
        return</del> <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#AArch64.DebugFault.2" title="function: FaultRecord AArch64.DebugFault(AccType acctype, boolean iswrite)"><del>AArch64.DebugFault</del></a> <ins>then
            largegrain = TCR_EL3.TG0 == '01';
            midgrain = TCR_EL3.TG0 == '10';
            inputsize = 64 -</ins><del>(acctype, iswrite);
    else
        return</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(TCR_EL3.T0SZ);
            inputsize_max = if </ins><a href="shared_pseudocode.html#impl-shared.Have52BitVAExt.0" title="function: boolean Have52BitVAExt()"><ins>Have52BitVAExt</ins></a><ins>() &amp;&amp; largegrain then 52 else 48;
            inputsize_min = 64 - (if !</ins><a href="shared_pseudocode.html#impl-shared.HaveSmallPageTblExt.0" title="function: boolean HaveSmallPageTblExt()"><ins>HaveSmallPageTblExt</ins></a><ins>() then 39 else if largegrain then 47 else 48);
            if inputsize &lt; inputsize_min then
                c = </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><ins>ConstrainUnpredictable</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_RESTnSZ" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESTnSZ</ins></a><ins>);
                assert c IN {</ins><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FORCE</ins></a><ins>, </ins><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FAULT</ins></a><ins>};
                if c == </ins><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FORCE</ins></a><ins> then inputsize = inputsize_min;
            ps = TCR_EL3.PS;
            basefound = inputsize >= inputsize_min &amp;&amp; inputsize &lt;= inputsize_max &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(inputaddr&lt;top:inputsize>);
            disabled = FALSE;
            baseregister = TTBR0_EL3;
            descaddr.memattrs = </ins><a href="shared_pseudocode.html#impl-shared.WalkAttrDecode.4" title="function: MemoryAttributes WalkAttrDecode(bits(2) SH, bits(2) ORGN, bits(2) IRGN, boolean secondstage)"><ins>WalkAttrDecode</ins></a><ins>(TCR_EL3.SH0, TCR_EL3.ORGN0, TCR_EL3.IRGN0, secondstage);
            reversedescriptors = SCTLR_EL3.EE == '1';
            lookupsecure = TRUE;
            singlepriv = TRUE;
            update_AF = </ins><a href="shared_pseudocode.html#impl-shared.HaveAccessFlagUpdateExt.0" title="function: boolean HaveAccessFlagUpdateExt()"><ins>HaveAccessFlagUpdateExt</ins></a><ins>() &amp;&amp; TCR_EL3.HA == '1';
            update_AP = </ins><a href="shared_pseudocode.html#impl-shared.HaveDirtyBitModifierExt.0" title="function: boolean HaveDirtyBitModifierExt()"><ins>HaveDirtyBitModifierExt</ins></a><ins>() &amp;&amp; update_AF &amp;&amp; TCR_EL3.HD == '1';
            hierattrsdisabled = </ins><a href="shared_pseudocode.html#AArch64.HaveHPDExt.0" title="function: boolean AArch64.HaveHPDExt()"><ins>AArch64.HaveHPDExt</ins></a><ins>() &amp;&amp; TCR_EL3.HPD == '1';
        elsif </ins><a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)"><ins>ELIsInHost</ins></a><ins>(el) then
            if inputaddr&lt;top> == '0' then
                largegrain = TCR_EL2.TG0 == '01';
                midgrain = TCR_EL2.TG0 == '10';
                inputsize = 64 - </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(TCR_EL2.T0SZ);
                inputsize_max = if </ins><a href="shared_pseudocode.html#impl-shared.Have52BitVAExt.0" title="function: boolean Have52BitVAExt()"><ins>Have52BitVAExt</ins></a><ins>() &amp;&amp; largegrain then 52 else 48;
                inputsize_min = 64 - (if !</ins><a href="shared_pseudocode.html#impl-shared.HaveSmallPageTblExt.0" title="function: boolean HaveSmallPageTblExt()"><ins>HaveSmallPageTblExt</ins></a><ins>() then 39 else if largegrain then 47 else 48);
                if inputsize &lt; inputsize_min then
                    c = </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><ins>ConstrainUnpredictable</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_RESTnSZ" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESTnSZ</ins></a><ins>);
                    assert c IN {</ins><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FORCE</ins></a><ins>, </ins><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FAULT</ins></a><ins>};
                    if c == </ins><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FORCE</ins></a><ins> then inputsize = inputsize_min;
                basefound = inputsize >= inputsize_min &amp;&amp; inputsize &lt;= inputsize_max &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(inputaddr&lt;top:inputsize>);
                disabled = TCR_EL2.EPD0 == '1' || (PSTATE.EL == </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins> &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.HaveE0PDExt.0" title="function: boolean HaveE0PDExt()"><ins>HaveE0PDExt</ins></a><ins>() &amp;&amp; TCR_EL2.E0PD0 == '1');
                baseregister = TTBR0_EL2;
                descaddr.memattrs = </ins><a href="shared_pseudocode.html#impl-shared.WalkAttrDecode.4" title="function: MemoryAttributes WalkAttrDecode(bits(2) SH, bits(2) ORGN, bits(2) IRGN, boolean secondstage)"><ins>WalkAttrDecode</ins></a><ins>(TCR_EL2.SH0, TCR_EL2.ORGN0, TCR_EL2.IRGN0, secondstage);
                hierattrsdisabled = </ins><a href="shared_pseudocode.html#AArch64.HaveHPDExt.0" title="function: boolean AArch64.HaveHPDExt()"><ins>AArch64.HaveHPDExt</ins></a><ins>() &amp;&amp; TCR_EL2.HPD0 == '1';
            else
                inputsize = 64 - </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(TCR_EL2.T1SZ);
                largegrain = TCR_EL2.TG1 == '11';       // TG1 and TG0 encodings differ
                midgrain = TCR_EL2.TG1 == '01';
                inputsize_max = if </ins><a href="shared_pseudocode.html#impl-shared.Have52BitVAExt.0" title="function: boolean Have52BitVAExt()"><ins>Have52BitVAExt</ins></a><ins>() &amp;&amp; largegrain then 52 else 48;
                inputsize_min = 64 - (if !</ins><a href="shared_pseudocode.html#impl-shared.HaveSmallPageTblExt.0" title="function: boolean HaveSmallPageTblExt()"><ins>HaveSmallPageTblExt</ins></a><ins>() then 39 else if largegrain then 47 else 48);
                if inputsize &lt; inputsize_min then
                    c = </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><ins>ConstrainUnpredictable</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_RESTnSZ" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESTnSZ</ins></a><ins>);
                    assert c IN {</ins><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FORCE</ins></a><ins>, </ins><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FAULT</ins></a><ins>};
                    if c == </ins><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FORCE</ins></a><ins> then inputsize = inputsize_min;
                basefound = inputsize >= inputsize_min &amp;&amp; inputsize &lt;= inputsize_max &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)"><ins>IsOnes</ins></a><ins>(inputaddr&lt;top:inputsize>);
                disabled = TCR_EL2.EPD1 == '1' || (PSTATE.EL == </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins> &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.HaveE0PDExt.0" title="function: boolean HaveE0PDExt()"><ins>HaveE0PDExt</ins></a><ins>() &amp;&amp; TCR_EL2.E0PD1 == '1');
                baseregister = TTBR1_EL2;
                descaddr.memattrs = </ins><a href="shared_pseudocode.html#impl-shared.WalkAttrDecode.4" title="function: MemoryAttributes WalkAttrDecode(bits(2) SH, bits(2) ORGN, bits(2) IRGN, boolean secondstage)"><ins>WalkAttrDecode</ins></a><ins>(TCR_EL2.SH1, TCR_EL2.ORGN1, TCR_EL2.IRGN1, secondstage);
                hierattrsdisabled = </ins><a href="shared_pseudocode.html#AArch64.HaveHPDExt.0" title="function: boolean AArch64.HaveHPDExt()"><ins>AArch64.HaveHPDExt</ins></a><ins>() &amp;&amp; TCR_EL2.HPD1 == '1';
            ps = TCR_EL2.IPS;
            reversedescriptors = SCTLR_EL2.EE == '1';
            lookupsecure = if </ins><a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()"><ins>IsSecureEL2Enabled</ins></a><ins>() then </ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>() else FALSE;
            singlepriv = FALSE;
            update_AF = </ins><a href="shared_pseudocode.html#impl-shared.HaveAccessFlagUpdateExt.0" title="function: boolean HaveAccessFlagUpdateExt()"><ins>HaveAccessFlagUpdateExt</ins></a><ins>() &amp;&amp; TCR_EL2.HA == '1';
            update_AP = </ins><a href="shared_pseudocode.html#impl-shared.HaveDirtyBitModifierExt.0" title="function: boolean HaveDirtyBitModifierExt()"><ins>HaveDirtyBitModifierExt</ins></a><ins>() &amp;&amp; update_AF &amp;&amp; TCR_EL2.HD == '1';
        elsif el == </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins> then
            inputsize = 64 - </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(TCR_EL2.T0SZ);
            largegrain = TCR_EL2.TG0 == '01';
            midgrain = TCR_EL2.TG0 == '10';
            inputsize_max = if </ins><a href="shared_pseudocode.html#impl-shared.Have52BitVAExt.0" title="function: boolean Have52BitVAExt()"><ins>Have52BitVAExt</ins></a><ins>() &amp;&amp; largegrain then 52 else 48;
            inputsize_min = 64 - (if !</ins><a href="shared_pseudocode.html#impl-shared.HaveSmallPageTblExt.0" title="function: boolean HaveSmallPageTblExt()"><ins>HaveSmallPageTblExt</ins></a><ins>() then 39 else if largegrain then 47 else 48);
            if inputsize &lt; inputsize_min then
                c = </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><ins>ConstrainUnpredictable</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_RESTnSZ" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESTnSZ</ins></a><ins>);
                assert c IN {</ins><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FORCE</ins></a><ins>, </ins><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FAULT</ins></a><ins>};
                if c == </ins><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FORCE</ins></a><ins> then inputsize = inputsize_min;
            ps = TCR_EL2.PS;
            basefound = inputsize >= inputsize_min &amp;&amp; inputsize &lt;= inputsize_max &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(inputaddr&lt;top:inputsize>);
            disabled = FALSE;
            baseregister = TTBR0_EL2;
            descaddr.memattrs = </ins><a href="shared_pseudocode.html#impl-shared.WalkAttrDecode.4" title="function: MemoryAttributes WalkAttrDecode(bits(2) SH, bits(2) ORGN, bits(2) IRGN, boolean secondstage)"><ins>WalkAttrDecode</ins></a><ins>(TCR_EL2.SH0, TCR_EL2.ORGN0, TCR_EL2.IRGN0, secondstage);
            reversedescriptors = SCTLR_EL2.EE == '1';
            lookupsecure = if </ins><a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()"><ins>IsSecureEL2Enabled</ins></a><ins>() then </ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>() else FALSE;
            singlepriv = TRUE;
            update_AF = </ins><a href="shared_pseudocode.html#impl-shared.HaveAccessFlagUpdateExt.0" title="function: boolean HaveAccessFlagUpdateExt()"><ins>HaveAccessFlagUpdateExt</ins></a><ins>() &amp;&amp; TCR_EL2.HA == '1';
            update_AP = </ins><a href="shared_pseudocode.html#impl-shared.HaveDirtyBitModifierExt.0" title="function: boolean HaveDirtyBitModifierExt()"><ins>HaveDirtyBitModifierExt</ins></a><ins>() &amp;&amp; update_AF &amp;&amp; TCR_EL2.HD == '1';
            hierattrsdisabled = </ins><a href="shared_pseudocode.html#AArch64.HaveHPDExt.0" title="function: boolean AArch64.HaveHPDExt()"><ins>AArch64.HaveHPDExt</ins></a><ins>() &amp;&amp; TCR_EL2.HPD == '1';
        else
            if inputaddr&lt;top> == '0' then
                inputsize = 64 - </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(TCR_EL1.T0SZ);
                largegrain = TCR_EL1.TG0 == '01';
                midgrain = TCR_EL1.TG0 == '10';
                inputsize_max = if </ins><a href="shared_pseudocode.html#impl-shared.Have52BitVAExt.0" title="function: boolean Have52BitVAExt()"><ins>Have52BitVAExt</ins></a><ins>() &amp;&amp; largegrain then 52 else 48;
                inputsize_min = 64 - (if !</ins><a href="shared_pseudocode.html#impl-shared.HaveSmallPageTblExt.0" title="function: boolean HaveSmallPageTblExt()"><ins>HaveSmallPageTblExt</ins></a><ins>() then 39 else if largegrain then 47 else 48);
                if inputsize &lt; inputsize_min then
                    c = </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><ins>ConstrainUnpredictable</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_RESTnSZ" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESTnSZ</ins></a><ins>);
                    assert c IN {</ins><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FORCE</ins></a><ins>, </ins><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FAULT</ins></a><ins>};
                    if c == </ins><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FORCE</ins></a><ins> then inputsize = inputsize_min;
                basefound = inputsize >= inputsize_min &amp;&amp; inputsize &lt;= inputsize_max &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(inputaddr&lt;top:inputsize>);
                disabled = TCR_EL1.EPD0 == '1' || (PSTATE.EL == </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins> &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.HaveE0PDExt.0" title="function: boolean HaveE0PDExt()"><ins>HaveE0PDExt</ins></a><ins>() &amp;&amp; TCR_EL1.E0PD0 == '1');
                disabled = disabled || (el == </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins> &amp;&amp; acctype == </ins><a href="shared_pseudocode.html#AccType_NONFAULT" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NONFAULT</ins></a><ins> &amp;&amp; TCR_EL1.NFD0 == '1');
                baseregister = TTBR0_EL1;
                descaddr.memattrs = </ins><a href="shared_pseudocode.html#impl-shared.WalkAttrDecode.4" title="function: MemoryAttributes WalkAttrDecode(bits(2) SH, bits(2) ORGN, bits(2) IRGN, boolean secondstage)"><ins>WalkAttrDecode</ins></a><ins>(TCR_EL1.SH0, TCR_EL1.ORGN0, TCR_EL1.IRGN0, secondstage);
                hierattrsdisabled = </ins><a href="shared_pseudocode.html#AArch64.HaveHPDExt.0" title="function: boolean AArch64.HaveHPDExt()"><ins>AArch64.HaveHPDExt</ins></a><ins>() &amp;&amp;  TCR_EL1.HPD0 == '1';
            else
                inputsize = 64 - </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(TCR_EL1.T1SZ);
                largegrain = TCR_EL1.TG1 == '11';       // TG1 and TG0 encodings differ
                midgrain = TCR_EL1.TG1 == '01';
                inputsize_max = if </ins><a href="shared_pseudocode.html#impl-shared.Have52BitVAExt.0" title="function: boolean Have52BitVAExt()"><ins>Have52BitVAExt</ins></a><ins>() &amp;&amp; largegrain then 52 else 48;
                inputsize_min = 64 - (if !</ins><a href="shared_pseudocode.html#impl-shared.HaveSmallPageTblExt.0" title="function: boolean HaveSmallPageTblExt()"><ins>HaveSmallPageTblExt</ins></a><ins>() then 39 else if largegrain then 47 else 48);
                if inputsize &lt; inputsize_min then
                    c = </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><ins>ConstrainUnpredictable</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_RESTnSZ" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESTnSZ</ins></a><ins>);
                    assert c IN {</ins><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FORCE</ins></a><ins>, </ins><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FAULT</ins></a><ins>};
                    if c == </ins><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FORCE</ins></a><ins> then inputsize = inputsize_min;
                basefound = inputsize >= inputsize_min &amp;&amp; inputsize &lt;= inputsize_max &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)"><ins>IsOnes</ins></a><ins>(inputaddr&lt;top:inputsize>);
                disabled = TCR_EL1.EPD1 == '1' || (PSTATE.EL == </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins> &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.HaveE0PDExt.0" title="function: boolean HaveE0PDExt()"><ins>HaveE0PDExt</ins></a><ins>() &amp;&amp; TCR_EL1.E0PD1 == '1');
                disabled = disabled || (el == </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins> &amp;&amp; acctype == </ins><a href="shared_pseudocode.html#AccType_NONFAULT" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NONFAULT</ins></a><ins> &amp;&amp; TCR_EL1.NFD1 == '1');
                baseregister = TTBR1_EL1;
                descaddr.memattrs = </ins><a href="shared_pseudocode.html#impl-shared.WalkAttrDecode.4" title="function: MemoryAttributes WalkAttrDecode(bits(2) SH, bits(2) ORGN, bits(2) IRGN, boolean secondstage)"><ins>WalkAttrDecode</ins></a><ins>(TCR_EL1.SH1, TCR_EL1.ORGN1, TCR_EL1.IRGN1, secondstage);
                hierattrsdisabled = </ins><a href="shared_pseudocode.html#AArch64.HaveHPDExt.0" title="function: boolean AArch64.HaveHPDExt()"><ins>AArch64.HaveHPDExt</ins></a><ins>() &amp;&amp;  TCR_EL1.HPD1 == '1';
            ps = TCR_EL1.IPS;
            reversedescriptors = SCTLR_EL1.EE == '1';
            lookupsecure = </ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>();
            singlepriv = FALSE;
            update_AF = </ins><a href="shared_pseudocode.html#impl-shared.HaveAccessFlagUpdateExt.0" title="function: boolean HaveAccessFlagUpdateExt()"><ins>HaveAccessFlagUpdateExt</ins></a><ins>() &amp;&amp; TCR_EL1.HA == '1';
            update_AP = </ins><a href="shared_pseudocode.html#impl-shared.HaveDirtyBitModifierExt.0" title="function: boolean HaveDirtyBitModifierExt()"><ins>HaveDirtyBitModifierExt</ins></a><ins>() &amp;&amp; update_AF &amp;&amp; TCR_EL1.HD == '1';
        if largegrain then
            grainsize = 16;                                             // Log2(64KB page size)
            firstblocklevel = (if </ins><a href="shared_pseudocode.html#impl-shared.Have52BitPAExt.0" title="function: boolean Have52BitPAExt()"><ins>Have52BitPAExt</ins></a><ins>() then 1 else 2);      // Largest block is 4TB (2^42 bytes) for 52 bit PA
                                                                        // and 512MB (2^29 bytes) otherwise
        elsif midgrain then
            grainsize = 14;                                             // Log2(16KB page size)
            firstblocklevel = 2;                                        // Largest block is 32MB (2^25 bytes)
        else // Small grain
            grainsize = 12;                                             // Log2(4KB page size)
            firstblocklevel = 1;                                        // Largest block is 1GB (2^30 bytes)
        stride = grainsize - 3;                                         // Log2(page size / 8 bytes)
        // The starting level is the number of strides needed to consume the input address
        level = 4 - </ins><a href="shared_pseudocode.html#impl-shared.RoundUp.1" title="function: integer RoundUp(real x)"><ins>RoundUp</ins></a><ins>(Real(inputsize - grainsize) / Real(stride));

    else
        // Second stage translation
        inputaddr = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(ipaddress);
        // Stage 2 translation table walk for the Secure EL2 translation regime
        if </ins><a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()"><ins>IsSecureEL2Enabled</ins></a><ins>() &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>() then

            // Stage 2 translation walk is in the Non-secure IPA space or the Secure IPA space
            t0size = if s1_nonsecure == '1' then VTCR_EL2.T0SZ else VSTCR_EL2.T0SZ;
            tg0    = if s1_nonsecure == '1' then VTCR_EL2.TG0 else VSTCR_EL2.TG0;

            // Stage 2 translation table walk is to the Non-secure PA space or to the Secure PA space
            nswalk = if s1_nonsecure == '1' then VTCR_EL2.NSW else VSTCR_EL2.SW;

            // Stage 2 translation accesses the Non-secure PA space or the Secure PA space
            if nswalk == '1' then
                nsaccess = '1';                                        // When walk is non-secure, access must be to the Non-secure PA space
            else
                if s1_nonsecure == '0' then
                    nsaccess = VSTCR_EL2.SA;                           // When walk is secure and in the Secure IPA space, access is specified by VSTCR_EL2.SA
                else
                    if VSTCR_EL2.SW == '1' || VSTCR_EL2.SA == '1' then nsaccess = '1';        // When walk is secure and in the Non-secure IPA space, access is non-secure when VSTCR_EL2.SA specifies the Non-secure PA space
                    else nsaccess = VTCR_EL2.NSA;                      // When walk is secure and in the Non-secure IPA space, if VSTCR_EL2.SA specifies the Secure PA space, access is specified by VSTCR_EL2.NSA
        else
            t0size = VTCR_EL2.T0SZ;
            tg0    = VTCR_EL2.TG0;
            nsaccess = '1';

        inputsize  = 64 - </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(t0size);
        largegrain = tg0 == '01';
        midgrain   = tg0 == '10';

        inputsize_max = if </ins><a href="shared_pseudocode.html#impl-shared.Have52BitVAExt.0" title="function: boolean Have52BitVAExt()"><ins>Have52BitVAExt</ins></a><ins>() &amp;&amp; largegrain then 52 else 48;
        inputsize_min = 64 - (if !</ins><a href="shared_pseudocode.html#impl-shared.HaveSmallPageTblExt.0" title="function: boolean HaveSmallPageTblExt()"><ins>HaveSmallPageTblExt</ins></a><ins>() then 39 else if largegrain then 47 else 48);
        if inputsize &lt; inputsize_min then
            c = </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><ins>ConstrainUnpredictable</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_RESTnSZ" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESTnSZ</ins></a><ins>);
            assert c IN {</ins><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FORCE</ins></a><ins>, </ins><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FAULT</ins></a><ins>};
            if c == </ins><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FORCE</ins></a><ins> then inputsize = inputsize_min;
        ps = VTCR_EL2.PS;
        basefound = inputsize >= inputsize_min &amp;&amp; inputsize &lt;= inputsize_max &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(inputaddr&lt;63:inputsize>);
        disabled = FALSE;
        descaddr.memattrs = </ins><a href="shared_pseudocode.html#impl-shared.WalkAttrDecode.4" title="function: MemoryAttributes WalkAttrDecode(bits(2) SH, bits(2) ORGN, bits(2) IRGN, boolean secondstage)"><ins>WalkAttrDecode</ins></a><ins>(VTCR_EL2.SH0, VTCR_EL2.ORGN0, VTCR_EL2.IRGN0, secondstage);
        reversedescriptors = SCTLR_EL2.EE == '1';
        singlepriv = TRUE;
        update_AF = </ins><a href="shared_pseudocode.html#impl-shared.HaveAccessFlagUpdateExt.0" title="function: boolean HaveAccessFlagUpdateExt()"><ins>HaveAccessFlagUpdateExt</ins></a><ins>() &amp;&amp; VTCR_EL2.HA == '1';
        update_AP = </ins><a href="shared_pseudocode.html#impl-shared.HaveDirtyBitModifierExt.0" title="function: boolean HaveDirtyBitModifierExt()"><ins>HaveDirtyBitModifierExt</ins></a><ins>() &amp;&amp; update_AF &amp;&amp; VTCR_EL2.HD == '1';

        lookupsecure = if </ins><a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()"><ins>IsSecureEL2Enabled</ins></a><ins>() then s1_nonsecure == '0' else FALSE;
        // Stage2 translation table walk is to secure PA space or to Non-secure PA space
        baseregister = if lookupsecure then VSTTBR_EL2 else VTTBR_EL2;
        startlevel   = if lookupsecure then </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(VSTCR_EL2.SL0) else </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(VTCR_EL2.SL0);
        if largegrain then
            grainsize = 16;                                         // Log2(64KB page size)
            level = 3 - startlevel;
            firstblocklevel = (if </ins><a href="shared_pseudocode.html#impl-shared.Have52BitPAExt.0" title="function: boolean Have52BitPAExt()"><ins>Have52BitPAExt</ins></a><ins>() then 1 else 2);  // Largest block is 4TB (2^42 bytes) for 52 bit PA
                                                                    // and 512MB (2^29 bytes) otherwise
        elsif midgrain then
            grainsize = 14;                                         // Log2(16KB page size)
            level = 3 - startlevel;
            firstblocklevel = 2;                                    // Largest block is 32MB (2^25 bytes)
        else // Small grain
            grainsize = 12;                                         // Log2(4KB page size)
            if </ins><a href="shared_pseudocode.html#impl-shared.HaveSmallPageTblExt.0" title="function: boolean HaveSmallPageTblExt()"><ins>HaveSmallPageTblExt</ins></a><ins>() &amp;&amp; startlevel == 3 then
                level = startlevel;                             // Startlevel 3 (VTCR_EL2.SL0 or VSCTR_EL2.SL0 == 0b11) for 4KB granule
            else
                level = 2 - startlevel;
            firstblocklevel = 1;                                    // Largest block is 1GB (2^30 bytes)
        stride = grainsize - 3;                                     // Log2(page size / 8 bytes)

        // Limits on IPA controls based on implemented PA size. Level 0 is only
        // supported by small grain translations
        if largegrain then                              // 64KB pages
            // Level 1 only supported if implemented PA size is greater than 2^42 bytes
            if level == 0 || (level == 1 &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.PAMax.0" title="function: integer PAMax()"><ins>PAMax</ins></a><ins>() &lt;= 42) then basefound = FALSE;
        elsif midgrain then                             // 16KB pages
            // Level 1 only supported if implemented PA size is greater than 2^40 bytes
            if level == 0 || (level == 1 &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.PAMax.0" title="function: integer PAMax()"><ins>PAMax</ins></a><ins>() &lt;= 40) then basefound = FALSE;
        else                                            // Small grain, 4KB pages
            // Level 0 only supported if implemented PA size is greater than 2^42 bytes
            if level &lt; 0 || (level == 0 &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.PAMax.0" title="function: integer PAMax()"><ins>PAMax</ins></a><ins>() &lt;= 42) then basefound = FALSE;

        // If the inputsize exceeds the PAMax value, the behavior is CONSTRAINED UNPREDICTABLE
        inputsizecheck = inputsize;
        if inputsize > </ins><a href="shared_pseudocode.html#impl-shared.PAMax.0" title="function: integer PAMax()"><ins>PAMax</ins></a><ins>() &amp;&amp; (!</ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>) || inputsize > 40) then
            case </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><ins>ConstrainUnpredictable</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_LARGEIPA" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_LARGEIPA</ins></a><ins>) of
                when </ins><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FORCE</ins></a><ins>
                    // Restrict the inputsize to the PAMax value
                    inputsize = </ins><a href="shared_pseudocode.html#impl-shared.PAMax.0" title="function: integer PAMax()"><ins>PAMax</ins></a><ins>();
                    inputsizecheck = </ins><a href="shared_pseudocode.html#impl-shared.PAMax.0" title="function: integer PAMax()"><ins>PAMax</ins></a><ins>();
                when </ins><a href="shared_pseudocode.html#Constraint_FORCENOSLCHECK" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FORCENOSLCHECK</ins></a><ins>
                    // As FORCE, except use the configured inputsize in the size checks below
                    inputsize = </ins><a href="shared_pseudocode.html#impl-shared.PAMax.0" title="function: integer PAMax()"><ins>PAMax</ins></a><ins>();
                when </ins><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FAULT</ins></a><ins>
                    // Generate a translation fault
                    basefound = FALSE;
                otherwise
                    </ins><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><ins>Unreachable</ins></a><ins>();

        // Number of entries in the starting level table =
        //     (Size of Input Address)/((Address per level)^(Num levels remaining)*(Size of Table))
        startsizecheck = inputsizecheck - ((3 - level)*stride + grainsize); // Log2(Num of entries)

        // Check for starting level table with fewer than 2 entries or longer than 16 pages.
        // Lower bound check is:  startsizecheck &lt; Log2(2 entries)
        // Upper bound check is:  startsizecheck > Log2(pagesize/8*16)
        if startsizecheck &lt; 1 || startsizecheck > stride + 4 then basefound = FALSE;

    if !basefound || disabled then
        level = 0;           // AArch32 reports this as a level 1 fault
        result.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch64.TranslationFault.7" title="function: FaultRecord AArch64.TranslationFault(bits(52) ipaddress, bit NS, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><ins>AArch64.TranslationFault</ins></a><ins>(ipaddress, s1_nonsecure,  level, acctype, iswrite,
                                                         secondstage, s2fs1walk);
        return result;

    case ps of
        when '000'  outputsize = 32;
        when '001'  outputsize = 36;
        when '010'  outputsize = 40;
        when '011'  outputsize = 42;
        when '100'  outputsize = 44;
        when '101'  outputsize = 48;
        when '110'  outputsize = (if </ins><a href="shared_pseudocode.html#impl-shared.Have52BitPAExt.0" title="function: boolean Have52BitPAExt()"><ins>Have52BitPAExt</ins></a><ins>() &amp;&amp; largegrain then 52 else 48);
        otherwise   outputsize = integer IMPLEMENTATION_DEFINED "Reserved Intermediate Physical Address size value";

    if outputsize > </ins><a href="shared_pseudocode.html#impl-shared.PAMax.0" title="function: integer PAMax()"><ins>PAMax</ins></a><ins>() then outputsize = </ins><a href="shared_pseudocode.html#impl-shared.PAMax.0" title="function: integer PAMax()"><ins>PAMax</ins></a><ins>();

    if outputsize &lt; 48 &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(baseregister&lt;47:outputsize>) then
        level = 0;
        result.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch64.AddressSizeFault.7" title="function: FaultRecord AArch64.AddressSizeFault(bits(52) ipaddress,bit NS, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><ins>AArch64.AddressSizeFault</ins></a><ins>(ipaddress,s1_nonsecure,  level, acctype, iswrite,
                                                         secondstage, s2fs1walk);
        return result;

    // Bottom bound of the Base address is:
    //     Log2(8 bytes per entry)+Log2(Number of entries in starting level table)
    // Number of entries in starting level table =
    //     (Size of Input Address)/((Address per level)^(Num levels remaining)*(Size of Table))
    baselowerbound = 3 + inputsize - ((3-level)*stride + grainsize);  // Log2(Num of entries*8)
    if outputsize == 52 then
        z = (if baselowerbound &lt; 6 then 6 else baselowerbound);
        baseaddress = baseregister&lt;5:2>:baseregister&lt;47:z>:</ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(z);
    else
        baseaddress = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(baseregister&lt;47:baselowerbound>:</ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(baselowerbound));

    ns_table = if lookupsecure then '0' else '1';
    ap_table = '00';
    xn_table = '0';
    pxn_table = '0';

    addrselecttop = inputsize - 1;

    apply_nvnv1_effect = </ins><a href="shared_pseudocode.html#impl-shared.HaveNVExt.0" title="function: boolean HaveNVExt()"><ins>HaveNVExt</ins></a><ins>() &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>() &amp;&amp; HCR_EL2.&lt;NV,NV1> == '11' &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><ins>() == </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins> &amp;&amp; !secondstage;
    repeat
        addrselectbottom = (3-level)*stride + grainsize;

        bits(52) index = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(inputaddr&lt;addrselecttop:addrselectbottom>:'000');
        descaddr.paddress.address = baseaddress OR index;
        descaddr.paddress.NS = ns_table;

        // If there are two stages of translation, then the first stage table walk addresses
        // are themselves subject to translation
        if secondstage || !</ins><a href="shared_pseudocode.html#impl-shared.HasS2Translation.0" title="function: boolean HasS2Translation()"><ins>HasS2Translation</ins></a><ins>() || (</ins><a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()"><ins>HaveNV2Ext</ins></a><ins>() &amp;&amp; acctype == </ins><a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NV2REGISTER</ins></a><ins>) then
            descaddr2 = descaddr;
        else
            hwupdatewalk = FALSE;
            descaddr2 = </ins><a href="shared_pseudocode.html#AArch64.SecondStageWalk.6" title="function: AddressDescriptor AArch64.SecondStageWalk(AddressDescriptor S1, bits(64) vaddress, AccType acctype, boolean iswrite, integer size, boolean hwupdatewalk)"><ins>AArch64.SecondStageWalk</ins></a><ins>(descaddr, vaddress, acctype, iswrite, 8, hwupdatewalk);
            // Check for a fault on the stage 2 walk
            if </ins><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><ins>(descaddr2) then
                result.addrdesc.fault = descaddr2.fault;
                return result;

        // Update virtual address for abort functions
        descaddr2.vaddress = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(vaddress);

        accdesc = CreateAccessDescriptorPTW(acctype, secondstage, s2fs1walk, level);
        desc = _Mem[descaddr2, 8, accdesc];

        if reversedescriptors then desc = </ins><a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)"><ins>BigEndianReverse</ins></a><ins>(desc);

        if desc&lt;0> == '0' || (desc&lt;1:0> == '01' &amp;&amp; (level == 3 ||
                                                    (</ins><a href="shared_pseudocode.html#impl-shared.HaveBlockBBM.0" title="function: boolean HaveBlockBBM()"><ins>HaveBlockBBM</ins></a><ins>() &amp;&amp; </ins><a href="shared_pseudocode.html#impl-aarch64.IsBlockDescriptorNTBitValid.0" title="function: boolean IsBlockDescriptorNTBitValid()"><ins>IsBlockDescriptorNTBitValid</ins></a><ins>() &amp;&amp; desc&lt;16> == '1'))) then
             // Fault (00), Reserved (10), Block (01) at level 3, or Block(01) with nT bit set.
            result.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch64.TranslationFault.7" title="function: FaultRecord AArch64.TranslationFault(bits(52) ipaddress, bit NS, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><ins>AArch64.TranslationFault</ins></a><ins>(ipaddress, s1_nonsecure, level, acctype,
                                                             iswrite, secondstage, s2fs1walk);
            return result;

        // Valid Block, Page, or Table entry
        if desc&lt;1:0> == '01' || level == 3 then                 // Block (01) or Page (11)
            blocktranslate = TRUE;
        else                                                    // Table (11)
            if (outputsize &lt; 52 &amp;&amp; largegrain &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(desc&lt;15:12>)) || (outputsize &lt; 48 &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(desc&lt;47:outputsize>)) then
                result.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch64.AddressSizeFault.7" title="function: FaultRecord AArch64.AddressSizeFault(bits(52) ipaddress,bit NS, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><ins>AArch64.AddressSizeFault</ins></a><ins>(ipaddress,s1_nonsecure,  level, acctype,
                                                                 iswrite, secondstage, s2fs1walk);
                return result;

            if outputsize == 52 then
                baseaddress = desc&lt;15:12>:desc&lt;47:grainsize>:</ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(grainsize);
            else
                baseaddress = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(desc&lt;47:grainsize>:</ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(grainsize));
            if !secondstage then
                // Unpack the upper and lower table attributes
                ns_table    = ns_table    OR desc&lt;63>;
            if !secondstage &amp;&amp; !hierattrsdisabled then
                ap_table&lt;1> = ap_table&lt;1> OR desc&lt;62>;       // read-only

                if apply_nvnv1_effect then
                    pxn_table   = pxn_table   OR desc&lt;60>;
                else
                    xn_table    = xn_table    OR desc&lt;60>;
                // pxn_table and ap_table[0] apply in EL1&amp;0 or EL2&amp;0 translation regimes
                if !singlepriv then
                    if !apply_nvnv1_effect then
                        pxn_table   = pxn_table   OR desc&lt;59>;
                        ap_table&lt;0> = ap_table&lt;0> OR desc&lt;61>;   // privileged

            level = level + 1;
            addrselecttop = addrselectbottom - 1;
            blocktranslate = FALSE;
    until blocktranslate;

    // Check block size is supported at this level
    if level &lt; firstblocklevel then
        result.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch64.TranslationFault.7" title="function: FaultRecord AArch64.TranslationFault(bits(52) ipaddress, bit NS, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><ins>AArch64.TranslationFault</ins></a><ins>(ipaddress, s1_nonsecure, level, acctype,
                                                         iswrite, secondstage, s2fs1walk);
        return result;

    // Check for misprogramming of the contiguous bit
    if largegrain then
        contiguousbitcheck = level == 2 &amp;&amp; inputsize &lt; 34;
    elsif midgrain then
        contiguousbitcheck = level == 2 &amp;&amp; inputsize &lt; 30;
    else
        contiguousbitcheck = level == 1 &amp;&amp; inputsize &lt; 34;

    if contiguousbitcheck &amp;&amp; desc&lt;52> == '1' then
        if boolean IMPLEMENTATION_DEFINED "Translation fault on misprogrammed contiguous bit" then
            result.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch64.TranslationFault.7" title="function: FaultRecord AArch64.TranslationFault(bits(52) ipaddress, bit NS, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><ins>AArch64.TranslationFault</ins></a><ins>(ipaddress, s1_nonsecure, level, acctype,
                                                             iswrite, secondstage, s2fs1walk);
            return result;

    // Check the output address is inside the supported range
    if (outputsize &lt; 52 &amp;&amp; largegrain &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(desc&lt;15:12>)) || (outputsize &lt; 48 &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(desc&lt;47:outputsize>)) then
        result.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch64.AddressSizeFault.7" title="function: FaultRecord AArch64.AddressSizeFault(bits(52) ipaddress,bit NS, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><ins>AArch64.AddressSizeFault</ins></a><ins>(ipaddress,s1_nonsecure,  level, acctype,
                                                         iswrite, secondstage, s2fs1walk);
        return result;

    // Unpack the descriptor into address and upper and lower block attributes
    if outputsize == 52 then
        outputaddress = desc&lt;15:12>:desc&lt;47:addrselectbottom>:inputaddr&lt;addrselectbottom-1:0>;
    else
        outputaddress = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(desc&lt;47:addrselectbottom>:inputaddr&lt;addrselectbottom-1:0>);
    // Check Access Flag
    if desc&lt;10> == '0' then
        if !update_AF then
            result.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch64.AccessFlagFault.7" title="function: FaultRecord AArch64.AccessFlagFault(bits(52) ipaddress,bit NS, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><ins>AArch64.AccessFlagFault</ins></a><ins>(ipaddress,s1_nonsecure,  level, acctype,
                                                            iswrite, secondstage, s2fs1walk);
            return result;
        else
            result.descupdate.AF = TRUE;

    if update_AP &amp;&amp; desc&lt;51> == '1' then
        // If hw update of access permission field is configured consider AP[2] as '0' / S2AP[2] as '1'
        if !secondstage &amp;&amp; desc&lt;7> == '1' then
            desc&lt;7> = '0';
            result.descupdate.AP = TRUE;
        elsif secondstage &amp;&amp; desc&lt;7> == '0' then
            desc&lt;7> = '1';
            result.descupdate.AP = TRUE;

    // Required descriptor if AF or AP[2]/S2AP[2] needs update
    result.descupdate.descaddr = descaddr;

    if apply_nvnv1_effect then
        pxn = desc&lt;54>;                                       // Bit[54] of the block/page descriptor holds PXN instead of UXN
        xn = '0';                                             // XN is '0'
        ap = desc&lt;7>:'01';                                    // Bit[6] of the block/page descriptor is treated as '0' regardless of value programmed
    else
        xn = desc&lt;54>;                                        // Bit[54] of the block/page descriptor holds UXN
        pxn = desc&lt;53>;                                       // Bit[53] of the block/page descriptor holds PXN
        ap = desc&lt;7:6>:'1';                                   // Bits[7:6] of the block/page descriptor hold AP[2:1]
    contiguousbit = desc&lt;52>;
    nG = desc&lt;11>;
    sh = desc&lt;9:8>;
    memattr = desc&lt;5:2>;                                      // AttrIndx and NS bit in stage 1

    result.domain = bits(4) UNKNOWN;                          // Domains not used
    result.level = level;
    result.blocksize = 2^((3-level)*stride + grainsize);

    // Stage 1 translation regimes also inherit attributes from the tables
    if !secondstage then
        result.perms.xn      = xn OR xn_table;
        result.perms.ap&lt;2>   = ap&lt;2> OR ap_table&lt;1>;          // Force read-only
        // PXN, nG and AP[1] apply in EL1&amp;0 or EL2&amp;0 stage 1 translation regimes
        if !singlepriv then
            result.perms.ap&lt;1> = ap&lt;1> AND NOT(ap_table&lt;0>);  // Force privileged only
            result.perms.pxn   = pxn OR pxn_table;
            // Pages from Non-secure tables are marked non-global in Secure EL1&amp;0
            if </ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>() then
                result.nG = nG OR ns_table;
            else
                result.nG = nG;
        else
            result.perms.ap&lt;1> = '1';
            result.perms.pxn   = '0';
            result.nG          = '0';
        result.GP = desc&lt;50>;                                 // Stage 1 block or pages might be guarded
        result.perms.ap&lt;0>   = '1';
        result.addrdesc.memattrs = </ins><a href="shared_pseudocode.html#AArch64.S1AttrDecode.3" title="function: MemoryAttributes AArch64.S1AttrDecode(bits(2) SH, bits(3) attr, AccType acctype)"><ins>AArch64.S1AttrDecode</ins></a><ins>(sh, memattr&lt;2:0>, acctype);
        result.addrdesc.paddress.NS = memattr&lt;3> OR ns_table;
    else
        result.perms.ap&lt;2:1> = ap&lt;2:1>;
        result.perms.ap&lt;0>   = '1';
        result.perms.xn      = xn;
        if </ins><a href="shared_pseudocode.html#impl-shared.HaveExtendedExecuteNeverExt.0" title="function: boolean HaveExtendedExecuteNeverExt()"><ins>HaveExtendedExecuteNeverExt</ins></a><ins>() then result.perms.xxn = desc&lt;53>;
        result.perms.pxn     = '0';
        result.nG            = '0';
        if s2fs1walk then
            result.addrdesc.memattrs = </ins><a href="shared_pseudocode.html#impl-shared.S2AttrDecode.3" title="function: MemoryAttributes S2AttrDecode(bits(2) SH, bits(4) attr, AccType acctype)"><ins>S2AttrDecode</ins></a><ins>(sh, memattr, </ins><a href="shared_pseudocode.html#AccType_PTW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_PTW</ins></a><ins>);
        else
            result.addrdesc.memattrs = </ins><a href="shared_pseudocode.html#impl-shared.S2AttrDecode.3" title="function: MemoryAttributes S2AttrDecode(bits(2) SH, bits(4) attr, AccType acctype)"><ins>S2AttrDecode</ins></a><ins>(sh, memattr, acctype);
        result.addrdesc.paddress.NS = nsaccess;

    result.addrdesc.paddress.address = outputaddress;
    result.addrdesc.fault = </ins><a href="shared_pseudocode.html#AArch64.NoFault.0" title="function: FaultRecord AArch64.NoFault()">AArch64.NoFault</a><ins>();
    result.contiguous = contiguousbit == '1';
    if </ins><a href="shared_pseudocode.html#impl-shared.HaveCommonNotPrivateTransExt.0" title="function: boolean HaveCommonNotPrivateTransExt()"><ins>HaveCommonNotPrivateTransExt</ins></a><ins>() then result.CnP = baseregister&lt;0>;

    return result;</ins><del>();</del></p></div><div class="ps" psname="shared.debug.ClearStickyErrors.ClearStickyErrors"><a id="shared.debug.ClearStickyErrors.ClearStickyErrors" name="shared.debug.ClearStickyErrors.ClearStickyErrors"></a><h3 class="pseudocode">
            Library pseudocode for <ins>shared</ins><del>aarch64</del>/<del>translation/</del>debug/<ins>ClearStickyErrors/ClearStickyErrors</ins><del>AArch64.CheckDebug</del></h3><p class="pseudocode"><ins>// ClearStickyErrors()
// ===================</ins><del>// AArch64.CheckDebug()
// ====================
// Called on each access to check for a debug exception or entry to Debug state.

FaultRecord</del>

<a id="impl-shared.ClearStickyErrors.0" name="impl-shared.ClearStickyErrors.0"></a><ins>ClearStickyErrors()
    EDSCR.TXU = '0';            // Clear TX underrun flag
    EDSCR.RXO = '0';            // Clear RX overrun flag

    if</ins><del>AArch64.CheckDebug(bits(64) vaddress,</del> <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><ins>Halted</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><ins>() then            // in Debug state
        EDSCR.ITO = '0';        // Clear ITR overrun flag

    // If halted and the ITR is not empty then it is UNPREDICTABLE whether the EDSCR.ERR is cleared.
    // The UNPREDICTABLE behavior also affects the instructions in flight, but this is not described
    // in the pseudocode.
    if</ins><del>acctype, boolean iswrite, integer size)</del> <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><ins>Halted</ins></a><a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><del>FaultRecord</del></a><ins>() &amp;&amp; EDSCR.ITE == '0' &amp;&amp;</ins><del>fault =</del> <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><ins>ConstrainUnpredictableBool</ins></a><a href="shared_pseudocode.html#AArch64.NoFault.0" title="function: FaultRecord AArch64.NoFault()"><del>AArch64.NoFault</del></a><ins>(</ins><del>();

    d_side = (acctype !=</del><del>);
    generate_exception = </del><a href="shared_pseudocode.html#AArch64.GenerateDebugExceptions.0" title="function: boolean AArch64.GenerateDebugExceptions()"><del>AArch64.GenerateDebugExceptions</del></a><del>() &amp;&amp; MDSCR_EL1.MDE == '1';
    halt = </del><a href="shared_pseudocode.html#impl-shared.HaltOnBreakpointOrWatchpoint.0" title="function: boolean HaltOnBreakpointOrWatchpoint()"><del>HaltOnBreakpointOrWatchpoint</del></a><del>();

    if generate_exception || halt then
        if d_side then
            fault = </del><a href="shared_pseudocode.html#AArch64.CheckWatchpoint.4" title="function: FaultRecord AArch64.CheckWatchpoint(bits(64) vaddress, AccType acctype, boolean iswrite, integer size)"><del>AArch64.CheckWatchpoint</del></a><del>(vaddress, acctype, iswrite, size);
        else
            fault = </del><a href="shared_pseudocode.html#AArch64.CheckBreakpoint.3" title="function: FaultRecord AArch64.CheckBreakpoint(bits(64) vaddress, AccType acctype, integer size)"><del>AArch64.CheckBreakpoint</del></a><a href="shared_pseudocode.html#Unpredictable_CLEARERRITEZERO" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_CLEARERRITEZERO</ins></a><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IFETCH</del></a><ins>) then
        return;
    EDSCR.ERR = '0';            // Clear cumulative error flag
</ins><del>(vaddress, acctype, size);
</del>
<ins>    return;</ins><del>    return fault;</del></p></div><div class="ps" psname="shared.debug.DebugTarget.DebugTarget"><a id="shared.debug.DebugTarget.DebugTarget" name="shared.debug.DebugTarget.DebugTarget"></a><h3 class="pseudocode">
            Library pseudocode for <ins>shared</ins><del>aarch64</del>/<del>translation/</del>debug/<ins>DebugTarget/DebugTarget</ins><del>AArch64.CheckWatchpoint</del></h3><p class="pseudocode"><ins>// DebugTarget()
// =============
// Returns the debug exception target Exception level
</ins><del>// AArch64.CheckWatchpoint()
// =========================
// Called before accessing the memory location of "size" bytes at "address".
</del>
<ins>bits(2)</ins><del>FaultRecord</del> <a id="impl-shared.DebugTarget.0" name="impl-shared.DebugTarget.0"></a><ins>DebugTarget()
    secure =</ins><del>AArch64.CheckWatchpoint(bits(64) vaddress,</del> <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><ins>();
    return</ins><del>acctype,
                                    boolean iswrite, integer size)
    assert !</del> <del>(</del><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><del>());

    match = FALSE;
    ispriv = </del><a href="shared_pseudocode.html#AArch64.AccessIsPrivileged.1" title="function: boolean AArch64.AccessIsPrivileged(AccType acctype)"><del>AArch64.AccessIsPrivileged</del></a><del>(acctype);

    for i = 0 to </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(ID_AA64DFR0_EL1.WRPs)
        match = match || </del><a href="shared_pseudocode.html#AArch64.WatchpointMatch.6" title="function: boolean AArch64.WatchpointMatch(integer n, bits(64) vaddress, integer size, boolean ispriv, AccType acctype, boolean iswrite)"><del>AArch64.WatchpointMatch</del></a><del>(i, vaddress, size, ispriv, acctype, iswrite);

    if match &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.HaltOnBreakpointOrWatchpoint.0" title="function: boolean HaltOnBreakpointOrWatchpoint()"><del>HaltOnBreakpointOrWatchpoint</del></a><del>() then
        if acctype != </del><a href="shared_pseudocode.html#AccType_NONFAULT" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NONFAULT</del></a><del> &amp;&amp; acctype != </del><a href="shared_pseudocode.html#AccType_CNOTFIRST" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_CNOTFIRST</del></a><del> then
            reason = </del><a href="shared_pseudocode.html#DebugHalt_Watchpoint" title="constant bits(6) DebugHalt_Watchpoint = '101011'"><del>DebugHalt_Watchpoint</del></a><del>;
            </del><a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)"><del>Halt</del></a><del>(reason);
        else
            // Fault will be reported and cancelled
            return </del><a href="shared_pseudocode.html#AArch64.DebugFault.2" title="function: FaultRecord AArch64.DebugFault(AccType acctype, boolean iswrite)"><del>AArch64.DebugFault</del></a><del>(acctype, iswrite);
    elsif match &amp;&amp; MDSCR_EL1.MDE == '1' &amp;&amp; </del><a href="shared_pseudocode.html#AArch64.GenerateDebugExceptions.0" title="function: boolean AArch64.GenerateDebugExceptions()"><del>AArch64.GenerateDebugExceptions</del></a><del>() then
        return </del><a href="shared_pseudocode.html#AArch64.DebugFault.2" title="function: FaultRecord AArch64.DebugFault(AccType acctype, boolean iswrite)"><del>AArch64.DebugFault</del></a><del>(acctype, iswrite);
    else
        return </del><a href="shared_pseudocode.html#AArch64.NoFault.0" title="function: FaultRecord AArch64.NoFault()"><del>AArch64.NoFault</del></a><a href="shared_pseudocode.html#impl-shared.DebugTargetFrom.1" title="function: bits(2) DebugTargetFrom(boolean secure)"><ins>DebugTargetFrom</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><ins>(secure);</ins><del>();</del></p></div><div class="ps" psname="shared.debug.DebugTarget.DebugTargetFrom"><a id="shared.debug.DebugTarget.DebugTargetFrom" name="shared.debug.DebugTarget.DebugTargetFrom"></a><h3 class="pseudocode">
            Library pseudocode for <ins>shared</ins><del>aarch64</del>/<ins>debug</ins><del>translation</del>/<ins>DebugTarget</ins><del>faults</del>/<ins>DebugTargetFrom</ins><del>AArch64.AccessFlagFault</del></h3><p class="pseudocode"><ins>// DebugTargetFrom()
// =================
</ins><del>// AArch64.AccessFlagFault()
// =========================
</del>
<ins>bits(2)</ins><del>FaultRecord</del> <a id="impl-shared.DebugTargetFrom.1" name="impl-shared.DebugTargetFrom.1"></a><ins>DebugTargetFrom(boolean secure)
    if</ins><del>AArch64.AccessFlagFault(bits(52) ipaddress,bit NS, integer level,</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><ins>(</ins><del>acctype, boolean iswrite, boolean secondstage,
                                    boolean s2fs1walk)

    extflag = bit UNKNOWN;
    errortype = bits(2) UNKNOWN;
    return</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#AArch64.CreateFaultRecord.10" title="function: FaultRecord AArch64.CreateFaultRecord(Fault type, bits(52) ipaddress, bit NS, integer level, AccType acctype, boolean write, bit extflag, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><del>AArch64.CreateFaultRecord</del></a><ins>) &amp;&amp; !secure then
        if</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_AccessFlag</del></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) then
            route_to_el2 = (HDCR.TDE == '1' || HCR.TGE == '1');
        else
            route_to_el2 = (MDCR_EL2.TDE == '1' || HCR_EL2.TGE == '1');
    else
        route_to_el2 = FALSE;

    if route_to_el2 then
        target = </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>;
    elsif </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.HighestELUsingAArch32.0" title="function: boolean HighestELUsingAArch32()"><ins>HighestELUsingAArch32</ins></a><ins>() &amp;&amp; secure then
        target = </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>;
    else
        target = </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>;

    return target;</ins><del>, ipaddress, NS, level, acctype, iswrite,
                                     extflag, errortype, secondstage, s2fs1walk);</del></p></div><div class="ps" psname="shared.debug.DoubleLockStatus.DoubleLockStatus"><a id="shared.debug.DoubleLockStatus.DoubleLockStatus" name="shared.debug.DoubleLockStatus.DoubleLockStatus"></a><h3 class="pseudocode">
            Library pseudocode for <ins>shared</ins><del>aarch64</del>/<ins>debug</ins><del>translation</del>/<ins>DoubleLockStatus</ins><del>faults</del>/<ins>DoubleLockStatus</ins><del>AArch64.AddressSizeFault</del></h3><p class="pseudocode"><ins>// DoubleLockStatus()
// ==================
// Returns the state of the OS Double Lock.
//    FALSE if OSDLR_EL1.DLK == 0 or DBGPRCR_EL1.CORENPDRQ == 1 or the PE is in Debug state.
//    TRUE if OSDLR_EL1.DLK == 1 and DBGPRCR_EL1.CORENPDRQ == 0 and the PE is in Non-debug state.
</ins><del>// AArch64.AddressSizeFault()
// ==========================
</del>
<ins>boolean</ins><del>FaultRecord</del> <a id="impl-shared.DoubleLockStatus.0" name="impl-shared.DoubleLockStatus.0"></a><ins>DoubleLockStatus()
    if !</ins><del>AArch64.AddressSizeFault(bits(52) ipaddress,bit NS, integer level,</del><a href="shared_pseudocode.html#impl-shared.HaveDoubleLock.0" title="function: boolean HaveDoubleLock()"><ins>HaveDoubleLock</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><ins>() then
        return FALSE;
    elsif</ins><del>acctype, boolean iswrite, boolean secondstage,
                                     boolean s2fs1walk)

    extflag = bit UNKNOWN;
    errortype = bits(2) UNKNOWN;
    return</del> <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><a href="shared_pseudocode.html#AArch64.CreateFaultRecord.10" title="function: FaultRecord AArch64.CreateFaultRecord(Fault type, bits(52) ipaddress, bit NS, integer level, AccType acctype, boolean write, bit extflag, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><del>AArch64.CreateFaultRecord</del></a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_AddressSize</del></a><ins>) then
        return DBGOSDLR.DLK == '1' &amp;&amp; DBGPRCR.CORENPDRQ == '0' &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><ins>Halted</ins></a><ins>();
    else
        return OSDLR_EL1.DLK == '1' &amp;&amp; DBGPRCR_EL1.CORENPDRQ == '0' &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><ins>Halted</ins></a><ins>();</ins><del>, ipaddress, NS, level, acctype, iswrite,
                                     extflag, errortype, secondstage, s2fs1walk);</del></p></div><div class="ps" psname="shared.debug.authentication.AllowExternalDebugAccess"><a id="shared.debug.authentication.AllowExternalDebugAccess" name="shared.debug.authentication.AllowExternalDebugAccess"></a><h3 class="pseudocode">
            Library pseudocode for <ins>shared</ins><del>aarch64</del>/<ins>debug</ins><del>translation</del>/<ins>authentication</ins><del>faults</del>/<ins>AllowExternalDebugAccess</ins><del>AArch64.AlignmentFault</del></h3><p class="pseudocode"><ins>// AllowExternalDebugAccess()
// ==========================
// Returns TRUE if the External Debugger access is allowed.
</ins><del>// AArch64.AlignmentFault()
// ========================
</del>
<ins>boolean</ins><del>FaultRecord</del> <a id="impl-shared.AllowExternalDebugAccess.1" name="impl-shared.AllowExternalDebugAccess.1"></a><ins>AllowExternalDebugAccess(boolean access_is_secure)
    // The access may also be subject to OS lock, power-down, etc.
    if</ins><del>AArch64.AlignmentFault(</del> <a href="shared_pseudocode.html#impl-shared.HaveSecureExtDebugView.0" title="function: boolean HaveSecureExtDebugView()"><ins>HaveSecureExtDebugView</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><ins>() ||</ins><del>acctype, boolean iswrite, boolean secondstage)

    ipaddress = bits(52) UNKNOWN;
    level = integer UNKNOWN;
    extflag = bit UNKNOWN;
    errortype = bits(2) UNKNOWN;
    s2fs1walk = boolean UNKNOWN;

    return</del> <a href="shared_pseudocode.html#impl-shared.ExternalDebugEnabled.0" title="function: boolean ExternalDebugEnabled()"><ins>ExternalDebugEnabled</ins></a><a href="shared_pseudocode.html#AArch64.CreateFaultRecord.10" title="function: FaultRecord AArch64.CreateFaultRecord(Fault type, bits(52) ipaddress, bit NS, integer level, AccType acctype, boolean write, bit extflag, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><del>AArch64.CreateFaultRecord</del></a><ins>() then
        if</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.HaveSecureExtDebugView.0" title="function: boolean HaveSecureExtDebugView()"><ins>HaveSecureExtDebugView</ins></a><a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_Alignment</del></a><ins>() then
            allow_secure = access_is_secure;
        else
            allow_secure = </ins><a href="shared_pseudocode.html#impl-shared.ExternalSecureDebugEnabled.0" title="function: boolean ExternalSecureDebugEnabled()"><ins>ExternalSecureDebugEnabled</ins></a><ins>();

        if allow_secure then
            return TRUE;
        elsif </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) then
            return (if </ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) then SDCR.EDAD else MDCR_EL3.EDAD) == '0';
        else
            return !</ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>();
    else
        return FALSE;</ins><del>, ipaddress, bit UNKNOWN, level, acctype, iswrite,
                                     extflag, errortype, secondstage, s2fs1walk);</del></p></div><div class="ps" psname="shared.debug.authentication.AllowExternalPMUAccess"><a id="shared.debug.authentication.AllowExternalPMUAccess" name="shared.debug.authentication.AllowExternalPMUAccess"></a><h3 class="pseudocode">
            Library pseudocode for <ins>shared</ins><del>aarch64</del>/<ins>debug</ins><del>translation</del>/<ins>authentication</ins><del>faults</del>/<ins>AllowExternalPMUAccess</ins><del>AArch64.AsynchExternalAbort</del></h3><p class="pseudocode"><ins>// AllowExternalPMUAccess()
// ========================
// Returns TRUE if the External Debugger access is allowed.
</ins><del>// AArch64.AsynchExternalAbort()
// =============================
// Wrapper function for asynchronous external aborts
</del>
<ins>boolean</ins><del>FaultRecord</del> <a id="impl-shared.AllowExternalPMUAccess.1" name="impl-shared.AllowExternalPMUAccess.1"></a><ins>AllowExternalPMUAccess(boolean access_is_secure)
    // The access may also be subject to OS lock, power-down, etc.
    if</ins><del>AArch64.AsynchExternalAbort(boolean parity, bits(2) errortype, bit extflag)

    type = if parity then</del> <a href="shared_pseudocode.html#impl-shared.HaveSecureExtDebugView.0" title="function: boolean HaveSecureExtDebugView()"><ins>HaveSecureExtDebugView</ins></a><a href="shared_pseudocode.html#Fault_AsyncParity" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_AsyncParity</del></a><ins>() ||</ins><del>else</del> <a href="shared_pseudocode.html#impl-shared.ExternalNoninvasiveDebugEnabled.0" title="function: boolean ExternalNoninvasiveDebugEnabled()"><ins>ExternalNoninvasiveDebugEnabled</ins></a><a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_AsyncExternal</del></a><ins>() then
        if</ins><del>;
    ipaddress = bits(52) UNKNOWN;
    level = integer UNKNOWN;
    acctype =</del> <a href="shared_pseudocode.html#impl-shared.HaveSecureExtDebugView.0" title="function: boolean HaveSecureExtDebugView()"><ins>HaveSecureExtDebugView</ins></a><a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NORMAL</del></a><ins>() then
            allow_secure = access_is_secure;
        else
            allow_secure =</ins><del>;
    iswrite = boolean UNKNOWN;
    secondstage = FALSE;
    s2fs1walk = FALSE;

    return</del> <a href="shared_pseudocode.html#impl-shared.ExternalSecureNoninvasiveDebugEnabled.0" title="function: boolean ExternalSecureNoninvasiveDebugEnabled()"><ins>ExternalSecureNoninvasiveDebugEnabled</ins></a><a href="shared_pseudocode.html#AArch64.CreateFaultRecord.10" title="function: FaultRecord AArch64.CreateFaultRecord(Fault type, bits(52) ipaddress, bit NS, integer level, AccType acctype, boolean write, bit extflag, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><del>AArch64.CreateFaultRecord</del></a><ins>();
        if allow_secure then
            return TRUE;
        elsif </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) then
            return (if </ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) then SDCR.EPMAD else MDCR_EL3.EPMAD) == '0';
        else
            return !</ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>();
    else
        return FALSE;</ins><del>(type, ipaddress, bit UNKNOWN, level, acctype, iswrite, extflag,
                                      errortype, secondstage, s2fs1walk);</del></p></div><div class="ps" psname="shared.debug.authentication.Debug_authentication"><a id="shared.debug.authentication.Debug_authentication" name="shared.debug.authentication.Debug_authentication"></a><h3 class="pseudocode">
            Library pseudocode for <ins>shared</ins><del>aarch64</del>/<ins>debug</ins><del>translation</del>/<ins>authentication</ins><del>faults</del>/<ins>Debug_authentication</ins><del>AArch64.DebugFault</del></h3><p class="pseudocode"><ins>signal DBGEN;
signal NIDEN;
signal SPIDEN;
signal SPNIDEN;</ins><del>// AArch64.DebugFault()
// ====================

FaultRecord</del><a id="AArch64.DebugFault.2" name="AArch64.DebugFault.2"></a><del>AArch64.DebugFault(</del><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><del> acctype, boolean iswrite)

    ipaddress = bits(52) UNKNOWN;
    errortype = bits(2) UNKNOWN;
    level = integer UNKNOWN;
    extflag = bit UNKNOWN;
    secondstage = FALSE;
    s2fs1walk = FALSE;

    return </del><a href="shared_pseudocode.html#AArch64.CreateFaultRecord.10" title="function: FaultRecord AArch64.CreateFaultRecord(Fault type, bits(52) ipaddress, bit NS, integer level, AccType acctype, boolean write, bit extflag, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><del>AArch64.CreateFaultRecord</del></a><del>(</del><a href="shared_pseudocode.html#Fault_Debug" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_Debug</del></a><del>, ipaddress, bit UNKNOWN, level, acctype, iswrite,
                                     extflag, errortype, secondstage, s2fs1walk);</del></p></div><div class="ps" psname="shared.debug.authentication.ExternalDebugEnabled"><a id="shared.debug.authentication.ExternalDebugEnabled" name="shared.debug.authentication.ExternalDebugEnabled"></a><h3 class="pseudocode">
            Library pseudocode for <ins>shared</ins><del>aarch64</del>/<ins>debug</ins><del>translation</del>/<ins>authentication</ins><del>faults</del>/<ins>ExternalDebugEnabled</ins><del>AArch64.NoFault</del></h3><p class="pseudocode"><ins>// ExternalDebugEnabled()
// ======================
</ins><del>// AArch64.NoFault()
// =================
</del>
<ins>boolean</ins><del>FaultRecord</del> <a id="impl-shared.ExternalDebugEnabled.0" name="impl-shared.ExternalDebugEnabled.0"></a><ins>ExternalDebugEnabled()
    // The definition of this function is IMPLEMENTATION DEFINED.
    // In the recommended interface, this function returns the state of the DBGEN signal.
    return DBGEN == HIGH;</ins><del>AArch64.NoFault()

    ipaddress = bits(52) UNKNOWN;
    level = integer UNKNOWN;
    acctype =</del><a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NORMAL</del></a><del>;
    iswrite = boolean UNKNOWN;
    extflag = bit UNKNOWN;
    errortype = bits(2) UNKNOWN;
    secondstage = FALSE;
    s2fs1walk = FALSE;

    return </del><a href="shared_pseudocode.html#AArch64.CreateFaultRecord.10" title="function: FaultRecord AArch64.CreateFaultRecord(Fault type, bits(52) ipaddress, bit NS, integer level, AccType acctype, boolean write, bit extflag, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><del>AArch64.CreateFaultRecord</del></a><del>(</del><a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_None</del></a><del>, ipaddress, bit UNKNOWN, level, acctype, iswrite,
                                     extflag, errortype, secondstage, s2fs1walk);</del></p></div><div class="ps" psname="shared.debug.authentication.ExternalHypInvasiveDebugEnabled"><a id="shared.debug.authentication.ExternalHypInvasiveDebugEnabled" name="shared.debug.authentication.ExternalHypInvasiveDebugEnabled"></a><h3 class="pseudocode">
            Library pseudocode for <ins>shared</ins><del>aarch64</del>/<ins>debug</ins><del>translation</del>/<ins>authentication</ins><del>faults</del>/<ins>ExternalHypInvasiveDebugEnabled</ins><del>AArch64.PermissionFault</del></h3><p class="pseudocode"><ins>// ExternalHypInvasiveDebugEnabled()
// =================================
</ins><del>// AArch64.PermissionFault()
// =========================
</del>
<ins>boolean</ins><del>FaultRecord</del> <a id="impl-shared.ExternalHypInvasiveDebugEnabled.0" name="impl-shared.ExternalHypInvasiveDebugEnabled.0"></a><ins>ExternalHypInvasiveDebugEnabled()
    // In the recommended interface, ExternalHypInvasiveDebugEnabled returns the state of the
    // (DBGEN AND HIDEN) signal.
    return</ins><del>AArch64.PermissionFault(bits(52) ipaddress,bit NS, integer level,</del> <del> acctype, boolean iswrite, boolean secondstage,
                                    boolean s2fs1walk)

    extflag = bit UNKNOWN;
    errortype = bits(2) UNKNOWN;
    return </del><a href="shared_pseudocode.html#AArch64.CreateFaultRecord.10" title="function: FaultRecord AArch64.CreateFaultRecord(Fault type, bits(52) ipaddress, bit NS, integer level, AccType acctype, boolean write, bit extflag, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><del>AArch64.CreateFaultRecord</del></a><del>(</del><a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_Permission</del></a><a href="shared_pseudocode.html#impl-shared.ExternalDebugEnabled.0" title="function: boolean ExternalDebugEnabled()"><ins>ExternalDebugEnabled</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><ins>() &amp;&amp; HIDEN == HIGH;</ins><del>, ipaddress, NS, level, acctype, iswrite,
                                     extflag, errortype, secondstage, s2fs1walk);</del></p></div><div class="ps" psname="shared.debug.authentication.ExternalHypNoninvasiveDebugEnabled"><a id="shared.debug.authentication.ExternalHypNoninvasiveDebugEnabled" name="shared.debug.authentication.ExternalHypNoninvasiveDebugEnabled"></a><h3 class="pseudocode">
            Library pseudocode for <ins>shared</ins><del>aarch64</del>/<ins>debug</ins><del>translation</del>/<ins>authentication</ins><del>faults</del>/<ins>ExternalHypNoninvasiveDebugEnabled</ins><del>AArch64.TranslationFault</del></h3><p class="pseudocode"><ins>// ExternalHypNoninvasiveDebugEnabled()
// ====================================
</ins><del>// AArch64.TranslationFault()
// ==========================
</del>
<ins>boolean</ins><del>FaultRecord</del> <a id="impl-shared.ExternalHypNoninvasiveDebugEnabled.0" name="impl-shared.ExternalHypNoninvasiveDebugEnabled.0"></a><ins>ExternalHypNoninvasiveDebugEnabled()
    // The definition of this function is IMPLEMENTATION DEFINED.
    // In the recommended interface, ExternalHypNoninvasiveDebugEnabled returns the state of the
    // (DBGEN OR NIDEN) AND (HIDEN OR HNIDEN) signal.
    return</ins><del>AArch64.TranslationFault(bits(52) ipaddress, bit NS, integer level,</del> <del> acctype, boolean iswrite, boolean secondstage,
                                     boolean s2fs1walk)

    extflag = bit UNKNOWN;
    errortype = bits(2) UNKNOWN;
    return </del><a href="shared_pseudocode.html#AArch64.CreateFaultRecord.10" title="function: FaultRecord AArch64.CreateFaultRecord(Fault type, bits(52) ipaddress, bit NS, integer level, AccType acctype, boolean write, bit extflag, bits(2) errortype, boolean secondstage, boolean s2fs1walk)"><del>AArch64.CreateFaultRecord</del></a><del>(</del><a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_Translation</del></a><a href="shared_pseudocode.html#impl-shared.ExternalNoninvasiveDebugEnabled.0" title="function: boolean ExternalNoninvasiveDebugEnabled()"><ins>ExternalNoninvasiveDebugEnabled</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><ins>() &amp;&amp; (HIDEN == HIGH || HNIDEN == HIGH);</ins><del>, ipaddress, NS, level, acctype, iswrite,
                                     extflag, errortype, secondstage, s2fs1walk);</del></p></div><div class="ps" psname="shared.debug.authentication.ExternalNoninvasiveDebugAllowed"><a id="shared.debug.authentication.ExternalNoninvasiveDebugAllowed" name="shared.debug.authentication.ExternalNoninvasiveDebugAllowed"></a><h3 class="pseudocode">
            Library pseudocode for <ins>shared</ins><del>aarch64</del>/<ins>debug</ins><del>translation</del>/<ins>authentication</ins><del>translation</del>/<ins>ExternalNoninvasiveDebugAllowed</ins><del>AArch64.CheckAndUpdateDescriptor</del></h3><p class="pseudocode"><ins>// ExternalNoninvasiveDebugAllowed()
// =================================
</ins><del>// AArch64.CheckAndUpdateDescriptor()
// ==================================
// Check and update translation table descriptor if hardware update is configured
</del>
<ins>boolean</ins><del>FaultRecord</del> <a id="impl-shared.ExternalNoninvasiveDebugAllowed.0" name="impl-shared.ExternalNoninvasiveDebugAllowed.0"></a><ins>ExternalNoninvasiveDebugAllowed()
    // Return TRUE if Trace and PC Sample-based Profiling are allowed
    return (</ins><del>AArch64.CheckAndUpdateDescriptor(</del><a href="shared_pseudocode.html#impl-shared.ExternalNoninvasiveDebugEnabled.0" title="function: boolean ExternalNoninvasiveDebugEnabled()"><ins>ExternalNoninvasiveDebugEnabled</ins></a><a href="shared_pseudocode.html#DescriptorUpdate" title="type DescriptorUpdate is ( boolean AF, boolean AP, AddressDescriptor descaddr )"><del>DescriptorUpdate</del></a><ins>() &amp;&amp;
            (!</ins><del>result,</del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><del>FaultRecord</del></a><ins>() ||</ins><del>fault,
                                             boolean secondstage, bits(64) vaddress,</del> <a href="shared_pseudocode.html#impl-shared.ExternalSecureNoninvasiveDebugEnabled.0" title="function: boolean ExternalSecureNoninvasiveDebugEnabled()"><ins>ExternalSecureNoninvasiveDebugEnabled</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><ins>() ||
             (</ins><del>acctype,
                                             boolean iswrite, boolean s2fs1walk, boolean hwupdatewalk)

    // Check if access flag can be updated
    // Address translation instructions are permitted to update AF but not required
    if result.AF then
        if fault.type ==</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_None</del></a><ins>(</ins><del>then
            hw_update_AF = TRUE;
        elsif</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><del>ConstrainUnpredictable</del></a><ins>) &amp;&amp; PSTATE.EL ==</ins><del>(</del> <del>) == </del><a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_TRUE</del></a><del> then
            hw_update_AF = TRUE;
        else
            hw_update_AF = FALSE;

    if result.AP &amp;&amp; fault.type == </del><a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_None</del></a><del> then
        write_perm_req = (iswrite || acctype IN {</del><a href="shared_pseudocode.html#AccType_ATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ATOMICRW</del></a><del>,</del><a href="shared_pseudocode.html#AccType_ORDEREDRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ORDEREDRW</del></a><del>, </del><a href="shared_pseudocode.html#AccType_ORDEREDATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ORDEREDATOMICRW</del></a><del> }) &amp;&amp; !s2fs1walk;
        hw_update_AP = (write_perm_req &amp;&amp; !(acctype IN {</del><a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_AT</del></a><del>, </del><a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_DC</del></a><del>, </del><a href="shared_pseudocode.html#AccType_DC_UNPRIV" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_DC_UNPRIV</del></a><del>})) || hwupdatewalk;
    else
        hw_update_AP = FALSE;

    if hw_update_AF || hw_update_AP then
        if secondstage || !</del><a href="shared_pseudocode.html#impl-shared.HasS2Translation.0" title="function: boolean HasS2Translation()"><del>HasS2Translation</del></a><del>() then
            descaddr2 = result.descaddr;
        else
            hwupdatewalk = TRUE;
            descaddr2 = </del><a href="shared_pseudocode.html#AArch64.SecondStageWalk.6" title="function: AddressDescriptor AArch64.SecondStageWalk(AddressDescriptor S1, bits(64) vaddress, AccType acctype, boolean iswrite, integer size, boolean hwupdatewalk)"><del>AArch64.SecondStageWalk</del></a><del>(result.descaddr, vaddress, acctype, iswrite, 8, hwupdatewalk);
            if </del><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><del>(descaddr2) then
                return descaddr2.fault;

        accdesc = CreateAccessDescriptor(</del><a href="shared_pseudocode.html#AccType_ATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_ATOMICRW</del></a><del>);
        desc = _Mem[descaddr2, 8, accdesc];
        el = </del><a href="shared_pseudocode.html#AArch64.AccessUsesEL.1" title="function: bits(2) AArch64.AccessUsesEL(AccType acctype)"><del>AArch64.AccessUsesEL</del></a><del>(acctype);
        case el of
            when </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>
                reversedescriptors = SCTLR_EL3.EE == '1';
            when </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>
                reversedescriptors = SCTLR_EL2.EE == '1';
            otherwise
                reversedescriptors = SCTLR_EL1.EE == '1';
        if reversedescriptors then
            desc = </del><a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)"><del>BigEndianReverse</del></a><del>(desc);

        if hw_update_AF then
            desc&lt;10> = '1';
        if hw_update_AP then
            desc&lt;7> = (if secondstage then '1' else '0');

        _Mem[descaddr2,8,accdesc] = if reversedescriptors then </del><a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)"><del>BigEndianReverse</del></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#Unpredictable_AFUPDATE" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_AFUPDATE</del></a> <ins>&amp;&amp; SDER.SUNIDEN == '1')));</ins><del>(desc) else desc;

    return fault;</del></p></div><div class="ps" psname="shared.debug.authentication.ExternalNoninvasiveDebugEnabled"><a id="shared.debug.authentication.ExternalNoninvasiveDebugEnabled" name="shared.debug.authentication.ExternalNoninvasiveDebugEnabled"></a><h3 class="pseudocode">
            Library pseudocode for <ins>shared</ins><del>aarch64</del>/<ins>debug</ins><del>translation</del>/<ins>authentication</ins><del>translation</del>/<ins>ExternalNoninvasiveDebugEnabled</ins><del>AArch64.FirstStageTranslate</del></h3><p class="pseudocode"><ins>// ExternalNoninvasiveDebugEnabled()
// =================================
</ins><del>// AArch64.FirstStageTranslate()
// =============================
// Perform a stage 1 translation walk. The function used by Address Translation operations is
// similar except it uses the translation regime specified for the instruction.
</del>
<ins>boolean</ins><del>AddressDescriptor</del> <a id="impl-shared.ExternalNoninvasiveDebugEnabled.0" name="impl-shared.ExternalNoninvasiveDebugEnabled.0"></a><ins>ExternalNoninvasiveDebugEnabled()
    // This function returns TRUE if the v8.4 Debug relaxations are implemented, otherwise this
    // function is IMPLEMENTATION DEFINED.
    // In the recommended interface, ExternalNoninvasiveDebugEnabled returns the state of the (DBGEN
    // OR NIDEN) signal.
    return !</ins><del>AArch64.FirstStageTranslate(bits(64) vaddress,</del><a href="shared_pseudocode.html#impl-shared.HaveNoninvasiveDebugAuth.0" title="function: boolean HaveNoninvasiveDebugAuth()"><ins>HaveNoninvasiveDebugAuth</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><ins>() ||</ins><del>acctype, boolean iswrite,
                                              boolean wasaligned, integer size)

    if</del> <del>() &amp;&amp; acctype == </del><a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NV2REGISTER</del></a><del> then
        s1_enabled = SCTLR_EL2.M == '1';
    elsif </del><a href="shared_pseudocode.html#impl-shared.HasS2Translation.0" title="function: boolean HasS2Translation()"><del>HasS2Translation</del></a><del>() then
        s1_enabled = HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.DC == '0' &amp;&amp; SCTLR_EL1.M == '1';
    else
        s1_enabled = </del><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><del>SCTLR</del></a><del>[].M == '1';

    ipaddress = bits(52) UNKNOWN;
    secondstage = FALSE;
    s2fs1walk = FALSE;

    if s1_enabled then                         // First stage enabled
        S1 = </del><a href="shared_pseudocode.html#AArch64.TranslationTableWalk.8" title="function: TLBRecord AArch64.TranslationTableWalk(bits(52) ipaddress, bit s1_nonsecure, bits(64) vaddress, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk, integer size)"><del>AArch64.TranslationTableWalk</del></a><del>(ipaddress, '1', vaddress, acctype, iswrite, secondstage,
                                            s2fs1walk, size);
        permissioncheck = TRUE;
        if acctype == </del><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IFETCH</del></a><del> then
            InGuardedPage = S1.GP == '1';      // Global state updated on instruction fetch that denotes
                                               // if the fetched instruction is from a guarded page.
    else
        S1 = </del><a href="shared_pseudocode.html#AArch64.TranslateAddressS1Off.3" title="function: TLBRecord AArch64.TranslateAddressS1Off(bits(64) vaddress, AccType acctype, boolean iswrite)"><del>AArch64.TranslateAddressS1Off</del></a><del>(vaddress, acctype, iswrite);
        permissioncheck = FALSE;
        if </del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>() &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.HaveTrapLoadStoreMultipleDeviceExt.0" title="function: boolean HaveTrapLoadStoreMultipleDeviceExt()"><del>HaveTrapLoadStoreMultipleDeviceExt</del></a><del>() &amp;&amp; </del><a href="shared_pseudocode.html#AArch32.ExecutingLSMInstr.0" title="function: boolean AArch32.ExecutingLSMInstr()"><del>AArch32.ExecutingLSMInstr</del></a><del>() then
            if S1.addrdesc.memattrs.type == </del><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Device</del></a><del> &amp;&amp; S1.addrdesc.memattrs.device != </del><a href="shared_pseudocode.html#DeviceType_GRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType_GRE</del></a><del> then
                nTLSMD = if </del><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><del>() == </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del> then SCTLR_EL2.nTLSMD else SCTLR_EL1.nTLSMD;
                if nTLSMD == '0' then
                    S1.addrdesc.fault = </del><a href="shared_pseudocode.html#AArch64.AlignmentFault.3" title="function: FaultRecord AArch64.AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)"><del>AArch64.AlignmentFault</del></a><del>(acctype, iswrite, secondstage);

    // Check for unaligned data accesses to Device memory
    if ((!wasaligned &amp;&amp; acctype != </del><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IFETCH</del></a><del>) || (acctype == </del><a href="shared_pseudocode.html#AccType_DCZVA" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_DCZVA</del></a><del>))
        &amp;&amp; S1.addrdesc.memattrs.type == </del><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Device</del></a><del> &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><del>(S1.addrdesc) then
        S1.addrdesc.fault = </del><a href="shared_pseudocode.html#AArch64.AlignmentFault.3" title="function: FaultRecord AArch64.AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)"><del>AArch64.AlignmentFault</del></a><del>(acctype, iswrite, secondstage);
    if !</del><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><del>(S1.addrdesc) &amp;&amp; permissioncheck then
        S1.addrdesc.fault = </del><a href="shared_pseudocode.html#AArch64.CheckPermission.6" title="function: FaultRecord AArch64.CheckPermission(Permissions perms, bits(64) vaddress, integer level, bit NS, AccType acctype, boolean iswrite)"><del>AArch64.CheckPermission</del></a><del>(S1.perms, vaddress, S1.level,
                                                    S1.addrdesc.paddress.NS,
                                                    acctype, iswrite);

    // Check for instruction fetches from Device memory not marked as execute-never. If there has
    // not been a Permission Fault then the memory is not marked execute-never.
    if (!</del><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><del>(S1.addrdesc) &amp;&amp; S1.addrdesc.memattrs.type == </del><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Device</del></a><del> &amp;&amp;
        acctype == </del><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IFETCH</del></a><del>) then
        S1.addrdesc = </del><a href="shared_pseudocode.html#AArch64.InstructionDevice.8" title="function: AddressDescriptor AArch64.InstructionDevice(AddressDescriptor addrdesc, bits(64) vaddress, bits(52) ipaddress, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><del>AArch64.InstructionDevice</del></a><del>(S1.addrdesc, vaddress, ipaddress, S1.level,
                                                acctype, iswrite,
                                                secondstage, s2fs1walk);
    // Check and update translation table descriptor if required
    hwupdatewalk = FALSE;
    s2fs1walk = FALSE;
    S1.addrdesc.fault = </del><a href="shared_pseudocode.html#AArch64.CheckAndUpdateDescriptor.8" title="function: FaultRecord AArch64.CheckAndUpdateDescriptor(DescriptorUpdate result, FaultRecord fault, boolean secondstage, bits(64) vaddress, AccType acctype, boolean iswrite, boolean s2fs1walk, boolean hwupdatewalk)"><del>AArch64.CheckAndUpdateDescriptor</del></a><a href="shared_pseudocode.html#impl-shared.ExternalDebugEnabled.0" title="function: boolean ExternalDebugEnabled()"><ins>ExternalDebugEnabled</ins></a><a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()"><del>HaveNV2Ext</del></a><ins>() || NIDEN == HIGH;</ins><del>(S1.descupdate, S1.addrdesc.fault,
                                                         secondstage, vaddress, acctype,
                                                         iswrite, s2fs1walk, hwupdatewalk);

    return S1.addrdesc;</del></p></div><div class="ps" psname="shared.debug.authentication.ExternalSecureDebugEnabled"><a id="shared.debug.authentication.ExternalSecureDebugEnabled" name="shared.debug.authentication.ExternalSecureDebugEnabled"></a><h3 class="pseudocode">
            Library pseudocode for <ins>shared</ins><del>aarch64</del>/<ins>debug</ins><del>translation</del>/<ins>authentication</ins><del>translation</del>/<ins>ExternalSecureDebugEnabled</ins><del>AArch64.FullTranslate</del></h3><p class="pseudocode"><ins>// ExternalSecureDebugEnabled()
// ============================
</ins><del>// AArch64.FullTranslate()
// =======================
// Perform both stage 1 and stage 2 translation walks for the current translation regime. The
// function used by Address Translation operations is similar except it uses the translation
// regime specified for the instruction.
</del>
<ins>boolean</ins><del>AddressDescriptor</del> <a id="impl-shared.ExternalSecureDebugEnabled.0" name="impl-shared.ExternalSecureDebugEnabled.0"></a><ins>ExternalSecureDebugEnabled()
    if !</ins><del>AArch64.FullTranslate(bits(64) vaddress,</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><ins>(</ins><del>acctype, boolean iswrite,
                                        boolean wasaligned, integer size)

    // First Stage Translation
    S1 =</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#AArch64.FirstStageTranslate.5" title="function: AddressDescriptor AArch64.FirstStageTranslate(bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><del>AArch64.FirstStageTranslate</del></a><ins>) &amp;&amp; !</ins><del>(vaddress, acctype, iswrite, wasaligned, size);
    if !</del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><ins>() then return FALSE;
    // The definition of this function is IMPLEMENTATION DEFINED.
    // In the recommended interface, this function returns the state of the (DBGEN AND SPIDEN) signal.
    // CoreSight allows asserting SPIDEN without also asserting DBGEN, but this is not recommended.
    return</ins><del>(S1) &amp;&amp; !(</del> <del>() &amp;&amp; acctype == </del><a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NV2REGISTER</del></a><del>) &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.HasS2Translation.0" title="function: boolean HasS2Translation()"><del>HasS2Translation</del></a><del>() then
        s2fs1walk = FALSE;
        hwupdatewalk = FALSE;
        result = </del><a href="shared_pseudocode.html#AArch64.SecondStageTranslate.8" title="function: AddressDescriptor AArch64.SecondStageTranslate(AddressDescriptor S1, bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, boolean s2fs1walk, integer size, boolean hwupdatewalk)"><del>AArch64.SecondStageTranslate</del></a><a href="shared_pseudocode.html#impl-shared.ExternalDebugEnabled.0" title="function: boolean ExternalDebugEnabled()"><ins>ExternalDebugEnabled</ins></a><a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()"><del>HaveNV2Ext</del></a><ins>() &amp;&amp; SPIDEN == HIGH;</ins><del>(S1, vaddress, acctype, iswrite, wasaligned, s2fs1walk,
                                              size, hwupdatewalk);
    else
        result = S1;

    return result;</del></p></div><div class="ps" psname="shared.debug.authentication.ExternalSecureNoninvasiveDebugEnabled"><a id="shared.debug.authentication.ExternalSecureNoninvasiveDebugEnabled" name="shared.debug.authentication.ExternalSecureNoninvasiveDebugEnabled"></a><h3 class="pseudocode">
            Library pseudocode for <ins>shared</ins><del>aarch64</del>/<ins>debug</ins><del>translation</del>/<ins>authentication</ins><del>translation</del>/<ins>ExternalSecureNoninvasiveDebugEnabled</ins><del>AArch64.SecondStageTranslate</del></h3><p class="pseudocode"><ins>// ExternalSecureNoninvasiveDebugEnabled()
// =======================================
</ins><del>// AArch64.SecondStageTranslate()
// ==============================
// Perform a stage 2 translation walk. The function used by Address Translation operations is
// similar except it uses the translation regime specified for the instruction.
</del>
<ins>boolean</ins><del>AddressDescriptor</del> <a id="impl-shared.ExternalSecureNoninvasiveDebugEnabled.0" name="impl-shared.ExternalSecureNoninvasiveDebugEnabled.0"></a><ins>ExternalSecureNoninvasiveDebugEnabled()
    if !</ins><del>AArch64.SecondStageTranslate(</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><del>AddressDescriptor</del></a><ins>(</ins><del>S1, bits(64) vaddress,</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><ins>) &amp;&amp; !</ins><del>acctype, boolean iswrite, boolean wasaligned,
                                               boolean s2fs1walk, integer size, boolean hwupdatewalk)
    assert</del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><a href="shared_pseudocode.html#impl-shared.HasS2Translation.0" title="function: boolean HasS2Translation()"><del>HasS2Translation</del></a><ins>() then return FALSE;
    // If the v8.4 Debug relaxations are implemented, this function returns the value of
    // ExternalSecureDebugEnabled(). Otherwise the definition of this function is
    // IMPLEMENTATION DEFINED.
    // In the recommended interface, this function returns the state of the (DBGEN OR NIDEN) AND
    // (SPIDEN OR SPNIDEN) signal.
    if</ins><del>();

    s2_enabled = HCR_EL2.VM == '1' || HCR_EL2.DC == '1';
    secondstage = TRUE;

    if s2_enabled then                        // Second stage enabled
        ipaddress = S1.paddress.address&lt;51:0>;
        NS = S1.paddress.NS;
        S2 =</del> <a href="shared_pseudocode.html#impl-shared.HaveNoninvasiveDebugAuth.0" title="function: boolean HaveNoninvasiveDebugAuth()"><ins>HaveNoninvasiveDebugAuth</ins></a><a href="shared_pseudocode.html#AArch64.TranslationTableWalk.8" title="function: TLBRecord AArch64.TranslationTableWalk(bits(52) ipaddress, bit s1_nonsecure, bits(64) vaddress, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk, integer size)"><del>AArch64.TranslationTableWalk</del></a><ins>() then
        return</ins><del>(ipaddress, NS, vaddress, acctype, iswrite, secondstage,
                                            s2fs1walk, size);

        // Check for unaligned data accesses to Device memory
        if ((!wasaligned &amp;&amp; acctype !=</del> <a href="shared_pseudocode.html#impl-shared.ExternalNoninvasiveDebugEnabled.0" title="function: boolean ExternalNoninvasiveDebugEnabled()"><ins>ExternalNoninvasiveDebugEnabled</ins></a><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IFETCH</del></a><ins>() &amp;&amp; (SPIDEN == HIGH || SPNIDEN == HIGH);
    else
        return</ins><del>) || (acctype ==</del> <del>))
            &amp;&amp; S2.addrdesc.memattrs.type == </del><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Device</del></a><del> &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><del>(S2.addrdesc) then
            S2.addrdesc.fault = </del><a href="shared_pseudocode.html#AArch64.AlignmentFault.3" title="function: FaultRecord AArch64.AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)"><del>AArch64.AlignmentFault</del></a><del>(acctype, iswrite, secondstage);

        // Check for permissions on Stage2 translations
        if !</del><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><del>(S2.addrdesc) then
            S2.addrdesc.fault = </del><a href="shared_pseudocode.html#AArch64.CheckS2Permission.9" title="function: FaultRecord AArch64.CheckS2Permission(Permissions perms, bits(64) vaddress, bits(52) ipaddress, integer level, AccType acctype, boolean iswrite, bit NS, boolean s2fs1walk, boolean hwupdatewalk)"><del>AArch64.CheckS2Permission</del></a><del>(S2.perms, vaddress, ipaddress, S2.level,
                                                          acctype, iswrite, NS,s2fs1walk, hwupdatewalk);

        // Check for instruction fetches from Device memory not marked as execute-never. As there
        // has not been a Permission Fault then the memory is not marked execute-never.
        if (!s2fs1walk &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><del>(S2.addrdesc) &amp;&amp; S2.addrdesc.memattrs.type == </del><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Device</del></a><del> &amp;&amp;
            acctype == </del><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IFETCH</del></a><del>) then
            S2.addrdesc = </del><a href="shared_pseudocode.html#AArch64.InstructionDevice.8" title="function: AddressDescriptor AArch64.InstructionDevice(AddressDescriptor addrdesc, bits(64) vaddress, bits(52) ipaddress, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><del>AArch64.InstructionDevice</del></a><del>(S2.addrdesc, vaddress, ipaddress, S2.level,
                                                    acctype, iswrite,
                                                    secondstage, s2fs1walk);

        // Check for protected table walk
        if (s2fs1walk &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><del>(S2.addrdesc) &amp;&amp; HCR_EL2.PTW == '1' &amp;&amp;
            S2.addrdesc.memattrs.type == </del><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Device</del></a><del>) then
            S2.addrdesc.fault = </del><a href="shared_pseudocode.html#AArch64.PermissionFault.7" title="function: FaultRecord AArch64.PermissionFault(bits(52) ipaddress,bit NS, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><del>AArch64.PermissionFault</del></a><del>(ipaddress, S1.paddress.NS,  S2.level, acctype,
                                                        iswrite, secondstage, s2fs1walk);

        // Check and update translation table descriptor if required
        S2.addrdesc.fault = </del><a href="shared_pseudocode.html#AArch64.CheckAndUpdateDescriptor.8" title="function: FaultRecord AArch64.CheckAndUpdateDescriptor(DescriptorUpdate result, FaultRecord fault, boolean secondstage, bits(64) vaddress, AccType acctype, boolean iswrite, boolean s2fs1walk, boolean hwupdatewalk)"><del>AArch64.CheckAndUpdateDescriptor</del></a><del>(S2.descupdate, S2.addrdesc.fault,
                                                             secondstage, vaddress, acctype,
                                                             iswrite, s2fs1walk, hwupdatewalk);
        result = </del><a href="shared_pseudocode.html#impl-shared.CombineS1S2Desc.2" title="function: AddressDescriptor CombineS1S2Desc(AddressDescriptor s1desc, AddressDescriptor s2desc)"><del>CombineS1S2Desc</del></a><a href="shared_pseudocode.html#impl-shared.ExternalSecureDebugEnabled.0" title="function: boolean ExternalSecureDebugEnabled()"><ins>ExternalSecureDebugEnabled</ins></a><a href="shared_pseudocode.html#AccType_DCZVA" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_DCZVA</del></a><ins>();</ins><del>(S1, S2.addrdesc);
    else
        result = S1;

    return result;</del></p></div><div class="ps" psname="shared.debug.cti.CTI_SetEventLevel"><a id="shared.debug.cti.CTI_SetEventLevel" name="shared.debug.cti.CTI_SetEventLevel"></a><h3 class="pseudocode">
            Library pseudocode for <ins>shared</ins><del>aarch64</del>/<ins>debug</ins><del>translation</del>/<ins>cti</ins><del>translation</del>/<ins>CTI_SetEventLevel</ins><del>AArch64.SecondStageWalk</del></h3><p class="pseudocode"><ins>// Set a Cross Trigger multi-cycle input event trigger to the specified level.
CTI_SetEventLevel(</ins><del>// AArch64.SecondStageWalk()
// =========================
// Perform a stage 2 translation on a stage 1 translation page table walk access.

AddressDescriptor</del><del>AArch64.SecondStageWalk(</del><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><del>AddressDescriptor</del></a><del> S1, bits(64) vaddress, </del><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><del> acctype,
                                          boolean iswrite, integer size, boolean hwupdatewalk)

    assert </del><a href="shared_pseudocode.html#impl-shared.HasS2Translation.0" title="function: boolean HasS2Translation()"><del>HasS2Translation</del></a><del>();

    s2fs1walk = TRUE;
    wasaligned = TRUE;
    return </del><a href="shared_pseudocode.html#AArch64.SecondStageTranslate.8" title="function: AddressDescriptor AArch64.SecondStageTranslate(AddressDescriptor S1, bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, boolean s2fs1walk, integer size, boolean hwupdatewalk)"><del>AArch64.SecondStageTranslate</del></a><a href="shared_pseudocode.html#CrossTriggerIn" title="enumeration CrossTriggerIn  {CrossTriggerIn_CrossHalt,     CrossTriggerIn_PMUOverflow, CrossTriggerIn_RSVD2,         CrossTriggerIn_RSVD3, CrossTriggerIn_TraceExtOut0,  CrossTriggerIn_TraceExtOut1, CrossTriggerIn_TraceExtOut2,  CrossTriggerIn_TraceExtOut3}"><ins>CrossTriggerIn</ins></a> <ins>id, signal level);</ins><del>(S1, vaddress, acctype, iswrite, wasaligned, s2fs1walk,
                                        size, hwupdatewalk);</del></p></div><div class="ps" psname="shared.debug.cti.CTI_SignalEvent"><a id="shared.debug.cti.CTI_SignalEvent" name="shared.debug.cti.CTI_SignalEvent"></a><h3 class="pseudocode">
            Library pseudocode for <ins>shared</ins><del>aarch64</del>/<ins>debug</ins><del>translation</del>/<ins>cti</ins><del>translation</del>/<ins>CTI_SignalEvent</ins><del>AArch64.TranslateAddress</del></h3><p class="pseudocode"><ins>// Signal a discrete event on a Cross Trigger input event trigger.</ins><del>// AArch64.TranslateAddress()
// ==========================
// Main entry point for translating an address

AddressDescriptor</del>
<a id="impl-shared.CTI_SignalEvent.1" name="impl-shared.CTI_SignalEvent.1"></a><ins>CTI_SignalEvent(</ins><del>AArch64.TranslateAddress(bits(64) vaddress,</del><del> acctype, boolean iswrite,
                                           boolean wasaligned, integer size)

    result = </del><a href="shared_pseudocode.html#AArch64.FullTranslate.5" title="function: AddressDescriptor AArch64.FullTranslate(bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><del>AArch64.FullTranslate</del></a><del>(vaddress, acctype, iswrite, wasaligned, size);

    if !(acctype IN {</del><a href="shared_pseudocode.html#AccType_PTW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_PTW</del></a><del>, </del><a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IC</del></a><del>, </del><a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_AT</del></a><del>}) &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><del>(result) then
        result.fault = </del><a href="shared_pseudocode.html#AArch64.CheckDebug.4" title="function: FaultRecord AArch64.CheckDebug(bits(64) vaddress, AccType acctype, boolean iswrite, integer size)"><del>AArch64.CheckDebug</del></a><del>(vaddress, acctype, iswrite, size);

    // Update virtual address for abort functions
    result.vaddress = </del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><a href="shared_pseudocode.html#CrossTriggerIn" title="enumeration CrossTriggerIn  {CrossTriggerIn_CrossHalt,     CrossTriggerIn_PMUOverflow, CrossTriggerIn_RSVD2,         CrossTriggerIn_RSVD3, CrossTriggerIn_TraceExtOut0,  CrossTriggerIn_TraceExtOut1, CrossTriggerIn_TraceExtOut2,  CrossTriggerIn_TraceExtOut3}"><ins>CrossTriggerIn</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a> <ins>id);</ins><del>(vaddress);

    return result;</del></p></div><div class="ps" psname="shared.debug.cti.CrossTrigger"><a id="shared.debug.cti.CrossTrigger" name="shared.debug.cti.CrossTrigger"></a><h3 class="pseudocode">
            Library pseudocode for <ins>shared</ins><del>aarch64</del>/<ins>debug</ins><del>translation</del>/<ins>cti</ins><del>walk</del>/<ins>CrossTrigger</ins><del>AArch64.TranslationTableWalk</del></h3><p class="pseudocode"><ins>enumeration</ins><del>// AArch64.TranslationTableWalk()
// ==============================
// Returns a result of a translation table walk
//
// Implementations might cache information from memory in any number of non-coherent TLB
// caching structures, and so avoid memory accesses that have been expressed in this
// pseudocode. The use of such TLBs is not expressed in this pseudocode.

TLBRecord</del> <a id="CrossTriggerOut" name="CrossTriggerOut"></a><ins>CrossTriggerOut {</ins><del>AArch64.TranslationTableWalk(bits(52) ipaddress, bit s1_nonsecure, bits(64) vaddress,</del><a id="CrossTriggerOut_DebugRequest" name="CrossTriggerOut_DebugRequest"></a><ins>CrossTriggerOut_DebugRequest,</ins><del>acctype, boolean iswrite, boolean secondstage,
                                       boolean s2fs1walk, integer size)
    if !secondstage then
        assert !</del> <a id="CrossTriggerOut_RestartRequest" name="CrossTriggerOut_RestartRequest"></a><ins>CrossTriggerOut_RestartRequest,</ins><del>(</del>
                             <a id="CrossTriggerOut_IRQ" name="CrossTriggerOut_IRQ"></a><ins>CrossTriggerOut_IRQ,</ins><del>());
    else
        assert</del>          <a id="CrossTriggerOut_RSVD3" name="CrossTriggerOut_RSVD3"></a><ins>CrossTriggerOut_RSVD3,</ins><del>() || (</del>
                             <a id="CrossTriggerOut_TraceExtIn0" name="CrossTriggerOut_TraceExtIn0"></a><ins>CrossTriggerOut_TraceExtIn0,</ins><del>(</del>  <a id="CrossTriggerOut_TraceExtIn1" name="CrossTriggerOut_TraceExtIn1"></a><ins>CrossTriggerOut_TraceExtIn1,</ins><del>) &amp;&amp; !</del>
                             <a id="CrossTriggerOut_TraceExtIn2" name="CrossTriggerOut_TraceExtIn2"></a><ins>CrossTriggerOut_TraceExtIn2,</ins><del>() &amp;&amp; !</del>  <a id="CrossTriggerOut_TraceExtIn3" name="CrossTriggerOut_TraceExtIn3"></a><ins>CrossTriggerOut_TraceExtIn3};

enumeration</ins><del>(</del> <a id="CrossTriggerIn" name="CrossTriggerIn"></a><ins>CrossTriggerIn  {</ins><del>) ) &amp;&amp;</del><a id="CrossTriggerIn_CrossHalt" name="CrossTriggerIn_CrossHalt"></a><ins>CrossTriggerIn_CrossHalt,</ins><del>();</del>     <a id="CrossTriggerIn_PMUOverflow" name="CrossTriggerIn_PMUOverflow"></a><ins>CrossTriggerIn_PMUOverflow,</ins><del>result;</del>
                             <a id="CrossTriggerIn_RSVD2" name="CrossTriggerIn_RSVD2"></a><ins>CrossTriggerIn_RSVD2,</ins><del>descaddr;
    bits(64) baseregister;
    bits(64) inputaddr;        // Input Address is 'vaddress' for stage 1, 'ipaddress' for stage 2

    descaddr.memattrs.type =</del>         <a id="CrossTriggerIn_RSVD3" name="CrossTriggerIn_RSVD3"></a><ins>CrossTriggerIn_RSVD3,</ins><del>;

    // Derived parameters for the page table walk:
    //  grainsize = Log2(Size of Table)         - Size of Table is 4KB, 16KB or 64KB in AArch64
    //  stride = Log2(Address per Level)        - Bits of address consumed at each level
    //  firstblocklevel = First level where a block entry is allowed
    //  ps = Physical Address size as encoded in TCR_EL1.IPS or TCR_ELx/VTCR_EL2.PS
    //  inputsize = Log2(Size of Input Address) - Input Address size in bits
    //  level = Level to start walk from
    // This means that the number of levels after start level = 3-level

    if !secondstage then
        // First stage translation
        inputaddr =</del>
                             <a id="CrossTriggerIn_TraceExtOut0" name="CrossTriggerIn_TraceExtOut0"></a><ins>CrossTriggerIn_TraceExtOut0,</ins><del>(vaddress);
        el =</del>  <a id="CrossTriggerIn_TraceExtOut1" name="CrossTriggerIn_TraceExtOut1"></a><ins>CrossTriggerIn_TraceExtOut1,</ins><del>(acctype);
        top =</del>
                             <a id="CrossTriggerIn_TraceExtOut2" name="CrossTriggerIn_TraceExtOut2"></a><ins>CrossTriggerIn_TraceExtOut2,</ins><del>(inputaddr, (acctype ==</del>  <del>), el);
        if el == </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del> then
            largegrain = TCR_EL3.TG0 == '01';
            midgrain = TCR_EL3.TG0 == '10';
            inputsize = 64 - </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(TCR_EL3.T0SZ);
            inputsize_max = if </del><a href="shared_pseudocode.html#impl-shared.Have52BitVAExt.0" title="function: boolean Have52BitVAExt()"><del>Have52BitVAExt</del></a><del>() &amp;&amp; largegrain then 52 else 48;
            inputsize_min = 64 - (if !</del><a href="shared_pseudocode.html#impl-shared.HaveSmallPageTblExt.0" title="function: boolean HaveSmallPageTblExt()"><del>HaveSmallPageTblExt</del></a><del>() then 39 else if largegrain then 47 else 48);
            if inputsize &lt; inputsize_min then
                c = </del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><del>ConstrainUnpredictable</del></a><del>(</del><a href="shared_pseudocode.html#Unpredictable_RESTnSZ" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESTnSZ</del></a><del>);
                assert c IN {</del><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FORCE</del></a><del>, </del><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FAULT</del></a><del>};
                if c == </del><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FORCE</del></a><del> then inputsize = inputsize_min;
            ps = TCR_EL3.PS;
            basefound = inputsize >= inputsize_min &amp;&amp; inputsize &lt;= inputsize_max &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(inputaddr&lt;top:inputsize>);
            disabled = FALSE;
            baseregister = TTBR0_EL3;
            descaddr.memattrs = </del><a href="shared_pseudocode.html#impl-shared.WalkAttrDecode.4" title="function: MemoryAttributes WalkAttrDecode(bits(2) SH, bits(2) ORGN, bits(2) IRGN, boolean secondstage)"><del>WalkAttrDecode</del></a><del>(TCR_EL3.SH0, TCR_EL3.ORGN0, TCR_EL3.IRGN0, secondstage);
            reversedescriptors = SCTLR_EL3.EE == '1';
            lookupsecure = TRUE;
            singlepriv = TRUE;
            update_AF = </del><a href="shared_pseudocode.html#impl-shared.HaveAccessFlagUpdateExt.0" title="function: boolean HaveAccessFlagUpdateExt()"><del>HaveAccessFlagUpdateExt</del></a><del>() &amp;&amp; TCR_EL3.HA == '1';
            update_AP = </del><a href="shared_pseudocode.html#impl-shared.HaveDirtyBitModifierExt.0" title="function: boolean HaveDirtyBitModifierExt()"><del>HaveDirtyBitModifierExt</del></a><del>() &amp;&amp; update_AF &amp;&amp; TCR_EL3.HD == '1';
            hierattrsdisabled = </del><a href="shared_pseudocode.html#AArch64.HaveHPDExt.0" title="function: boolean AArch64.HaveHPDExt()"><del>AArch64.HaveHPDExt</del></a><del>() &amp;&amp; TCR_EL3.HPD == '1';
        elsif </del><a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)"><del>ELIsInHost</del></a><del>(el) then
            if inputaddr&lt;top> == '0' then
                largegrain = TCR_EL2.TG0 == '01';
                midgrain = TCR_EL2.TG0 == '10';
                inputsize = 64 - </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(TCR_EL2.T0SZ);
                inputsize_max = if </del><a href="shared_pseudocode.html#impl-shared.Have52BitVAExt.0" title="function: boolean Have52BitVAExt()"><del>Have52BitVAExt</del></a><del>() &amp;&amp; largegrain then 52 else 48;
                inputsize_min = 64 - (if !</del><a href="shared_pseudocode.html#impl-shared.HaveSmallPageTblExt.0" title="function: boolean HaveSmallPageTblExt()"><del>HaveSmallPageTblExt</del></a><del>() then 39 else if largegrain then 47 else 48);
                if inputsize &lt; inputsize_min then
                    c = </del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><del>ConstrainUnpredictable</del></a><del>(</del><a href="shared_pseudocode.html#Unpredictable_RESTnSZ" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESTnSZ</del></a><del>);
                    assert c IN {</del><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FORCE</del></a><del>, </del><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FAULT</del></a><del>};
                    if c == </del><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FORCE</del></a><del> then inputsize = inputsize_min;
                basefound = inputsize >= inputsize_min &amp;&amp; inputsize &lt;= inputsize_max &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(inputaddr&lt;top:inputsize>);
                disabled = TCR_EL2.EPD0 == '1' || (PSTATE.EL == </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del> &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.HaveE0PDExt.0" title="function: boolean HaveE0PDExt()"><del>HaveE0PDExt</del></a><del>() &amp;&amp; TCR_EL2.E0PD0 == '1');
                baseregister = TTBR0_EL2;
                descaddr.memattrs = </del><a href="shared_pseudocode.html#impl-shared.WalkAttrDecode.4" title="function: MemoryAttributes WalkAttrDecode(bits(2) SH, bits(2) ORGN, bits(2) IRGN, boolean secondstage)"><del>WalkAttrDecode</del></a><del>(TCR_EL2.SH0, TCR_EL2.ORGN0, TCR_EL2.IRGN0, secondstage);
                hierattrsdisabled = </del><a href="shared_pseudocode.html#AArch64.HaveHPDExt.0" title="function: boolean AArch64.HaveHPDExt()"><del>AArch64.HaveHPDExt</del></a><del>() &amp;&amp; TCR_EL2.HPD0 == '1';
            else
                inputsize = 64 - </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(TCR_EL2.T1SZ);
                largegrain = TCR_EL2.TG1 == '11';       // TG1 and TG0 encodings differ
                midgrain = TCR_EL2.TG1 == '01';
                inputsize_max = if </del><a href="shared_pseudocode.html#impl-shared.Have52BitVAExt.0" title="function: boolean Have52BitVAExt()"><del>Have52BitVAExt</del></a><del>() &amp;&amp; largegrain then 52 else 48;
                inputsize_min = 64 - (if !</del><a href="shared_pseudocode.html#impl-shared.HaveSmallPageTblExt.0" title="function: boolean HaveSmallPageTblExt()"><del>HaveSmallPageTblExt</del></a><del>() then 39 else if largegrain then 47 else 48);
                if inputsize &lt; inputsize_min then
                    c = </del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><del>ConstrainUnpredictable</del></a><del>(</del><a href="shared_pseudocode.html#Unpredictable_RESTnSZ" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESTnSZ</del></a><del>);
                    assert c IN {</del><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FORCE</del></a><del>, </del><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FAULT</del></a><del>};
                    if c == </del><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FORCE</del></a><del> then inputsize = inputsize_min;
                basefound = inputsize >= inputsize_min &amp;&amp; inputsize &lt;= inputsize_max &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)"><del>IsOnes</del></a><del>(inputaddr&lt;top:inputsize>);
                disabled = TCR_EL2.EPD1 == '1' || (PSTATE.EL == </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del> &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.HaveE0PDExt.0" title="function: boolean HaveE0PDExt()"><del>HaveE0PDExt</del></a><del>() &amp;&amp; TCR_EL2.E0PD1 == '1');
                baseregister = TTBR1_EL2;
                descaddr.memattrs = </del><a href="shared_pseudocode.html#impl-shared.WalkAttrDecode.4" title="function: MemoryAttributes WalkAttrDecode(bits(2) SH, bits(2) ORGN, bits(2) IRGN, boolean secondstage)"><del>WalkAttrDecode</del></a><del>(TCR_EL2.SH1, TCR_EL2.ORGN1, TCR_EL2.IRGN1, secondstage);
                hierattrsdisabled = </del><a href="shared_pseudocode.html#AArch64.HaveHPDExt.0" title="function: boolean AArch64.HaveHPDExt()"><del>AArch64.HaveHPDExt</del></a><del>() &amp;&amp; TCR_EL2.HPD1 == '1';
            ps = TCR_EL2.IPS;
            reversedescriptors = SCTLR_EL2.EE == '1';
            lookupsecure = if </del><a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()"><del>IsSecureEL2Enabled</del></a><del>() then </del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>() else FALSE;
            singlepriv = FALSE;
            update_AF = </del><a href="shared_pseudocode.html#impl-shared.HaveAccessFlagUpdateExt.0" title="function: boolean HaveAccessFlagUpdateExt()"><del>HaveAccessFlagUpdateExt</del></a><del>() &amp;&amp; TCR_EL2.HA == '1';
            update_AP = </del><a href="shared_pseudocode.html#impl-shared.HaveDirtyBitModifierExt.0" title="function: boolean HaveDirtyBitModifierExt()"><del>HaveDirtyBitModifierExt</del></a><del>() &amp;&amp; update_AF &amp;&amp; TCR_EL2.HD == '1';
        elsif el == </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del> then
            inputsize = 64 - </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(TCR_EL2.T0SZ);
            largegrain = TCR_EL2.TG0 == '01';
            midgrain = TCR_EL2.TG0 == '10';
            inputsize_max = if </del><a href="shared_pseudocode.html#impl-shared.Have52BitVAExt.0" title="function: boolean Have52BitVAExt()"><del>Have52BitVAExt</del></a><del>() &amp;&amp; largegrain then 52 else 48;
            inputsize_min = 64 - (if !</del><a href="shared_pseudocode.html#impl-shared.HaveSmallPageTblExt.0" title="function: boolean HaveSmallPageTblExt()"><del>HaveSmallPageTblExt</del></a><del>() then 39 else if largegrain then 47 else 48);
            if inputsize &lt; inputsize_min then
                c = </del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><del>ConstrainUnpredictable</del></a><del>(</del><a href="shared_pseudocode.html#Unpredictable_RESTnSZ" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESTnSZ</del></a><del>);
                assert c IN {</del><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FORCE</del></a><del>, </del><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FAULT</del></a><del>};
                if c == </del><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FORCE</del></a><del> then inputsize = inputsize_min;
            ps = TCR_EL2.PS;
            basefound = inputsize >= inputsize_min &amp;&amp; inputsize &lt;= inputsize_max &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(inputaddr&lt;top:inputsize>);
            disabled = FALSE;
            baseregister = TTBR0_EL2;
            descaddr.memattrs = </del><a href="shared_pseudocode.html#impl-shared.WalkAttrDecode.4" title="function: MemoryAttributes WalkAttrDecode(bits(2) SH, bits(2) ORGN, bits(2) IRGN, boolean secondstage)"><del>WalkAttrDecode</del></a><del>(TCR_EL2.SH0, TCR_EL2.ORGN0, TCR_EL2.IRGN0, secondstage);
            reversedescriptors = SCTLR_EL2.EE == '1';
            lookupsecure = if </del><a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()"><del>IsSecureEL2Enabled</del></a><del>() then </del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>() else FALSE;
            singlepriv = TRUE;
            update_AF = </del><a href="shared_pseudocode.html#impl-shared.HaveAccessFlagUpdateExt.0" title="function: boolean HaveAccessFlagUpdateExt()"><del>HaveAccessFlagUpdateExt</del></a><del>() &amp;&amp; TCR_EL2.HA == '1';
            update_AP = </del><a href="shared_pseudocode.html#impl-shared.HaveDirtyBitModifierExt.0" title="function: boolean HaveDirtyBitModifierExt()"><del>HaveDirtyBitModifierExt</del></a><del>() &amp;&amp; update_AF &amp;&amp; TCR_EL2.HD == '1';
            hierattrsdisabled = </del><a href="shared_pseudocode.html#AArch64.HaveHPDExt.0" title="function: boolean AArch64.HaveHPDExt()"><del>AArch64.HaveHPDExt</del></a><del>() &amp;&amp; TCR_EL2.HPD == '1';
        else
            if inputaddr&lt;top> == '0' then
                inputsize = 64 - </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(TCR_EL1.T0SZ);
                largegrain = TCR_EL1.TG0 == '01';
                midgrain = TCR_EL1.TG0 == '10';
                inputsize_max = if </del><a href="shared_pseudocode.html#impl-shared.Have52BitVAExt.0" title="function: boolean Have52BitVAExt()"><del>Have52BitVAExt</del></a><del>() &amp;&amp; largegrain then 52 else 48;
                inputsize_min = 64 - (if !</del><a href="shared_pseudocode.html#impl-shared.HaveSmallPageTblExt.0" title="function: boolean HaveSmallPageTblExt()"><del>HaveSmallPageTblExt</del></a><del>() then 39 else if largegrain then 47 else 48);
                if inputsize &lt; inputsize_min then
                    c = </del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><del>ConstrainUnpredictable</del></a><del>(</del><a href="shared_pseudocode.html#Unpredictable_RESTnSZ" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESTnSZ</del></a><del>);
                    assert c IN {</del><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FORCE</del></a><del>, </del><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FAULT</del></a><del>};
                    if c == </del><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FORCE</del></a><del> then inputsize = inputsize_min;
                basefound = inputsize >= inputsize_min &amp;&amp; inputsize &lt;= inputsize_max &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(inputaddr&lt;top:inputsize>);
                disabled = TCR_EL1.EPD0 == '1' || (PSTATE.EL == </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del> &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.HaveE0PDExt.0" title="function: boolean HaveE0PDExt()"><del>HaveE0PDExt</del></a><del>() &amp;&amp; TCR_EL1.E0PD0 == '1');
                disabled = disabled || (el == </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del> &amp;&amp; acctype == </del><a href="shared_pseudocode.html#AccType_NONFAULT" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NONFAULT</del></a><del> &amp;&amp; TCR_EL1.NFD0 == '1');
                baseregister = TTBR0_EL1;
                descaddr.memattrs = </del><a href="shared_pseudocode.html#impl-shared.WalkAttrDecode.4" title="function: MemoryAttributes WalkAttrDecode(bits(2) SH, bits(2) ORGN, bits(2) IRGN, boolean secondstage)"><del>WalkAttrDecode</del></a><del>(TCR_EL1.SH0, TCR_EL1.ORGN0, TCR_EL1.IRGN0, secondstage);
                hierattrsdisabled = </del><a href="shared_pseudocode.html#AArch64.HaveHPDExt.0" title="function: boolean AArch64.HaveHPDExt()"><del>AArch64.HaveHPDExt</del></a><del>() &amp;&amp;  TCR_EL1.HPD0 == '1';
            else
                inputsize = 64 - </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(TCR_EL1.T1SZ);
                largegrain = TCR_EL1.TG1 == '11';       // TG1 and TG0 encodings differ
                midgrain = TCR_EL1.TG1 == '01';
                inputsize_max = if </del><a href="shared_pseudocode.html#impl-shared.Have52BitVAExt.0" title="function: boolean Have52BitVAExt()"><del>Have52BitVAExt</del></a><del>() &amp;&amp; largegrain then 52 else 48;
                inputsize_min = 64 - (if !</del><a href="shared_pseudocode.html#impl-shared.HaveSmallPageTblExt.0" title="function: boolean HaveSmallPageTblExt()"><del>HaveSmallPageTblExt</del></a><del>() then 39 else if largegrain then 47 else 48);
                if inputsize &lt; inputsize_min then
                    c = </del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><del>ConstrainUnpredictable</del></a><del>(</del><a href="shared_pseudocode.html#Unpredictable_RESTnSZ" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESTnSZ</del></a><del>);
                    assert c IN {</del><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FORCE</del></a><del>, </del><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FAULT</del></a><del>};
                    if c == </del><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FORCE</del></a><del> then inputsize = inputsize_min;
                basefound = inputsize >= inputsize_min &amp;&amp; inputsize &lt;= inputsize_max &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)"><del>IsOnes</del></a><del>(inputaddr&lt;top:inputsize>);
                disabled = TCR_EL1.EPD1 == '1' || (PSTATE.EL == </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del> &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.HaveE0PDExt.0" title="function: boolean HaveE0PDExt()"><del>HaveE0PDExt</del></a><del>() &amp;&amp; TCR_EL1.E0PD1 == '1');
                disabled = disabled || (el == </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del> &amp;&amp; acctype == </del><a href="shared_pseudocode.html#AccType_NONFAULT" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NONFAULT</del></a><del> &amp;&amp; TCR_EL1.NFD1 == '1');
                baseregister = TTBR1_EL1;
                descaddr.memattrs = </del><a href="shared_pseudocode.html#impl-shared.WalkAttrDecode.4" title="function: MemoryAttributes WalkAttrDecode(bits(2) SH, bits(2) ORGN, bits(2) IRGN, boolean secondstage)"><del>WalkAttrDecode</del></a><del>(TCR_EL1.SH1, TCR_EL1.ORGN1, TCR_EL1.IRGN1, secondstage);
                hierattrsdisabled = </del><a href="shared_pseudocode.html#AArch64.HaveHPDExt.0" title="function: boolean AArch64.HaveHPDExt()"><del>AArch64.HaveHPDExt</del></a><del>() &amp;&amp;  TCR_EL1.HPD1 == '1';
            ps = TCR_EL1.IPS;
            reversedescriptors = SCTLR_EL1.EE == '1';
            lookupsecure = </del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>();
            singlepriv = FALSE;
            update_AF = </del><a href="shared_pseudocode.html#impl-shared.HaveAccessFlagUpdateExt.0" title="function: boolean HaveAccessFlagUpdateExt()"><del>HaveAccessFlagUpdateExt</del></a><del>() &amp;&amp; TCR_EL1.HA == '1';
            update_AP = </del><a href="shared_pseudocode.html#impl-shared.HaveDirtyBitModifierExt.0" title="function: boolean HaveDirtyBitModifierExt()"><del>HaveDirtyBitModifierExt</del></a><del>() &amp;&amp; update_AF &amp;&amp; TCR_EL1.HD == '1';
        if largegrain then
            grainsize = 16;                                             // Log2(64KB page size)
            firstblocklevel = (if </del><a href="shared_pseudocode.html#impl-shared.Have52BitPAExt.0" title="function: boolean Have52BitPAExt()"><del>Have52BitPAExt</del></a><del>() then 1 else 2);      // Largest block is 4TB (2^42 bytes) for 52 bit PA
                                                                        // and 512MB (2^29 bytes) otherwise
        elsif midgrain then
            grainsize = 14;                                             // Log2(16KB page size)
            firstblocklevel = 2;                                        // Largest block is 32MB (2^25 bytes)
        else // Small grain
            grainsize = 12;                                             // Log2(4KB page size)
            firstblocklevel = 1;                                        // Largest block is 1GB (2^30 bytes)
        stride = grainsize - 3;                                         // Log2(page size / 8 bytes)
        // The starting level is the number of strides needed to consume the input address
        level = 4 - </del><a href="shared_pseudocode.html#impl-shared.RoundUp.1" title="function: integer RoundUp(real x)"><del>RoundUp</del></a><del>(Real(inputsize - grainsize) / Real(stride));

    else
        // Second stage translation
        inputaddr = </del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><del>(ipaddress);
        // Stage 2 translation table walk for the Secure EL2 translation regime
        if </del><a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()"><del>IsSecureEL2Enabled</del></a><del>() &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>() then

            // Stage 2 translation walk is in the Non-secure IPA space or the Secure IPA space
            t0size = if s1_nonsecure == '1' then VTCR_EL2.T0SZ else VSTCR_EL2.T0SZ;
            tg0    = if s1_nonsecure == '1' then VTCR_EL2.TG0 else VSTCR_EL2.TG0;

            // Stage 2 translation table walk is to the Non-secure PA space or to the Secure PA space
            nswalk = if s1_nonsecure == '1' then VTCR_EL2.NSW else VSTCR_EL2.SW;

            // Stage 2 translation accesses the Non-secure PA space or the Secure PA space
            if nswalk == '1' then
                nsaccess = '1';                                        // When walk is non-secure, access must be to the Non-secure PA space
            else
                if s1_nonsecure == '0' then
                    nsaccess = VSTCR_EL2.SA;                           // When walk is secure and in the Secure IPA space, access is specified by VSTCR_EL2.SA
                else
                    if VSTCR_EL2.SW == '1' || VSTCR_EL2.SA == '1' then nsaccess = '1';        // When walk is secure and in the Non-secure IPA space, access is non-secure when VSTCR_EL2.SA specifies the Non-secure PA space
                    else nsaccess = VTCR_EL2.NSA;                      // When walk is secure and in the Non-secure IPA space, if VSTCR_EL2.SA specifies the Secure PA space, access is specified by VSTCR_EL2.NSA
        else
            t0size = VTCR_EL2.T0SZ;
            tg0    = VTCR_EL2.TG0;
            nsaccess = '1';

        inputsize  = 64 - </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(t0size);
        largegrain = tg0 == '01';
        midgrain   = tg0 == '10';

        inputsize_max = if </del><a href="shared_pseudocode.html#impl-shared.Have52BitVAExt.0" title="function: boolean Have52BitVAExt()"><del>Have52BitVAExt</del></a><del>() &amp;&amp; largegrain then 52 else 48;
        inputsize_min = 64 - (if !</del><a href="shared_pseudocode.html#impl-shared.HaveSmallPageTblExt.0" title="function: boolean HaveSmallPageTblExt()"><del>HaveSmallPageTblExt</del></a><del>() then 39 else if largegrain then 47 else 48);
        if inputsize &lt; inputsize_min then
            c = </del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><del>ConstrainUnpredictable</del></a><del>(</del><a href="shared_pseudocode.html#Unpredictable_RESTnSZ" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESTnSZ</del></a><del>);
            assert c IN {</del><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FORCE</del></a><del>, </del><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FAULT</del></a><del>};
            if c == </del><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FORCE</del></a><del> then inputsize = inputsize_min;
        ps = VTCR_EL2.PS;
        basefound = inputsize >= inputsize_min &amp;&amp; inputsize &lt;= inputsize_max &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(inputaddr&lt;63:inputsize>);
        disabled = FALSE;
        descaddr.memattrs = </del><a href="shared_pseudocode.html#impl-shared.WalkAttrDecode.4" title="function: MemoryAttributes WalkAttrDecode(bits(2) SH, bits(2) ORGN, bits(2) IRGN, boolean secondstage)"><del>WalkAttrDecode</del></a><del>(VTCR_EL2.IRGN0, VTCR_EL2.ORGN0, VTCR_EL2.SH0, secondstage);
        reversedescriptors = SCTLR_EL2.EE == '1';
        singlepriv = TRUE;
        update_AF = </del><a href="shared_pseudocode.html#impl-shared.HaveAccessFlagUpdateExt.0" title="function: boolean HaveAccessFlagUpdateExt()"><del>HaveAccessFlagUpdateExt</del></a><del>() &amp;&amp; VTCR_EL2.HA == '1';
        update_AP = </del><a href="shared_pseudocode.html#impl-shared.HaveDirtyBitModifierExt.0" title="function: boolean HaveDirtyBitModifierExt()"><del>HaveDirtyBitModifierExt</del></a><del>() &amp;&amp; update_AF &amp;&amp; VTCR_EL2.HD == '1';

        lookupsecure = if </del><a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()"><del>IsSecureEL2Enabled</del></a><del>() then s1_nonsecure == '0' else FALSE;
        // Stage2 translation table walk is to secure PA space or to Non-secure PA space
        baseregister = if lookupsecure then VSTTBR_EL2 else VTTBR_EL2;
        startlevel   = if lookupsecure then </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(VSTCR_EL2.SL0) else </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(VTCR_EL2.SL0);
        if largegrain then
            grainsize = 16;                                         // Log2(64KB page size)
            level = 3 - startlevel;
            firstblocklevel = (if </del><a href="shared_pseudocode.html#impl-shared.Have52BitPAExt.0" title="function: boolean Have52BitPAExt()"><del>Have52BitPAExt</del></a><del>() then 1 else 2);  // Largest block is 4TB (2^42 bytes) for 52 bit PA
                                                                    // and 512MB (2^29 bytes) otherwise
        elsif midgrain then
            grainsize = 14;                                         // Log2(16KB page size)
            level = 3 - startlevel;
            firstblocklevel = 2;                                    // Largest block is 32MB (2^25 bytes)
        else // Small grain
            grainsize = 12;                                         // Log2(4KB page size)
            if </del><a href="shared_pseudocode.html#impl-shared.HaveSmallPageTblExt.0" title="function: boolean HaveSmallPageTblExt()"><del>HaveSmallPageTblExt</del></a><del>() &amp;&amp; startlevel == 3 then
                level = startlevel;                             // Startlevel 3 (VTCR_EL2.SL0 or VSCTR_EL2.SL0 == 0b11) for 4KB granule
            else
                level = 2 - startlevel;
            firstblocklevel = 1;                                    // Largest block is 1GB (2^30 bytes)
        stride = grainsize - 3;                                     // Log2(page size / 8 bytes)

        // Limits on IPA controls based on implemented PA size. Level 0 is only
        // supported by small grain translations
        if largegrain then                              // 64KB pages
            // Level 1 only supported if implemented PA size is greater than 2^42 bytes
            if level == 0 || (level == 1 &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.PAMax.0" title="function: integer PAMax()"><del>PAMax</del></a><del>() &lt;= 42) then basefound = FALSE;
        elsif midgrain then                             // 16KB pages
            // Level 1 only supported if implemented PA size is greater than 2^40 bytes
            if level == 0 || (level == 1 &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.PAMax.0" title="function: integer PAMax()"><del>PAMax</del></a><del>() &lt;= 40) then basefound = FALSE;
        else                                            // Small grain, 4KB pages
            // Level 0 only supported if implemented PA size is greater than 2^42 bytes
            if level &lt; 0 || (level == 0 &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.PAMax.0" title="function: integer PAMax()"><del>PAMax</del></a><del>() &lt;= 42) then basefound = FALSE;

        // If the inputsize exceeds the PAMax value, the behavior is CONSTRAINED UNPREDICTABLE
        inputsizecheck = inputsize;
        if inputsize > </del><a href="shared_pseudocode.html#impl-shared.PAMax.0" title="function: integer PAMax()"><del>PAMax</del></a><del>() &amp;&amp; (!</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>) || inputsize > 40) then
            case </del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><del>ConstrainUnpredictable</del></a><del>(</del><a href="shared_pseudocode.html#Unpredictable_LARGEIPA" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_LARGEIPA</del></a><del>) of
                when </del><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FORCE</del></a><del>
                    // Restrict the inputsize to the PAMax value
                    inputsize = </del><a href="shared_pseudocode.html#impl-shared.PAMax.0" title="function: integer PAMax()"><del>PAMax</del></a><del>();
                    inputsizecheck = </del><a href="shared_pseudocode.html#impl-shared.PAMax.0" title="function: integer PAMax()"><del>PAMax</del></a><del>();
                when </del><a href="shared_pseudocode.html#Constraint_FORCENOSLCHECK" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FORCENOSLCHECK</del></a><del>
                    // As FORCE, except use the configured inputsize in the size checks below
                    inputsize = </del><a href="shared_pseudocode.html#impl-shared.PAMax.0" title="function: integer PAMax()"><del>PAMax</del></a><del>();
                when </del><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FAULT</del></a><del>
                    // Generate a translation fault
                    basefound = FALSE;
                otherwise
                    </del><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><del>Unreachable</del></a><del>();

        // Number of entries in the starting level table =
        //     (Size of Input Address)/((Address per level)^(Num levels remaining)*(Size of Table))
        startsizecheck = inputsizecheck - ((3 - level)*stride + grainsize); // Log2(Num of entries)

        // Check for starting level table with fewer than 2 entries or longer than 16 pages.
        // Lower bound check is:  startsizecheck &lt; Log2(2 entries)
        // Upper bound check is:  startsizecheck > Log2(pagesize/8*16)
        if startsizecheck &lt; 1 || startsizecheck > stride + 4 then basefound = FALSE;

    if !basefound || disabled then
        level = 0;           // AArch32 reports this as a level 1 fault
        result.addrdesc.fault = </del><a href="shared_pseudocode.html#AArch64.TranslationFault.7" title="function: FaultRecord AArch64.TranslationFault(bits(52) ipaddress, bit NS, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><del>AArch64.TranslationFault</del></a><del>(ipaddress, s1_nonsecure,  level, acctype, iswrite,
                                                         secondstage, s2fs1walk);
        return result;

    case ps of
        when '000'  outputsize = 32;
        when '001'  outputsize = 36;
        when '010'  outputsize = 40;
        when '011'  outputsize = 42;
        when '100'  outputsize = 44;
        when '101'  outputsize = 48;
        when '110'  outputsize = (if </del><a href="shared_pseudocode.html#impl-shared.Have52BitPAExt.0" title="function: boolean Have52BitPAExt()"><del>Have52BitPAExt</del></a><del>() &amp;&amp; largegrain then 52 else 48);
        otherwise   outputsize = integer IMPLEMENTATION_DEFINED "Reserved Intermediate Physical Address size value";

    if outputsize > </del><a href="shared_pseudocode.html#impl-shared.PAMax.0" title="function: integer PAMax()"><del>PAMax</del></a><del>() then outputsize = </del><a href="shared_pseudocode.html#impl-shared.PAMax.0" title="function: integer PAMax()"><del>PAMax</del></a><del>();

    if outputsize &lt; 48 &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(baseregister&lt;47:outputsize>) then
        level = 0;
        result.addrdesc.fault = </del><a href="shared_pseudocode.html#AArch64.AddressSizeFault.7" title="function: FaultRecord AArch64.AddressSizeFault(bits(52) ipaddress,bit NS, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><del>AArch64.AddressSizeFault</del></a><del>(ipaddress,s1_nonsecure,  level, acctype, iswrite,
                                                         secondstage, s2fs1walk);
        return result;

    // Bottom bound of the Base address is:
    //     Log2(8 bytes per entry)+Log2(Number of entries in starting level table)
    // Number of entries in starting level table =
    //     (Size of Input Address)/((Address per level)^(Num levels remaining)*(Size of Table))
    baselowerbound = 3 + inputsize - ((3-level)*stride + grainsize);  // Log2(Num of entries*8)
    if outputsize == 52 then
        z = (if baselowerbound &lt; 6 then 6 else baselowerbound);
        baseaddress = baseregister&lt;5:2>:baseregister&lt;47:z>:</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(z);
    else
        baseaddress = </del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><del>(baseregister&lt;47:baselowerbound>:</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(baselowerbound));

    ns_table = if lookupsecure then '0' else '1';
    ap_table = '00';
    xn_table = '0';
    pxn_table = '0';

    addrselecttop = inputsize - 1;

    apply_nvnv1_effect = </del><a href="shared_pseudocode.html#impl-shared.HaveNVExt.0" title="function: boolean HaveNVExt()"><del>HaveNVExt</del></a><del>() &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; HCR_EL2.&lt;NV,NV1> == '11' &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><del>() == </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del> &amp;&amp; !secondstage;
    repeat
        addrselectbottom = (3-level)*stride + grainsize;

        bits(52) index = </del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><del>(inputaddr&lt;addrselecttop:addrselectbottom>:'000');
        descaddr.paddress.address = baseaddress OR index;
        descaddr.paddress.NS = ns_table;

        // If there are two stages of translation, then the first stage table walk addresses
        // are themselves subject to translation
        if secondstage || !</del><a href="shared_pseudocode.html#impl-shared.HasS2Translation.0" title="function: boolean HasS2Translation()"><del>HasS2Translation</del></a><del>() || (</del><a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()"><del>HaveNV2Ext</del></a><del>() &amp;&amp; acctype == </del><a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NV2REGISTER</del></a><del>) then
            descaddr2 = descaddr;
        else
            hwupdatewalk = FALSE;
            descaddr2 = </del><a href="shared_pseudocode.html#AArch64.SecondStageWalk.6" title="function: AddressDescriptor AArch64.SecondStageWalk(AddressDescriptor S1, bits(64) vaddress, AccType acctype, boolean iswrite, integer size, boolean hwupdatewalk)"><del>AArch64.SecondStageWalk</del></a><del>(descaddr, vaddress, acctype, iswrite, 8, hwupdatewalk);
            // Check for a fault on the stage 2 walk
            if </del><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><del>(descaddr2) then
                result.addrdesc.fault = descaddr2.fault;
                return result;

        // Update virtual address for abort functions
        descaddr2.vaddress = </del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><del>(vaddress);

        accdesc = CreateAccessDescriptorPTW(acctype, secondstage, s2fs1walk, level);
        desc = _Mem[descaddr2, 8, accdesc];

        if reversedescriptors then desc = </del><a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)"><del>BigEndianReverse</del></a><del>(desc);

        if desc&lt;0> == '0' || (desc&lt;1:0> == '01' &amp;&amp; (level == 3 ||
                                                    (</del><a href="shared_pseudocode.html#impl-shared.HaveBlockBBM.0" title="function: boolean HaveBlockBBM()"><del>HaveBlockBBM</del></a><del>() &amp;&amp; </del><a href="shared_pseudocode.html#impl-aarch64.IsBlockDescriptorNTBitValid.0" title="function: boolean IsBlockDescriptorNTBitValid()"><del>IsBlockDescriptorNTBitValid</del></a><del>() &amp;&amp; desc&lt;16> == '1'))) then
             // Fault (00), Reserved (10), Block (01) at level 3, or Block(01) with nT bit set.
            result.addrdesc.fault = </del><a href="shared_pseudocode.html#AArch64.TranslationFault.7" title="function: FaultRecord AArch64.TranslationFault(bits(52) ipaddress, bit NS, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><del>AArch64.TranslationFault</del></a><del>(ipaddress, s1_nonsecure, level, acctype,
                                                             iswrite, secondstage, s2fs1walk);
            return result;

        // Valid Block, Page, or Table entry
        if desc&lt;1:0> == '01' || level == 3 then                 // Block (01) or Page (11)
            blocktranslate = TRUE;
        else                                                    // Table (11)
            if (outputsize &lt; 52 &amp;&amp; largegrain &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(desc&lt;15:12>)) || (outputsize &lt; 48 &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(desc&lt;47:outputsize>)) then
                result.addrdesc.fault = </del><a href="shared_pseudocode.html#AArch64.AddressSizeFault.7" title="function: FaultRecord AArch64.AddressSizeFault(bits(52) ipaddress,bit NS, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><del>AArch64.AddressSizeFault</del></a><del>(ipaddress,s1_nonsecure,  level, acctype,
                                                                 iswrite, secondstage, s2fs1walk);
                return result;

            if outputsize == 52 then
                baseaddress = desc&lt;15:12>:desc&lt;47:grainsize>:</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(grainsize);
            else
                baseaddress = </del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><del>(desc&lt;47:grainsize>:</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(grainsize));
            if !secondstage then
                // Unpack the upper and lower table attributes
                ns_table    = ns_table    OR desc&lt;63>;
            if !secondstage &amp;&amp; !hierattrsdisabled then
                ap_table&lt;1> = ap_table&lt;1> OR desc&lt;62>;       // read-only

                if apply_nvnv1_effect then
                    pxn_table   = pxn_table   OR desc&lt;60>;
                else
                    xn_table    = xn_table    OR desc&lt;60>;
                // pxn_table and ap_table[0] apply in EL1&amp;0 or EL2&amp;0 translation regimes
                if !singlepriv then
                    if !apply_nvnv1_effect then
                        pxn_table   = pxn_table   OR desc&lt;59>;
                        ap_table&lt;0> = ap_table&lt;0> OR desc&lt;61>;   // privileged

            level = level + 1;
            addrselecttop = addrselectbottom - 1;
            blocktranslate = FALSE;
    until blocktranslate;

    // Check block size is supported at this level
    if level &lt; firstblocklevel then
        result.addrdesc.fault = </del><a href="shared_pseudocode.html#AArch64.TranslationFault.7" title="function: FaultRecord AArch64.TranslationFault(bits(52) ipaddress, bit NS, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><del>AArch64.TranslationFault</del></a><del>(ipaddress, s1_nonsecure, level, acctype,
                                                         iswrite, secondstage, s2fs1walk);
        return result;

    // Check for misprogramming of the contiguous bit
    if largegrain then
        contiguousbitcheck = level == 2 &amp;&amp; inputsize &lt; 34;
    elsif midgrain then
        contiguousbitcheck = level == 2 &amp;&amp; inputsize &lt; 30;
    else
        contiguousbitcheck = level == 1 &amp;&amp; inputsize &lt; 34;

    if contiguousbitcheck &amp;&amp; desc&lt;52> == '1' then
        if boolean IMPLEMENTATION_DEFINED "Translation fault on misprogrammed contiguous bit" then
            result.addrdesc.fault = </del><a href="shared_pseudocode.html#AArch64.TranslationFault.7" title="function: FaultRecord AArch64.TranslationFault(bits(52) ipaddress, bit NS, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><del>AArch64.TranslationFault</del></a><del>(ipaddress, s1_nonsecure, level, acctype,
                                                             iswrite, secondstage, s2fs1walk);
            return result;

    // Check the output address is inside the supported range
    if (outputsize &lt; 52 &amp;&amp; largegrain &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(desc&lt;15:12>)) || (outputsize &lt; 48 &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(desc&lt;47:outputsize>)) then
        result.addrdesc.fault = </del><a href="shared_pseudocode.html#AArch64.AddressSizeFault.7" title="function: FaultRecord AArch64.AddressSizeFault(bits(52) ipaddress,bit NS, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><del>AArch64.AddressSizeFault</del></a><del>(ipaddress,s1_nonsecure,  level, acctype,
                                                         iswrite, secondstage, s2fs1walk);
        return result;

    // Unpack the descriptor into address and upper and lower block attributes
    if outputsize == 52 then
        outputaddress = desc&lt;15:12>:desc&lt;47:addrselectbottom>:inputaddr&lt;addrselectbottom-1:0>;
    else
        outputaddress = </del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><del>(desc&lt;47:addrselectbottom>:inputaddr&lt;addrselectbottom-1:0>);
    // Check Access Flag
    if desc&lt;10> == '0' then
        if !update_AF then
            result.addrdesc.fault = </del><a href="shared_pseudocode.html#AArch64.AccessFlagFault.7" title="function: FaultRecord AArch64.AccessFlagFault(bits(52) ipaddress,bit NS, integer level, AccType acctype, boolean iswrite, boolean secondstage, boolean s2fs1walk)"><del>AArch64.AccessFlagFault</del></a><del>(ipaddress,s1_nonsecure,  level, acctype,
                                                            iswrite, secondstage, s2fs1walk);
            return result;
        else
            result.descupdate.AF = TRUE;

    if update_AP &amp;&amp; desc&lt;51> == '1' then
        // If hw update of access permission field is configured consider AP[2] as '0' / S2AP[2] as '1'
        if !secondstage &amp;&amp; desc&lt;7> == '1' then
            desc&lt;7> = '0';
            result.descupdate.AP = TRUE;
        elsif secondstage &amp;&amp; desc&lt;7> == '0' then
            desc&lt;7> = '1';
            result.descupdate.AP = TRUE;

    // Required descriptor if AF or AP[2]/S2AP[2] needs update
    result.descupdate.descaddr = descaddr;

    if apply_nvnv1_effect then
        pxn = desc&lt;54>;                                       // Bit[54] of the block/page descriptor holds PXN instead of UXN
        xn = '0';                                             // XN is '0'
        ap = desc&lt;7>:'01';                                    // Bit[6] of the block/page descriptor is treated as '0' regardless of value programmed
    else
        xn = desc&lt;54>;                                        // Bit[54] of the block/page descriptor holds UXN
        pxn = desc&lt;53>;                                       // Bit[53] of the block/page descriptor holds PXN
        ap = desc&lt;7:6>:'1';                                   // Bits[7:6] of the block/page descriptor hold AP[2:1]
    contiguousbit = desc&lt;52>;
    nG = desc&lt;11>;
    sh = desc&lt;9:8>;
    memattr = desc&lt;5:2>;                                      // AttrIndx and NS bit in stage 1

    result.domain = bits(4) UNKNOWN;                          // Domains not used
    result.level = level;
    result.blocksize = 2^((3-level)*stride + grainsize);

    // Stage 1 translation regimes also inherit attributes from the tables
    if !secondstage then
        result.perms.xn      = xn OR xn_table;
        result.perms.ap&lt;2>   = ap&lt;2> OR ap_table&lt;1>;          // Force read-only
        // PXN, nG and AP[1] apply in EL1&amp;0 or EL2&amp;0 stage 1 translation regimes
        if !singlepriv then
            result.perms.ap&lt;1> = ap&lt;1> AND NOT(ap_table&lt;0>);  // Force privileged only
            result.perms.pxn   = pxn OR pxn_table;
            // Pages from Non-secure tables are marked non-global in Secure EL1&amp;0
            if </del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>() then
                result.nG = nG OR ns_table;
            else
                result.nG = nG;
        else
            result.perms.ap&lt;1> = '1';
            result.perms.pxn   = '0';
            result.nG          = '0';
        result.GP = desc&lt;50>;                                 // Stage 1 block or pages might be guarded
        result.perms.ap&lt;0>   = '1';
        result.addrdesc.memattrs = </del><a href="shared_pseudocode.html#AArch64.S1AttrDecode.3" title="function: MemoryAttributes AArch64.S1AttrDecode(bits(2) SH, bits(3) attr, AccType acctype)"><del>AArch64.S1AttrDecode</del></a><del>(sh, memattr&lt;2:0>, acctype);
        result.addrdesc.paddress.NS = memattr&lt;3> OR ns_table;
    else
        result.perms.ap&lt;2:1> = ap&lt;2:1>;
        result.perms.ap&lt;0>   = '1';
        result.perms.xn      = xn;
        if </del><a href="shared_pseudocode.html#impl-shared.HaveExtendedExecuteNeverExt.0" title="function: boolean HaveExtendedExecuteNeverExt()"><del>HaveExtendedExecuteNeverExt</del></a><del>() then result.perms.xxn = desc&lt;53>;
        result.perms.pxn     = '0';
        result.nG            = '0';
        if s2fs1walk then
            result.addrdesc.memattrs = </del><a href="shared_pseudocode.html#impl-shared.S2AttrDecode.3" title="function: MemoryAttributes S2AttrDecode(bits(2) SH, bits(4) attr, AccType acctype)"><del>S2AttrDecode</del></a><del>(sh, memattr, </del><a href="shared_pseudocode.html#AccType_PTW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_PTW</del></a><del>);
        else
            result.addrdesc.memattrs = </del><a href="shared_pseudocode.html#impl-shared.S2AttrDecode.3" title="function: MemoryAttributes S2AttrDecode(bits(2) SH, bits(4) attr, AccType acctype)"><del>S2AttrDecode</del></a><del>(sh, memattr, acctype);
        result.addrdesc.paddress.NS = nsaccess;

    result.addrdesc.paddress.address = outputaddress;
    result.addrdesc.fault = </del><a href="shared_pseudocode.html#AArch64.NoFault.0" title="function: FaultRecord AArch64.NoFault()"><del>AArch64.NoFault</del></a><del>();
    result.contiguous = contiguousbit == '1';
    if </del><a href="shared_pseudocode.html#impl-shared.HaveCommonNotPrivateTransExt.0" title="function: boolean HaveCommonNotPrivateTransExt()"><del>HaveCommonNotPrivateTransExt</del></a><a id="CrossTriggerIn_TraceExtOut3" name="CrossTriggerIn_TraceExtOut3"></a><ins>CrossTriggerIn_TraceExtOut3};</ins><del>() then result.CnP = baseregister&lt;0>;

    return result;</del></p></div><div class="ps" psname="shared.debug.dccanditr.CheckForDCCInterrupts"><a id="shared.debug.dccanditr.CheckForDCCInterrupts" name="shared.debug.dccanditr.CheckForDCCInterrupts"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>dccanditr</ins><del>ClearStickyErrors</del>/<ins>CheckForDCCInterrupts</ins><del>ClearStickyErrors</del></h3><p class="pseudocode"><ins>// CheckForDCCInterrupts()
// =======================</ins><del>// ClearStickyErrors()
// ===================</del>

<a id="impl-shared.CheckForDCCInterrupts.0" name="impl-shared.CheckForDCCInterrupts.0"></a><ins>CheckForDCCInterrupts()
    commrx = (EDSCR.RXfull == '1');
    commtx = (EDSCR.TXfull == '0');
</ins><del>ClearStickyErrors()
    EDSCR.TXU = '0';            // Clear TX underrun flag
    EDSCR.RXO = '0';            // Clear RX overrun flag
</del>
<ins>    // COMMRX and COMMTX support is optional and not recommended for new designs.
    // SetInterruptRequestLevel(InterruptID_COMMRX, if commrx then HIGH else LOW);
    // SetInterruptRequestLevel(InterruptID_COMMTX, if commtx then HIGH else LOW);

    // The value to be driven onto the common COMMIRQ signal.
</ins>    if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><del>Halted</del></a><ins>(</ins><del>() then            // in Debug state
        EDSCR.ITO = '0';        // Clear ITR overrun flag

    // If halted and the ITR is not empty then it is UNPREDICTABLE whether the EDSCR.ERR is cleared.
    // The UNPREDICTABLE behavior also affects the instructions in flight, but this is not described
    // in the pseudocode.
    if</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><del>Halted</del></a><ins>) then
        commirq = ((commrx &amp;&amp; DBGDCCINT.RX == '1') ||
                   (commtx &amp;&amp; DBGDCCINT.TX == '1'));
    else
        commirq = ((commrx &amp;&amp; MDCCINT_EL1.RX == '1') ||
                   (commtx &amp;&amp; MDCCINT_EL1.TX == '1'));
    SetInterruptRequestLevel(</ins><del>() &amp;&amp; EDSCR.ITE == '0' &amp;&amp;</del><del>(</del><a href="shared_pseudocode.html#Unpredictable_CLEARERRITEZERO" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_CLEARERRITEZERO</del></a><a href="shared_pseudocode.html#InterruptID_COMMIRQ" title="enumeration InterruptID {InterruptID_PMUIRQ, InterruptID_COMMIRQ, InterruptID_CTIIRQ, InterruptID_COMMRX, InterruptID_COMMTX}"><ins>InterruptID_COMMIRQ</ins></a><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><del>ConstrainUnpredictableBool</del></a><ins>, if commirq then HIGH else LOW);
</ins><del>) then
        return;
    EDSCR.ERR = '0';            // Clear cumulative error flag
</del>
    return;</p></div><div class="ps" psname="shared.debug.dccanditr.DBGDTRRX_EL0"><a id="shared.debug.dccanditr.DBGDTRRX_EL0" name="shared.debug.dccanditr.DBGDTRRX_EL0"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>dccanditr</ins><del>DebugTarget</del>/<ins>DBGDTRRX_EL0</ins><del>DebugTarget</del></h3><p class="pseudocode"><ins>// DBGDTRRX_EL0[] (external write)
// ===============================
// Called on writes to debug register 0x08C.</ins><del>// DebugTarget()
// =============
// Returns the debug exception target Exception level

bits(2)</del>

<a id="impl-shared.DBGDTRRX_EL0.write.1" name="impl-shared.DBGDTRRX_EL0.write.1"></a><ins>DBGDTRRX_EL0[boolean memory_mapped] = bits(32) value

    if EDPRSR&lt;6:5,0> != '001' then                      // Check DLK, OSLK and PU bits
        IMPLEMENTATION_DEFINED "signal slave-generated error";
        return;

    if EDSCR.ERR == '1' then return;                    // Error flag set: ignore write

    // The Software lock is OPTIONAL.
    if memory_mapped &amp;&amp; EDLSR.SLK == '1' then return;   // Software lock locked: ignore write

    if EDSCR.RXfull == '1' || (</ins><del>DebugTarget()
    secure =</del><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><ins>Halted</ins></a><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><ins>() &amp;&amp; EDSCR.MA == '1' &amp;&amp; EDSCR.ITE == '0') then
        EDSCR.RXO = '1';  EDSCR.ERR = '1';              // Overrun condition: ignore write
        return;

    EDSCR.RXfull = '1';
    DTRRX = value;

    if</ins><del>();
    return</del> <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><ins>Halted</ins></a><a href="shared_pseudocode.html#impl-shared.DebugTargetFrom.1" title="function: bits(2) DebugTargetFrom(boolean secure)"><del>DebugTargetFrom</del></a><ins>() &amp;&amp; EDSCR.MA == '1' then
        EDSCR.ITE = '0';                            // See comments in EDITR[] (external write)
        if !</ins><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>() then
            </ins><a href="shared_pseudocode.html#impl-shared.ExecuteA64.1" title="function: ExecuteA64(bits(32) instr)"><ins>ExecuteA64</ins></a><ins>(0xD5330501&lt;31:0>);               // A64 "MRS X1,DBGDTRRX_EL0"
            </ins><a href="shared_pseudocode.html#impl-shared.ExecuteA64.1" title="function: ExecuteA64(bits(32) instr)"><ins>ExecuteA64</ins></a><ins>(0xB8004401&lt;31:0>);               // A64 "STR W1,[X0],#4"
            </ins><a href="shared_pseudocode.html#impl-aarch64.X.write.1" title="accessor: X[integer n] = bits(width) value"><ins>X</ins></a><ins>[1] = bits(64) UNKNOWN;
        else
            </ins><a href="shared_pseudocode.html#impl-shared.ExecuteT32.2" title="function: ExecuteT32(bits(16) hw1, bits(16) hw2)"><ins>ExecuteT32</ins></a><ins>(0xEE10&lt;15:0> /*hw1*/, 0x1E15&lt;15:0> /*hw2*/);  // T32 "MRS R1,DBGDTRRXint"
            </ins><a href="shared_pseudocode.html#impl-shared.ExecuteT32.2" title="function: ExecuteT32(bits(16) hw1, bits(16) hw2)"><ins>ExecuteT32</ins></a><ins>(0xF840&lt;15:0> /*hw1*/, 0x1B04&lt;15:0> /*hw2*/);  // T32 "STR R1,[R0],#4"
            </ins><a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value"><ins>R</ins></a><ins>[1] = bits(32) UNKNOWN;
        // If the store aborts, the Data Abort exception is taken and EDSCR.ERR is set to 1
        if EDSCR.ERR == '1' then
            EDSCR.RXfull = bit UNKNOWN;
            DBGDTRRX_EL0 = bits(32) UNKNOWN;
        else
            // "MRS X1,DBGDTRRX_EL0" calls DBGDTR_EL0[] (read) which clears RXfull.
            assert EDSCR.RXfull == '0';

        EDSCR.ITE = '1';                                // See comments in EDITR[] (external write)
    return;

// DBGDTRRX_EL0[] (external read)
// ==============================

bits(32) </ins><a id="impl-shared.DBGDTRRX_EL0.read.1" name="impl-shared.DBGDTRRX_EL0.read.1"></a><ins>DBGDTRRX_EL0[boolean memory_mapped]
    return DTRRX;</ins><del>(secure);</del></p></div><div class="ps" psname="shared.debug.dccanditr.DBGDTRTX_EL0"><a id="shared.debug.dccanditr.DBGDTRTX_EL0" name="shared.debug.dccanditr.DBGDTRTX_EL0"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>dccanditr</ins><del>DebugTarget</del>/<ins>DBGDTRTX_EL0</ins><del>DebugTargetFrom</del></h3><p class="pseudocode"><ins>// DBGDTRTX_EL0[] (external read)
// ==============================
// Called on reads of debug register 0x080.
</ins><del>// DebugTargetFrom()
// =================
</del>
<ins>bits(32)</ins><del>bits(2)</del> <a id="impl-shared.DBGDTRTX_EL0.read.1" name="impl-shared.DBGDTRTX_EL0.read.1"></a><ins>DBGDTRTX_EL0[boolean memory_mapped]

    if EDPRSR&lt;6:5,0> != '001' then                      // Check DLK, OSLK and PU bits
        IMPLEMENTATION_DEFINED "signal slave-generated error";
        return bits(32) UNKNOWN;

    underrun = EDSCR.TXfull == '0' || (</ins><del>DebugTargetFrom(boolean secure)
    if</del><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><ins>Halted</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>() &amp;&amp; EDSCR.MA == '1' &amp;&amp; EDSCR.ITE == '0');
    value = if underrun then bits(32) UNKNOWN else DTRTX;

    if EDSCR.ERR == '1' then return value;              // Error flag set: no side-effects

    // The Software lock is OPTIONAL.
    if memory_mapped &amp;&amp; EDLSR.SLK == '1' then           // Software lock locked: no side-effects
        return value;

    if underrun then
        EDSCR.TXU = '1';  EDSCR.ERR = '1';              // Underrun condition: block side-effects
        return value;                                   // Return UNKNOWN

    EDSCR.TXfull = '0';
    if</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><ins>Halted</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>() &amp;&amp; EDSCR.MA == '1' then
        EDSCR.ITE = '0';                                // See comments in EDITR[] (external write)

        if !</ins><del>) &amp;&amp; !secure then
        if</del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><ins>() then</ins><del>(</del>
            <a href="shared_pseudocode.html#impl-shared.ExecuteA64.1" title="function: ExecuteA64(bits(32) instr)"><ins>ExecuteA64</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>(0xB8404401&lt;31:0>);               // A64 "LDR W1,[X0],#4"
        else</ins><del>) then
            route_to_el2 = (HDCR.TDE == '1' || HCR.TGE == '1');
        else
            route_to_el2 = (MDCR_EL2.TDE == '1' || HCR_EL2.TGE == '1');
    else
        route_to_el2 = FALSE;

    if route_to_el2 then
        target =</del>
            <a href="shared_pseudocode.html#impl-shared.ExecuteT32.2" title="function: ExecuteT32(bits(16) hw1, bits(16) hw2)"><ins>ExecuteT32</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>(0xF850&lt;15:0> /*hw1*/, 0x1B04&lt;15:0> /*hw2*/);      // T32 "LDR R1,[R0],#4"
        // If the load aborts, the Data Abort exception is taken and EDSCR.ERR is set to 1
        if EDSCR.ERR == '1' then
            EDSCR.TXfull = bit UNKNOWN;
            DBGDTRTX_EL0 = bits(32) UNKNOWN;
        else
            if !</ins><del>;
    elsif</del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>() then</ins><del>(</del>
                <a href="shared_pseudocode.html#impl-shared.ExecuteA64.1" title="function: ExecuteA64(bits(32) instr)"><ins>ExecuteA64</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><ins>(0xD5130501&lt;31:0>);           // A64 "MSR DBGDTRTX_EL0,X1"
            else</ins><del>) &amp;&amp;</del>
                <a href="shared_pseudocode.html#impl-shared.ExecuteT32.2" title="function: ExecuteT32(bits(16) hw1, bits(16) hw2)"><ins>ExecuteT32</ins></a><a href="shared_pseudocode.html#impl-shared.HighestELUsingAArch32.0" title="function: boolean HighestELUsingAArch32()"><del>HighestELUsingAArch32</del></a><ins>(0xEE00&lt;15:0> /*hw1*/, 0x1E15&lt;15:0> /*hw2*/);  // T32 "MSR DBGDTRTXint,R1"
            // "MSR DBGDTRTX_EL0,X1" calls DBGDTR_EL0[] (write) which sets TXfull.
            assert EDSCR.TXfull == '1';
        if !</ins><del>() &amp;&amp; secure then
        target =</del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><ins>() then</ins><del>;
    else
        target =</del>
            <a href="shared_pseudocode.html#impl-aarch64.X.write.1" title="accessor: X[integer n] = bits(width) value"><ins>X</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>[1] = bits(64) UNKNOWN;
        else
            </ins><a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value"><ins>R</ins></a><ins>[1] = bits(32) UNKNOWN;
        EDSCR.ITE = '1';                                // See comments in EDITR[] (external write)

    return value;

// DBGDTRTX_EL0[] (external write)
// ===============================

</ins><a id="impl-shared.DBGDTRTX_EL0.write.1" name="impl-shared.DBGDTRTX_EL0.write.1"></a><ins>DBGDTRTX_EL0[boolean memory_mapped] = bits(32) value
    // The Software lock is OPTIONAL.
    if memory_mapped &amp;&amp; EDLSR.SLK == '1' then return;   // Software lock locked: ignore write
    DTRTX = value;
    return;</ins><del>;

    return target;</del></p></div><div class="ps" psname="shared.debug.dccanditr.DBGDTR_EL0"><a id="shared.debug.dccanditr.DBGDTR_EL0" name="shared.debug.dccanditr.DBGDTR_EL0"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>dccanditr</ins><del>DoubleLockStatus</del>/<ins>DBGDTR_EL0</ins><del>DoubleLockStatus</del></h3><p class="pseudocode"><ins>// DBGDTR_EL0[] (write)
// ====================
// System register writes to DBGDTR_EL0, DBGDTRTX_EL0 (AArch64) and DBGDTRTXint (AArch32)</ins><del>// DoubleLockStatus()
// ==================
// Returns the state of the OS Double Lock.
//    FALSE if OSDLR_EL1.DLK == 0 or DBGPRCR_EL1.CORENPDRQ == 1 or the PE is in Debug state.
//    TRUE if OSDLR_EL1.DLK == 1 and DBGPRCR_EL1.CORENPDRQ == 0 and the PE is in Non-debug state.

boolean</del>

<a id="impl-shared.DBGDTR_EL0.write.0" name="impl-shared.DBGDTR_EL0.write.0"></a><ins>DBGDTR_EL0[] = bits(N) value
    // For MSR DBGDTRTX_EL0,&lt;Rt>  N=32, value=X[t]&lt;31:0>, X[t]&lt;63:32> is ignored
    // For MSR DBGDTR_EL0,&lt;Xt>    N=64, value=X[t]&lt;63:0>
    assert N IN {32,64};
    if EDSCR.TXfull == '1' then
        value = bits(N) UNKNOWN;
    // On a 64-bit write, implement a half-duplex channel
    if N == 64 then DTRRX = value&lt;63:32>;
    DTRTX = value&lt;31:0>;        // 32-bit or 64-bit write
    EDSCR.TXfull = '1';
    return;

// DBGDTR_EL0[] (read)
// ===================
// System register reads of DBGDTR_EL0, DBGDTRRX_EL0 (AArch64) and DBGDTRRXint (AArch32)

bits(N)</ins><del>DoubleLockStatus()
    if !</del> <del>() then
        return FALSE;
    elsif </del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>) then
        return DBGOSDLR.DLK == '1' &amp;&amp; DBGPRCR.CORENPDRQ == '0' &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><del>Halted</del></a><del>();
    else
        return OSDLR_EL1.DLK == '1' &amp;&amp; DBGPRCR_EL1.CORENPDRQ == '0' &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><del>Halted</del></a><a id="impl-shared.DBGDTR_EL0.read.0" name="impl-shared.DBGDTR_EL0.read.0"></a><ins>DBGDTR_EL0[]
    // For MRS &lt;Rt>,DBGDTRTX_EL0  N=32, X[t]=Zeros(32):result
    // For MRS &lt;Xt>,DBGDTR_EL0    N=64, X[t]=result
    assert N IN {32,64};
    bits(N) result;
    if EDSCR.RXfull == '0' then
        result = bits(N) UNKNOWN;
    else
        // On a 64-bit read, implement a half-duplex channel
        // NOTE: the word order is reversed on reads with regards to writes
        if N == 64 then result&lt;63:32> = DTRTX;
        result&lt;31:0> = DTRRX;
    EDSCR.RXfull = '0';
    return result;</ins><del>();</del></p></div><div class="ps" psname="shared.debug.dccanditr.DTR"><a id="shared.debug.dccanditr.DTR" name="shared.debug.dccanditr.DTR"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>dccanditr</ins><del>authentication</del>/<ins>DTR</ins><del>AllowExternalDebugAccess</del></h3><p class="pseudocode"><ins>bits(32) DTRRX;
bits(32) DTRTX;</ins><del>// AllowExternalDebugAccess()
// ==========================
// Returns TRUE if the External Debugger access is allowed.

boolean</del><a id="impl-shared.AllowExternalDebugAccess.1" name="impl-shared.AllowExternalDebugAccess.1"></a><del>AllowExternalDebugAccess(boolean access_is_secure)
    // The access may also be subject to OS lock, power-down, etc.
    if </del><a href="shared_pseudocode.html#impl-shared.HaveSecureExtDebugView.0" title="function: boolean HaveSecureExtDebugView()"><del>HaveSecureExtDebugView</del></a><del>() || </del><a href="shared_pseudocode.html#impl-shared.ExternalDebugEnabled.0" title="function: boolean ExternalDebugEnabled()"><del>ExternalDebugEnabled</del></a><del>() then
        if </del><a href="shared_pseudocode.html#impl-shared.HaveSecureExtDebugView.0" title="function: boolean HaveSecureExtDebugView()"><del>HaveSecureExtDebugView</del></a><del>() then
            allow_secure = access_is_secure;
        else
            allow_secure = </del><a href="shared_pseudocode.html#impl-shared.ExternalSecureDebugEnabled.0" title="function: boolean ExternalSecureDebugEnabled()"><del>ExternalSecureDebugEnabled</del></a><del>();

        if allow_secure then
            return TRUE;
        elsif </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) then
            return (if </del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) then SDCR.EDAD else MDCR_EL3.EDAD) == '0';
        else
            return !</del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>();
    else
        return FALSE;</del></p></div><div class="ps" psname="shared.debug.dccanditr.EDITR"><a id="shared.debug.dccanditr.EDITR" name="shared.debug.dccanditr.EDITR"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>dccanditr</ins><del>authentication</del>/<ins>EDITR</ins><del>AllowExternalPMUAccess</del></h3><p class="pseudocode"><ins>// EDITR[] (external write)
</ins><del>// AllowExternalPMUAccess()
</del>// ========================
<ins>// Called on writes to debug register 0x084.</ins><del>// Returns TRUE if the External Debugger access is allowed.

boolean</del>

<a id="impl-shared.EDITR.write.1" name="impl-shared.EDITR.write.1"></a><ins>EDITR[boolean memory_mapped] = bits(32) value
    if EDPRSR&lt;6:5,0> != '001' then                      // Check DLK, OSLK and PU bits
        IMPLEMENTATION_DEFINED "signal slave-generated error";
        return;

    if EDSCR.ERR == '1' then return;                    // Error flag set: ignore write

    // The Software lock is OPTIONAL.
    if memory_mapped &amp;&amp; EDLSR.SLK == '1' then return;   // Software lock locked: ignore write

    if !</ins><del>AllowExternalPMUAccess(boolean access_is_secure)
    // The access may also be subject to OS lock, power-down, etc.
    if</del><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><ins>Halted</ins></a><a href="shared_pseudocode.html#impl-shared.HaveSecureExtDebugView.0" title="function: boolean HaveSecureExtDebugView()"><del>HaveSecureExtDebugView</del></a><ins>() then return;                           // Non-debug state: ignore write

    if EDSCR.ITE == '0' || EDSCR.MA == '1' then
        EDSCR.ITO = '1';  EDSCR.ERR = '1';              // Overrun condition: block write
        return;

    // ITE indicates whether the processor is ready to accept another instruction; the processor
    // may support multiple outstanding instructions. Unlike the "InstrCompl" flag in [v7A] there
    // is no indication that the pipeline is empty (all instructions have completed). In this
    // pseudocode, the assumption is that only one instruction can be executed at a time,
    // meaning ITE acts like "InstrCompl".
    EDSCR.ITE = '0';

    if !</ins><del>() ||</del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><a href="shared_pseudocode.html#impl-shared.ExternalNoninvasiveDebugEnabled.0" title="function: boolean ExternalNoninvasiveDebugEnabled()"><del>ExternalNoninvasiveDebugEnabled</del></a><ins>() then</ins><del>() then
        if</del>
        <a href="shared_pseudocode.html#impl-shared.ExecuteA64.1" title="function: ExecuteA64(bits(32) instr)"><ins>ExecuteA64</ins></a><a href="shared_pseudocode.html#impl-shared.HaveSecureExtDebugView.0" title="function: boolean HaveSecureExtDebugView()"><del>HaveSecureExtDebugView</del></a><ins>(value);
    else</ins><del>() then
            allow_secure = access_is_secure;
        else
            allow_secure =</del>
        <del>();
        if allow_secure then
            return TRUE;
        elsif </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) then
            return (if </del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) then SDCR.EPMAD else MDCR_EL3.EPMAD) == '0';
        else
            return !</del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><a href="shared_pseudocode.html#impl-shared.ExecuteT32.2" title="function: ExecuteT32(bits(16) hw1, bits(16) hw2)"><ins>ExecuteT32</ins></a><a href="shared_pseudocode.html#impl-shared.ExternalSecureNoninvasiveDebugEnabled.0" title="function: boolean ExternalSecureNoninvasiveDebugEnabled()"><del>ExternalSecureNoninvasiveDebugEnabled</del></a><ins>(value&lt;15:0>/*hw1*/, value&lt;31:16> /*hw2*/);

    EDSCR.ITE = '1';

    return;</ins><del>();
    else
        return FALSE;</del></p></div><div class="ps" psname="shared.debug.halting.DCPSInstruction"><a id="shared.debug.halting.DCPSInstruction" name="shared.debug.halting.DCPSInstruction"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>halting</ins><del>authentication</del>/<ins>DCPSInstruction</ins><del>Debug_authentication</del></h3><p class="pseudocode"><ins>// DCPSInstruction()
// =================
// Operation of the DCPS instruction in Debug state</ins><del>signal DBGEN;
signal NIDEN;
signal SPIDEN;
signal SPNIDEN;</del>

<a id="impl-shared.DCPSInstruction.1" name="impl-shared.DCPSInstruction.1"></a><ins>DCPSInstruction(bits(2) target_el)

    </ins><a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()"><ins>SynchronizeContext</ins></a><ins>();

    case target_el of
        when </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>
            if PSTATE.EL == </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins> || (PSTATE.EL == </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins> &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>()) then handle_el = PSTATE.EL;
            elsif </ins><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>() &amp;&amp; HCR_EL2.TGE == '1' then UndefinedFault();
            else handle_el = </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>;

        when </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>
            if !</ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) then UndefinedFault();
            elsif PSTATE.EL == </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins> &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>() then handle_el = </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>;
            elsif !</ins><a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()"><ins>IsSecureEL2Enabled</ins></a><ins>() &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>() then UndefinedFault();
            else handle_el = </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>;
        when </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>
            if EDSCR.SDD == '1' || !</ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) then UndefinedFault();
            handle_el = </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>;
        otherwise
            </ins><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><ins>Unreachable</ins></a><ins>();

    from_secure = </ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>();
    if </ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(handle_el) then
        if PSTATE.M == </ins><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><ins>M32_Monitor</ins></a><ins> then SCR.NS = '0';
        assert </ins><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>();                  // Cannot move from AArch64 to AArch32
        case handle_el of
            when </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)"><ins>AArch32.WriteMode</ins></a><ins>(</ins><a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'"><ins>M32_Svc</ins></a><ins>);
                if </ins><a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()"><ins>HavePANExt</ins></a><ins>() &amp;&amp; SCTLR.SPAN == '0' then
                    PSTATE.PAN = '1';
            when </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>  </ins><a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)"><ins>AArch32.WriteMode</ins></a><ins>(</ins><a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'"><ins>M32_Hyp</ins></a><ins>);
            when </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)"><ins>AArch32.WriteMode</ins></a><ins>(</ins><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><ins>M32_Monitor</ins></a><ins>);
                if </ins><a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()"><ins>HavePANExt</ins></a><ins>() then
                    if !from_secure then
                        PSTATE.PAN = '0';
                    elsif SCTLR.SPAN == '0' then
                        PSTATE.PAN = '1';
        if handle_el == </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins> then
            ELR_hyp = bits(32) UNKNOWN;  HSR = bits(32) UNKNOWN;
        else
            </ins><a href="shared_pseudocode.html#impl-aarch32.LR.write.none" title="accessor: LR = bits(32) value"><ins>LR</ins></a><ins> = bits(32) UNKNOWN;
        </ins><a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(32) value"><ins>SPSR</ins></a><ins>[] = bits(32) UNKNOWN;
        PSTATE.E = </ins><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><ins>SCTLR</ins></a><ins>[].EE;
        DLR = bits(32) UNKNOWN;  DSPSR = bits(32) UNKNOWN;

    else                                        // Targeting AArch64
        if </ins><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>() then
            </ins><a href="shared_pseudocode.html#AArch64.MaybeZeroRegisterUppers.0" title="function: AArch64.MaybeZeroRegisterUppers()"><ins>AArch64.MaybeZeroRegisterUppers</ins></a><ins>();
        </ins><a href="shared_pseudocode.html#impl-aarch64.MaybeZeroSVEUppers.1" title="function: MaybeZeroSVEUppers(bits(2) target_el)"><ins>MaybeZeroSVEUppers</ins></a><ins>(target_el);
        PSTATE.nRW = '0';  PSTATE.SP = '1';  PSTATE.EL = handle_el;
        if </ins><a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()"><ins>HavePANExt</ins></a><ins>() &amp;&amp; ((handle_el == </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins> &amp;&amp; SCTLR_EL1.SPAN == '0') ||
                             (handle_el == </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins> &amp;&amp; HCR_EL2.E2H == '1' &amp;&amp;
                             HCR_EL2.TGE == '1' &amp;&amp; SCTLR_EL2.SPAN == '0')) then
            PSTATE.PAN = '1';
        </ins><a href="shared_pseudocode.html#impl-aarch64.ELR.write.0" title="accessor: ELR[] = bits(64) value"><ins>ELR</ins></a><ins>[] = bits(64) UNKNOWN;  </ins><a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(32) value"><ins>SPSR</ins></a><ins>[] = bits(32) UNKNOWN;  </ins><a href="shared_pseudocode.html#impl-aarch64.ESR.write.0" title="accessor: ESR[] = ESRType value"><ins>ESR</ins></a><ins>[] = bits(32) UNKNOWN;
        DLR_EL0 = bits(64) UNKNOWN;  DSPSR_EL0 = bits(32) UNKNOWN;
        if </ins><a href="shared_pseudocode.html#impl-shared.HaveUAOExt.0" title="function: boolean HaveUAOExt()"><ins>HaveUAOExt</ins></a><ins>() then PSTATE.UAO = '0';

    </ins><a href="shared_pseudocode.html#impl-shared.UpdateEDSCRFields.0" title="function: UpdateEDSCRFields()"><ins>UpdateEDSCRFields</ins></a><ins>();                        // Update EDSCR PE state flags
    sync_errors = </ins><a href="shared_pseudocode.html#impl-shared.HaveIESB.0" title="function: boolean HaveIESB()"><ins>HaveIESB</ins></a><ins>() &amp;&amp; </ins><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><ins>SCTLR</ins></a><ins>[].IESB == '1';
    if </ins><a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()"><ins>HaveDoubleFaultExt</ins></a><ins>() &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>() then
        sync_errors = sync_errors || (SCR_EL3.EA == '1' &amp;&amp; SCR_EL3.NMEA == '1' &amp;&amp; PSTATE.EL == </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>);
    // SCTLR[].IESB might be ignored in Debug state.
    if !</ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><ins>ConstrainUnpredictableBool</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_IESBinDebug" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_IESBinDebug</ins></a><ins>) then
        sync_errors = FALSE;
    if sync_errors then
        </ins><a href="shared_pseudocode.html#impl-shared.SynchronizeErrors.0" title="function: SynchronizeErrors()"><ins>SynchronizeErrors</ins></a><ins>();
    return;</ins></p></div><div class="ps" psname="shared.debug.halting.DRPSInstruction"><a id="shared.debug.halting.DRPSInstruction" name="shared.debug.halting.DRPSInstruction"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>halting</ins><del>authentication</del>/<ins>DRPSInstruction</ins><del>ExternalDebugEnabled</del></h3><p class="pseudocode"><ins>// DRPSInstruction()
// =================
// Operation of the A64 DRPS and T32 ERET instructions in Debug state</ins><del>// ExternalDebugEnabled()
// ======================

boolean</del>

<a id="impl-shared.DRPSInstruction.0" name="impl-shared.DRPSInstruction.0"></a><ins>DRPSInstruction()</ins><del>ExternalDebugEnabled()
    // The definition of this function is IMPLEMENTATION DEFINED.
    // In the recommended interface, this function returns the state of the DBGEN signal.
    return DBGEN == HIGH;</del>

    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()"><ins>SynchronizeContext</ins></a><ins>();

    sync_errors = </ins><a href="shared_pseudocode.html#impl-shared.HaveIESB.0" title="function: boolean HaveIESB()"><ins>HaveIESB</ins></a><ins>() &amp;&amp; </ins><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><ins>SCTLR</ins></a><ins>[].IESB == '1';
    if </ins><a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()"><ins>HaveDoubleFaultExt</ins></a><ins>() &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>() then
        sync_errors = sync_errors || (SCR_EL3.EA == '1' &amp;&amp; SCR_EL3.NMEA == '1' &amp;&amp; PSTATE.EL == </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>);
    // SCTLR[].IESB might be ignored in Debug state.
    if !</ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><ins>ConstrainUnpredictableBool</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_IESBinDebug" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_IESBinDebug</ins></a><ins>) then
        sync_errors = FALSE;
    if sync_errors then
        </ins><a href="shared_pseudocode.html#impl-shared.SynchronizeErrors.0" title="function: SynchronizeErrors()"><ins>SynchronizeErrors</ins></a><ins>();

    </ins><a href="shared_pseudocode.html#impl-shared.SetPSTATEFromPSR.1" title="function: SetPSTATEFromPSR(bits(32) spsr)"><ins>SetPSTATEFromPSR</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.SPSR.read.0" title="accessor: bits(32) SPSR[]"><ins>SPSR</ins></a><ins>[]);

    // PSTATE.{N,Z,C,V,Q,GE,SS,D,A,I,F} are not observable and ignored in Debug state, so
    // behave as if UNKNOWN.
    if </ins><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>() then
        PSTATE.&lt;N,Z,C,V,Q,GE,SS,A,I,F> = bits(13) UNKNOWN;
        //  In AArch32, all instructions are T32 and unconditional.
        PSTATE.IT = '00000000';  PSTATE.T = '1';        // PSTATE.J is RES0
        DLR = bits(32) UNKNOWN;  DSPSR = bits(32) UNKNOWN;
    else
        PSTATE.&lt;N,Z,C,V,SS,D,A,I,F> = bits(9) UNKNOWN;
        DLR_EL0 = bits(64) UNKNOWN;  DSPSR_EL0 = bits(32) UNKNOWN;

    </ins><a href="shared_pseudocode.html#impl-shared.UpdateEDSCRFields.0" title="function: UpdateEDSCRFields()"><ins>UpdateEDSCRFields</ins></a><ins>();                                // Update EDSCR PE state flags

    return;</ins></p></div><div class="ps" psname="shared.debug.halting.DebugHalt"><a id="shared.debug.halting.DebugHalt" name="shared.debug.halting.DebugHalt"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>halting</ins><del>authentication</del>/<ins>DebugHalt</ins><del>ExternalHypInvasiveDebugEnabled</del></h3><p class="pseudocode"><ins>constant bits(6)</ins><del>// ExternalHypInvasiveDebugEnabled()
// =================================

boolean</del> <a id="DebugHalt_Breakpoint" name="DebugHalt_Breakpoint"></a><ins>DebugHalt_Breakpoint      = '000111';
constant bits(6)</ins><del>ExternalHypInvasiveDebugEnabled()
    // In the recommended interface, ExternalHypInvasiveDebugEnabled returns the state of the
    // (DBGEN AND HIDEN) signal.
    return</del> <a id="DebugHalt_EDBGRQ" name="DebugHalt_EDBGRQ"></a><ins>DebugHalt_EDBGRQ          = '010011';
constant bits(6) </ins><a id="DebugHalt_Step_Normal" name="DebugHalt_Step_Normal"></a><ins>DebugHalt_Step_Normal     = '011011';
constant bits(6) </ins><a id="DebugHalt_Step_Exclusive" name="DebugHalt_Step_Exclusive"></a><ins>DebugHalt_Step_Exclusive  = '011111';
constant bits(6) </ins><a id="DebugHalt_OSUnlockCatch" name="DebugHalt_OSUnlockCatch"></a><ins>DebugHalt_OSUnlockCatch   = '100011';
constant bits(6) </ins><a id="DebugHalt_ResetCatch" name="DebugHalt_ResetCatch"></a><ins>DebugHalt_ResetCatch      = '100111';
constant bits(6) </ins><a id="DebugHalt_Watchpoint" name="DebugHalt_Watchpoint"></a><ins>DebugHalt_Watchpoint      = '101011';
constant bits(6) </ins><a id="DebugHalt_HaltInstruction" name="DebugHalt_HaltInstruction"></a><ins>DebugHalt_HaltInstruction = '101111';
constant bits(6) </ins><a id="DebugHalt_SoftwareAccess" name="DebugHalt_SoftwareAccess"></a><ins>DebugHalt_SoftwareAccess  = '110011';
constant bits(6) </ins><a id="DebugHalt_ExceptionCatch" name="DebugHalt_ExceptionCatch"></a><ins>DebugHalt_ExceptionCatch  = '110111';
constant bits(6) </ins><a id="DebugHalt_Step_NoSyndrome" name="DebugHalt_Step_NoSyndrome"></a><ins>DebugHalt_Step_NoSyndrome = '111011';</ins><del>() &amp;&amp; HIDEN == HIGH;</del></p></div><div class="ps" psname="shared.debug.halting.DisableITRAndResumeInstructionPrefetch"><a id="shared.debug.halting.DisableITRAndResumeInstructionPrefetch" name="shared.debug.halting.DisableITRAndResumeInstructionPrefetch"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>halting</ins><del>authentication</del>/<ins>DisableITRAndResumeInstructionPrefetch</ins><del>ExternalHypNoninvasiveDebugEnabled</del></h3><p class="pseudocode"><del>// ExternalHypNoninvasiveDebugEnabled()
// ====================================

boolean </del><a id="impl-shared.DisableITRAndResumeInstructionPrefetch.0" name="impl-shared.DisableITRAndResumeInstructionPrefetch.0"></a><del>ExternalHypNoninvasiveDebugEnabled()
    // The definition of this function is IMPLEMENTATION DEFINED.
    // In the recommended interface, ExternalHypNoninvasiveDebugEnabled returns the state of the
    // (DBGEN OR NIDEN) AND (HIDEN OR HNIDEN) signal.
    return </del><a href="shared_pseudocode.html#impl-shared.ExternalNoninvasiveDebugEnabled.0" title="function: boolean ExternalNoninvasiveDebugEnabled()"><del>ExternalNoninvasiveDebugEnabled</del></a><ins>DisableITRAndResumeInstructionPrefetch();</ins><del>() &amp;&amp; (HIDEN == HIGH || HNIDEN == HIGH);</del></p></div><div class="ps" psname="shared.debug.halting.ExecuteA64"><a id="shared.debug.halting.ExecuteA64" name="shared.debug.halting.ExecuteA64"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>halting</ins><del>authentication</del>/<ins>ExecuteA64</ins><del>ExternalNoninvasiveDebugAllowed</del></h3><p class="pseudocode"><ins>// Execute an A64 instruction in Debug state.</ins><del>// ExternalNoninvasiveDebugAllowed()
// =================================

boolean</del>
<a id="impl-shared.ExecuteA64.1" name="impl-shared.ExecuteA64.1"></a><ins>ExecuteA64(bits(32) instr);</ins><del>ExternalNoninvasiveDebugAllowed()
    // Return TRUE if Trace and PC Sample-based Profiling are allowed
    return (</del><a href="shared_pseudocode.html#impl-shared.ExternalNoninvasiveDebugEnabled.0" title="function: boolean ExternalNoninvasiveDebugEnabled()"><del>ExternalNoninvasiveDebugEnabled</del></a><del>() &amp;&amp;
            (!</del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>() || </del><a href="shared_pseudocode.html#impl-shared.ExternalSecureNoninvasiveDebugEnabled.0" title="function: boolean ExternalSecureNoninvasiveDebugEnabled()"><del>ExternalSecureNoninvasiveDebugEnabled</del></a><del>() ||
             (</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>) &amp;&amp; PSTATE.EL == </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del> &amp;&amp; SDER.SUNIDEN == '1')));</del></p></div><div class="ps" psname="shared.debug.halting.ExecuteT32"><a id="shared.debug.halting.ExecuteT32" name="shared.debug.halting.ExecuteT32"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>halting</ins><del>authentication</del>/<ins>ExecuteT32</ins><del>ExternalNoninvasiveDebugEnabled</del></h3><p class="pseudocode"><ins>// Execute a T32 instruction in Debug state.</ins><del>// ExternalNoninvasiveDebugEnabled()
// =================================

boolean</del>
<a id="impl-shared.ExecuteT32.2" name="impl-shared.ExecuteT32.2"></a><ins>ExecuteT32(bits(16) hw1, bits(16) hw2);</ins><del>ExternalNoninvasiveDebugEnabled()
    // This function returns TRUE if the v8.4 Debug relaxations are implemented, otherwise this
    // function is IMPLEMENTATION DEFINED.
    // In the recommended interface, ExternalNoninvasiveDebugEnabled returns the state of the (DBGEN
    // OR NIDEN) signal.
    return !</del><a href="shared_pseudocode.html#impl-shared.HaveNoninvasiveDebugAuth.0" title="function: boolean HaveNoninvasiveDebugAuth()"><del>HaveNoninvasiveDebugAuth</del></a><del>() || </del><a href="shared_pseudocode.html#impl-shared.ExternalDebugEnabled.0" title="function: boolean ExternalDebugEnabled()"><del>ExternalDebugEnabled</del></a><del>() || NIDEN == HIGH;</del></p></div><div class="ps" psname="shared.debug.halting.ExitDebugState"><a id="shared.debug.halting.ExitDebugState" name="shared.debug.halting.ExitDebugState"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>halting</ins><del>authentication</del>/<ins>ExitDebugState</ins><del>ExternalSecureDebugEnabled</del></h3><p class="pseudocode"><ins>// ExitDebugState()
// ================</ins><del>// ExternalSecureDebugEnabled()
// ============================

boolean</del>

<a id="impl-shared.ExitDebugState.0" name="impl-shared.ExitDebugState.0"></a><ins>ExitDebugState()
    assert</ins><del>ExternalSecureDebugEnabled()
    if !</del> <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><ins>Halted</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><ins>();</ins><del>(</del>
    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()"><ins>SynchronizeContext</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><ins>();

    // Although EDSCR.STATUS signals that the PE is restarting, debuggers must use EDPRSR.SDR to
    // detect that the PE has restarted.
    EDSCR.STATUS = '000001';                           // Signal restarting
    EDESR&lt;2:0> = '000';                                // Clear any pending Halting debug events

    bits(64) new_pc;
    bits(32) spsr;

    if</ins><del>) &amp;&amp; !</del> <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><ins>() then
        new_pc =</ins><del>() then return FALSE;
    // The definition of this function is IMPLEMENTATION DEFINED.
    // In the recommended interface, this function returns the state of the (DBGEN AND SPIDEN) signal.
    // CoreSight allows asserting SPIDEN without also asserting DBGEN, but this is not recommended.
    return</del> <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><a href="shared_pseudocode.html#impl-shared.ExternalDebugEnabled.0" title="function: boolean ExternalDebugEnabled()"><del>ExternalDebugEnabled</del></a><ins>(DLR);
        spsr = DSPSR;
    else
        new_pc = DLR_EL0;
        spsr = DSPSR_EL0;
    // If this is an illegal return, SetPSTATEFromPSR() will set PSTATE.IL.
    </ins><a href="shared_pseudocode.html#impl-shared.SetPSTATEFromPSR.1" title="function: SetPSTATEFromPSR(bits(32) spsr)"><ins>SetPSTATEFromPSR</ins></a><ins>(spsr);                            // Can update privileged bits, even at EL0

    if </ins><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>() then
        if </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><ins>ConstrainUnpredictableBool</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_RESTARTALIGNPC" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESTARTALIGNPC</ins></a><ins>) then new_pc&lt;0> = '0';
        </ins><a href="shared_pseudocode.html#impl-shared.BranchTo.2" title="function: BranchTo(bits(N) target, BranchType branch_type)"><ins>BranchTo</ins></a><ins>(new_pc&lt;31:0>, </ins><a href="shared_pseudocode.html#BranchType_DBGEXIT" title="enumeration BranchType { BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}"><ins>BranchType_DBGEXIT</ins></a><ins>);    // AArch32 branch
    else
        // If targeting AArch32 then possibly zero the 32 most significant bits of the target PC
        if spsr&lt;4> == '1' &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><ins>ConstrainUnpredictableBool</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_RESTARTZEROUPPERPC" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESTARTZEROUPPERPC</ins></a><ins>) then
            new_pc&lt;63:32> = </ins><a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><ins>Zeros</ins></a><ins>();
        </ins><a href="shared_pseudocode.html#impl-shared.BranchTo.2" title="function: BranchTo(bits(N) target, BranchType branch_type)"><ins>BranchTo</ins></a><ins>(new_pc, </ins><a href="shared_pseudocode.html#BranchType_DBGEXIT" title="enumeration BranchType { BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}"><ins>BranchType_DBGEXIT</ins></a><ins>);          // A type of branch that is never predicted

    (EDSCR.STATUS,EDPRSR.SDR) = ('000010','1');        // Atomically signal restarted
    </ins><a href="shared_pseudocode.html#impl-shared.UpdateEDSCRFields.0" title="function: UpdateEDSCRFields()"><ins>UpdateEDSCRFields</ins></a><ins>();                               // Stop signalling PE state
    </ins><a href="shared_pseudocode.html#impl-shared.DisableITRAndResumeInstructionPrefetch.0" title="function: DisableITRAndResumeInstructionPrefetch()"><ins>DisableITRAndResumeInstructionPrefetch</ins></a><ins>();

    return;</ins><del>() &amp;&amp; SPIDEN == HIGH;</del></p></div><div class="ps" psname="shared.debug.halting.Halt"><a id="shared.debug.halting.Halt" name="shared.debug.halting.Halt"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>halting</ins><del>authentication</del>/<ins>Halt</ins><del>ExternalSecureNoninvasiveDebugEnabled</del></h3><p class="pseudocode"><ins>// Halt()
// ======</ins><del>// ExternalSecureNoninvasiveDebugEnabled()
// =======================================

boolean</del>

<a id="impl-shared.Halt.1" name="impl-shared.Halt.1"></a><ins>Halt(bits(6) reason)</ins><del>ExternalSecureNoninvasiveDebugEnabled()
    if !</del>

    <a href="shared_pseudocode.html#impl-shared.CTI_SignalEvent.1" title="function: CTI_SignalEvent(CrossTriggerIn id)"><ins>CTI_SignalEvent</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a>(<a href="shared_pseudocode.html#CrossTriggerIn_CrossHalt" title="enumeration CrossTriggerIn  {CrossTriggerIn_CrossHalt,     CrossTriggerIn_PMUOverflow, CrossTriggerIn_RSVD2,         CrossTriggerIn_RSVD3, CrossTriggerIn_TraceExtOut0,  CrossTriggerIn_TraceExtOut1, CrossTriggerIn_TraceExtOut2,  CrossTriggerIn_TraceExtOut3}"><ins>CrossTriggerIn_CrossHalt</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><ins>);  // Trigger other cores to halt

    bits(64) preferred_restart_address =</ins><del>) &amp;&amp; !</del> <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><ins>ThisInstrAddr</ins></a><ins>();
    spsr = </ins><a href="shared_pseudocode.html#impl-shared.GetPSRFromPSTATE.0" title="function: bits(32) GetPSRFromPSTATE()"><ins>GetPSRFromPSTATE</ins></a><ins>();

    if </ins><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>() then
        // If entering from AArch32 state, spsr&lt;21> is the DIT bit which has to be moved for DSPSR
        spsr&lt;24> = spsr&lt;21>;
        spsr&lt;21> = PSTATE.SS;                    // Always save the SS bit

    if </ins><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>() then
        DLR = preferred_restart_address&lt;31:0>;
        DSPSR = spsr;
    else
        DLR_EL0 = preferred_restart_address;
        DSPSR_EL0 = spsr;

    EDSCR.ITE = '1';  EDSCR.ITO = '0';
    if </ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a><ins>() then
        EDSCR.SDD = '0';                        // If entered in Secure state, allow debug
    elsif</ins><del>() then return FALSE;
    // If the v8.4 Debug relaxations are implemented, this function returns the value of
    // ExternalSecureDebugEnabled(). Otherwise the definition of this function is
    // IMPLEMENTATION DEFINED.
    // In the recommended interface, this function returns the state of the (DBGEN OR NIDEN) AND
    // (SPIDEN OR SPNIDEN) signal.
    if</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-shared.HaveNoninvasiveDebugAuth.0" title="function: boolean HaveNoninvasiveDebugAuth()"><del>HaveNoninvasiveDebugAuth</del></a><ins>(</ins><del>() then
        return</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-shared.ExternalNoninvasiveDebugEnabled.0" title="function: boolean ExternalNoninvasiveDebugEnabled()"><del>ExternalNoninvasiveDebugEnabled</del></a><ins>) then
        EDSCR.SDD = if</ins><del>() &amp;&amp; (SPIDEN == HIGH || SPNIDEN == HIGH);
    else
        return</del> <a href="shared_pseudocode.html#impl-shared.ExternalSecureDebugEnabled.0" title="function: boolean ExternalSecureDebugEnabled()">ExternalSecureDebugEnabled</a><ins>() then '0' else '1';
    else
        assert EDSCR.SDD == '1';                // Otherwise EDSCR.SDD is RES1
    EDSCR.MA = '0';
    // PSTATE.{SS,D,A,I,F} are not observable and ignored in Debug state, so behave as if
    // UNKNOWN. PSTATE.{N,Z,C,V,Q,GE} are also not observable, but since these are not changed on
    // exception entry, this function also leaves them unchanged. PSTATE.{E,M,nRW,EL,SP} are
    // unchanged. PSTATE.IL is set to 0.
    if </ins><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>() then
        PSTATE.&lt;SS,A,I,F> = bits(4) UNKNOWN;
        //  In AArch32, all instructions are T32 and unconditional.
        PSTATE.IT = '00000000';  PSTATE.T = '1'; // PSTATE.J is RES0
    else
        PSTATE.&lt;SS,D,A,I,F> = bits(5) UNKNOWN;
    PSTATE.IL = '0';

    </ins><a href="shared_pseudocode.html#impl-shared.StopInstructionPrefetchAndEnableITR.0" title="function: StopInstructionPrefetchAndEnableITR()"><ins>StopInstructionPrefetchAndEnableITR</ins></a><ins>();
    EDSCR.STATUS = reason;                      // Signal entered Debug state
    </ins><a href="shared_pseudocode.html#impl-shared.UpdateEDSCRFields.0" title="function: UpdateEDSCRFields()"><ins>UpdateEDSCRFields</ins></a><ins>();                        // Update EDSCR PE state flags.

    return;</ins><del>();</del></p></div><div class="ps" psname="shared.debug.halting.HaltOnBreakpointOrWatchpoint"><a id="shared.debug.halting.HaltOnBreakpointOrWatchpoint" name="shared.debug.halting.HaltOnBreakpointOrWatchpoint"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>halting</ins><del>cti</del>/<ins>HaltOnBreakpointOrWatchpoint</ins><del>CTI_SetEventLevel</del></h3><p class="pseudocode"><ins>// HaltOnBreakpointOrWatchpoint()
// ==============================
// Returns TRUE if the Breakpoint and Watchpoint debug events should be considered for Debug
// state entry, FALSE if they should be considered for a debug exception.

boolean</ins><del>// Set a Cross Trigger multi-cycle input event trigger to the specified level.
CTI_SetEventLevel(</del> <a id="impl-shared.HaltOnBreakpointOrWatchpoint.0" name="impl-shared.HaltOnBreakpointOrWatchpoint.0"></a><ins>HaltOnBreakpointOrWatchpoint()
    return </ins><a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()"><ins>HaltingAllowed</ins></a><ins>() &amp;&amp; EDSCR.HDE == '1' &amp;&amp; OSLSR_EL1.OSLK == '0';</ins><del>id, signal level);</del></p></div><div class="ps" psname="shared.debug.halting.Halted"><a id="shared.debug.halting.Halted" name="shared.debug.halting.Halted"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>halting</ins><del>cti</del>/<ins>Halted</ins><del>CTI_SignalEvent</del></h3><p class="pseudocode"><ins>// Halted()
// ========

boolean</ins><del>// Signal a discrete event on a Cross Trigger input event trigger.</del> <a id="impl-shared.Halted.0" name="impl-shared.Halted.0"></a><ins>Halted()
    return !(EDSCR.STATUS IN {'000001', '000010'});                     // Halted</ins><del>CTI_SignalEvent(</del><a href="shared_pseudocode.html#CrossTriggerIn" title="enumeration CrossTriggerIn  {CrossTriggerIn_CrossHalt,     CrossTriggerIn_PMUOverflow, CrossTriggerIn_RSVD2,         CrossTriggerIn_RSVD3, CrossTriggerIn_TraceExtOut0,  CrossTriggerIn_TraceExtOut1, CrossTriggerIn_TraceExtOut2,  CrossTriggerIn_TraceExtOut3}"><del>CrossTriggerIn</del></a><del> id);</del></p></div><div class="ps" psname="shared.debug.halting.HaltingAllowed"><a id="shared.debug.halting.HaltingAllowed" name="shared.debug.halting.HaltingAllowed"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>halting</ins><del>cti</del>/<ins>HaltingAllowed</ins><del>CrossTrigger</del></h3><p class="pseudocode"><ins>// HaltingAllowed()
// ================
// Returns TRUE if halting is currently allowed, FALSE if halting is prohibited.

boolean</ins><del>enumeration</del> <a id="impl-shared.HaltingAllowed.0" name="impl-shared.HaltingAllowed.0"></a><ins>HaltingAllowed()
    if</ins><del>CrossTriggerOut {</del> <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><ins>Halted</ins></a><ins>() ||</ins><del>CrossTriggerOut_DebugRequest,</del> <a href="shared_pseudocode.html#impl-shared.DoubleLockStatus.0" title="function: boolean DoubleLockStatus()"><ins>DoubleLockStatus</ins></a><ins>() then
        return FALSE;
    elsif</ins><del>CrossTriggerOut_RestartRequest,</del> <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>() then
        return</ins><del>CrossTriggerOut_IRQ,</del> <a href="shared_pseudocode.html#impl-shared.ExternalSecureDebugEnabled.0" title="function: boolean ExternalSecureDebugEnabled()"><ins>ExternalSecureDebugEnabled</ins></a><ins>();
    else
        return</ins><del>CrossTriggerOut_RSVD3,</del> <del>CrossTriggerOut_TraceExtIn0,  </del><a id="CrossTriggerOut_TraceExtIn1" name="CrossTriggerOut_TraceExtIn1"></a><del>CrossTriggerOut_TraceExtIn1,
                             </del><a id="CrossTriggerOut_TraceExtIn2" name="CrossTriggerOut_TraceExtIn2"></a><del>CrossTriggerOut_TraceExtIn2,  </del><a id="CrossTriggerOut_TraceExtIn3" name="CrossTriggerOut_TraceExtIn3"></a><del>CrossTriggerOut_TraceExtIn3};

enumeration </del><a id="CrossTriggerIn" name="CrossTriggerIn"></a><del>CrossTriggerIn  {</del><a id="CrossTriggerIn_CrossHalt" name="CrossTriggerIn_CrossHalt"></a><del>CrossTriggerIn_CrossHalt,     </del><a id="CrossTriggerIn_PMUOverflow" name="CrossTriggerIn_PMUOverflow"></a><del>CrossTriggerIn_PMUOverflow,
                             </del><a id="CrossTriggerIn_RSVD2" name="CrossTriggerIn_RSVD2"></a><del>CrossTriggerIn_RSVD2,         </del><a id="CrossTriggerIn_RSVD3" name="CrossTriggerIn_RSVD3"></a><del>CrossTriggerIn_RSVD3,
                             </del><a id="CrossTriggerIn_TraceExtOut0" name="CrossTriggerIn_TraceExtOut0"></a><del>CrossTriggerIn_TraceExtOut0,  </del><a id="CrossTriggerIn_TraceExtOut1" name="CrossTriggerIn_TraceExtOut1"></a><del>CrossTriggerIn_TraceExtOut1,
                             </del><a id="CrossTriggerIn_TraceExtOut2" name="CrossTriggerIn_TraceExtOut2"></a><del>CrossTriggerIn_TraceExtOut2,  </del><a id="CrossTriggerIn_TraceExtOut3" name="CrossTriggerIn_TraceExtOut3"></a><a href="shared_pseudocode.html#impl-shared.ExternalDebugEnabled.0" title="function: boolean ExternalDebugEnabled()"><ins>ExternalDebugEnabled</ins></a><ins>();</ins><del>CrossTriggerIn_TraceExtOut3};</del></p></div><div class="ps" psname="shared.debug.halting.Restarting"><a id="shared.debug.halting.Restarting" name="shared.debug.halting.Restarting"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>halting</ins><del>dccanditr</del>/<ins>Restarting</ins><del>CheckForDCCInterrupts</del></h3><p class="pseudocode"><ins>// Restarting()
// ============

boolean</ins><del>// CheckForDCCInterrupts()
// =======================</del> <a id="impl-shared.Restarting.0" name="impl-shared.Restarting.0"></a><ins>Restarting()
    return EDSCR.STATUS == '000001';                                    // Restarting</ins><del>CheckForDCCInterrupts()
    commrx = (EDSCR.RXfull == '1');
    commtx = (EDSCR.TXfull == '0');

    // COMMRX and COMMTX support is optional and not recommended for new designs.
    // SetInterruptRequestLevel(InterruptID_COMMRX, if commrx then HIGH else LOW);
    // SetInterruptRequestLevel(InterruptID_COMMTX, if commtx then HIGH else LOW);

    // The value to be driven onto the common COMMIRQ signal.
    if</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>) then
        commirq = ((commrx &amp;&amp; DBGDCCINT.RX == '1') ||
                   (commtx &amp;&amp; DBGDCCINT.TX == '1'));
    else
        commirq = ((commrx &amp;&amp; MDCCINT_EL1.RX == '1') ||
                   (commtx &amp;&amp; MDCCINT_EL1.TX == '1'));
    SetInterruptRequestLevel(</del><a href="shared_pseudocode.html#InterruptID_COMMIRQ" title="enumeration InterruptID {InterruptID_PMUIRQ, InterruptID_COMMIRQ, InterruptID_CTIIRQ, InterruptID_COMMRX, InterruptID_COMMTX}"><del>InterruptID_COMMIRQ</del></a><del>, if commirq then HIGH else LOW);

    return;</del></p></div><div class="ps" psname="shared.debug.halting.StopInstructionPrefetchAndEnableITR"><a id="shared.debug.halting.StopInstructionPrefetchAndEnableITR" name="shared.debug.halting.StopInstructionPrefetchAndEnableITR"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>halting</ins><del>dccanditr</del>/<ins>StopInstructionPrefetchAndEnableITR</ins><del>DBGDTRRX_EL0</del></h3><p class="pseudocode"><del>// DBGDTRRX_EL0[] (external write)
// ===============================
// Called on writes to debug register 0x08C.

</del><a id="impl-shared.DBGDTRRX_EL0.write.1" name="impl-shared.DBGDTRRX_EL0.write.1"></a><del>DBGDTRRX_EL0[boolean memory_mapped] = bits(32) value

    if EDPRSR&lt;6:5,0> != '001' then                      // Check DLK, OSLK and PU bits
        IMPLEMENTATION_DEFINED "signal slave-generated error";
        return;

    if EDSCR.ERR == '1' then return;                    // Error flag set: ignore write

    // The Software lock is OPTIONAL.
    if memory_mapped &amp;&amp; EDLSR.SLK == '1' then return;   // Software lock locked: ignore write

    if EDSCR.RXfull == '1' || (</del><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><del>Halted</del></a><del>() &amp;&amp; EDSCR.MA == '1' &amp;&amp; EDSCR.ITE == '0') then
        EDSCR.RXO = '1';  EDSCR.ERR = '1';              // Overrun condition: ignore write
        return;

    EDSCR.RXfull = '1';
    DTRRX = value;

    if </del><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><del>Halted</del></a><del>() &amp;&amp; EDSCR.MA == '1' then
        EDSCR.ITE = '0';                                // See comments in EDITR[] (external write)

        if !</del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>() then
            </del><a href="shared_pseudocode.html#impl-shared.ExecuteA64.1" title="function: ExecuteA64(bits(32) instr)"><del>ExecuteA64</del></a><del>(0xD5330501&lt;31:0>);               // A64 "MRS X1,DBGDTRRX_EL0"
            </del><a href="shared_pseudocode.html#impl-shared.ExecuteA64.1" title="function: ExecuteA64(bits(32) instr)"><del>ExecuteA64</del></a><del>(0xB8004401&lt;31:0>);               // A64 "STR W1,[X0],#4"
            </del><a href="shared_pseudocode.html#impl-aarch64.X.write.1" title="accessor: X[integer n] = bits(width) value"><del>X</del></a><del>[1] = bits(64) UNKNOWN;
        else
            </del><a href="shared_pseudocode.html#impl-shared.ExecuteT32.2" title="function: ExecuteT32(bits(16) hw1, bits(16) hw2)"><del>ExecuteT32</del></a><del>(0xEE10&lt;15:0> /*hw1*/, 0x1E15&lt;15:0> /*hw2*/);  // T32 "MRS R1,DBGDTRRXint"
            </del><a href="shared_pseudocode.html#impl-shared.ExecuteT32.2" title="function: ExecuteT32(bits(16) hw1, bits(16) hw2)"><del>ExecuteT32</del></a><del>(0xF840&lt;15:0> /*hw1*/, 0x1B04&lt;15:0> /*hw2*/);  // T32 "STR R1,[R0],#4"
            </del><a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value"><del>R</del></a><del>[1] = bits(32) UNKNOWN;
        // If the store aborts, the Data Abort exception is taken and EDSCR.ERR is set to 1
        if EDSCR.ERR == '1' then
            EDSCR.RXfull = bit UNKNOWN;
            DBGDTRRX_EL0 = bits(32) UNKNOWN;
        else
            // "MRS X1,DBGDTRRX_EL0" calls DBGDTR_EL0[] (read) which clears RXfull.
            assert EDSCR.RXfull == '0';

        EDSCR.ITE = '1';                                // See comments in EDITR[] (external write)
    return;

// DBGDTRRX_EL0[] (external read)
// ==============================

bits(32) </del><a id="impl-shared.StopInstructionPrefetchAndEnableITR.0" name="impl-shared.StopInstructionPrefetchAndEnableITR.0"></a><ins>StopInstructionPrefetchAndEnableITR();</ins><del>DBGDTRRX_EL0[boolean memory_mapped]
    return DTRRX;</del></p></div><div class="ps" psname="shared.debug.halting.UpdateEDSCRFields"><a id="shared.debug.halting.UpdateEDSCRFields" name="shared.debug.halting.UpdateEDSCRFields"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>halting</ins><del>dccanditr</del>/<ins>UpdateEDSCRFields</ins><del>DBGDTRTX_EL0</del></h3><p class="pseudocode"><ins>// UpdateEDSCRFields()
// ===================
// Update EDSCR PE state fields</ins><del>// DBGDTRTX_EL0[] (external read)
// ==============================
// Called on reads of debug register 0x080.

bits(32)</del>

<a id="impl-shared.UpdateEDSCRFields.0" name="impl-shared.UpdateEDSCRFields.0"></a><ins>UpdateEDSCRFields()
</ins><del>DBGDTRTX_EL0[boolean memory_mapped]
</del>
<ins>    if !</ins><del>    if EDPRSR&lt;6:5,0> != '001' then                      // Check DLK, OSLK and PU bits
        IMPLEMENTATION_DEFINED "signal slave-generated error";
        return bits(32) UNKNOWN;

    underrun = EDSCR.TXfull == '0' || (</del><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a><ins>() then
        EDSCR.EL = '00';
        EDSCR.NS = bit UNKNOWN;
        EDSCR.RW = '1111';
    else
        EDSCR.EL = PSTATE.EL;
        EDSCR.NS = if</ins><del>() &amp;&amp; EDSCR.MA == '1' &amp;&amp; EDSCR.ITE == '0');
    value = if underrun then bits(32) UNKNOWN else DTRTX;

    if EDSCR.ERR == '1' then return value;              // Error flag set: no side-effects

    // The Software lock is OPTIONAL.
    if memory_mapped &amp;&amp; EDLSR.SLK == '1' then           // Software lock locked: no side-effects
        return value;

    if underrun then
        EDSCR.TXU = '1';  EDSCR.ERR = '1';              // Underrun condition: block side-effects
        return value;                                   // Return UNKNOWN

    EDSCR.TXfull = '0';
    if</del> <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><del>Halted</del></a><ins>() then '0' else '1';
</ins><del>() &amp;&amp; EDSCR.MA == '1' then
        EDSCR.ITE = '0';                                // See comments in EDITR[] (external write)
</del>
<ins>        bits(4) RW;
        RW&lt;1> = if</ins><del>        if !</del> <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><ins>(</ins><del>() then</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#impl-shared.ExecuteA64.1" title="function: ExecuteA64(bits(32) instr)"><del>ExecuteA64</del></a><ins>) then '0' else '1';
        if PSTATE.EL !=</ins><del>(0xB8404401&lt;31:0>);               // A64 "LDR W1,[X0],#4"
        else</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#impl-shared.ExecuteT32.2" title="function: ExecuteT32(bits(16) hw1, bits(16) hw2)"><del>ExecuteT32</del></a> <ins>then
            RW&lt;0> = RW&lt;1>;
</ins><del>(0xF850&lt;15:0> /*hw1*/, 0x1B04&lt;15:0> /*hw2*/);      // T32 "LDR R1,[R0],#4"
        // If the load aborts, the Data Abort exception is taken and EDSCR.ERR is set to 1
        if EDSCR.ERR == '1' then
            EDSCR.TXfull = bit UNKNOWN;
            DBGDTRTX_EL0 = bits(32) UNKNOWN;
</del>        else
<ins>            RW&lt;0> = if</ins><del>            if !</del> <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a><ins>() then '0' else '1';
        if !</ins><del>() then</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-shared.ExecuteA64.1" title="function: ExecuteA64(bits(32) instr)"><del>ExecuteA64</del></a><ins>(</ins><del>(0xD5130501&lt;31:0>);           // A64 "MSR DBGDTRTX_EL0,X1"
            else</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-shared.ExecuteT32.2" title="function: ExecuteT32(bits(16) hw1, bits(16) hw2)"><del>ExecuteT32</del></a><ins>) || (</ins><del>(0xEE00&lt;15:0> /*hw1*/, 0x1E15&lt;15:0> /*hw2*/);  // T32 "MSR DBGDTRTXint,R1"
            // "MSR DBGDTRTX_EL0,X1" calls DBGDTR_EL0[] (write) which sets TXfull.
            assert EDSCR.TXfull == '1';

        if !</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><ins>(</ins><del>() then</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-aarch64.X.write.1" title="accessor: X[integer n] = bits(width) value"><del>X</del></a><ins>) &amp;&amp;</ins><del>[1] = bits(64) UNKNOWN;
        else</del> <a href="shared_pseudocode.html#impl-shared.SCR_GEN.read.0" title="accessor: SCRType SCR_GEN[]"><ins>SCR_GEN</ins></a><a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value"><del>R</del></a><ins>[].NS == '0' &amp;&amp; !</ins><del>[1] = bits(32) UNKNOWN;

        EDSCR.ITE = '1';                                // See comments in EDITR[] (external write)

    return value;

// DBGDTRTX_EL0[] (external write)
// ===============================</del><a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()"><ins>IsSecureEL2Enabled</ins></a><ins>()) then
            RW&lt;2> = RW&lt;1>;
        else
            RW&lt;2> = if </ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) then '0' else '1';
        if !</ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) then
            RW&lt;3> = RW&lt;2>;
        else
            RW&lt;3> = if </ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) then '0' else '1';

        // The least-significant bits of EDSCR.RW are UNKNOWN if any higher EL is using AArch32.
        if RW&lt;3> == '0' then RW&lt;2:0> = bits(3) UNKNOWN;
        elsif RW&lt;2> == '0' then RW&lt;1:0> = bits(2) UNKNOWN;
        elsif RW&lt;1> == '0' then RW&lt;0> = bit UNKNOWN;
        EDSCR.RW = RW;
</ins><del>DBGDTRTX_EL0[boolean memory_mapped] = bits(32) value
    // The Software lock is OPTIONAL.
    if memory_mapped &amp;&amp; EDLSR.SLK == '1' then return;   // Software lock locked: ignore write
    DTRTX = value;
</del>    return;</p></div><div class="ps" psname="shared.debug.haltingevents.CheckExceptionCatch"><a id="shared.debug.haltingevents.CheckExceptionCatch" name="shared.debug.haltingevents.CheckExceptionCatch"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>haltingevents</ins><del>dccanditr</del>/<ins>CheckExceptionCatch</ins><del>DBGDTR_EL0</del></h3><p class="pseudocode"><ins>// CheckExceptionCatch()
// =====================
// Check whether an Exception Catch debug event is set on the current Exception level</ins><del>// DBGDTR_EL0[] (write)
// ====================
// System register writes to DBGDTR_EL0, DBGDTRTX_EL0 (AArch64) and DBGDTRTXint (AArch32)</del>

<a id="impl-shared.CheckExceptionCatch.1" name="impl-shared.CheckExceptionCatch.1"></a><ins>CheckExceptionCatch(boolean exception_entry)
    // Called after an exception entry or exit, that is, such that IsSecure() and PSTATE.EL are correct
    // for the exception target.
    base = if</ins><del>DBGDTR_EL0[] = bits(N) value
    // For MSR DBGDTRTX_EL0,&lt;Rt>  N=32, value=X[t]&lt;31:0>, X[t]&lt;63:32> is ignored
    // For MSR DBGDTR_EL0,&lt;Xt>    N=64, value=X[t]&lt;63:0>
    assert N IN {32,64};
    if EDSCR.TXfull == '1' then
        value = bits(N) UNKNOWN;
    // On a 64-bit write, implement a half-duplex channel
    if N == 64 then DTRRX = value&lt;63:32>;
    DTRTX = value&lt;31:0>;        // 32-bit or 64-bit write
    EDSCR.TXfull = '1';
    return;

// DBGDTR_EL0[] (read)
// ===================
// System register reads of DBGDTR_EL0, DBGDTRRX_EL0 (AArch64) and DBGDTRRXint (AArch32)

bits(N)</del> <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>() then 0 else 4;
    if </ins><a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()"><ins>HaltingAllowed</ins></a><ins>() then
        if </ins><a href="shared_pseudocode.html#impl-shared.HaveExtendedECDebugEvents.0" title="function: boolean HaveExtendedECDebugEvents()"><ins>HaveExtendedECDebugEvents</ins></a><ins>() then
            exception_exit = !exception_entry;
            ctrl = EDECCR&lt;</ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(PSTATE.EL) + base + 8>:EDECCR&lt;</ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(PSTATE.EL) + base>;
            case ctrl of
                when '00'  halt = FALSE;
                when '01'  halt = TRUE;
                when '10'  halt = (exception_exit == TRUE);
                when '11'  halt = (exception_entry == TRUE);
        else
            halt = (EDECCR&lt;</ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(PSTATE.EL) + base> == '1');
        if halt then </ins><a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)"><ins>Halt</ins></a><ins>(</ins><a href="shared_pseudocode.html#DebugHalt_ExceptionCatch" title="constant bits(6) DebugHalt_ExceptionCatch = '110111'"><ins>DebugHalt_ExceptionCatch</ins></a><ins>);</ins><del>DBGDTR_EL0[]
    // For MRS &lt;Rt>,DBGDTRTX_EL0  N=32, X[t]=Zeros(32):result
    // For MRS &lt;Xt>,DBGDTR_EL0    N=64, X[t]=result
    assert N IN {32,64};
    bits(N) result;
    if EDSCR.RXfull == '0' then
        result = bits(N) UNKNOWN;
    else
        // On a 64-bit read, implement a half-duplex channel
        // NOTE: the word order is reversed on reads with regards to writes
        if N == 64 then result&lt;63:32> = DTRTX;
        result&lt;31:0> = DTRRX;
    EDSCR.RXfull = '0';
    return result;</del></p></div><div class="ps" psname="shared.debug.haltingevents.CheckHaltingStep"><a id="shared.debug.haltingevents.CheckHaltingStep" name="shared.debug.haltingevents.CheckHaltingStep"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>haltingevents</ins><del>dccanditr</del>/<ins>CheckHaltingStep</ins><del>DTR</del></h3><p class="pseudocode"><ins>// CheckHaltingStep()
// ==================
// Check whether EDESR.SS has been set by Halting Step</ins><del>bits(32) DTRRX;
bits(32) DTRTX;</del>

<a id="impl-shared.CheckHaltingStep.0" name="impl-shared.CheckHaltingStep.0"></a><ins>CheckHaltingStep()
    if </ins><a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()"><ins>HaltingAllowed</ins></a><ins>() &amp;&amp; EDESR.SS == '1' then
        // The STATUS code depends on how we arrived at the state where EDESR.SS == 1.
        if </ins><a href="shared_pseudocode.html#impl-shared.HaltingStep_DidNotStep.0" title="function: boolean HaltingStep_DidNotStep()"><ins>HaltingStep_DidNotStep</ins></a><ins>() then
            </ins><a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)"><ins>Halt</ins></a><ins>(</ins><a href="shared_pseudocode.html#DebugHalt_Step_NoSyndrome" title="constant bits(6) DebugHalt_Step_NoSyndrome = '111011'"><ins>DebugHalt_Step_NoSyndrome</ins></a><ins>);
        elsif </ins><a href="shared_pseudocode.html#impl-shared.HaltingStep_SteppedEX.0" title="function: boolean HaltingStep_SteppedEX()"><ins>HaltingStep_SteppedEX</ins></a><ins>() then
            </ins><a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)"><ins>Halt</ins></a><ins>(</ins><a href="shared_pseudocode.html#DebugHalt_Step_Exclusive" title="constant bits(6) DebugHalt_Step_Exclusive = '011111'"><ins>DebugHalt_Step_Exclusive</ins></a><ins>);
        else
            </ins><a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)"><ins>Halt</ins></a><ins>(</ins><a href="shared_pseudocode.html#DebugHalt_Step_Normal" title="constant bits(6) DebugHalt_Step_Normal = '011011'"><ins>DebugHalt_Step_Normal</ins></a><ins>);</ins></p></div><div class="ps" psname="shared.debug.haltingevents.CheckOSUnlockCatch"><a id="shared.debug.haltingevents.CheckOSUnlockCatch" name="shared.debug.haltingevents.CheckOSUnlockCatch"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>haltingevents</ins><del>dccanditr</del>/<ins>CheckOSUnlockCatch</ins><del>EDITR</del></h3><p class="pseudocode"><ins>// CheckOSUnlockCatch()
// ====================
// Called on unlocking the OS Lock to pend an OS Unlock Catch debug event</ins><del>// EDITR[] (external write)
// ========================
// Called on writes to debug register 0x084.</del>

<a id="impl-shared.CheckOSUnlockCatch.0" name="impl-shared.CheckOSUnlockCatch.0"></a><ins>CheckOSUnlockCatch()
    if EDECR.OSUCE == '1' &amp;&amp; !</ins><del>EDITR[boolean memory_mapped] = bits(32) value
    if EDPRSR&lt;6:5,0> != '001' then                      // Check DLK, OSLK and PU bits
        IMPLEMENTATION_DEFINED "signal slave-generated error";
        return;

    if EDSCR.ERR == '1' then return;                    // Error flag set: ignore write

    // The Software lock is OPTIONAL.
    if memory_mapped &amp;&amp; EDLSR.SLK == '1' then return;   // Software lock locked: ignore write

    if !</del><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a><ins>() then EDESR.OSUC = '1';</ins><del>() then return;                           // Non-debug state: ignore write

    if EDSCR.ITE == '0' || EDSCR.MA == '1' then
        EDSCR.ITO = '1';  EDSCR.ERR = '1';              // Overrun condition: block write
        return;

    // ITE indicates whether the processor is ready to accept another instruction; the processor
    // may support multiple outstanding instructions. Unlike the "InstrCompl" flag in [v7A] there
    // is no indication that the pipeline is empty (all instructions have completed). In this
    // pseudocode, the assumption is that only one instruction can be executed at a time,
    // meaning ITE acts like "InstrCompl".
    EDSCR.ITE = '0';

    if !</del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>() then
        </del><a href="shared_pseudocode.html#impl-shared.ExecuteA64.1" title="function: ExecuteA64(bits(32) instr)"><del>ExecuteA64</del></a><del>(value);
    else
        </del><a href="shared_pseudocode.html#impl-shared.ExecuteT32.2" title="function: ExecuteT32(bits(16) hw1, bits(16) hw2)"><del>ExecuteT32</del></a><del>(value&lt;15:0>/*hw1*/, value&lt;31:16> /*hw2*/);

    EDSCR.ITE = '1';

    return;</del></p></div><div class="ps" psname="shared.debug.haltingevents.CheckPendingOSUnlockCatch"><a id="shared.debug.haltingevents.CheckPendingOSUnlockCatch" name="shared.debug.haltingevents.CheckPendingOSUnlockCatch"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>haltingevents</ins><del>halting</del>/<ins>CheckPendingOSUnlockCatch</ins><del>DCPSInstruction</del></h3><p class="pseudocode"><ins>// CheckPendingOSUnlockCatch()
// ===========================
// Check whether EDESR.OSUC has been set by an OS Unlock Catch debug event</ins><del>// DCPSInstruction()
// =================
// Operation of the DCPS instruction in Debug state</del>

<a id="impl-shared.CheckPendingOSUnlockCatch.0" name="impl-shared.CheckPendingOSUnlockCatch.0"></a><ins>CheckPendingOSUnlockCatch()
    if</ins><del>DCPSInstruction(bits(2) target_el)</del> <a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()"><ins>HaltingAllowed</ins></a><a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()"><del>SynchronizeContext</del></a><ins>() &amp;&amp; EDESR.OSUC == '1' then</ins><del>();

    case target_el of
        when</del>
        <a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)"><ins>Halt</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>(</ins><del>if PSTATE.EL ==</del><del> || (PSTATE.EL == </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del> &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>()) then handle_el = PSTATE.EL;
            elsif </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; HCR_EL2.TGE == '1' then UndefinedFault();
            else handle_el = </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>;

        when </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>
            if !</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) then UndefinedFault();
            elsif PSTATE.EL == </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del> &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>() then handle_el = </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>;
            elsif !</del><a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()"><del>IsSecureEL2Enabled</del></a><del>() &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>() then UndefinedFault();
            else handle_el = </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>;
        when </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>
            if EDSCR.SDD == '1' || !</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) then UndefinedFault();
            handle_el = </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>;
        otherwise
            </del><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><del>Unreachable</del></a><del>();

    from_secure = </del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>();
    if </del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(handle_el) then
        if PSTATE.M == </del><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><del>M32_Monitor</del></a><del> then SCR.NS = '0';
        assert </del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>();                  // Cannot move from AArch64 to AArch32
        case handle_el of
            when </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)"><del>AArch32.WriteMode</del></a><del>(</del><a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'"><del>M32_Svc</del></a><del>);
                if </del><a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()"><del>HavePANExt</del></a><del>() &amp;&amp; SCTLR.SPAN == '0' then
                    PSTATE.PAN = '1';
            when </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>  </del><a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)"><del>AArch32.WriteMode</del></a><del>(</del><a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'"><del>M32_Hyp</del></a><del>);
            when </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)"><del>AArch32.WriteMode</del></a><del>(</del><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><del>M32_Monitor</del></a><del>);
                if </del><a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()"><del>HavePANExt</del></a><del>() then
                    if !from_secure then
                        PSTATE.PAN = '0';
                    elsif SCTLR.SPAN == '0' then
                        PSTATE.PAN = '1';
        if handle_el == </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del> then
            ELR_hyp = bits(32) UNKNOWN;  HSR = bits(32) UNKNOWN;
        else
            </del><a href="shared_pseudocode.html#impl-aarch32.LR.write.none" title="accessor: LR = bits(32) value"><del>LR</del></a><del> = bits(32) UNKNOWN;
        </del><a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(32) value"><del>SPSR</del></a><del>[] = bits(32) UNKNOWN;
        PSTATE.E = </del><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><del>SCTLR</del></a><del>[].EE;
        DLR = bits(32) UNKNOWN;  DSPSR = bits(32) UNKNOWN;

    else                                        // Targeting AArch64
        if </del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>() then
            </del><a href="shared_pseudocode.html#AArch64.MaybeZeroRegisterUppers.0" title="function: AArch64.MaybeZeroRegisterUppers()"><del>AArch64.MaybeZeroRegisterUppers</del></a><del>();
        </del><a href="shared_pseudocode.html#impl-aarch64.MaybeZeroSVEUppers.1" title="function: MaybeZeroSVEUppers(bits(2) target_el)"><del>MaybeZeroSVEUppers</del></a><del>(target_el);
        PSTATE.nRW = '0';  PSTATE.SP = '1';  PSTATE.EL = handle_el;
        if </del><a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()"><del>HavePANExt</del></a><del>() &amp;&amp; ((handle_el == </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del> &amp;&amp; SCTLR_EL1.SPAN == '0') ||
                             (handle_el == </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del> &amp;&amp; HCR_EL2.E2H == '1' &amp;&amp;
                             HCR_EL2.TGE == '1' &amp;&amp; SCTLR_EL2.SPAN == '0')) then
            PSTATE.PAN = '1';
        </del><a href="shared_pseudocode.html#impl-aarch64.ELR.write.0" title="accessor: ELR[] = bits(64) value"><del>ELR</del></a><del>[] = bits(64) UNKNOWN;  </del><a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(32) value"><del>SPSR</del></a><del>[] = bits(32) UNKNOWN;  </del><a href="shared_pseudocode.html#impl-aarch64.ESR.write.0" title="accessor: ESR[] = ESRType value"><del>ESR</del></a><del>[] = bits(32) UNKNOWN;
        DLR_EL0 = bits(64) UNKNOWN;  DSPSR_EL0 = bits(32) UNKNOWN;

        if </del><a href="shared_pseudocode.html#impl-shared.HaveUAOExt.0" title="function: boolean HaveUAOExt()"><del>HaveUAOExt</del></a><del>() then PSTATE.UAO = '0';

    </del><a href="shared_pseudocode.html#impl-shared.UpdateEDSCRFields.0" title="function: UpdateEDSCRFields()"><del>UpdateEDSCRFields</del></a><del>();                        // Update EDSCR PE state flags
    sync_errors = </del><a href="shared_pseudocode.html#impl-shared.HaveIESB.0" title="function: boolean HaveIESB()"><del>HaveIESB</del></a><del>() &amp;&amp; </del><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><del>SCTLR</del></a><del>[].IESB == '1';
    if </del><a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()"><del>HaveDoubleFaultExt</del></a><del>() &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>() then
        sync_errors = sync_errors || (SCR_EL3.EA == '1' &amp;&amp; SCR_EL3.NMEA == '1' &amp;&amp; PSTATE.EL == </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>);
    // SCTLR[].IESB might be ignored in Debug state.
    if !</del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><del>ConstrainUnpredictableBool</del></a><del>(</del><a href="shared_pseudocode.html#Unpredictable_IESBinDebug" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_IESBinDebug</del></a><del>) then
        sync_errors = FALSE;
    if sync_errors then
        </del><a href="shared_pseudocode.html#impl-shared.SynchronizeErrors.0" title="function: SynchronizeErrors()"><del>SynchronizeErrors</del></a><a href="shared_pseudocode.html#DebugHalt_OSUnlockCatch" title="constant bits(6) DebugHalt_OSUnlockCatch = '100011'"><ins>DebugHalt_OSUnlockCatch</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>);</ins><del>();
    return;</del></p></div><div class="ps" psname="shared.debug.haltingevents.CheckPendingResetCatch"><a id="shared.debug.haltingevents.CheckPendingResetCatch" name="shared.debug.haltingevents.CheckPendingResetCatch"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>haltingevents</ins><del>halting</del>/<ins>CheckPendingResetCatch</ins><del>DRPSInstruction</del></h3><p class="pseudocode"><ins>// CheckPendingResetCatch()
// ========================
// Check whether EDESR.RC has been set by a Reset Catch debug event</ins><del>// DRPSInstruction()
// =================
// Operation of the A64 DRPS and T32 ERET instructions in Debug state</del>

<a id="impl-shared.CheckPendingResetCatch.0" name="impl-shared.CheckPendingResetCatch.0"></a><ins>CheckPendingResetCatch()
    if</ins><del>DRPSInstruction()</del> <a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()"><ins>HaltingAllowed</ins></a><a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()"><del>SynchronizeContext</del></a><ins>() &amp;&amp; EDESR.RC == '1' then</ins><del>();

    sync_errors =</del>
        <a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)"><ins>Halt</ins></a><a href="shared_pseudocode.html#impl-shared.HaveIESB.0" title="function: boolean HaveIESB()"><del>HaveIESB</del></a><ins>(</ins><del>() &amp;&amp;</del><del>[].IESB == '1';
    if </del><a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()"><del>HaveDoubleFaultExt</del></a><del>() &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>() then
        sync_errors = sync_errors || (SCR_EL3.EA == '1' &amp;&amp; SCR_EL3.NMEA == '1' &amp;&amp; PSTATE.EL == </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>);
    // SCTLR[].IESB might be ignored in Debug state.
    if !</del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><del>ConstrainUnpredictableBool</del></a><del>(</del><a href="shared_pseudocode.html#Unpredictable_IESBinDebug" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_IESBinDebug</del></a><del>) then
        sync_errors = FALSE;
    if sync_errors then
        </del><a href="shared_pseudocode.html#impl-shared.SynchronizeErrors.0" title="function: SynchronizeErrors()"><del>SynchronizeErrors</del></a><del>();

    </del><a href="shared_pseudocode.html#impl-shared.SetPSTATEFromPSR.1" title="function: SetPSTATEFromPSR(bits(32) spsr)"><del>SetPSTATEFromPSR</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.SPSR.read.0" title="accessor: bits(32) SPSR[]"><del>SPSR</del></a><del>[]);

    // PSTATE.{N,Z,C,V,Q,GE,SS,D,A,I,F} are not observable and ignored in Debug state, so
    // behave as if UNKNOWN.
    if </del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>() then
        PSTATE.&lt;N,Z,C,V,Q,GE,SS,A,I,F> = bits(13) UNKNOWN;
        //  In AArch32, all instructions are T32 and unconditional.
        PSTATE.IT = '00000000';  PSTATE.T = '1';        // PSTATE.J is RES0
        DLR = bits(32) UNKNOWN;  DSPSR = bits(32) UNKNOWN;
    else
        PSTATE.&lt;N,Z,C,V,SS,D,A,I,F> = bits(9) UNKNOWN;
        DLR_EL0 = bits(64) UNKNOWN;  DSPSR_EL0 = bits(32) UNKNOWN;

    </del><a href="shared_pseudocode.html#impl-shared.UpdateEDSCRFields.0" title="function: UpdateEDSCRFields()"><del>UpdateEDSCRFields</del></a><a href="shared_pseudocode.html#DebugHalt_ResetCatch" title="constant bits(6) DebugHalt_ResetCatch = '100111'"><ins>DebugHalt_ResetCatch</ins></a><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><del>SCTLR</del></a><ins>);</ins><del>();                                // Update EDSCR PE state flags

    return;</del></p></div><div class="ps" psname="shared.debug.haltingevents.CheckResetCatch"><a id="shared.debug.haltingevents.CheckResetCatch" name="shared.debug.haltingevents.CheckResetCatch"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>haltingevents</ins><del>halting</del>/<ins>CheckResetCatch</ins><del>DebugHalt</del></h3><p class="pseudocode"><ins>// CheckResetCatch()
// =================
// Called after reset</ins><del>constant bits(6)</del>

<a id="impl-shared.CheckResetCatch.0" name="impl-shared.CheckResetCatch.0"></a><ins>CheckResetCatch()
    if EDECR.RCE == '1' then
        EDESR.RC = '1';
        // If halting is allowed then halt immediately
        if</ins><del>DebugHalt_Breakpoint      = '000111';
constant bits(6)</del> <a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()"><ins>HaltingAllowed</ins></a><ins>() then</ins><del>DebugHalt_EDBGRQ          = '010011';
constant bits(6)</del> <a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)"><ins>Halt</ins></a><ins>(</ins><del>DebugHalt_Step_Normal     = '011011';
constant bits(6)</del><del>DebugHalt_Step_Exclusive  = '011111';
constant bits(6) </del><a id="DebugHalt_OSUnlockCatch" name="DebugHalt_OSUnlockCatch"></a><del>DebugHalt_OSUnlockCatch   = '100011';
constant bits(6) </del><a id="DebugHalt_ResetCatch" name="DebugHalt_ResetCatch"></a><del>DebugHalt_ResetCatch      = '100111';
constant bits(6) </del><a id="DebugHalt_Watchpoint" name="DebugHalt_Watchpoint"></a><del>DebugHalt_Watchpoint      = '101011';
constant bits(6) </del><a id="DebugHalt_HaltInstruction" name="DebugHalt_HaltInstruction"></a><del>DebugHalt_HaltInstruction = '101111';
constant bits(6) </del><a id="DebugHalt_SoftwareAccess" name="DebugHalt_SoftwareAccess"></a><del>DebugHalt_SoftwareAccess  = '110011';
constant bits(6) </del><a id="DebugHalt_ExceptionCatch" name="DebugHalt_ExceptionCatch"></a><del>DebugHalt_ExceptionCatch  = '110111';
constant bits(6) </del><a id="DebugHalt_Step_NoSyndrome" name="DebugHalt_Step_NoSyndrome"></a><a href="shared_pseudocode.html#DebugHalt_ResetCatch" title="constant bits(6) DebugHalt_ResetCatch = '100111'"><ins>DebugHalt_ResetCatch</ins></a><ins>);</ins><del>DebugHalt_Step_NoSyndrome = '111011';</del></p></div><div class="ps" psname="shared.debug.haltingevents.CheckSoftwareAccessToDebugRegisters"><a id="shared.debug.haltingevents.CheckSoftwareAccessToDebugRegisters" name="shared.debug.haltingevents.CheckSoftwareAccessToDebugRegisters"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>haltingevents</ins><del>halting</del>/<ins>CheckSoftwareAccessToDebugRegisters</ins><del>DisableITRAndResumeInstructionPrefetch</del></h3><p class="pseudocode"><ins>// CheckSoftwareAccessToDebugRegisters()
// =====================================
// Check for access to Breakpoint and Watchpoint registers.

</ins><a id="impl-shared.CheckSoftwareAccessToDebugRegisters.0" name="impl-shared.CheckSoftwareAccessToDebugRegisters.0"></a><ins>CheckSoftwareAccessToDebugRegisters()
    os_lock = (if </ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>) then DBGOSLSR.OSLK else OSLSR_EL1.OSLK);
    if </ins><a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()"><ins>HaltingAllowed</ins></a><ins>() &amp;&amp; EDSCR.TDA == '1' &amp;&amp; os_lock == '0' then
        </ins><a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)"><ins>Halt</ins></a><ins>(</ins><a href="shared_pseudocode.html#DebugHalt_SoftwareAccess" title="constant bits(6) DebugHalt_SoftwareAccess = '110011'"><ins>DebugHalt_SoftwareAccess</ins></a><ins>);</ins><del>DisableITRAndResumeInstructionPrefetch();</del></p></div><div class="ps" psname="shared.debug.haltingevents.ExternalDebugRequest"><a id="shared.debug.haltingevents.ExternalDebugRequest" name="shared.debug.haltingevents.ExternalDebugRequest"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>haltingevents</ins><del>halting</del>/<ins>ExternalDebugRequest</ins><del>ExecuteA64</del></h3><p class="pseudocode"><ins>// ExternalDebugRequest()
// ======================</ins><del>// Execute an A64 instruction in Debug state.</del>

<a id="impl-shared.ExternalDebugRequest.0" name="impl-shared.ExternalDebugRequest.0"></a><ins>ExternalDebugRequest()
    if</ins><del>ExecuteA64(bits(32) instr);</del> <a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()"><ins>HaltingAllowed</ins></a><ins>() then
        </ins><a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)"><ins>Halt</ins></a><ins>(</ins><a href="shared_pseudocode.html#DebugHalt_EDBGRQ" title="constant bits(6) DebugHalt_EDBGRQ = '010011'"><ins>DebugHalt_EDBGRQ</ins></a><ins>);
    // Otherwise the CTI continues to assert the debug request until it is taken.</ins></p></div><div class="ps" psname="shared.debug.haltingevents.HaltingStep_DidNotStep"><a id="shared.debug.haltingevents.HaltingStep_DidNotStep" name="shared.debug.haltingevents.HaltingStep_DidNotStep"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>haltingevents</ins><del>halting</del>/<ins>HaltingStep_DidNotStep</ins><del>ExecuteT32</del></h3><p class="pseudocode"><ins>// Returns TRUE if the previously executed instruction was executed in the inactive state, that is,
// if it was not itself stepped.
boolean</ins><del>// Execute a T32 instruction in Debug state.</del> <a id="impl-shared.HaltingStep_DidNotStep.0" name="impl-shared.HaltingStep_DidNotStep.0"></a><ins>HaltingStep_DidNotStep();</ins><del>ExecuteT32(bits(16) hw1, bits(16) hw2);</del></p></div><div class="ps" psname="shared.debug.haltingevents.HaltingStep_SteppedEX"><a id="shared.debug.haltingevents.HaltingStep_SteppedEX" name="shared.debug.haltingevents.HaltingStep_SteppedEX"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>haltingevents</ins><del>halting</del>/<ins>HaltingStep_SteppedEX</ins><del>ExitDebugState</del></h3><p class="pseudocode"><ins>// Returns TRUE if the previously executed instruction was a Load-Exclusive class instruction
// executed in the active-not-pending state.
boolean</ins><del>// ExitDebugState()
// ================</del> <a id="impl-shared.HaltingStep_SteppedEX.0" name="impl-shared.HaltingStep_SteppedEX.0"></a><ins>HaltingStep_SteppedEX();</ins><del>ExitDebugState()
    assert</del><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><del>Halted</del></a><del>();
    </del><a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()"><del>SynchronizeContext</del></a><del>();

    // Although EDSCR.STATUS signals that the PE is restarting, debuggers must use EDPRSR.SDR to
    // detect that the PE has restarted.
    EDSCR.STATUS = '000001';                           // Signal restarting
    EDESR&lt;2:0> = '000';                                // Clear any pending Halting debug events

    bits(64) new_pc;
    bits(32) spsr;

    if </del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>() then
        new_pc = </del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><del>(DLR);
        spsr = DSPSR;
    else
        new_pc = DLR_EL0;
        spsr = DSPSR_EL0;
    // If this is an illegal return, SetPSTATEFromPSR() will set PSTATE.IL.
    </del><a href="shared_pseudocode.html#impl-shared.SetPSTATEFromPSR.1" title="function: SetPSTATEFromPSR(bits(32) spsr)"><del>SetPSTATEFromPSR</del></a><del>(spsr);                            // Can update privileged bits, even at EL0

    if </del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>() then
        if </del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><del>ConstrainUnpredictableBool</del></a><del>(</del><a href="shared_pseudocode.html#Unpredictable_RESTARTALIGNPC" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESTARTALIGNPC</del></a><del>) then new_pc&lt;0> = '0';
        </del><a href="shared_pseudocode.html#impl-shared.BranchTo.2" title="function: BranchTo(bits(N) target, BranchType branch_type)"><del>BranchTo</del></a><del>(new_pc&lt;31:0>, </del><a href="shared_pseudocode.html#BranchType_DBGEXIT" title="enumeration BranchType { BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}"><del>BranchType_DBGEXIT</del></a><del>);    // AArch32 branch
    else
        // If targeting AArch32 then possibly zero the 32 most significant bits of the target PC
        if spsr&lt;4> == '1' &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><del>ConstrainUnpredictableBool</del></a><del>(</del><a href="shared_pseudocode.html#Unpredictable_RESTARTZEROUPPERPC" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESTARTZEROUPPERPC</del></a><del>) then
            new_pc&lt;63:32> = </del><a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><del>Zeros</del></a><del>();
        </del><a href="shared_pseudocode.html#impl-shared.BranchTo.2" title="function: BranchTo(bits(N) target, BranchType branch_type)"><del>BranchTo</del></a><del>(new_pc, </del><a href="shared_pseudocode.html#BranchType_DBGEXIT" title="enumeration BranchType { BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}"><del>BranchType_DBGEXIT</del></a><del>);          // A type of branch that is never predicted

    (EDSCR.STATUS,EDPRSR.SDR) = ('000010','1');        // Atomically signal restarted
    </del><a href="shared_pseudocode.html#impl-shared.UpdateEDSCRFields.0" title="function: UpdateEDSCRFields()"><del>UpdateEDSCRFields</del></a><del>();                               // Stop signalling PE state
    </del><a href="shared_pseudocode.html#impl-shared.DisableITRAndResumeInstructionPrefetch.0" title="function: DisableITRAndResumeInstructionPrefetch()"><del>DisableITRAndResumeInstructionPrefetch</del></a><del>();

    return;</del></p></div><div class="ps" psname="shared.debug.haltingevents.RunHaltingStep"><a id="shared.debug.haltingevents.RunHaltingStep" name="shared.debug.haltingevents.RunHaltingStep"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>haltingevents</ins><del>halting</del>/<ins>RunHaltingStep</ins><del>Halt</del></h3><p class="pseudocode"><ins>// RunHaltingStep()
// ================</ins><del>// Halt()
// ======</del>

<a id="impl-shared.RunHaltingStep.4" name="impl-shared.RunHaltingStep.4"></a><ins>RunHaltingStep(boolean exception_generated, bits(2) exception_target, boolean syscall,
               boolean reset)
    // "exception_generated" is TRUE if the previous instruction generated a synchronous exception
    // or was cancelled by an asynchronous exception.
    //
    // if "exception_generated" is TRUE then "exception_target" is the target of the exception, and
    // "syscall" is TRUE if the exception is a synchronous exception where the preferred return
    // address is the instruction following that which generated the exception.
    //
    // "reset" is TRUE if exiting reset state into the highest EL.

    if reset then assert !</ins><del>Halt(bits(6) reason)</del><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><ins>Halted</ins></a><a href="shared_pseudocode.html#impl-shared.CTI_SignalEvent.1" title="function: CTI_SignalEvent(CrossTriggerIn id)"><del>CTI_SignalEvent</del></a><ins>();             // Cannot come out of reset halted
    active = EDECR.SS == '1' &amp;&amp; !</ins><del>(</del><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><ins>Halted</ins></a><a href="shared_pseudocode.html#CrossTriggerIn_CrossHalt" title="enumeration CrossTriggerIn  {CrossTriggerIn_CrossHalt,     CrossTriggerIn_PMUOverflow, CrossTriggerIn_RSVD2,         CrossTriggerIn_RSVD3, CrossTriggerIn_TraceExtOut0,  CrossTriggerIn_TraceExtOut1, CrossTriggerIn_TraceExtOut2,  CrossTriggerIn_TraceExtOut3}"><del>CrossTriggerIn_CrossHalt</del></a><ins>();

    if active &amp;&amp; reset then                     // Coming out of reset with EDECR.SS set
        EDESR.SS = '1';
    elsif active &amp;&amp;</ins><del>);  // Trigger other cores to halt
    if</del> <a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()"><ins>HaltingAllowed</ins></a><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a>() then
<ins>        if exception_generated &amp;&amp; exception_target ==</ins><del>        DLR =</del> <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><del>ThisInstrAddr</del></a><del>();
        DSPSR = </del><a href="shared_pseudocode.html#impl-shared.GetPSRFromPSTATE.0" title="function: bits(32) GetPSRFromPSTATE()"><del>GetPSRFromPSTATE</del></a><del>();
        DSPSR.SS = PSTATE.SS;                   // Always save PSTATE.SS
    else
        DLR_EL0 = </del><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><del>ThisInstrAddr</del></a><del>();
        DSPSR_EL0 = </del><a href="shared_pseudocode.html#impl-shared.GetPSRFromPSTATE.0" title="function: bits(32) GetPSRFromPSTATE()"><del>GetPSRFromPSTATE</del></a><del>();
        DSPSR_EL0.SS = PSTATE.SS;               // Always save PSTATE.SS

    EDSCR.ITE = '1';  EDSCR.ITO = '0';
    if </del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>() then
        EDSCR.SDD = '0';                        // If entered in Secure state, allow debug
    elsif </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> <ins>then
            advance = syscall ||</ins><del>) then
        EDSCR.SDD = if</del> <a href="shared_pseudocode.html#impl-shared.ExternalSecureDebugEnabled.0" title="function: boolean ExternalSecureDebugEnabled()">ExternalSecureDebugEnabled</a><del>() then '0' else '1';
    else
        assert EDSCR.SDD == '1';                // Otherwise EDSCR.SDD is RES1
    EDSCR.MA = '0';
    // PSTATE.{SS,D,A,I,F} are not observable and ignored in Debug state, so behave as if
    // UNKNOWN. PSTATE.{N,Z,C,V,Q,GE} are also not observable, but since these are not changed on
    // exception entry, this function also leaves them unchanged. PSTATE.{E,M,nRW,EL,SP} are
    // unchanged. PSTATE.IL is set to 0.
    if </del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>() then
        PSTATE.&lt;SS,A,I,F> = bits(4) UNKNOWN;
        //  In AArch32, all instructions are T32 and unconditional.
        PSTATE.IT = '00000000';  PSTATE.T = '1'; // PSTATE.J is RES0
    else
        PSTATE.&lt;SS,D,A,I,F> = bits(5) UNKNOWN;
    PSTATE.IL = '0';

    </del><a href="shared_pseudocode.html#impl-shared.StopInstructionPrefetchAndEnableITR.0" title="function: StopInstructionPrefetchAndEnableITR()"><del>StopInstructionPrefetchAndEnableITR</del></a><del>();
    EDSCR.STATUS = reason;                      // Signal entered Debug state
    </del><a href="shared_pseudocode.html#impl-shared.UpdateEDSCRFields.0" title="function: UpdateEDSCRFields()"><del>UpdateEDSCRFields</del></a><ins>();
        else
            advance = TRUE;
        if advance then EDESR.SS = '1';
</ins><del>();                        // Update EDSCR PE state flags.
</del>
    return;</p></div><div class="ps" psname="shared.debug.interrupts.ExternalDebugInterruptsDisabled"><a id="shared.debug.interrupts.ExternalDebugInterruptsDisabled" name="shared.debug.interrupts.ExternalDebugInterruptsDisabled"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>interrupts</ins><del>halting</del>/<ins>ExternalDebugInterruptsDisabled</ins><del>HaltOnBreakpointOrWatchpoint</del></h3><p class="pseudocode"><ins>// ExternalDebugInterruptsDisabled()
// =================================
// Determine whether EDSCR disables interrupts routed to 'target'
</ins><del>// HaltOnBreakpointOrWatchpoint()
// ==============================
// Returns TRUE if the Breakpoint and Watchpoint debug events should be considered for Debug
// state entry, FALSE if they should be considered for a debug exception.
</del>
boolean <a id="impl-shared.ExternalDebugInterruptsDisabled.1" name="impl-shared.ExternalDebugInterruptsDisabled.1"></a><ins>ExternalDebugInterruptsDisabled(bits(2) target)
    case target of
        when</ins><del>HaltOnBreakpointOrWatchpoint()
    return</del> <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()"><del>HaltingAllowed</del></a><ins>
            int_dis = EDSCR.INTdis == '11' &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.ExternalSecureDebugEnabled.0" title="function: boolean ExternalSecureDebugEnabled()"><ins>ExternalSecureDebugEnabled</ins></a><ins>();
        when </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>
            int_dis = EDSCR.INTdis == '1x' &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.ExternalDebugEnabled.0" title="function: boolean ExternalDebugEnabled()"><ins>ExternalDebugEnabled</ins></a><ins>();
        when </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>
            if </ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>() then
                int_dis = EDSCR.INTdis == '1x' &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.ExternalSecureDebugEnabled.0" title="function: boolean ExternalSecureDebugEnabled()"><ins>ExternalSecureDebugEnabled</ins></a><ins>();
            else
                int_dis = EDSCR.INTdis != '00' &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.ExternalDebugEnabled.0" title="function: boolean ExternalDebugEnabled()"><ins>ExternalDebugEnabled</ins></a><ins>();
    return int_dis;</ins><del>() &amp;&amp; EDSCR.HDE == '1' &amp;&amp; OSLSR_EL1.OSLK == '0';</del></p></div><div class="ps" psname="shared.debug.interrupts.InterruptID"><a id="shared.debug.interrupts.InterruptID" name="shared.debug.interrupts.InterruptID"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>interrupts</ins><del>halting</del>/<ins>InterruptID</ins><del>Halted</del></h3><p class="pseudocode"><ins>enumeration</ins><del>// Halted()
// ========

boolean</del> <a id="InterruptID" name="InterruptID"></a><ins>InterruptID {</ins><del>Halted()
    return !(EDSCR.STATUS IN {'000001', '000010'});                     // Halted</del><a id="InterruptID_PMUIRQ" name="InterruptID_PMUIRQ"></a><ins>InterruptID_PMUIRQ, </ins><a id="InterruptID_COMMIRQ" name="InterruptID_COMMIRQ"></a><ins>InterruptID_COMMIRQ, </ins><a id="InterruptID_CTIIRQ" name="InterruptID_CTIIRQ"></a><ins>InterruptID_CTIIRQ,
                         </ins><a id="InterruptID_COMMRX" name="InterruptID_COMMRX"></a><ins>InterruptID_COMMRX, </ins><a id="InterruptID_COMMTX" name="InterruptID_COMMTX"></a><ins>InterruptID_COMMTX};</ins></p></div><div class="ps" psname="shared.debug.interrupts.SetInterruptRequestLevel"><a id="shared.debug.interrupts.SetInterruptRequestLevel" name="shared.debug.interrupts.SetInterruptRequestLevel"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>interrupts</ins><del>halting</del>/<ins>SetInterruptRequestLevel</ins><del>HaltingAllowed</del></h3><p class="pseudocode"><ins>// Set a level-sensitive interrupt to the specified level.
SetInterruptRequestLevel(</ins><del>// HaltingAllowed()
// ================
// Returns TRUE if halting is currently allowed, FALSE if halting is prohibited.

boolean</del><del>HaltingAllowed()
    if </del><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><del>Halted</del></a><del>() || </del><a href="shared_pseudocode.html#impl-shared.DoubleLockStatus.0" title="function: boolean DoubleLockStatus()"><del>DoubleLockStatus</del></a><del>() then
        return FALSE;
    elsif </del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>() then
        return </del><a href="shared_pseudocode.html#impl-shared.ExternalSecureDebugEnabled.0" title="function: boolean ExternalSecureDebugEnabled()"><del>ExternalSecureDebugEnabled</del></a><del>();
    else
        return </del><a href="shared_pseudocode.html#impl-shared.ExternalDebugEnabled.0" title="function: boolean ExternalDebugEnabled()"><del>ExternalDebugEnabled</del></a><a href="shared_pseudocode.html#InterruptID" title="enumeration InterruptID {InterruptID_PMUIRQ, InterruptID_COMMIRQ, InterruptID_CTIIRQ, InterruptID_COMMRX, InterruptID_COMMTX}"><ins>InterruptID</ins></a> <ins>id, signal level);</ins><del>();</del></p></div><div class="ps" psname="shared.debug.samplebasedprofiling.CreatePCSample"><a id="shared.debug.samplebasedprofiling.CreatePCSample" name="shared.debug.samplebasedprofiling.CreatePCSample"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>samplebasedprofiling</ins><del>halting</del>/<ins>CreatePCSample</ins><del>Restarting</del></h3><p class="pseudocode"><ins>// CreatePCSample()
// ================</ins><del>// Restarting()
// ============

boolean</del>

<a id="impl-shared.CreatePCSample.0" name="impl-shared.CreatePCSample.0"></a><ins>CreatePCSample()
    // In a simple sequential execution of the program, CreatePCSample is executed each time the PE
    // executes an instruction that can be sampled. An implementation is not constrained such that
    // reads of EDPCSRlo return the current values of PC, etc.

    pc_sample.valid =</ins><del>Restarting()
    return EDSCR.STATUS == '000001';                                    // Restarting</del> <a href="shared_pseudocode.html#impl-shared.ExternalNoninvasiveDebugAllowed.0" title="function: boolean ExternalNoninvasiveDebugAllowed()"><ins>ExternalNoninvasiveDebugAllowed</ins></a><ins>() &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><ins>Halted</ins></a><ins>();
    pc_sample.pc = </ins><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><ins>ThisInstrAddr</ins></a><ins>();
    pc_sample.el = PSTATE.EL;
    pc_sample.rw = if </ins><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>() then '0' else '1';
    pc_sample.ns = if </ins><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>() then '0' else '1';
    pc_sample.contextidr = if </ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>) then CONTEXTIDR else CONTEXTIDR_EL1;
    pc_sample.has_el2 = </ins><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>();

    if </ins><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>() then
        if </ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) then
            pc_sample.vmid = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><ins>ZeroExtend</ins></a><ins>(VTTBR.VMID, 16);
        elsif !</ins><a href="shared_pseudocode.html#impl-shared.Have16bitVMID.0" title="function: boolean Have16bitVMID()"><ins>Have16bitVMID</ins></a><ins>() || VTCR_EL2.VS == '0' then
            pc_sample.vmid = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><ins>ZeroExtend</ins></a><ins>(VTTBR_EL2.VMID&lt;7:0>, 16);
        else
            pc_sample.vmid = VTTBR_EL2.VMID;
        if </ins><a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><ins>HaveVirtHostExt</ins></a><ins>() &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) then
            pc_sample.contextidr_el2 = CONTEXTIDR_EL2;
        else
            pc_sample.contextidr_el2 = bits(32) UNKNOWN;
        pc_sample.el0h = PSTATE.EL == </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins> &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><ins>IsInHost</ins></a><ins>();
    return;</ins></p></div><div class="ps" psname="shared.debug.samplebasedprofiling.EDPCSRlo"><a id="shared.debug.samplebasedprofiling.EDPCSRlo" name="shared.debug.samplebasedprofiling.EDPCSRlo"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>samplebasedprofiling</ins><del>halting</del>/<ins>EDPCSRlo</ins><del>StopInstructionPrefetchAndEnableITR</del></h3><p class="pseudocode"><ins>// EDPCSRlo[] (read)
// =================

bits(32) </ins><a id="impl-shared.EDPCSRlo.read.1" name="impl-shared.EDPCSRlo.read.1"></a><ins>EDPCSRlo[boolean memory_mapped]

    if EDPRSR&lt;6:5,0> != '001' then                      // Check DLK, OSLK and PU bits
        IMPLEMENTATION_DEFINED "signal slave-generated error";
        return bits(32) UNKNOWN;

    // The Software lock is OPTIONAL.
    update = !memory_mapped || EDLSR.SLK == '0';        // Software locked: no side-effects

    if pc_sample.valid then
        sample = pc_sample.pc&lt;31:0>;
        if update then
            if </ins><a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><ins>HaveVirtHostExt</ins></a><ins>() &amp;&amp; EDSCR.SC2 == '1' then
                EDPCSRhi.PC = (if pc_sample.rw == '0' then </ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(24) else pc_sample.pc&lt;55:32>);
                EDPCSRhi.EL = pc_sample.el;
                EDPCSRhi.NS = pc_sample.ns;
            else
                EDPCSRhi = (if pc_sample.rw == '0' then </ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(32) else pc_sample.pc&lt;63:32>);
            EDCIDSR = pc_sample.contextidr;
            if </ins><a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><ins>HaveVirtHostExt</ins></a><ins>() &amp;&amp; EDSCR.SC2 == '1' then
                EDVIDSR = (if </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) &amp;&amp; pc_sample.ns == '1' then pc_sample.contextidr_el2
                           else bits(32) UNKNOWN);
            else
                if </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) &amp;&amp; pc_sample.ns == '1' &amp;&amp; pc_sample.el IN {</ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>,</ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>} then
                    EDVIDSR.VMID = pc_sample.vmid;
                else
                    EDVIDSR.VMID = </ins><a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><ins>Zeros</ins></a><ins>();
                EDVIDSR.NS = pc_sample.ns;
                EDVIDSR.E2 = (if pc_sample.el == </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins> then '1' else '0');
                EDVIDSR.E3 = (if pc_sample.el == </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins> then '1' else '0') AND pc_sample.rw;
                // The conditions for setting HV are not specified if PCSRhi is zero.
                // An example implementation may be "pc_sample.rw".
                EDVIDSR.HV = (if !</ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(EDPCSRhi) then '1' else bit IMPLEMENTATION_DEFINED "0 or 1");
    else
        sample = </ins><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><ins>(32);
        if update then
            EDPCSRhi = bits(32) UNKNOWN;
            EDCIDSR = bits(32) UNKNOWN;
            EDVIDSR = bits(32) UNKNOWN;

    return sample;</ins><del>StopInstructionPrefetchAndEnableITR();</del></p></div><div class="ps" psname="shared.debug.samplebasedprofiling.PCSample"><a id="shared.debug.samplebasedprofiling.PCSample" name="shared.debug.samplebasedprofiling.PCSample"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>samplebasedprofiling</ins><del>halting</del>/<ins>PCSample</ins><del>UpdateEDSCRFields</del></h3><p class="pseudocode"><ins>type</ins><del>// UpdateEDSCRFields()
// ===================
// Update EDSCR PE state fields</del> <a id="PCSample" name="PCSample"></a><ins>PCSample is (
    boolean valid,
    bits(64) pc,
    bits(2) el,
    bit rw,
    bit ns,
    boolean has_el2,
    bits(32) contextidr,
    bits(32) contextidr_el2,
    boolean el0h,
    bits(16) vmid
)</ins><del>UpdateEDSCRFields()

    if !</del>

<del>() then
        EDSCR.EL = '00';
        EDSCR.NS = bit UNKNOWN;
        EDSCR.RW = '1111';
    else
        EDSCR.EL = PSTATE.EL;
        EDSCR.NS = if </del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>() then '0' else '1';

        bits(4) RW;
        RW&lt;1> = if </del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>) then '0' else '1';
        if PSTATE.EL != </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del> then
            RW&lt;0> = RW&lt;1>;
        else
            RW&lt;0> = if </del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>() then '0' else '1';
        if !</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) || (</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.SCR_GEN.read.0" title="accessor: SCRType SCR_GEN[]"><del>SCR_GEN</del></a><del>[].NS == '0' &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()"><del>IsSecureEL2Enabled</del></a><del>()) then
            RW&lt;2> = RW&lt;1>;
        else
            RW&lt;2> = if </del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) then '0' else '1';
        if !</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) then
            RW&lt;3> = RW&lt;2>;
        else
            RW&lt;3> = if </del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><a href="shared_pseudocode.html#PCSample" title="type PCSample is ( boolean valid, bits(64) pc, bits(2) el, bit rw, bit ns, boolean has_el2, bits(32) contextidr, bits(32) contextidr_el2, boolean el0h, bits(16) vmid )"><ins>PCSample</ins></a><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><del>Halted</del></a> <ins>pc_sample;</ins><del>) then '0' else '1';

        // The least-significant bits of EDSCR.RW are UNKNOWN if any higher EL is using AArch32.
        if RW&lt;3> == '0' then RW&lt;2:0> = bits(3) UNKNOWN;
        elsif RW&lt;2> == '0' then RW&lt;1:0> = bits(2) UNKNOWN;
        elsif RW&lt;1> == '0' then RW&lt;0> = bit UNKNOWN;
        EDSCR.RW = RW;
    return;</del></p></div><div class="ps" psname="shared.debug.samplebasedprofiling.PMPCSR"><a id="shared.debug.samplebasedprofiling.PMPCSR" name="shared.debug.samplebasedprofiling.PMPCSR"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>samplebasedprofiling</ins><del>haltingevents</del>/<ins>PMPCSR</ins><del>CheckExceptionCatch</del></h3><p class="pseudocode"><ins>// PMPCSR[] (read)
// ===============

bits(32)</ins><del>// CheckExceptionCatch()
// =====================
// Check whether an Exception Catch debug event is set on the current Exception level</del> <a id="impl-shared.PMPCSR.read.1" name="impl-shared.PMPCSR.read.1"></a><ins>PMPCSR[boolean memory_mapped]

    if EDPRSR&lt;6:5,0> != '001' then                      // Check DLK, OSLK and PU bits
        IMPLEMENTATION_DEFINED "signal slave-generated error";
        return bits(32) UNKNOWN;

    // The Software lock is OPTIONAL.
    update = !memory_mapped || PMLSR.SLK == '0';        // Software locked: no side-effects

    if pc_sample.valid then
        sample = pc_sample.pc&lt;31:0>;
        if update then
            PMPCSR&lt;55:32> = (if pc_sample.rw == '0' then</ins><del>CheckExceptionCatch(boolean exception_entry)
    // Called after an exception entry or exit, that is, such that IsSecure() and PSTATE.EL are correct
    // for the exception target.
    base = if</del> <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><ins>(24) else pc_sample.pc&lt;55:32>);
            PMPCSR.EL = pc_sample.el;
            PMPCSR.NS = pc_sample.ns;

            PMCID1SR = pc_sample.contextidr;
            PMCID2SR = if pc_sample.has_el2 then pc_sample.contextidr_el2 else bits(32) UNKNOWN;

            PMVIDSR.VMID = (if pc_sample.has_el2 &amp;&amp; pc_sample.el IN {</ins><del>() then 0 else 4;
    if</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()"><del>HaltingAllowed</del></a><ins>,</ins><del>() then
        if</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#impl-shared.HaveExtendedECDebugEvents.0" title="function: boolean HaveExtendedECDebugEvents()"><del>HaveExtendedECDebugEvents</del></a><ins>} &amp;&amp; !pc_sample.el0h
                            then pc_sample.vmid else bits(16) UNKNOWN);
    else
        sample =</ins><del>() then
            exception_exit = !exception_entry;
            ctrl = EDECCR&lt;</del> <del>(PSTATE.EL) + base + 8>:EDECCR&lt;</del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(PSTATE.EL) + base>;
            case ctrl of
                when '00'  halt = FALSE;
                when '01'  halt = TRUE;
                when '10'  halt = (exception_exit == TRUE);
                when '11'  halt = (exception_entry == TRUE);
        else
            halt = (EDECCR&lt;</del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(PSTATE.EL) + base> == '1');
        if halt then </del><a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)"><del>Halt</del></a><del>(</del><a href="shared_pseudocode.html#DebugHalt_ExceptionCatch" title="constant bits(6) DebugHalt_ExceptionCatch = '110111'"><del>DebugHalt_ExceptionCatch</del></a><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>(32);
        if update then
            PMPCSR&lt;55:32>  = bits(24) UNKNOWN;
            PMPCSR.EL = bits(2) UNKNOWN;
            PMPCSR.NS = bit UNKNOWN;

            PMCID1SR = bits(32) UNKNOWN;
            PMCID2SR = bits(32) UNKNOWN;

            PMVIDSR.VMID = bits(16) UNKNOWN;

    return sample;</ins><del>);</del></p></div><div class="ps" psname="shared.debug.softwarestep.CheckSoftwareStep"><a id="shared.debug.softwarestep.CheckSoftwareStep" name="shared.debug.softwarestep.CheckSoftwareStep"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>softwarestep</ins><del>haltingevents</del>/<ins>CheckSoftwareStep</ins><del>CheckHaltingStep</del></h3><p class="pseudocode"><ins>// CheckSoftwareStep()
// ===================
// Take a Software Step exception if in the active-pending state</ins><del>// CheckHaltingStep()
// ==================
// Check whether EDESR.SS has been set by Halting Step</del>

<a id="impl-shared.CheckSoftwareStep.0" name="impl-shared.CheckSoftwareStep.0"></a><ins>CheckSoftwareStep()

    // Other self-hosted debug functions will call AArch32.GenerateDebugExceptions() if called from
    // AArch32 state. However, because Software Step is only active when the debug target Exception
    // level is using AArch64, CheckSoftwareStep only calls AArch64.GenerateDebugExceptions().
    if !</ins><del>CheckHaltingStep()
    if</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()"><del>HaltingAllowed</del></a><ins>(</ins><del>() &amp;&amp; EDESR.SS == '1' then
        // The STATUS code depends on how we arrived at the state where EDESR.SS == 1.
        if</del><a href="shared_pseudocode.html#impl-shared.DebugTarget.0" title="function: bits(2) DebugTarget()"><ins>DebugTarget</ins></a><a href="shared_pseudocode.html#impl-shared.HaltingStep_DidNotStep.0" title="function: boolean HaltingStep_DidNotStep()"><del>HaltingStep_DidNotStep</del></a><ins>()) &amp;&amp;</ins><del>() then</del> <a href="shared_pseudocode.html#AArch64.GenerateDebugExceptions.0" title="function: boolean AArch64.GenerateDebugExceptions()"><ins>AArch64.GenerateDebugExceptions</ins></a><a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)"><del>Halt</del></a><ins>() then
        if MDSCR_EL1.SS == '1' &amp;&amp; PSTATE.SS == '0' then</ins><del>(</del>
            <del>);
        elsif </del><a href="shared_pseudocode.html#impl-shared.HaltingStep_SteppedEX.0" title="function: boolean HaltingStep_SteppedEX()"><del>HaltingStep_SteppedEX</del></a><del>() then
            </del><a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)"><del>Halt</del></a><del>(</del><a href="shared_pseudocode.html#DebugHalt_Step_Exclusive" title="constant bits(6) DebugHalt_Step_Exclusive = '011111'"><del>DebugHalt_Step_Exclusive</del></a><del>);
        else
            </del><a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)"><del>Halt</del></a><del>(</del><a href="shared_pseudocode.html#DebugHalt_Step_Normal" title="constant bits(6) DebugHalt_Step_Normal = '011011'"><del>DebugHalt_Step_Normal</del></a><a href="shared_pseudocode.html#AArch64.SoftwareStepException.0" title="function: AArch64.SoftwareStepException()"><ins>AArch64.SoftwareStepException</ins></a><a href="shared_pseudocode.html#DebugHalt_Step_NoSyndrome" title="constant bits(6) DebugHalt_Step_NoSyndrome = '111011'"><del>DebugHalt_Step_NoSyndrome</del></a><ins>();</ins><del>);</del></p></div><div class="ps" psname="shared.debug.softwarestep.DebugExceptionReturnSS"><a id="shared.debug.softwarestep.DebugExceptionReturnSS" name="shared.debug.softwarestep.DebugExceptionReturnSS"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>softwarestep</ins><del>haltingevents</del>/<ins>DebugExceptionReturnSS</ins><del>CheckOSUnlockCatch</del></h3><p class="pseudocode"><ins>// DebugExceptionReturnSS()
// ========================
// Returns value to write to PSTATE.SS on an exception return or Debug state exit.

bit</ins><del>// CheckOSUnlockCatch()
// ====================
// Called on unlocking the OS Lock to pend an OS Unlock Catch debug event</del> <a id="impl-shared.DebugExceptionReturnSS.1" name="impl-shared.DebugExceptionReturnSS.1"></a><ins>DebugExceptionReturnSS(bits(32) spsr)
    assert</ins><del>CheckOSUnlockCatch()
    if EDECR.OSUCE == '1' &amp;&amp; !</del> <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a><ins>() ||</ins><del>() then EDESR.OSUC = '1';</del> <a href="shared_pseudocode.html#impl-shared.Restarting.0" title="function: boolean Restarting()"><ins>Restarting</ins></a><ins>() ||  PSTATE.EL != </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>;

    SS_bit = '0';

    if MDSCR_EL1.SS == '1' then
        if </ins><a href="shared_pseudocode.html#impl-shared.Restarting.0" title="function: boolean Restarting()"><ins>Restarting</ins></a><ins>() then
            enabled_at_source = FALSE;
        elsif </ins><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>() then
            enabled_at_source = </ins><a href="shared_pseudocode.html#AArch32.GenerateDebugExceptions.0" title="function: boolean AArch32.GenerateDebugExceptions()"><ins>AArch32.GenerateDebugExceptions</ins></a><ins>();
        else
            enabled_at_source = </ins><a href="shared_pseudocode.html#AArch64.GenerateDebugExceptions.0" title="function: boolean AArch64.GenerateDebugExceptions()"><ins>AArch64.GenerateDebugExceptions</ins></a><ins>();

        if </ins><a href="shared_pseudocode.html#impl-shared.IllegalExceptionReturn.1" title="function: boolean IllegalExceptionReturn(bits(32) spsr)"><ins>IllegalExceptionReturn</ins></a><ins>(spsr) then
            dest = PSTATE.EL;
        else
            (valid, dest) = </ins><a href="shared_pseudocode.html#impl-shared.ELFromSPSR.1" title="function: (boolean,bits(2)) ELFromSPSR(bits(32) spsr)"><ins>ELFromSPSR</ins></a><ins>(spsr);  assert valid;

        secure = </ins><a href="shared_pseudocode.html#impl-shared.IsSecureBelowEL3.0" title="function: boolean IsSecureBelowEL3()"><ins>IsSecureBelowEL3</ins></a><ins>() || dest == </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>;
        if </ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(dest) then
            enabled_at_dest = </ins><a href="shared_pseudocode.html#AArch32.GenerateDebugExceptionsFrom.2" title="function: boolean AArch32.GenerateDebugExceptionsFrom(bits(2) from, boolean secure)"><ins>AArch32.GenerateDebugExceptionsFrom</ins></a><ins>(dest, secure);
        else
            mask = spsr&lt;9>;
            enabled_at_dest = </ins><a href="shared_pseudocode.html#AArch64.GenerateDebugExceptionsFrom.3" title="function: boolean AArch64.GenerateDebugExceptionsFrom(bits(2) from, boolean secure, bit mask)"><ins>AArch64.GenerateDebugExceptionsFrom</ins></a><ins>(dest, secure, mask);
        ELd = </ins><a href="shared_pseudocode.html#impl-shared.DebugTargetFrom.1" title="function: bits(2) DebugTargetFrom(boolean secure)"><ins>DebugTargetFrom</ins></a><ins>(secure);
        if !</ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(ELd) &amp;&amp; !enabled_at_source &amp;&amp; enabled_at_dest then
            SS_bit = spsr&lt;21>;
    return SS_bit;</ins></p></div><div class="ps" psname="shared.debug.softwarestep.SSAdvance"><a id="shared.debug.softwarestep.SSAdvance" name="shared.debug.softwarestep.SSAdvance"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>softwarestep</ins><del>haltingevents</del>/<ins>SSAdvance</ins><del>CheckPendingOSUnlockCatch</del></h3><p class="pseudocode"><ins>// SSAdvance()
// ===========
// Advance the Software Step state machine.</ins><del>// CheckPendingOSUnlockCatch()
// ===========================
// Check whether EDESR.OSUC has been set by an OS Unlock Catch debug event</del>

<a id="impl-shared.SSAdvance.0" name="impl-shared.SSAdvance.0"></a><ins>SSAdvance()

    // A simpler implementation of this function just clears PSTATE.SS to zero regardless of the
    // current Software Step state machine. However, this check is made to illustrate that the
    // processor only needs to consider advancing the state machine from the active-not-pending
    // state.
    target =</ins><del>CheckPendingOSUnlockCatch()
    if</del> <a href="shared_pseudocode.html#impl-shared.DebugTarget.0" title="function: bits(2) DebugTarget()"><ins>DebugTarget</ins></a><a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()"><del>HaltingAllowed</del></a><ins>();
    step_enabled = !</ins><del>() &amp;&amp; EDESR.OSUC == '1' then</del><del>(</del><a href="shared_pseudocode.html#DebugHalt_OSUnlockCatch" title="constant bits(6) DebugHalt_OSUnlockCatch = '100011'"><del>DebugHalt_OSUnlockCatch</del></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)"><del>Halt</del></a><ins>(target) &amp;&amp; MDSCR_EL1.SS == '1';
    active_not_pending = step_enabled &amp;&amp; PSTATE.SS == '1';

    if active_not_pending then PSTATE.SS = '0';

    return;</ins><del>);</del></p></div><div class="ps" psname="shared.debug.softwarestep.SoftwareStep_DidNotStep"><a id="shared.debug.softwarestep.SoftwareStep_DidNotStep" name="shared.debug.softwarestep.SoftwareStep_DidNotStep"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>softwarestep</ins><del>haltingevents</del>/<ins>SoftwareStep_DidNotStep</ins><del>CheckPendingResetCatch</del></h3><p class="pseudocode"><ins>// Returns TRUE if the previously executed instruction was executed in the inactive state, that is,
// if it was not itself stepped.
boolean</ins><del>// CheckPendingResetCatch()
// ========================
// Check whether EDESR.RC has been set by a Reset Catch debug event</del> <a id="impl-shared.SoftwareStep_DidNotStep.0" name="impl-shared.SoftwareStep_DidNotStep.0"></a><ins>SoftwareStep_DidNotStep();</ins><del>CheckPendingResetCatch()
    if</del><a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()"><del>HaltingAllowed</del></a><del>() &amp;&amp; EDESR.RC == '1' then
        </del><a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)"><del>Halt</del></a><del>(</del><a href="shared_pseudocode.html#DebugHalt_ResetCatch" title="constant bits(6) DebugHalt_ResetCatch = '100111'"><del>DebugHalt_ResetCatch</del></a><del>);</del></p></div><div class="ps" psname="shared.debug.softwarestep.SoftwareStep_SteppedEX"><a id="shared.debug.softwarestep.SoftwareStep_SteppedEX" name="shared.debug.softwarestep.SoftwareStep_SteppedEX"></a><h3 class="pseudocode">
            Library pseudocode for shared/debug/<ins>softwarestep</ins><del>haltingevents</del>/<ins>SoftwareStep_SteppedEX</ins><del>CheckResetCatch</del></h3><p class="pseudocode"><ins>// Returns TRUE if the previously executed instruction was a Load-Exclusive class instruction
// executed in the active-not-pending state.
boolean</ins><del>// CheckResetCatch()
// =================
// Called after reset</del> <a id="impl-shared.SoftwareStep_SteppedEX.0" name="impl-shared.SoftwareStep_SteppedEX.0"></a><ins>SoftwareStep_SteppedEX();</ins><del>CheckResetCatch()
    if EDECR.RCE == '1' then
        EDESR.RC = '1';
        // If halting is allowed then halt immediately
        if</del><a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()"><del>HaltingAllowed</del></a><del>() then </del><a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)"><del>Halt</del></a><del>(</del><a href="shared_pseudocode.html#DebugHalt_ResetCatch" title="constant bits(6) DebugHalt_ResetCatch = '100111'"><del>DebugHalt_ResetCatch</del></a><del>);</del></p></div><div class="ps" psname="shared.exceptions.exceptions.ConditionSyndrome"><a id="shared.exceptions.exceptions.ConditionSyndrome" name="shared.exceptions.exceptions.ConditionSyndrome"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>exceptions</ins><del>debug</del>/<ins>exceptions</ins><del>haltingevents</del>/<ins>ConditionSyndrome</ins><del>CheckSoftwareAccessToDebugRegisters</del></h3><p class="pseudocode"><ins>// ConditionSyndrome()
// ===================
// Return CV and COND fields of instruction syndrome

bits(5)</ins><del>// CheckSoftwareAccessToDebugRegisters()
// =====================================
// Check for access to Breakpoint and Watchpoint registers.</del> <a id="impl-shared.ConditionSyndrome.0" name="impl-shared.ConditionSyndrome.0"></a><ins>ConditionSyndrome()

    bits(5) syndrome;

    if</ins><del>CheckSoftwareAccessToDebugRegisters()
    os_lock = (if</del> <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><ins>() then
        cond =</ins><del>(</del> <a href="shared_pseudocode.html#AArch32.CurrentCond.0" title="function: bits(4) AArch32.CurrentCond()"><ins>AArch32.CurrentCond</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>();
        if PSTATE.T == '0' then             // A32
            syndrome&lt;4> = '1';
            // A conditional A32 instruction that is known to pass its condition code check
            // can be presented either with COND set to 0xE, the value for unconditional, or
            // the COND value held in the instruction.
            if</ins><del>) then DBGOSLSR.OSLK else OSLSR_EL1.OSLK);
    if</del> <a href="shared_pseudocode.html#impl-shared.ConditionHolds.1" title="function: boolean ConditionHolds(bits(4) cond)"><ins>ConditionHolds</ins></a><a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()"><del>HaltingAllowed</del></a><ins>(cond) &amp;&amp;</ins><del>() &amp;&amp; EDSCR.TDA == '1' &amp;&amp; os_lock == '0' then</del> <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><ins>ConstrainUnpredictableBool</ins></a><a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)"><del>Halt</del></a>(<a href="shared_pseudocode.html#Unpredictable_ESRCONDPASS" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_ESRCONDPASS</ins></a><a href="shared_pseudocode.html#DebugHalt_SoftwareAccess" title="constant bits(6) DebugHalt_SoftwareAccess = '110011'"><del>DebugHalt_SoftwareAccess</del></a><ins>) then
                syndrome&lt;3:0> = '1110';
            else
                syndrome&lt;3:0> = cond;
        else                                // T32
            // When a T32 instruction is trapped, it is IMPLEMENTATION DEFINED whether:
            //  * CV set to 0 and COND is set to an UNKNOWN value
            //  * CV set to 1 and COND is set to the condition code for the condition that
            //    applied to the instruction.
            if boolean IMPLEMENTATION_DEFINED "Condition valid for trapped T32" then
                syndrome&lt;4> = '1';
                syndrome&lt;3:0> = cond;
            else
                syndrome&lt;4> = '0';
                syndrome&lt;3:0> = bits(4) UNKNOWN;
    else
        syndrome&lt;4> = '1';
        syndrome&lt;3:0> = '1110';

    return syndrome;</ins><del>);</del></p></div><div class="ps" psname="shared.exceptions.exceptions.Exception"><a id="shared.exceptions.exceptions.Exception" name="shared.exceptions.exceptions.Exception"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>exceptions</ins><del>debug</del>/<ins>exceptions</ins><del>haltingevents</del>/<ins>Exception</ins><del>ExternalDebugRequest</del></h3><p class="pseudocode"><ins>enumeration</ins><del>// ExternalDebugRequest()
// ======================</del> <a id="Exception" name="Exception"></a><ins>Exception {</ins><del>ExternalDebugRequest()
    if</del><a id="Exception_Uncategorized" name="Exception_Uncategorized"></a><ins>Exception_Uncategorized,       // Uncategorized or unknown reason</ins><del>() then</del>
                       <a id="Exception_WFxTrap" name="Exception_WFxTrap"></a><ins>Exception_WFxTrap,             // Trapped WFI or WFE instruction</ins><del>(</del>
                       <a id="Exception_CP15RTTrap" name="Exception_CP15RTTrap"></a><ins>Exception_CP15RTTrap,          // Trapped AArch32 MCR or MRC access to CP15
                       </ins><a id="Exception_CP15RRTTrap" name="Exception_CP15RRTTrap"></a><ins>Exception_CP15RRTTrap,         // Trapped AArch32 MCRR or MRRC access to CP15
                       </ins><a id="Exception_CP14RTTrap" name="Exception_CP14RTTrap"></a><ins>Exception_CP14RTTrap,          // Trapped AArch32 MCR or MRC access to CP14
                       </ins><a id="Exception_CP14DTTrap" name="Exception_CP14DTTrap"></a><ins>Exception_CP14DTTrap,          // Trapped AArch32 LDC or STC access to CP14
                       </ins><a id="Exception_AdvSIMDFPAccessTrap" name="Exception_AdvSIMDFPAccessTrap"></a><ins>Exception_AdvSIMDFPAccessTrap, // HCPTR-trapped access to SIMD or FP
                       </ins><a id="Exception_FPIDTrap" name="Exception_FPIDTrap"></a><ins>Exception_FPIDTrap,            // Trapped access to SIMD or FP ID register
                       // Trapped BXJ instruction not supported in Armv8
                       </ins><a id="Exception_PACTrap" name="Exception_PACTrap"></a><ins>Exception_PACTrap,             // Trapped invalid PAC use
                       </ins><a id="Exception_CP14RRTTrap" name="Exception_CP14RRTTrap"></a><ins>Exception_CP14RRTTrap,         // Trapped MRRC access to CP14 from AArch32
                       </ins><a id="Exception_IllegalState" name="Exception_IllegalState"></a><ins>Exception_IllegalState,        // Illegal Execution state
                       </ins><a id="Exception_SupervisorCall" name="Exception_SupervisorCall"></a><ins>Exception_SupervisorCall,      // Supervisor Call
                       </ins><a id="Exception_HypervisorCall" name="Exception_HypervisorCall"></a><ins>Exception_HypervisorCall,      // Hypervisor Call
                       </ins><a id="Exception_MonitorCall" name="Exception_MonitorCall"></a><ins>Exception_MonitorCall,         // Monitor Call or Trapped SMC instruction
                       </ins><a id="Exception_SystemRegisterTrap" name="Exception_SystemRegisterTrap"></a><ins>Exception_SystemRegisterTrap,  // Trapped MRS or MSR system register access
                       </ins><a id="Exception_ERetTrap" name="Exception_ERetTrap"></a><ins>Exception_ERetTrap,            // Trapped invalid ERET use
                       </ins><a id="Exception_InstructionAbort" name="Exception_InstructionAbort"></a><ins>Exception_InstructionAbort,    // Instruction Abort or Prefetch Abort
                       </ins><a id="Exception_PCAlignment" name="Exception_PCAlignment"></a><ins>Exception_PCAlignment,         // PC alignment fault
                       </ins><a id="Exception_DataAbort" name="Exception_DataAbort"></a><ins>Exception_DataAbort,           // Data Abort
                       </ins><a id="Exception_NV2DataAbort" name="Exception_NV2DataAbort"></a><ins>Exception_NV2DataAbort,        // Data abort at EL1 reported as being from EL2
                       </ins><a id="Exception_SPAlignment" name="Exception_SPAlignment"></a><ins>Exception_SPAlignment,         // SP alignment fault
                       </ins><a id="Exception_FPTrappedException" name="Exception_FPTrappedException"></a><ins>Exception_FPTrappedException,  // IEEE trapped FP exception
                       </ins><a id="Exception_SError" name="Exception_SError"></a><ins>Exception_SError,              // SError interrupt
                       </ins><a id="Exception_Breakpoint" name="Exception_Breakpoint"></a><ins>Exception_Breakpoint,          // (Hardware) Breakpoint
                       </ins><a id="Exception_SoftwareStep" name="Exception_SoftwareStep"></a><ins>Exception_SoftwareStep,        // Software Step
                       </ins><a id="Exception_Watchpoint" name="Exception_Watchpoint"></a><ins>Exception_Watchpoint,          // Watchpoint
                       </ins><a id="Exception_SoftwareBreakpoint" name="Exception_SoftwareBreakpoint"></a><ins>Exception_SoftwareBreakpoint,  // Software Breakpoint Instruction
                       </ins><a id="Exception_VectorCatch" name="Exception_VectorCatch"></a><ins>Exception_VectorCatch,         // AArch32 Vector Catch
                       </ins><a id="Exception_IRQ" name="Exception_IRQ"></a><ins>Exception_IRQ,                 // IRQ interrupt
                       </ins><a id="Exception_SVEAccessTrap" name="Exception_SVEAccessTrap"></a><ins>Exception_SVEAccessTrap,       // HCPTR trapped access to SVE
                       </ins><a id="Exception_BranchTarget" name="Exception_BranchTarget"></a><ins>Exception_BranchTarget,        // Branch Target Identification
                       </ins><a id="Exception_FIQ" name="Exception_FIQ"></a><ins>Exception_FIQ};                // FIQ interrupt</ins><del>);
    // Otherwise the CTI continues to assert the debug request until it is taken.</del></p></div><div class="ps" psname="shared.exceptions.exceptions.ExceptionRecord"><a id="shared.exceptions.exceptions.ExceptionRecord" name="shared.exceptions.exceptions.ExceptionRecord"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>exceptions</ins><del>debug</del>/<ins>exceptions</ins><del>haltingevents</del>/<ins>ExceptionRecord</ins><del>HaltingStep_DidNotStep</del></h3><p class="pseudocode"><ins>type</ins><del>// Returns TRUE if the previously executed instruction was executed in the inactive state, that is,
// if it was not itself stepped.
boolean</del> <a id="ExceptionRecord" name="ExceptionRecord"></a><ins>ExceptionRecord is (</ins><del>HaltingStep_DidNotStep();</del><a href="shared_pseudocode.html#Exception" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception</ins></a><ins> type,              // Exception class
                         bits(25)  syndrome,          // Syndrome record
                         bits(64)  vaddress,          // Virtual fault address
                         boolean   ipavalid,          // Physical fault address for second stage faults is valid
                         bits(1)   NS,                // Physical fault address for second stage faults is Non-secure or secure
                         bits(52)  ipaddress)         // Physical fault address for second stage faults</ins></p></div><div class="ps" psname="shared.exceptions.exceptions.ExceptionSyndrome"><a id="shared.exceptions.exceptions.ExceptionSyndrome" name="shared.exceptions.exceptions.ExceptionSyndrome"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>exceptions</ins><del>debug</del>/<ins>exceptions</ins><del>haltingevents</del>/<ins>ExceptionSyndrome</ins><del>HaltingStep_SteppedEX</del></h3><p class="pseudocode"><ins>// ExceptionSyndrome()
// ===================
// Return a blank exception syndrome record for an exception of the given type.

ExceptionRecord</ins><del>// Returns TRUE if the previously executed instruction was a Load-Exclusive class instruction
// executed in the active-not-pending state.
boolean</del> <a id="impl-shared.ExceptionSyndrome.1" name="impl-shared.ExceptionSyndrome.1"></a><ins>ExceptionSyndrome(</ins><del>HaltingStep_SteppedEX();</del><a href="shared_pseudocode.html#Exception" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><ins>Exception</ins></a><ins> type)

    </ins><a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is (Exception type, bits(25) syndrome, bits(64) vaddress, boolean ipavalid, bits(1) NS, bits(52) ipaddress)"><ins>ExceptionRecord</ins></a><ins> r;

    r.type = type;

    // Initialize all other fields
    r.syndrome = </ins><a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><ins>Zeros</ins></a><ins>();
    r.vaddress = </ins><a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><ins>Zeros</ins></a><ins>();
    r.ipavalid = FALSE;
    r.NS = '0';
    r.ipaddress = </ins><a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><ins>Zeros</ins></a><ins>();

    return r;</ins></p></div><div class="ps" psname="shared.exceptions.traps.ReservedValue"><a id="shared.exceptions.traps.ReservedValue" name="shared.exceptions.traps.ReservedValue"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>exceptions</ins><del>debug</del>/<ins>traps</ins><del>haltingevents</del>/<ins>ReservedValue</ins><del>RunHaltingStep</del></h3><p class="pseudocode"><ins>// ReservedValue()
// ===============</ins><del>// RunHaltingStep()
// ================</del>

<a id="impl-shared.ReservedValue.0" name="impl-shared.ReservedValue.0"></a><ins>ReservedValue()
    if</ins><del>RunHaltingStep(boolean exception_generated, bits(2) exception_target, boolean syscall,
               boolean reset)
    // "exception_generated" is TRUE if the previous instruction generated a synchronous exception
    // or was cancelled by an asynchronous exception.
    //
    // if "exception_generated" is TRUE then "exception_target" is the target of the exception, and
    // "syscall" is TRUE if the exception is a synchronous exception where the preferred return
    // address is the instruction following that which generated the exception.
    //
    // "reset" is TRUE if exiting reset state into the highest EL.

    if reset then assert !</del> <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><del>Halted</del></a><ins>() &amp;&amp; !</ins><del>();             // Cannot come out of reset halted
    active = EDECR.SS == '1' &amp;&amp; !</del><a href="shared_pseudocode.html#AArch32.GeneralExceptionsToAArch64.0" title="function: boolean AArch32.GeneralExceptionsToAArch64()"><ins>AArch32.GeneralExceptionsToAArch64</ins></a><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><del>Halted</del></a><ins>() then</ins><del>();

    if active &amp;&amp; reset then                     // Coming out of reset with EDECR.SS set
        EDESR.SS = '1';
    elsif active &amp;&amp;</del>
        <a href="shared_pseudocode.html#AArch32.TakeUndefInstrException.0" title="function: AArch32.TakeUndefInstrException()"><ins>AArch32.TakeUndefInstrException</ins></a><a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()"><del>HaltingAllowed</del></a><ins>();
    else</ins><del>() then
        if exception_generated &amp;&amp; exception_target ==</del>
        <del> then
            advance = syscall || </del><a href="shared_pseudocode.html#impl-shared.ExternalSecureDebugEnabled.0" title="function: boolean ExternalSecureDebugEnabled()"><del>ExternalSecureDebugEnabled</del></a><a href="shared_pseudocode.html#AArch64.UndefinedFault.0" title="function: AArch64.UndefinedFault()"><ins>AArch64.UndefinedFault</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><ins>();</ins><del>();
        else
            advance = TRUE;
        if advance then EDESR.SS = '1';

    return;</del></p></div><div class="ps" psname="shared.exceptions.traps.UnallocatedEncoding"><a id="shared.exceptions.traps.UnallocatedEncoding" name="shared.exceptions.traps.UnallocatedEncoding"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>exceptions</ins><del>debug</del>/<ins>traps</ins><del>interrupts</del>/<ins>UnallocatedEncoding</ins><del>ExternalDebugInterruptsDisabled</del></h3><p class="pseudocode"><ins>// UnallocatedEncoding()
// =====================</ins><del>// ExternalDebugInterruptsDisabled()
// =================================
// Determine whether EDSCR disables interrupts routed to 'target'

boolean</del>

<a id="impl-shared.UnallocatedEncoding.0" name="impl-shared.UnallocatedEncoding.0"></a><ins>UnallocatedEncoding()
    if</ins><del>ExternalDebugInterruptsDisabled(bits(2) target)
    case target of
        when</del> <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><ins>() &amp;&amp;</ins><del>int_dis = EDSCR.INTdis == '11' &amp;&amp;</del> <a href="shared_pseudocode.html#AArch32.ExecutingCP10or11Instr.0" title="function: boolean AArch32.ExecutingCP10or11Instr()"><ins>AArch32.ExecutingCP10or11Instr</ins></a><a href="shared_pseudocode.html#impl-shared.ExternalSecureDebugEnabled.0" title="function: boolean ExternalSecureDebugEnabled()"><del>ExternalSecureDebugEnabled</del></a><ins>() then
        FPEXC.DEX = '0';
    if</ins><del>();
        when</del> <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>() &amp;&amp; !</ins><del>int_dis = EDSCR.INTdis == '1x' &amp;&amp;</del><a href="shared_pseudocode.html#AArch32.GeneralExceptionsToAArch64.0" title="function: boolean AArch32.GeneralExceptionsToAArch64()"><ins>AArch32.GeneralExceptionsToAArch64</ins></a><a href="shared_pseudocode.html#impl-shared.ExternalDebugEnabled.0" title="function: boolean ExternalDebugEnabled()"><del>ExternalDebugEnabled</del></a><ins>() then</ins><del>();
        when</del>
        <a href="shared_pseudocode.html#AArch32.TakeUndefInstrException.0" title="function: AArch32.TakeUndefInstrException()"><ins>AArch32.TakeUndefInstrException</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>();
    else</ins><del>if</del>
        <del>() then
                int_dis = EDSCR.INTdis == '1x' &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.ExternalSecureDebugEnabled.0" title="function: boolean ExternalSecureDebugEnabled()"><del>ExternalSecureDebugEnabled</del></a><del>();
            else
                int_dis = EDSCR.INTdis != '00' &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.ExternalDebugEnabled.0" title="function: boolean ExternalDebugEnabled()"><del>ExternalDebugEnabled</del></a><a href="shared_pseudocode.html#AArch64.UndefinedFault.0" title="function: AArch64.UndefinedFault()"><ins>AArch64.UndefinedFault</ins></a><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><ins>();</ins><del>();
    return int_dis;</del></p></div><div class="ps" psname="shared.functions.aborts.EncodeLDFSC"><a id="shared.functions.aborts.EncodeLDFSC" name="shared.functions.aborts.EncodeLDFSC"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>functions</ins><del>debug</del>/<ins>aborts</ins><del>interrupts</del>/<ins>EncodeLDFSC</ins><del>InterruptID</del></h3><p class="pseudocode"><ins>// EncodeLDFSC()
// =============
// Function that gives the Long-descriptor FSC code for types of Fault

bits(6)</ins><del>enumeration</del> <a id="impl-shared.EncodeLDFSC.2" name="impl-shared.EncodeLDFSC.2"></a><ins>EncodeLDFSC(</ins><del>InterruptID {</del><a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault</ins></a> <ins>type, integer level)

    bits(6) result;
    case type of
        when</ins><del>InterruptID_PMUIRQ,</del> <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_AddressSize</ins></a>         <ins>result = '0000':level&lt;1:0>; assert level IN {0,1,2,3};
        when</ins><del>InterruptID_COMMIRQ,</del> <a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_AccessFlag</ins></a>          <ins>result = '0010':level&lt;1:0>; assert level IN {1,2,3};
        when</ins><del>InterruptID_CTIIRQ,</del> <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_Permission</ins></a>          <ins>result = '0011':level&lt;1:0>; assert level IN {1,2,3};
        when</ins><del>InterruptID_COMMRX,</del> <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_Translation</ins></a><ins>         result = '0001':level&lt;1:0>; assert level IN {0,1,2,3};
        when </ins><a href="shared_pseudocode.html#Fault_SyncExternal" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_SyncExternal</ins></a><ins>        result = '010000';
        when </ins><a href="shared_pseudocode.html#Fault_SyncExternalOnWalk" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_SyncExternalOnWalk</ins></a><ins>  result = '0101':level&lt;1:0>; assert level IN {0,1,2,3};
        when </ins><a href="shared_pseudocode.html#Fault_SyncParity" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_SyncParity</ins></a><ins>          result = '011000';
        when </ins><a href="shared_pseudocode.html#Fault_SyncParityOnWalk" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_SyncParityOnWalk</ins></a><ins>    result = '0111':level&lt;1:0>; assert level IN {0,1,2,3};
        when </ins><a href="shared_pseudocode.html#Fault_AsyncParity" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_AsyncParity</ins></a><ins>         result = '011001';
        when </ins><a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_AsyncExternal</ins></a><ins>       result = '010001';
        when </ins><a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_Alignment</ins></a><ins>           result = '100001';
        when </ins><a href="shared_pseudocode.html#Fault_Debug" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_Debug</ins></a><ins>               result = '100010';
        when </ins><a href="shared_pseudocode.html#Fault_TLBConflict" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_TLBConflict</ins></a><ins>         result = '110000';
        when </ins><a href="shared_pseudocode.html#Fault_HWUpdateAccessFlag" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_HWUpdateAccessFlag</ins></a><ins>  result = '110001';
        when </ins><a href="shared_pseudocode.html#Fault_Lockdown" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_Lockdown</ins></a><ins>            result = '110100';  // IMPLEMENTATION DEFINED
        when </ins><a href="shared_pseudocode.html#Fault_Exclusive" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_Exclusive</ins></a><ins>           result = '110101';  // IMPLEMENTATION DEFINED
        otherwise                      </ins><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><ins>Unreachable</ins></a><ins>();

    return result;</ins><del>InterruptID_COMMTX};</del></p></div><div class="ps" psname="shared.functions.aborts.IPAValid"><a id="shared.functions.aborts.IPAValid" name="shared.functions.aborts.IPAValid"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>functions</ins><del>debug</del>/<ins>aborts</ins><del>interrupts</del>/<ins>IPAValid</ins><del>SetInterruptRequestLevel</del></h3><p class="pseudocode"><ins>// IPAValid()
// ==========
// Return TRUE if the IPA is reported for the abort

boolean</ins><del>// Set a level-sensitive interrupt to the specified level.
SetInterruptRequestLevel(</del> <a id="impl-shared.IPAValid.1" name="impl-shared.IPAValid.1"></a><ins>IPAValid(</ins><a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><ins>FaultRecord</ins></a><ins> fault)
    assert fault.type != </ins><a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_None</ins></a><ins>;

    if fault.s2fs1walk then
        return fault.type IN {</ins><a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_AccessFlag</ins></a><ins>, </ins><a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_Permission</ins></a><ins>, </ins><a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_Translation</ins></a><ins>,
                              </ins><a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_AddressSize</ins></a><ins>};
    elsif fault.secondstage then
        return fault.type IN {</ins><a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_AccessFlag</ins></a><ins>, </ins><a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_Translation</ins></a><ins>, </ins><a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_AddressSize</ins></a><ins>};
    else
        return FALSE;</ins><del>id, signal level);</del></p></div><div class="ps" psname="shared.functions.aborts.IsAsyncAbort"><a id="shared.functions.aborts.IsAsyncAbort" name="shared.functions.aborts.IsAsyncAbort"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>functions</ins><del>debug</del>/<ins>aborts</ins><del>samplebasedprofiling</del>/<ins>IsAsyncAbort</ins><del>CreatePCSample</del></h3><p class="pseudocode"><ins>// IsAsyncAbort()
// ==============
// Returns TRUE if the abort currently being processed is an asynchronous abort, and FALSE
// otherwise.

boolean</ins><del>// CreatePCSample()
// ================</del> <a id="impl-shared.IsAsyncAbort.1" name="impl-shared.IsAsyncAbort.1"></a><ins>IsAsyncAbort(</ins><del>CreatePCSample()
    // In a simple sequential execution of the program, CreatePCSample is executed each time the PE
    // executes an instruction that can be sampled. An implementation is not constrained such that
    // reads of EDPCSRlo return the current values of PC, etc.

    pc_sample.valid =</del><a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault</ins></a><a href="shared_pseudocode.html#impl-shared.ExternalNoninvasiveDebugAllowed.0" title="function: boolean ExternalNoninvasiveDebugAllowed()"><del>ExternalNoninvasiveDebugAllowed</del></a> <ins>type)
    assert type !=</ins><del>() &amp;&amp; !</del> <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_None</ins></a><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><del>Halted</del></a><ins>;

    return (type IN {</ins><del>();
    pc_sample.pc =</del><a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_AsyncExternal</ins></a><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><del>ThisInstrAddr</del></a><ins>,</ins><del>();
    pc_sample.el = PSTATE.EL;
    pc_sample.rw = if</del> <a href="shared_pseudocode.html#Fault_AsyncParity" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_AsyncParity</ins></a><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><ins>});

// IsAsyncAbort()
// ==============

boolean</ins><del>() then '0' else '1';
    pc_sample.ns = if</del> <a href="shared_pseudocode.html#impl-shared.IsAsyncAbort.1" title="function: boolean IsAsyncAbort(Fault type)"><ins>IsAsyncAbort</ins></a><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><ins>(</ins><del>() then '0' else '1';
    pc_sample.contextidr = if</del><a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><ins>FaultRecord</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a> <ins>fault)
    return</ins><del>(</del> <del>) then CONTEXTIDR else CONTEXTIDR_EL1;
    pc_sample.has_el2 = </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>();
    if </del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() then
        if </del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) then
            pc_sample.vmid = </del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><del>ZeroExtend</del></a><del>(VTTBR.VMID, 16);
        elsif !</del><a href="shared_pseudocode.html#impl-shared.Have16bitVMID.0" title="function: boolean Have16bitVMID()"><del>Have16bitVMID</del></a><del>() || VTCR_EL2.VS == '0' then
            pc_sample.vmid = </del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><del>ZeroExtend</del></a><del>(VTTBR_EL2.VMID&lt;7:0>, 16);
        else
            pc_sample.vmid = VTTBR_EL2.VMID;
        if </del><a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><del>HaveVirtHostExt</del></a><del>() &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) then
            pc_sample.contextidr_el2 = CONTEXTIDR_EL2;
        else
            pc_sample.contextidr_el2 = bits(32) UNKNOWN;
        pc_sample.el0h = PSTATE.EL == </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del> &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><del>IsInHost</del></a><a href="shared_pseudocode.html#impl-shared.IsAsyncAbort.1" title="function: boolean IsAsyncAbort(Fault type)"><ins>IsAsyncAbort</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>(fault.type);</ins><del>();
    return;</del></p></div><div class="ps" psname="shared.functions.aborts.IsDebugException"><a id="shared.functions.aborts.IsDebugException" name="shared.functions.aborts.IsDebugException"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>functions</ins><del>debug</del>/<ins>aborts</ins><del>samplebasedprofiling</del>/<ins>IsDebugException</ins><del>EDPCSRlo</del></h3><p class="pseudocode"><ins>// IsDebugException()
// ==================
</ins><del>// EDPCSRlo[] (read)
// =================
</del>
<ins>boolean</ins><del>bits(32)</del> <a id="impl-shared.IsDebugException.1" name="impl-shared.IsDebugException.1"></a><ins>IsDebugException(</ins><del>EDPCSRlo[boolean memory_mapped]

    if EDPRSR&lt;6:5,0> != '001' then                      // Check DLK, OSLK and PU bits
        IMPLEMENTATION_DEFINED "signal slave-generated error";
        return bits(32) UNKNOWN;

    // The Software lock is OPTIONAL.
    update = !memory_mapped || EDLSR.SLK == '0';        // Software locked: no side-effects

    if pc_sample.valid then
        sample = pc_sample.pc&lt;31:0>;
        if update then
            if</del><a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><ins>FaultRecord</ins></a><a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><del>HaveVirtHostExt</del></a> <ins>fault)
    assert fault.type !=</ins><del>() &amp;&amp; EDSCR.SC2 == '1' then
                EDPCSRhi.PC = (if pc_sample.rw == '0' then</del> <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_None</ins></a><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><ins>;
    return fault.type ==</ins><del>(24) else pc_sample.pc&lt;55:32>);
                EDPCSRhi.EL = pc_sample.el;
                EDPCSRhi.NS = pc_sample.ns;
            else
                EDPCSRhi = (if pc_sample.rw == '0' then</del> <del>(32) else pc_sample.pc&lt;63:32>);
            EDCIDSR = pc_sample.contextidr;
            if </del><a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><del>HaveVirtHostExt</del></a><del>() &amp;&amp; EDSCR.SC2 == '1' then
                EDVIDSR = (if </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) &amp;&amp; pc_sample.ns == '1' then pc_sample.contextidr_el2
                           else bits(32) UNKNOWN);
            else
                if </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) &amp;&amp; pc_sample.ns == '1' &amp;&amp; pc_sample.el IN {</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>,</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>} then
                    EDVIDSR.VMID = pc_sample.vmid;
                else
                    EDVIDSR.VMID = </del><a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><del>Zeros</del></a><del>();
                EDVIDSR.NS = pc_sample.ns;
                EDVIDSR.E2 = (if pc_sample.el == </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del> then '1' else '0');
                EDVIDSR.E3 = (if pc_sample.el == </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del> then '1' else '0') AND pc_sample.rw;
                // The conditions for setting HV are not specified if PCSRhi is zero.
                // An example implementation may be "pc_sample.rw".
                EDVIDSR.HV = (if !</del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(EDPCSRhi) then '1' else bit IMPLEMENTATION_DEFINED "0 or 1");
    else
        sample = </del><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a><a href="shared_pseudocode.html#Fault_Debug" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_Debug</ins></a><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><ins>;</ins><del>(32);
        if update then
            EDPCSRhi = bits(32) UNKNOWN;
            EDCIDSR = bits(32) UNKNOWN;
            EDVIDSR = bits(32) UNKNOWN;

    return sample;</del></p></div><div class="ps" psname="shared.functions.aborts.IsExternalAbort"><a id="shared.functions.aborts.IsExternalAbort" name="shared.functions.aborts.IsExternalAbort"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>functions</ins><del>debug</del>/<ins>aborts</ins><del>samplebasedprofiling</del>/<ins>IsExternalAbort</ins><del>PCSample</del></h3><p class="pseudocode"><ins>// IsExternalAbort()
// =================
// Returns TRUE if the abort currently being processed is an external abort and FALSE otherwise.

boolean</ins><del>type</del> <a id="impl-shared.IsExternalAbort.1" name="impl-shared.IsExternalAbort.1"></a><ins>IsExternalAbort(</ins><del>PCSample is (
    boolean valid,
    bits(64) pc,
    bits(2) el,
    bit rw,
    bit ns,
    boolean has_el2,
    bits(32) contextidr,
    bits(32) contextidr_el2,
    boolean el0h,
    bits(16) vmid
)</del><a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault</ins></a><a href="shared_pseudocode.html#PCSample" title="type PCSample is ( boolean valid, bits(64) pc, bits(2) el, bit rw, bit ns, boolean has_el2, bits(32) contextidr, bits(32) contextidr_el2, boolean el0h, bits(16) vmid )"><del>PCSample</del></a><ins> type)
    assert type != </ins><a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_None</ins></a><ins>;

    return (type IN {</ins><a href="shared_pseudocode.html#Fault_SyncExternal" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_SyncExternal</ins></a><ins>, </ins><a href="shared_pseudocode.html#Fault_SyncParity" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_SyncParity</ins></a><ins>, </ins><a href="shared_pseudocode.html#Fault_SyncExternalOnWalk" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_SyncExternalOnWalk</ins></a><ins>, </ins><a href="shared_pseudocode.html#Fault_SyncParityOnWalk" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_SyncParityOnWalk</ins></a><ins>,
                     </ins><a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_AsyncExternal</ins></a><ins>, </ins><a href="shared_pseudocode.html#Fault_AsyncParity" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_AsyncParity</ins></a><ins> });

// IsExternalAbort()
// =================

boolean </ins><a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault type)"><ins>IsExternalAbort</ins></a><ins>(</ins><a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><ins>FaultRecord</ins></a><ins> fault)
    return </ins><a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault type)"><ins>IsExternalAbort</ins></a><ins>(fault.type);</ins><del>pc_sample;</del></p></div><div class="ps" psname="shared.functions.aborts.IsExternalSyncAbort"><a id="shared.functions.aborts.IsExternalSyncAbort" name="shared.functions.aborts.IsExternalSyncAbort"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>functions</ins><del>debug</del>/<ins>aborts</ins><del>samplebasedprofiling</del>/<ins>IsExternalSyncAbort</ins><del>PMPCSR</del></h3><p class="pseudocode"><ins>// IsExternalSyncAbort()
// =====================
// Returns TRUE if the abort currently being processed is an external synchronous abort and FALSE otherwise.
</ins><del>// PMPCSR[] (read)
// ===============
</del>
<ins>boolean</ins><del>bits(32)</del> <a id="impl-shared.IsExternalSyncAbort.1" name="impl-shared.IsExternalSyncAbort.1"></a><ins>IsExternalSyncAbort(</ins><del>PMPCSR[boolean memory_mapped]

    if EDPRSR&lt;6:5,0> != '001' then                      // Check DLK, OSLK and PU bits
        IMPLEMENTATION_DEFINED "signal slave-generated error";
        return bits(32) UNKNOWN;

    // The Software lock is OPTIONAL.
    update = !memory_mapped || PMLSR.SLK == '0';        // Software locked: no side-effects

    if pc_sample.valid then
        sample = pc_sample.pc&lt;31:0>;
        if update then
            PMPCSR&lt;55:32> = (if pc_sample.rw == '0' then</del><a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault</ins></a><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a> <ins>type)
    assert type !=</ins><del>(24) else pc_sample.pc&lt;55:32>);
            PMPCSR.EL = pc_sample.el;
            PMPCSR.NS = pc_sample.ns;

            PMCID1SR = pc_sample.contextidr;
            PMCID2SR = if pc_sample.has_el2 then pc_sample.contextidr_el2 else bits(32) UNKNOWN;

            PMVIDSR.VMID = (if pc_sample.has_el2 &amp;&amp; pc_sample.el IN {</del> <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_None</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>;

    return (type IN {</ins><del>,</del><a href="shared_pseudocode.html#Fault_SyncExternal" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_SyncExternal</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>,</ins><del>} &amp;&amp; !pc_sample.el0h
                            then pc_sample.vmid else bits(16) UNKNOWN);
    else
        sample =</del> <a href="shared_pseudocode.html#Fault_SyncParity" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_SyncParity</ins></a><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a><ins>, </ins><a href="shared_pseudocode.html#Fault_SyncExternalOnWalk" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_SyncExternalOnWalk</ins></a><ins>, </ins><a href="shared_pseudocode.html#Fault_SyncParityOnWalk" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_SyncParityOnWalk</ins></a><ins>});

// IsExternalSyncAbort()
// =====================

boolean </ins><a href="shared_pseudocode.html#impl-shared.IsExternalSyncAbort.1" title="function: boolean IsExternalSyncAbort(Fault type)"><ins>IsExternalSyncAbort</ins></a><ins>(</ins><a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><ins>FaultRecord</ins></a><ins> fault)
    return </ins><a href="shared_pseudocode.html#impl-shared.IsExternalSyncAbort.1" title="function: boolean IsExternalSyncAbort(Fault type)"><ins>IsExternalSyncAbort</ins></a><ins>(fault.type);</ins><del>(32);
        if update then
            PMPCSR&lt;55:32>  = bits(24) UNKNOWN;
            PMPCSR.EL = bits(2) UNKNOWN;
            PMPCSR.NS = bit UNKNOWN;

            PMCID1SR = bits(32) UNKNOWN;
            PMCID2SR = bits(32) UNKNOWN;

            PMVIDSR.VMID = bits(16) UNKNOWN;

    return sample;</del></p></div><div class="ps" psname="shared.functions.aborts.IsFault"><a id="shared.functions.aborts.IsFault" name="shared.functions.aborts.IsFault"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>functions</ins><del>debug</del>/<ins>aborts</ins><del>softwarestep</del>/<ins>IsFault</ins><del>CheckSoftwareStep</del></h3><p class="pseudocode"><ins>// IsFault()
// =========
// Return TRUE if a fault is associated with an address descriptor

boolean</ins><del>// CheckSoftwareStep()
// ===================
// Take a Software Step exception if in the active-pending state</del> <a id="impl-shared.IsFault.1" name="impl-shared.IsFault.1"></a><ins>IsFault(</ins><del>CheckSoftwareStep()

    // Other self-hosted debug functions will call AArch32.GenerateDebugExceptions() if called from
    // AArch32 state. However, because Software Step is only active when the debug target Exception
    // level is using AArch64, CheckSoftwareStep only calls AArch64.GenerateDebugExceptions().
    if !</del><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><ins>AddressDescriptor</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a> <ins>addrdesc)
    return addrdesc.fault.type !=</ins><del>(</del> <del>()) &amp;&amp; </del><a href="shared_pseudocode.html#AArch64.GenerateDebugExceptions.0" title="function: boolean AArch64.GenerateDebugExceptions()"><del>AArch64.GenerateDebugExceptions</del></a><del>() then
        if MDSCR_EL1.SS == '1' &amp;&amp; PSTATE.SS == '0' then
            </del><a href="shared_pseudocode.html#AArch64.SoftwareStepException.0" title="function: AArch64.SoftwareStepException()"><del>AArch64.SoftwareStepException</del></a><a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_None</ins></a><a href="shared_pseudocode.html#impl-shared.DebugTarget.0" title="function: bits(2) DebugTarget()"><del>DebugTarget</del></a><ins>;</ins><del>();</del></p></div><div class="ps" psname="shared.functions.aborts.IsSErrorInterrupt"><a id="shared.functions.aborts.IsSErrorInterrupt" name="shared.functions.aborts.IsSErrorInterrupt"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>functions</ins><del>debug</del>/<ins>aborts</ins><del>softwarestep</del>/<ins>IsSErrorInterrupt</ins><del>DebugExceptionReturnSS</del></h3><p class="pseudocode"><ins>// IsSErrorInterrupt()
// ===================
// Returns TRUE if the abort currently being processed is an SError interrupt, and FALSE
// otherwise.
</ins><del>// DebugExceptionReturnSS()
// ========================
// Returns value to write to PSTATE.SS on an exception return or Debug state exit.
</del>
<ins>boolean</ins><del>bit</del> <a id="impl-shared.IsSErrorInterrupt.1" name="impl-shared.IsSErrorInterrupt.1"></a><ins>IsSErrorInterrupt(</ins><del>DebugExceptionReturnSS(bits(32) spsr)
    assert</del><a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault</ins></a><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><del>Halted</del></a> <ins>type)
    assert type !=</ins><del>() ||</del> <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_None</ins></a><a href="shared_pseudocode.html#impl-shared.Restarting.0" title="function: boolean Restarting()"><del>Restarting</del></a><ins>;

    return (type IN {</ins><del>() ||  PSTATE.EL !=</del><a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_AsyncExternal</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>,</ins><del>;

    SS_bit = '0';

    if MDSCR_EL1.SS == '1' then
        if</del> <a href="shared_pseudocode.html#Fault_AsyncParity" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_AsyncParity</ins></a><a href="shared_pseudocode.html#impl-shared.Restarting.0" title="function: boolean Restarting()"><del>Restarting</del></a><ins>});

// IsSErrorInterrupt()
// ===================

boolean</ins><del>() then
            enabled_at_source = FALSE;
        elsif</del> <a href="shared_pseudocode.html#impl-shared.IsSErrorInterrupt.1" title="function: boolean IsSErrorInterrupt(Fault type)"><ins>IsSErrorInterrupt</ins></a><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><ins>(</ins><del>() then
            enabled_at_source =</del><a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><ins>FaultRecord</ins></a><a href="shared_pseudocode.html#AArch32.GenerateDebugExceptions.0" title="function: boolean AArch32.GenerateDebugExceptions()"><del>AArch32.GenerateDebugExceptions</del></a> <ins>fault)
    return</ins><del>();
        else
            enabled_at_source =</del> <del>();

        if </del><a href="shared_pseudocode.html#impl-shared.IllegalExceptionReturn.1" title="function: boolean IllegalExceptionReturn(bits(32) spsr)"><del>IllegalExceptionReturn</del></a><del>(spsr) then
            dest = PSTATE.EL;
        else
            (valid, dest) = </del><a href="shared_pseudocode.html#impl-shared.ELFromSPSR.1" title="function: (boolean,bits(2)) ELFromSPSR(bits(32) spsr)"><del>ELFromSPSR</del></a><del>(spsr);  assert valid;

        secure = </del><a href="shared_pseudocode.html#impl-shared.IsSecureBelowEL3.0" title="function: boolean IsSecureBelowEL3()"><del>IsSecureBelowEL3</del></a><del>() || dest == </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>;

        if </del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(dest) then
            enabled_at_dest = </del><a href="shared_pseudocode.html#AArch32.GenerateDebugExceptionsFrom.2" title="function: boolean AArch32.GenerateDebugExceptionsFrom(bits(2) from, boolean secure)"><del>AArch32.GenerateDebugExceptionsFrom</del></a><del>(dest, secure);
        else
            mask = spsr&lt;9>;
            enabled_at_dest = </del><a href="shared_pseudocode.html#AArch64.GenerateDebugExceptionsFrom.3" title="function: boolean AArch64.GenerateDebugExceptionsFrom(bits(2) from, boolean secure, bit mask)"><del>AArch64.GenerateDebugExceptionsFrom</del></a><del>(dest, secure, mask);

        ELd = </del><a href="shared_pseudocode.html#impl-shared.DebugTargetFrom.1" title="function: bits(2) DebugTargetFrom(boolean secure)"><del>DebugTargetFrom</del></a><del>(secure);
        if !</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><a href="shared_pseudocode.html#impl-shared.IsSErrorInterrupt.1" title="function: boolean IsSErrorInterrupt(Fault type)"><ins>IsSErrorInterrupt</ins></a><a href="shared_pseudocode.html#AArch64.GenerateDebugExceptions.0" title="function: boolean AArch64.GenerateDebugExceptions()"><del>AArch64.GenerateDebugExceptions</del></a><ins>(fault.type);</ins><del>(ELd) &amp;&amp; !enabled_at_source &amp;&amp; enabled_at_dest then
            SS_bit = spsr&lt;21>;
    return SS_bit;</del></p></div><div class="ps" psname="shared.functions.aborts.IsSecondStage"><a id="shared.functions.aborts.IsSecondStage" name="shared.functions.aborts.IsSecondStage"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>functions</ins><del>debug</del>/<ins>aborts</ins><del>softwarestep</del>/<ins>IsSecondStage</ins><del>SSAdvance</del></h3><p class="pseudocode"><ins>// IsSecondStage()
// ===============

boolean</ins><del>// SSAdvance()
// ===========
// Advance the Software Step state machine.</del> <a id="impl-shared.IsSecondStage.1" name="impl-shared.IsSecondStage.1"></a><ins>IsSecondStage(</ins><del>SSAdvance()

    // A simpler implementation of this function just clears PSTATE.SS to zero regardless of the
    // current Software Step state machine. However, this check is made to illustrate that the
    // processor only needs to consider advancing the state machine from the active-not-pending
    // state.
    target =</del><a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><ins>FaultRecord</ins></a><a href="shared_pseudocode.html#impl-shared.DebugTarget.0" title="function: bits(2) DebugTarget()"><del>DebugTarget</del></a> <ins>fault)
    assert fault.type !=</ins><del>();
    step_enabled = !</del> <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault_None</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><ins>;
</ins><del>(target) &amp;&amp; MDSCR_EL1.SS == '1';
    active_not_pending = step_enabled &amp;&amp; PSTATE.SS == '1';
</del>
<ins>    return fault.secondstage;</ins><del>    if active_not_pending then PSTATE.SS = '0';

    return;</del></p></div><div class="ps" psname="shared.functions.aborts.LSInstructionSyndrome"><a id="shared.functions.aborts.LSInstructionSyndrome" name="shared.functions.aborts.LSInstructionSyndrome"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>functions</ins><del>debug</del>/<ins>aborts</ins><del>softwarestep</del>/<ins>LSInstructionSyndrome</ins><del>SoftwareStep_DidNotStep</del></h3><p class="pseudocode"><ins>bits(11)</ins><del>// Returns TRUE if the previously executed instruction was executed in the inactive state, that is,
// if it was not itself stepped.
boolean</del> <a id="impl-shared.LSInstructionSyndrome.0" name="impl-shared.LSInstructionSyndrome.0"></a><ins>LSInstructionSyndrome();</ins><del>SoftwareStep_DidNotStep();</del></p></div><div class="ps" psname="shared.functions.common.ASR"><a id="shared.functions.common.ASR" name="shared.functions.common.ASR"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>functions</ins><del>debug</del>/<ins>common</ins><del>softwarestep</del>/<ins>ASR</ins><del>SoftwareStep_SteppedEX</del></h3><p class="pseudocode"><ins>// ASR()
// =====

bits(N)</ins><del>// Returns TRUE if the previously executed instruction was a Load-Exclusive class instruction
// executed in the active-not-pending state.
boolean</del> <a id="impl-shared.ASR.2" name="impl-shared.ASR.2"></a><ins>ASR(bits(N) x, integer shift)
    assert shift >= 0;
    if shift == 0 then
        result = x;
    else
        (result, -) =</ins><del>SoftwareStep_SteppedEX();</del> <a href="shared_pseudocode.html#impl-shared.ASR_C.2" title="function: (bits(N), bit) ASR_C(bits(N) x, integer shift)"><ins>ASR_C</ins></a><ins>(x, shift);
    return result;</ins></p></div><div class="ps" psname="shared.functions.common.ASR_C"><a id="shared.functions.common.ASR_C" name="shared.functions.common.ASR_C"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>functions</ins><del>exceptions</del>/<ins>common</ins><del>exceptions</del>/<ins>ASR_C</ins><del>ConditionSyndrome</del></h3><p class="pseudocode"><ins>// ASR_C()
// =======
</ins><del>// ConditionSyndrome()
// ===================
// Return CV and COND fields of instruction syndrome
</del>
<ins>(bits(N), bit)</ins><del>bits(5)</del> <a id="impl-shared.ASR_C.2" name="impl-shared.ASR_C.2"></a><ins>ASR_C(bits(N) x, integer shift)
    assert shift > 0;
    shift = if shift > N then N else shift;
    extended_x =</ins><del>ConditionSyndrome()

    bits(5) syndrome;

    if</del> <del>() then
        cond = </del><a href="shared_pseudocode.html#AArch32.CurrentCond.0" title="function: bits(4) AArch32.CurrentCond()"><del>AArch32.CurrentCond</del></a><del>();
        if PSTATE.T == '0' then             // A32
            syndrome&lt;4> = '1';
            // A conditional A32 instruction that is known to pass its condition code check
            // can be presented either with COND set to 0xE, the value for unconditional, or
            // the COND value held in the instruction.
            if </del><a href="shared_pseudocode.html#impl-shared.ConditionHolds.1" title="function: boolean ConditionHolds(bits(4) cond)"><del>ConditionHolds</del></a><del>(cond) &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><del>ConstrainUnpredictableBool</del></a><del>(</del><a href="shared_pseudocode.html#Unpredictable_ESRCONDPASS" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_ESRCONDPASS</del></a><a href="shared_pseudocode.html#impl-shared.SignExtend.2" title="function: bits(N) SignExtend(bits(M) x, integer N)"><ins>SignExtend</ins></a><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><ins>(x, shift+N);
    result = extended_x&lt;shift+N-1:shift>;
    carry_out = extended_x&lt;shift-1>;
    return (result, carry_out);</ins><del>) then
                syndrome&lt;3:0> = '1110';
            else
                syndrome&lt;3:0> = cond;
        else                                // T32
            // When a T32 instruction is trapped, it is IMPLEMENTATION DEFINED whether:
            //  * CV set to 0 and COND is set to an UNKNOWN value
            //  * CV set to 1 and COND is set to the condition code for the condition that
            //    applied to the instruction.
            if boolean IMPLEMENTATION_DEFINED "Condition valid for trapped T32" then
                syndrome&lt;4> = '1';
                syndrome&lt;3:0> = cond;
            else
                syndrome&lt;4> = '0';
                syndrome&lt;3:0> = bits(4) UNKNOWN;
    else
        syndrome&lt;4> = '1';
        syndrome&lt;3:0> = '1110';

    return syndrome;</del></p></div><div class="ps" psname="shared.functions.common.Abs"><a id="shared.functions.common.Abs" name="shared.functions.common.Abs"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>functions</ins><del>exceptions</del>/<ins>common</ins><del>exceptions</del>/<ins>Abs</ins><del>Exception</del></h3><p class="pseudocode"><ins>// Abs()
// =====

integer</ins><del>enumeration</del> <a id="impl-shared.Abs.1" name="impl-shared.Abs.1"></a><ins>Abs(integer x)
    return if x >= 0 then x else -x;

// Abs()
// =====

real</ins><del>Exception {</del> <del>Exception_Uncategorized,       // Uncategorized or unknown reason
                       </del><a id="Exception_WFxTrap" name="Exception_WFxTrap"></a><del>Exception_WFxTrap,             // Trapped WFI or WFE instruction
                       </del><a id="Exception_CP15RTTrap" name="Exception_CP15RTTrap"></a><del>Exception_CP15RTTrap,          // Trapped AArch32 MCR or MRC access to CP15
                       </del><a id="Exception_CP15RRTTrap" name="Exception_CP15RRTTrap"></a><del>Exception_CP15RRTTrap,         // Trapped AArch32 MCRR or MRRC access to CP15
                       </del><a id="Exception_CP14RTTrap" name="Exception_CP14RTTrap"></a><del>Exception_CP14RTTrap,          // Trapped AArch32 MCR or MRC access to CP14
                       </del><a id="Exception_CP14DTTrap" name="Exception_CP14DTTrap"></a><del>Exception_CP14DTTrap,          // Trapped AArch32 LDC or STC access to CP14
                       </del><a id="Exception_AdvSIMDFPAccessTrap" name="Exception_AdvSIMDFPAccessTrap"></a><del>Exception_AdvSIMDFPAccessTrap, // HCPTR-trapped access to SIMD or FP
                       </del><a id="Exception_FPIDTrap" name="Exception_FPIDTrap"></a><del>Exception_FPIDTrap,            // Trapped access to SIMD or FP ID register
                       // Trapped BXJ instruction not supported in ARMv8
                       </del><a id="Exception_PACTrap" name="Exception_PACTrap"></a><del>Exception_PACTrap,             // Trapped invalid PAC use
                       </del><a id="Exception_CP14RRTTrap" name="Exception_CP14RRTTrap"></a><del>Exception_CP14RRTTrap,         // Trapped MRRC access to CP14 from AArch32
                       </del><a id="Exception_IllegalState" name="Exception_IllegalState"></a><del>Exception_IllegalState,        // Illegal Execution state
                       </del><a id="Exception_SupervisorCall" name="Exception_SupervisorCall"></a><del>Exception_SupervisorCall,      // Supervisor Call
                       </del><a id="Exception_HypervisorCall" name="Exception_HypervisorCall"></a><del>Exception_HypervisorCall,      // Hypervisor Call
                       </del><a id="Exception_MonitorCall" name="Exception_MonitorCall"></a><del>Exception_MonitorCall,         // Monitor Call or Trapped SMC instruction
                       </del><a id="Exception_SystemRegisterTrap" name="Exception_SystemRegisterTrap"></a><del>Exception_SystemRegisterTrap,  // Trapped MRS or MSR system register access
                       </del><a id="Exception_ERetTrap" name="Exception_ERetTrap"></a><del>Exception_ERetTrap,            // Trapped invalid ERET use
                       </del><a id="Exception_InstructionAbort" name="Exception_InstructionAbort"></a><del>Exception_InstructionAbort,    // Instruction Abort or Prefetch Abort
                       </del><a id="Exception_PCAlignment" name="Exception_PCAlignment"></a><del>Exception_PCAlignment,         // PC alignment fault
                       </del><a id="Exception_DataAbort" name="Exception_DataAbort"></a><del>Exception_DataAbort,           // Data Abort
                       </del><a id="Exception_NV2DataAbort" name="Exception_NV2DataAbort"></a><del>Exception_NV2DataAbort,        // Data abort at EL1 reported as being from EL2
                       </del><a id="Exception_SPAlignment" name="Exception_SPAlignment"></a><del>Exception_SPAlignment,         // SP alignment fault
                       </del><a id="Exception_FPTrappedException" name="Exception_FPTrappedException"></a><del>Exception_FPTrappedException,  // IEEE trapped FP exception
                       </del><a id="Exception_SError" name="Exception_SError"></a><del>Exception_SError,              // SError interrupt
                       </del><a id="Exception_Breakpoint" name="Exception_Breakpoint"></a><del>Exception_Breakpoint,          // (Hardware) Breakpoint
                       </del><a id="Exception_SoftwareStep" name="Exception_SoftwareStep"></a><del>Exception_SoftwareStep,        // Software Step
                       </del><a id="Exception_Watchpoint" name="Exception_Watchpoint"></a><del>Exception_Watchpoint,          // Watchpoint
                       </del><a id="Exception_SoftwareBreakpoint" name="Exception_SoftwareBreakpoint"></a><del>Exception_SoftwareBreakpoint,  // Software Breakpoint Instruction
                       </del><a id="Exception_VectorCatch" name="Exception_VectorCatch"></a><del>Exception_VectorCatch,         // AArch32 Vector Catch
                       </del><a id="Exception_IRQ" name="Exception_IRQ"></a><del>Exception_IRQ,                 // IRQ interrupt
                       </del><a id="Exception_SVEAccessTrap" name="Exception_SVEAccessTrap"></a><del>Exception_SVEAccessTrap,       // HCPTR trapped access to SVE
                       </del><a id="Exception_BranchTarget" name="Exception_BranchTarget"></a><del>Exception_BranchTarget,        // Branch Target Identification
                       </del><a id="Exception_FIQ" name="Exception_FIQ"></a><a href="shared_pseudocode.html#impl-shared.Abs.1" title="function: integer Abs(integer x)"><ins>Abs</ins></a><ins>(real x)
    return if x >= 0.0 then x else -x;</ins><del>Exception_FIQ};                // FIQ interrupt</del></p></div><div class="ps" psname="shared.functions.common.Align"><a id="shared.functions.common.Align" name="shared.functions.common.Align"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>functions</ins><del>exceptions</del>/<ins>common</ins><del>exceptions</del>/<ins>Align</ins><del>ExceptionRecord</del></h3><p class="pseudocode"><ins>// Align()
// =======

integer</ins><del>type</del> <a id="impl-shared.Align.2" name="impl-shared.Align.2"></a><ins>Align(integer x, integer y)
    return y * (x DIV y);

// Align()
// =======

bits(N)</ins><del>ExceptionRecord is (</del> <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)"><ins>Align</ins></a><a href="shared_pseudocode.html#Exception" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception</del></a><ins>(bits(N) x, integer y)
    return </ins><a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)"><ins>Align</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(x), y)&lt;N-1:0>;</ins><del>type,              // Exception class
                         bits(25)  syndrome,          // Syndrome record
                         bits(64)  vaddress,          // Virtual fault address
                         boolean   ipavalid,          // Physical fault address for second stage faults is valid
                         bits(1)   NS,                // Physical fault address for second stage faults is Non-secure or secure
                         bits(52)  ipaddress)         // Physical fault address for second stage faults</del></p></div><div class="ps" psname="shared.functions.common.BitCount"><a id="shared.functions.common.BitCount" name="shared.functions.common.BitCount"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>functions</ins><del>exceptions</del>/<ins>common</ins><del>exceptions</del>/<ins>BitCount</ins><del>ExceptionSyndrome</del></h3><p class="pseudocode"><ins>// BitCount()
// ==========
</ins><del>// ExceptionSyndrome()
// ===================
// Return a blank exception syndrome record for an exception of the given type.
</del>
<ins>integer</ins><del>ExceptionRecord</del> <a id="impl-shared.BitCount.1" name="impl-shared.BitCount.1"></a><ins>BitCount(bits(N) x)
    integer result = 0;
    for i = 0 to N-1
        if x&lt;i> == '1' then
            result = result + 1;
    return result;</ins><del>ExceptionSyndrome(</del><a href="shared_pseudocode.html#Exception" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap,  Exception_PACTrap, Exception_CP14RRTTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_BranchTarget, Exception_FIQ}"><del>Exception</del></a><del> type)

    </del><a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is (Exception type, bits(25) syndrome, bits(64) vaddress, boolean ipavalid, bits(1) NS, bits(52) ipaddress)"><del>ExceptionRecord</del></a><del> r;

    r.type = type;

    // Initialize all other fields
    r.syndrome = </del><a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><del>Zeros</del></a><del>();
    r.vaddress = </del><a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><del>Zeros</del></a><del>();
    r.ipavalid = FALSE;
    r.NS = '0';
    r.ipaddress = </del><a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><del>Zeros</del></a><del>();

    return r;</del></p></div><div class="ps" psname="shared.functions.common.CountLeadingSignBits"><a id="shared.functions.common.CountLeadingSignBits" name="shared.functions.common.CountLeadingSignBits"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>functions</ins><del>exceptions</del>/<ins>common</ins><del>traps</del>/<ins>CountLeadingSignBits</ins><del>ReservedValue</del></h3><p class="pseudocode"><ins>// CountLeadingSignBits()
// ======================

integer</ins><del>// ReservedValue()
// ===============</del> <a id="impl-shared.CountLeadingSignBits.1" name="impl-shared.CountLeadingSignBits.1"></a><ins>CountLeadingSignBits(bits(N) x)
    return</ins><del>ReservedValue()
    if</del> <del>() &amp;&amp; !</del><a href="shared_pseudocode.html#AArch32.GeneralExceptionsToAArch64.0" title="function: boolean AArch32.GeneralExceptionsToAArch64()"><del>AArch32.GeneralExceptionsToAArch64</del></a><del>() then
        </del><a href="shared_pseudocode.html#AArch32.TakeUndefInstrException.0" title="function: AArch32.TakeUndefInstrException()"><del>AArch32.TakeUndefInstrException</del></a><del>();
    else
        </del><a href="shared_pseudocode.html#AArch64.UndefinedFault.0" title="function: AArch64.UndefinedFault()"><del>AArch64.UndefinedFault</del></a><a href="shared_pseudocode.html#impl-shared.CountLeadingZeroBits.1" title="function: integer CountLeadingZeroBits(bits(N) x)"><ins>CountLeadingZeroBits</ins></a><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><ins>(x&lt;N-1:1> EOR x&lt;N-2:0>);</ins><del>();</del></p></div><div class="ps" psname="shared.functions.common.CountLeadingZeroBits"><a id="shared.functions.common.CountLeadingZeroBits" name="shared.functions.common.CountLeadingZeroBits"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>functions</ins><del>exceptions</del>/<ins>common</ins><del>traps</del>/<ins>CountLeadingZeroBits</ins><del>SystemAccessType</del></h3><p class="pseudocode"><ins>// CountLeadingZeroBits()
// ======================

integer</ins><del>enumeration</del> <a id="impl-shared.CountLeadingZeroBits.1" name="impl-shared.CountLeadingZeroBits.1"></a><ins>CountLeadingZeroBits(bits(N) x)
    return N - (</ins><del>SystemAccessType {</del><del>SystemAccessType_RT,  </del><a id="SystemAccessType_RRT" name="SystemAccessType_RRT"></a><del>SystemAccessType_RRT,  </del><a id="SystemAccessType_DT" name="SystemAccessType_DT"></a><a href="shared_pseudocode.html#impl-shared.HighestSetBit.1" title="function: integer HighestSetBit(bits(N) x)"><ins>HighestSetBit</ins></a><ins>(x) + 1);</ins><del>SystemAccessType_DT };</del></p></div><div class="ps" psname="shared.functions.common.Elem"><a id="shared.functions.common.Elem" name="shared.functions.common.Elem"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>functions</ins><del>exceptions</del>/<ins>common</ins><del>traps</del>/<ins>Elem</ins><del>UnallocatedEncoding</del></h3><p class="pseudocode"><ins>// Elem[] - non-assignment form
// ============================

bits(size)</ins><del>// UnallocatedEncoding()
// =====================</del> <a id="impl-shared.Elem.read.3" name="impl-shared.Elem.read.3"></a><ins>Elem[bits(N) vector, integer e, integer size]
    assert e >= 0 &amp;&amp; (e+1)*size &lt;= N;
    return vector&lt;e*size+size-1 : e*size>;

// Elem[] - non-assignment form
// ============================

bits(size)</ins><del>UnallocatedEncoding()
    if</del> <a id="impl-shared.Elem.read.2" name="impl-shared.Elem.read.2"></a><ins>Elem[bits(N) vector, integer e]
    return</ins><del>() &amp;&amp;</del> <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]"><ins>Elem</ins></a><a href="shared_pseudocode.html#AArch32.ExecutingCP10or11Instr.0" title="function: boolean AArch32.ExecutingCP10or11Instr()"><del>AArch32.ExecutingCP10or11Instr</del></a><ins>[vector, e, size];

// Elem[] - assignment form
// ========================</ins><del>() then
        FPEXC.DEX = '0';
    if</del>

<a id="impl-shared.Elem.write.3" name="impl-shared.Elem.write.3"></a><ins>Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value
    assert e >= 0 &amp;&amp; (e+1)*size &lt;= N;
    vector&lt;(e+1)*size-1:e*size> = value;
    return;

// Elem[] - assignment form
// ========================</ins><del>() &amp;&amp; !</del>

<a id="impl-shared.Elem.write.2" name="impl-shared.Elem.write.2"></a><ins>Elem[bits(N) &amp;vector, integer e] = bits(size) value</ins><del>() then</del>
    <del>();
    else
        </del><a href="shared_pseudocode.html#AArch64.UndefinedFault.0" title="function: AArch64.UndefinedFault()"><del>AArch64.UndefinedFault</del></a><a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value"><ins>Elem</ins></a><a href="shared_pseudocode.html#AArch32.TakeUndefInstrException.0" title="function: AArch32.TakeUndefInstrException()"><del>AArch32.TakeUndefInstrException</del></a><ins>[vector, e, size] = value;
    return;</ins><del>();</del></p></div><div class="ps" psname="shared.functions.common.Extend"><a id="shared.functions.common.Extend" name="shared.functions.common.Extend"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>common</ins><del>aborts</del>/<ins>Extend</ins><del>EncodeLDFSC</del></h3><p class="pseudocode"><ins>// Extend()
// ========
</ins><del>// EncodeLDFSC()
// =============
// Function that gives the Long-descriptor FSC code for types of Fault
</del>
<ins>bits(N)</ins><del>bits(6)</del> <a id="impl-shared.Extend.3" name="impl-shared.Extend.3"></a><ins>Extend(bits(M) x, integer N, boolean unsigned)
    return if unsigned then</ins><del>EncodeLDFSC(</del> <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><ins>ZeroExtend</ins></a><a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault</del></a><ins>(x, N) else</ins><del>type, integer level)

    bits(6) result;
    case type of
        when</del> <a href="shared_pseudocode.html#impl-shared.SignExtend.2" title="function: bits(N) SignExtend(bits(M) x, integer N)"><ins>SignExtend</ins></a><a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_AddressSize</del></a><ins>(x, N);

// Extend()
// ========

bits(N)</ins><del>result = '0000':level&lt;1:0>; assert level IN {0,1,2,3};
        when</del> <a id="impl-shared.Extend.2" name="impl-shared.Extend.2"></a><ins>Extend(bits(M) x, boolean unsigned)
    return</ins><del>result = '0010':level&lt;1:0>; assert level IN {1,2,3};
        when</del> <del>          result = '0011':level&lt;1:0>; assert level IN {1,2,3};
        when </del><a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_Translation</del></a><del>         result = '0001':level&lt;1:0>; assert level IN {0,1,2,3};
        when </del><a href="shared_pseudocode.html#Fault_SyncExternal" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_SyncExternal</del></a><del>        result = '010000';
        when </del><a href="shared_pseudocode.html#Fault_SyncExternalOnWalk" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_SyncExternalOnWalk</del></a><del>  result = '0101':level&lt;1:0>; assert level IN {0,1,2,3};
        when </del><a href="shared_pseudocode.html#Fault_SyncParity" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_SyncParity</del></a><del>          result = '011000';
        when </del><a href="shared_pseudocode.html#Fault_SyncParityOnWalk" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_SyncParityOnWalk</del></a><del>    result = '0111':level&lt;1:0>; assert level IN {0,1,2,3};
        when </del><a href="shared_pseudocode.html#Fault_AsyncParity" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_AsyncParity</del></a><del>         result = '011001';
        when </del><a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_AsyncExternal</del></a><del>       result = '010001';
        when </del><a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_Alignment</del></a><del>           result = '100001';
        when </del><a href="shared_pseudocode.html#Fault_Debug" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_Debug</del></a><del>               result = '100010';
        when </del><a href="shared_pseudocode.html#Fault_TLBConflict" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_TLBConflict</del></a><del>         result = '110000';
        when </del><a href="shared_pseudocode.html#Fault_HWUpdateAccessFlag" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_HWUpdateAccessFlag</del></a><del>  result = '110001';
        when </del><a href="shared_pseudocode.html#Fault_Lockdown" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_Lockdown</del></a><del>            result = '110100';  // IMPLEMENTATION DEFINED
        when </del><a href="shared_pseudocode.html#Fault_Exclusive" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_Exclusive</del></a><del>           result = '110101';  // IMPLEMENTATION DEFINED
        otherwise                      </del><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><del>Unreachable</del></a><a href="shared_pseudocode.html#impl-shared.Extend.3" title="function: bits(N) Extend(bits(M) x, integer N, boolean unsigned)"><ins>Extend</ins></a><a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_Permission</del></a><ins>(x, N, unsigned);</ins><del>();

    return result;</del></p></div><div class="ps" psname="shared.functions.common.HighestSetBit"><a id="shared.functions.common.HighestSetBit" name="shared.functions.common.HighestSetBit"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>common</ins><del>aborts</del>/<ins>HighestSetBit</ins><del>IPAValid</del></h3><p class="pseudocode"><ins>// HighestSetBit()
// ===============
</ins><del>// IPAValid()
// ==========
// Return TRUE if the IPA is reported for the abort
</del>
<ins>integer</ins><del>boolean</del> <a id="impl-shared.HighestSetBit.1" name="impl-shared.HighestSetBit.1"></a><ins>HighestSetBit(bits(N) x)
    for i = N-1 downto 0
        if x&lt;i> == '1' then return i;
    return -1;</ins><del>IPAValid(</del><a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><del>FaultRecord</del></a><del> fault)
    assert fault.type != </del><a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_None</del></a><del>;

    if fault.s2fs1walk then
        return fault.type IN {</del><a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_AccessFlag</del></a><del>, </del><a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_Permission</del></a><del>, </del><a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_Translation</del></a><del>,
                              </del><a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_AddressSize</del></a><del>};
    elsif fault.secondstage then
        return fault.type IN {</del><a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_AccessFlag</del></a><del>, </del><a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_Translation</del></a><del>, </del><a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_AddressSize</del></a><del>};
    else
        return FALSE;</del></p></div><div class="ps" psname="shared.functions.common.Int"><a id="shared.functions.common.Int" name="shared.functions.common.Int"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>common</ins><del>aborts</del>/<ins>Int</ins><del>IsAsyncAbort</del></h3><p class="pseudocode"><ins>// Int()
// =====
</ins><del>// IsAsyncAbort()
// ==============
// Returns TRUE if the abort currently being processed is an asynchronous abort, and FALSE
// otherwise.
</del>
<ins>integer</ins><del>boolean</del> <a id="impl-shared.Int.2" name="impl-shared.Int.2"></a><ins>Int(bits(N) x, boolean unsigned)
    result = if unsigned then</ins><del>IsAsyncAbort(</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault</del></a><ins>(x) else</ins><del>type)
    assert type !=</del> <del>;

    return (type IN {</del><a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_AsyncExternal</del></a><del>, </del><a href="shared_pseudocode.html#Fault_AsyncParity" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_AsyncParity</del></a><del>});

// IsAsyncAbort()
// ==============

boolean </del><a href="shared_pseudocode.html#impl-shared.IsAsyncAbort.1" title="function: boolean IsAsyncAbort(Fault type)"><del>IsAsyncAbort</del></a><del>(</del><a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><del>FaultRecord</del></a><del> fault)
    return </del><a href="shared_pseudocode.html#impl-shared.IsAsyncAbort.1" title="function: boolean IsAsyncAbort(Fault type)"><del>IsAsyncAbort</del></a><a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)"><ins>SInt</ins></a><a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_None</del></a><ins>(x);
    return result;</ins><del>(fault.type);</del></p></div><div class="ps" psname="shared.functions.common.IsOnes"><a id="shared.functions.common.IsOnes" name="shared.functions.common.IsOnes"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>common</ins><del>aborts</del>/<ins>IsOnes</ins><del>IsDebugException</del></h3><p class="pseudocode"><ins>// IsOnes()
// ========
</ins><del>// IsDebugException()
// ==================
</del>
boolean <a id="impl-shared.IsOnes.1" name="impl-shared.IsOnes.1"></a><ins>IsOnes(bits(N) x)
    return x ==</ins><del>IsDebugException(</del> <del> fault)
    assert fault.type != </del><a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_None</del></a><del>;
    return fault.type == </del><a href="shared_pseudocode.html#Fault_Debug" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_Debug</del></a><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><del>FaultRecord</del></a><ins>(N);</ins><del>;</del></p></div><div class="ps" psname="shared.functions.common.IsZero"><a id="shared.functions.common.IsZero" name="shared.functions.common.IsZero"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>common</ins><del>aborts</del>/<ins>IsZero</ins><del>IsExternalAbort</del></h3><p class="pseudocode"><ins>// IsZero()
// ========
</ins><del>// IsExternalAbort()
// =================
// Returns TRUE if the abort currently being processed is an external abort and FALSE otherwise.
</del>
boolean <a id="impl-shared.IsZero.1" name="impl-shared.IsZero.1"></a><ins>IsZero(bits(N) x)
    return x ==</ins><del>IsExternalAbort(</del> <del> type)
    assert type != </del><a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_None</del></a><del>;

    return (type IN {</del><a href="shared_pseudocode.html#Fault_SyncExternal" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_SyncExternal</del></a><del>, </del><a href="shared_pseudocode.html#Fault_SyncParity" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_SyncParity</del></a><del>, </del><a href="shared_pseudocode.html#Fault_SyncExternalOnWalk" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_SyncExternalOnWalk</del></a><del>, </del><a href="shared_pseudocode.html#Fault_SyncParityOnWalk" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_SyncParityOnWalk</del></a><del>,
                     </del><a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_AsyncExternal</del></a><del>, </del><a href="shared_pseudocode.html#Fault_AsyncParity" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_AsyncParity</del></a><del> });

// IsExternalAbort()
// =================

boolean </del><a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault type)"><del>IsExternalAbort</del></a><del>(</del><a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><del>FaultRecord</del></a><del> fault)
    return </del><a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault type)"><del>IsExternalAbort</del></a><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault</del></a><ins>(N);</ins><del>(fault.type);</del></p></div><div class="ps" psname="shared.functions.common.IsZeroBit"><a id="shared.functions.common.IsZeroBit" name="shared.functions.common.IsZeroBit"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>common</ins><del>aborts</del>/<ins>IsZeroBit</ins><del>IsExternalSyncAbort</del></h3><p class="pseudocode"><ins>// IsZeroBit()
// ===========
</ins><del>// IsExternalSyncAbort()
// =====================
// Returns TRUE if the abort currently being processed is an external synchronous abort and FALSE otherwise.
</del>
<ins>bit</ins><del>boolean</del> <a id="impl-shared.IsZeroBit.1" name="impl-shared.IsZeroBit.1"></a><ins>IsZeroBit(bits(N) x)
    return if</ins><del>IsExternalSyncAbort(</del> <del> type)
    assert type != </del><a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_None</del></a><del>;

    return (type IN {</del><a href="shared_pseudocode.html#Fault_SyncExternal" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_SyncExternal</del></a><del>, </del><a href="shared_pseudocode.html#Fault_SyncParity" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_SyncParity</del></a><del>, </del><a href="shared_pseudocode.html#Fault_SyncExternalOnWalk" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_SyncExternalOnWalk</del></a><del>, </del><a href="shared_pseudocode.html#Fault_SyncParityOnWalk" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_SyncParityOnWalk</del></a><del>});

// IsExternalSyncAbort()
// =====================

boolean </del><a href="shared_pseudocode.html#impl-shared.IsExternalSyncAbort.1" title="function: boolean IsExternalSyncAbort(Fault type)"><del>IsExternalSyncAbort</del></a><del>(</del><a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><del>FaultRecord</del></a><del> fault)
    return </del><a href="shared_pseudocode.html#impl-shared.IsExternalSyncAbort.1" title="function: boolean IsExternalSyncAbort(Fault type)"><del>IsExternalSyncAbort</del></a><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault</del></a><ins>(x) then '1' else '0';</ins><del>(fault.type);</del></p></div><div class="ps" psname="shared.functions.common.LSL"><a id="shared.functions.common.LSL" name="shared.functions.common.LSL"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>common</ins><del>aborts</del>/<ins>LSL</ins><del>IsFault</del></h3><p class="pseudocode"><ins>// LSL()
// =====
</ins><del>// IsFault()
// =========
// Return TRUE if a fault is associated with an address descriptor
</del>
<ins>bits(N)</ins><del>boolean</del> <a id="impl-shared.LSL.2" name="impl-shared.LSL.2"></a><ins>LSL(bits(N) x, integer shift)
    assert shift >= 0;
    if shift == 0 then
        result = x;
    else
        (result, -) =</ins><del>IsFault(</del> <del> addrdesc)
    return addrdesc.fault.type != </del><a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_None</del></a><a href="shared_pseudocode.html#impl-shared.LSL_C.2" title="function: (bits(N), bit) LSL_C(bits(N) x, integer shift)"><ins>LSL_C</ins></a><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><del>AddressDescriptor</del></a><ins>(x, shift);
    return result;</ins><del>;</del></p></div><div class="ps" psname="shared.functions.common.LSL_C"><a id="shared.functions.common.LSL_C" name="shared.functions.common.LSL_C"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>common</ins><del>aborts</del>/<ins>LSL_C</ins><del>IsSErrorInterrupt</del></h3><p class="pseudocode"><ins>// LSL_C()
// =======
</ins><del>// IsSErrorInterrupt()
// ===================
// Returns TRUE if the abort currently being processed is an SError interrupt, and FALSE
// otherwise.
</del>
<ins>(bits(N), bit)</ins><del>boolean</del> <a id="impl-shared.LSL_C.2" name="impl-shared.LSL_C.2"></a><ins>LSL_C(bits(N) x, integer shift)
    assert shift > 0;
    shift = if shift > N then N else shift;
    extended_x = x :</ins><del>IsSErrorInterrupt(</del> <del> type)
    assert type != </del><a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_None</del></a><del>;

    return (type IN {</del><a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_AsyncExternal</del></a><del>, </del><a href="shared_pseudocode.html#Fault_AsyncParity" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_AsyncParity</del></a><del>});

// IsSErrorInterrupt()
// ===================

boolean </del><a href="shared_pseudocode.html#impl-shared.IsSErrorInterrupt.1" title="function: boolean IsSErrorInterrupt(Fault type)"><del>IsSErrorInterrupt</del></a><del>(</del><a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><del>FaultRecord</del></a><del> fault)
    return </del><a href="shared_pseudocode.html#impl-shared.IsSErrorInterrupt.1" title="function: boolean IsSErrorInterrupt(Fault type)"><del>IsSErrorInterrupt</del></a><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault</del></a><ins>(shift);
    result = extended_x&lt;N-1:0>;
    carry_out = extended_x&lt;N>;
    return (result, carry_out);</ins><del>(fault.type);</del></p></div><div class="ps" psname="shared.functions.common.LSR"><a id="shared.functions.common.LSR" name="shared.functions.common.LSR"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>common</ins><del>aborts</del>/<ins>LSR</ins><del>IsSecondStage</del></h3><p class="pseudocode"><ins>// LSR()
// =====
</ins><del>// IsSecondStage()
// ===============
</del>
<ins>bits(N)</ins><del>boolean</del> <a id="impl-shared.LSR.2" name="impl-shared.LSR.2"></a><ins>LSR(bits(N) x, integer shift)
    assert shift >= 0;
    if shift == 0 then
        result = x;
    else
        (result, -) =</ins><del>IsSecondStage(</del> <del> fault)
    assert fault.type != </del><a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault_None</del></a><a href="shared_pseudocode.html#impl-shared.LSR_C.2" title="function: (bits(N), bit) LSR_C(bits(N) x, integer shift)"><ins>LSR_C</ins></a><a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><del>FaultRecord</del></a><ins>(x, shift);
    return result;</ins><del>;

    return fault.secondstage;</del></p></div><div class="ps" psname="shared.functions.common.LSR_C"><a id="shared.functions.common.LSR_C" name="shared.functions.common.LSR_C"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>common</ins><del>aborts</del>/<ins>LSR_C</ins><del>LSInstructionSyndrome</del></h3><p class="pseudocode"><ins>// LSR_C()
// =======

(bits(N), bit)</ins><del>bits(11)</del> <a id="impl-shared.LSR_C.2" name="impl-shared.LSR_C.2"></a><ins>LSR_C(bits(N) x, integer shift)
    assert shift > 0;
    shift = if shift > N then N else shift;
    extended_x =</ins><del>LSInstructionSyndrome();</del> <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><ins>ZeroExtend</ins></a><ins>(x, shift+N);
    result = extended_x&lt;shift+N-1:shift>;
    carry_out = extended_x&lt;shift-1>;
    return (result, carry_out);</ins></p></div><div class="ps" psname="shared.functions.common.LowestSetBit"><a id="shared.functions.common.LowestSetBit" name="shared.functions.common.LowestSetBit"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/<ins>LowestSetBit</ins><del>ASR</del></h3><p class="pseudocode"><ins>// LowestSetBit()
// ==============
</ins><del>// ASR()
// =====
</del>
<ins>integer</ins><del>bits(N)</del> <a id="impl-shared.LowestSetBit.1" name="impl-shared.LowestSetBit.1"></a><ins>LowestSetBit(bits(N) x)
    for i = 0 to N-1
        if x&lt;i> == '1' then return i;
    return N;</ins><del>ASR(bits(N) x, integer shift)
    assert shift >= 0;
    if shift == 0 then
        result = x;
    else
        (result, -) =</del><a href="shared_pseudocode.html#impl-shared.ASR_C.2" title="function: (bits(N), bit) ASR_C(bits(N) x, integer shift)"><del>ASR_C</del></a><del>(x, shift);
    return result;</del></p></div><div class="ps" psname="shared.functions.common.Max"><a id="shared.functions.common.Max" name="shared.functions.common.Max"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/<ins>Max</ins><del>ASR_C</del></h3><p class="pseudocode"><ins>// Max()
// =====
</ins><del>// ASR_C()
// =======
</del>
<ins>integer</ins><del>(bits(N), bit)</del> <a id="impl-shared.Max.2" name="impl-shared.Max.2"></a><ins>Max(integer a, integer b)
    return if a >= b then a else b;

// Max()
// =====

real</ins><del>ASR_C(bits(N) x, integer shift)
    assert shift > 0;
    shift = if shift > N then N else shift;
    extended_x =</del> <a href="shared_pseudocode.html#impl-shared.Max.2" title="function: integer Max(integer a, integer b)"><ins>Max</ins></a><a href="shared_pseudocode.html#impl-shared.SignExtend.2" title="function: bits(N) SignExtend(bits(M) x, integer N)"><del>SignExtend</del></a><ins>(real a, real b)
    return if a >= b then a else b;</ins><del>(x, shift+N);
    result = extended_x&lt;shift+N-1:shift>;
    carry_out = extended_x&lt;shift-1>;
    return (result, carry_out);</del></p></div><div class="ps" psname="shared.functions.common.Min"><a id="shared.functions.common.Min" name="shared.functions.common.Min"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/<ins>Min</ins><del>Abs</del></h3><p class="pseudocode"><ins>// Min()
</ins><del>// Abs()
</del>// =====

integer <a id="impl-shared.Min.2" name="impl-shared.Min.2"></a><ins>Min(integer a, integer b)
    return if a &lt;= b then a else b;
</ins><del>Abs(integer x)
    return if x >= 0 then x else -x;
</del>
<ins>// Min()
</ins><del>// Abs()
</del>// =====

real <a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)"><ins>Min</ins></a><a href="shared_pseudocode.html#impl-shared.Abs.1" title="function: integer Abs(integer x)"><del>Abs</del></a><ins>(real a, real b)
    return if a &lt;= b then a else b;</ins><del>(real x)
    return if x >= 0.0 then x else -x;</del></p></div><div class="ps" psname="shared.functions.common.Ones"><a id="shared.functions.common.Ones" name="shared.functions.common.Ones"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/<ins>Ones</ins><del>Align</del></h3><p class="pseudocode"><ins>// Ones()
// ======
</ins><del>// Align()
// =======
</del>
<ins>bits(N)</ins><del>integer</del> <a id="impl-shared.Ones.1" name="impl-shared.Ones.1"></a><ins>Ones(integer N)
    return</ins><del>Align(integer x, integer y)
    return y * (x DIV y);

// Align()
// =======

bits(N)</del> <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)"><del>Align</del></a><ins>('1',N);

// Ones()
// ======

bits(N)</ins><del>(bits(N) x, integer y)
    return</del> <a id="impl-shared.Ones.0" name="impl-shared.Ones.0"></a><ins>Ones()
    return</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>(N);</ins><del>(x), y)&lt;N-1:0>;</del></p></div><div class="ps" psname="shared.functions.common.ROR"><a id="shared.functions.common.ROR" name="shared.functions.common.ROR"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/<ins>ROR</ins><del>BitCount</del></h3><p class="pseudocode"><ins>// ROR()
// =====
</ins><del>// BitCount()
// ==========
</del>
<ins>bits(N)</ins><del>integer</del> <a id="impl-shared.ROR.2" name="impl-shared.ROR.2"></a><ins>ROR(bits(N) x, integer shift)
    assert shift >= 0;
    if shift == 0 then
        result = x;
    else
        (result, -) =</ins><del>BitCount(bits(N) x)
    integer result = 0;
    for i = 0 to N-1
        if x&lt;i> == '1' then
            result = result + 1;
    return result;</del> <a href="shared_pseudocode.html#impl-shared.ROR_C.2" title="function: (bits(N), bit) ROR_C(bits(N) x, integer shift)"><ins>ROR_C</ins></a><ins>(x, shift);
    return result;</ins></p></div><div class="ps" psname="shared.functions.common.ROR_C"><a id="shared.functions.common.ROR_C" name="shared.functions.common.ROR_C"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/<ins>ROR_C</ins><del>CountLeadingSignBits</del></h3><p class="pseudocode"><ins>// ROR_C()
// =======
</ins><del>// CountLeadingSignBits()
// ======================
</del>
<ins>(bits(N), bit)</ins><del>integer</del> <a id="impl-shared.ROR_C.2" name="impl-shared.ROR_C.2"></a><ins>ROR_C(bits(N) x, integer shift)
    assert shift != 0;
    m = shift MOD N;
    result =</ins><del>CountLeadingSignBits(bits(N) x)
    return</del> <a href="shared_pseudocode.html#impl-shared.LSR.2" title="function: bits(N) LSR(bits(N) x, integer shift)"><ins>LSR</ins></a><a href="shared_pseudocode.html#impl-shared.CountLeadingZeroBits.1" title="function: integer CountLeadingZeroBits(bits(N) x)"><del>CountLeadingZeroBits</del></a><ins>(x,m) OR </ins><a href="shared_pseudocode.html#impl-shared.LSL.2" title="function: bits(N) LSL(bits(N) x, integer shift)"><ins>LSL</ins></a><ins>(x,N-m);
    carry_out = result&lt;N-1>;
    return (result, carry_out);</ins><del>(x&lt;N-1:1> EOR x&lt;N-2:0>);</del></p></div><div class="ps" psname="shared.functions.common.Replicate"><a id="shared.functions.common.Replicate" name="shared.functions.common.Replicate"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/<ins>Replicate</ins><del>CountLeadingZeroBits</del></h3><p class="pseudocode"><ins>// Replicate()
// ===========
</ins><del>// CountLeadingZeroBits()
// ======================
</del>
<ins>bits(N)</ins><del>integer</del> <a id="impl-shared.Replicate.1" name="impl-shared.Replicate.1"></a><ins>Replicate(bits(M) x)
    assert N MOD M == 0;
    return</ins><del>CountLeadingZeroBits(bits(N) x)
    return N - (</del> <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><a href="shared_pseudocode.html#impl-shared.HighestSetBit.1" title="function: integer HighestSetBit(bits(N) x)"><del>HighestSetBit</del></a><ins>(x, N DIV M);

bits(M*N) </ins><a id="impl-shared.Replicate.2" name="impl-shared.Replicate.2"></a><ins>Replicate(bits(M) x, integer N);</ins><del>(x) + 1);</del></p></div><div class="ps" psname="shared.functions.common.RoundDown"><a id="shared.functions.common.RoundDown" name="shared.functions.common.RoundDown"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/<ins>RoundDown</ins><del>Elem</del></h3><p class="pseudocode"><ins>integer</ins><del>// Elem[] - non-assignment form
// ============================

bits(size)</del> <a id="impl-shared.RoundDown.1" name="impl-shared.RoundDown.1"></a><ins>RoundDown(real x);</ins><del>Elem[bits(N) vector, integer e, integer size]
    assert e >= 0 &amp;&amp; (e+1)*size &lt;= N;
    return vector&lt;e*size+size-1 : e*size>;

// Elem[] - non-assignment form
// ============================

bits(size)</del><a id="impl-shared.Elem.read.2" name="impl-shared.Elem.read.2"></a><del>Elem[bits(N) vector, integer e]
    return </del><a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]"><del>Elem</del></a><del>[vector, e, size];

// Elem[] - assignment form
// ========================

</del><a id="impl-shared.Elem.write.3" name="impl-shared.Elem.write.3"></a><del>Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value
    assert e >= 0 &amp;&amp; (e+1)*size &lt;= N;
    vector&lt;(e+1)*size-1:e*size> = value;
    return;

// Elem[] - assignment form
// ========================

</del><a id="impl-shared.Elem.write.2" name="impl-shared.Elem.write.2"></a><del>Elem[bits(N) &amp;vector, integer e] = bits(size) value
    </del><a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value"><del>Elem</del></a><del>[vector, e, size] = value;
    return;</del></p></div><div class="ps" psname="shared.functions.common.RoundTowardsZero"><a id="shared.functions.common.RoundTowardsZero" name="shared.functions.common.RoundTowardsZero"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/<ins>RoundTowardsZero</ins><del>Extend</del></h3><p class="pseudocode"><ins>// RoundTowardsZero()
// ==================
</ins><del>// Extend()
// ========
</del>
<ins>integer</ins><del>bits(N)</del> <a id="impl-shared.RoundTowardsZero.1" name="impl-shared.RoundTowardsZero.1"></a><ins>RoundTowardsZero(real x)
    return if x == 0.0 then 0 else if x >= 0.0 then</ins><del>Extend(bits(M) x, integer N, boolean unsigned)
    return if unsigned then</del> <a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)"><ins>RoundDown</ins></a><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><del>ZeroExtend</del></a><ins>(x) else</ins><del>(x, N) else</del> <del>(x, N);

// Extend()
// ========

bits(N) </del><a id="impl-shared.Extend.2" name="impl-shared.Extend.2"></a><del>Extend(bits(M) x, boolean unsigned)
    return </del><a href="shared_pseudocode.html#impl-shared.Extend.3" title="function: bits(N) Extend(bits(M) x, integer N, boolean unsigned)"><del>Extend</del></a><a href="shared_pseudocode.html#impl-shared.RoundUp.1" title="function: integer RoundUp(real x)"><ins>RoundUp</ins></a><a href="shared_pseudocode.html#impl-shared.SignExtend.2" title="function: bits(N) SignExtend(bits(M) x, integer N)"><del>SignExtend</del></a><ins>(x);</ins><del>(x, N, unsigned);</del></p></div><div class="ps" psname="shared.functions.common.RoundUp"><a id="shared.functions.common.RoundUp" name="shared.functions.common.RoundUp"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/<ins>RoundUp</ins><del>HighestSetBit</del></h3><p class="pseudocode"><del>// HighestSetBit()
// ===============

</del>integer <a id="impl-shared.RoundUp.1" name="impl-shared.RoundUp.1"></a><ins>RoundUp(real x);</ins><del>HighestSetBit(bits(N) x)
    for i = N-1 downto 0
        if x&lt;i> == '1' then return i;
    return -1;</del></p></div><div class="ps" psname="shared.functions.common.SInt"><a id="shared.functions.common.SInt" name="shared.functions.common.SInt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/<ins>SInt</ins><del>Int</del></h3><p class="pseudocode"><ins>// SInt()
// ======
</ins><del>// Int()
// =====
</del>
integer <a id="impl-shared.SInt.1" name="impl-shared.SInt.1"></a><ins>SInt(bits(N) x)
    result = 0;
    for i = 0 to N-1
        if x&lt;i> == '1' then result = result + 2^i;
    if x&lt;N-1> == '1' then result = result - 2^N;
    return result;</ins><del>Int(bits(N) x, boolean unsigned)
    result = if unsigned then</del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(x) else </del><a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)"><del>SInt</del></a><del>(x);
    return result;</del></p></div><div class="ps" psname="shared.functions.common.SignExtend"><a id="shared.functions.common.SignExtend" name="shared.functions.common.SignExtend"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/<ins>SignExtend</ins><del>IsOnes</del></h3><p class="pseudocode"><ins>// SignExtend()
// ============
</ins><del>// IsOnes()
// ========
</del>
<ins>bits(N)</ins><del>boolean</del> <a id="impl-shared.SignExtend.2" name="impl-shared.SignExtend.2"></a><ins>SignExtend(bits(M) x, integer N)
    assert N >= M;
    return</ins><del>IsOnes(bits(N) x)
    return x ==</del> <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a><ins>(x&lt;M-1>, N-M) : x;

// SignExtend()
// ============

bits(N) </ins><a id="impl-shared.SignExtend.1" name="impl-shared.SignExtend.1"></a><ins>SignExtend(bits(M) x)
    return </ins><a href="shared_pseudocode.html#impl-shared.SignExtend.2" title="function: bits(N) SignExtend(bits(M) x, integer N)"><ins>SignExtend</ins></a><ins>(x, N);</ins><del>(N);</del></p></div><div class="ps" psname="shared.functions.common.UInt"><a id="shared.functions.common.UInt" name="shared.functions.common.UInt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/<ins>UInt</ins><del>IsZero</del></h3><p class="pseudocode"><ins>// UInt()
// ======
</ins><del>// IsZero()
// ========
</del>
<ins>integer</ins><del>boolean</del> <a id="impl-shared.UInt.1" name="impl-shared.UInt.1"></a><ins>UInt(bits(N) x)
    result = 0;
    for i = 0 to N-1
        if x&lt;i> == '1' then result = result + 2^i;
    return result;</ins><del>IsZero(bits(N) x)
    return x ==</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(N);</del></p></div><div class="ps" psname="shared.functions.common.ZeroExtend"><a id="shared.functions.common.ZeroExtend" name="shared.functions.common.ZeroExtend"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/<ins>ZeroExtend</ins><del>IsZeroBit</del></h3><p class="pseudocode"><ins>// ZeroExtend()
// ============
</ins><del>// IsZeroBit()
// ===========
</del>
<ins>bits(N)</ins><del>bit</del> <a id="impl-shared.ZeroExtend.2" name="impl-shared.ZeroExtend.2"></a><ins>ZeroExtend(bits(M) x, integer N)
    assert N >= M;
    return</ins><del>IsZeroBit(bits(N) x)
    return if</del> <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><ins>(N-M) : x;

// ZeroExtend()
// ============

bits(N) </ins><a id="impl-shared.ZeroExtend.1" name="impl-shared.ZeroExtend.1"></a><ins>ZeroExtend(bits(M) x)
    return </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><ins>ZeroExtend</ins></a><ins>(x, N);</ins><del>(x) then '1' else '0';</del></p></div><div class="ps" psname="shared.functions.common.Zeros"><a id="shared.functions.common.Zeros" name="shared.functions.common.Zeros"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/<ins>Zeros</ins><del>LSL</del></h3><p class="pseudocode"><ins>// Zeros()
// =======
</ins><del>// LSL()
// =====
</del>
bits(N) <a id="impl-shared.Zeros.1" name="impl-shared.Zeros.1"></a><ins>Zeros(integer N)
    return</ins><del>LSL(bits(N) x, integer shift)
    assert shift >= 0;
    if shift == 0 then
        result = x;
    else
        (result, -) =</del> <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><a href="shared_pseudocode.html#impl-shared.LSL_C.2" title="function: (bits(N), bit) LSL_C(bits(N) x, integer shift)"><del>LSL_C</del></a><ins>('0',N);

// Zeros()
// =======

bits(N) </ins><a id="impl-shared.Zeros.0" name="impl-shared.Zeros.0"></a><ins>Zeros()
    return </ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(N);</ins><del>(x, shift);
    return result;</del></p></div><div class="ps" psname="shared.functions.crc.BitReverse"><a id="shared.functions.crc.BitReverse" name="shared.functions.crc.BitReverse"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>crc</ins><del>common</del>/<ins>BitReverse</ins><del>LSL_C</del></h3><p class="pseudocode"><ins>// BitReverse()
// ============
</ins><del>// LSL_C()
// =======
</del>
<ins>bits(N)</ins><del>(bits(N), bit)</del> <a id="impl-shared.BitReverse.1" name="impl-shared.BitReverse.1"></a><ins>BitReverse(bits(N) data)
    bits(N) result;
    for i = 0 to N-1
        result&lt;N-i-1> = data&lt;i>;
    return result;</ins><del>LSL_C(bits(N) x, integer shift)
    assert shift > 0;
    shift = if shift > N then N else shift;
    extended_x = x :</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(shift);
    result = extended_x&lt;N-1:0>;
    carry_out = extended_x&lt;N>;
    return (result, carry_out);</del></p></div><div class="ps" psname="shared.functions.crc.HaveCRCExt"><a id="shared.functions.crc.HaveCRCExt" name="shared.functions.crc.HaveCRCExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>crc</ins><del>common</del>/<ins>HaveCRCExt</ins><del>LSR</del></h3><p class="pseudocode"><ins>// HaveCRCExt()
// ============
</ins><del>// LSR()
// =====
</del>
<ins>boolean</ins><del>bits(N)</del> <a id="impl-shared.HaveCRCExt.0" name="impl-shared.HaveCRCExt.0"></a><ins>HaveCRCExt()
    return</ins><del>LSR(bits(N) x, integer shift)
    assert shift >= 0;
    if shift == 0 then
        result = x;
    else
        (result, -) =</del> <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><ins>HasArchVersion</ins></a><a href="shared_pseudocode.html#impl-shared.LSR_C.2" title="function: (bits(N), bit) LSR_C(bits(N) x, integer shift)"><del>LSR_C</del></a><ins>(</ins><a href="shared_pseudocode.html#ARMv8p1" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p1</ins></a><ins>) || boolean IMPLEMENTATION_DEFINED "Have CRC extension";</ins><del>(x, shift);
    return result;</del></p></div><div class="ps" psname="shared.functions.crc.Poly32Mod2"><a id="shared.functions.crc.Poly32Mod2" name="shared.functions.crc.Poly32Mod2"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>crc</ins><del>common</del>/<ins>Poly32Mod2</ins><del>LSR_C</del></h3><p class="pseudocode"><ins>// Poly32Mod2()
// ============
</ins><del>// LSR_C()
// =======
</del>
<ins>// Poly32Mod2 on a bitstring does a polynomial Modulus over {0,1} operation

bits(32)</ins><del>(bits(N), bit)</del> <a id="impl-shared.Poly32Mod2.2" name="impl-shared.Poly32Mod2.2"></a><ins>Poly32Mod2(bits(N) data, bits(32) poly)
    assert N > 32;
    for i = N-1 downto 32
        if data&lt;i> == '1' then
            data&lt;i-1:0> = data&lt;i-1:0> EOR (poly:</ins><del>LSR_C(bits(N) x, integer shift)
    assert shift > 0;
    shift = if shift > N then N else shift;
    extended_x =</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><del>ZeroExtend</del></a><ins>(i-32));
    return data&lt;31:0>;</ins><del>(x, shift+N);
    result = extended_x&lt;shift+N-1:shift>;
    carry_out = extended_x&lt;shift-1>;
    return (result, carry_out);</del></p></div><div class="ps" psname="shared.functions.crypto.AESInvMixColumns"><a id="shared.functions.crypto.AESInvMixColumns" name="shared.functions.crypto.AESInvMixColumns"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>crypto</ins><del>common</del>/<ins>AESInvMixColumns</ins><del>LowestSetBit</del></h3><p class="pseudocode"><ins>bits(128)</ins><del>// LowestSetBit()
// ==============

integer</del> <a id="impl-shared.AESInvMixColumns.1" name="impl-shared.AESInvMixColumns.1"></a><ins>AESInvMixColumns(bits (128) op);</ins><del>LowestSetBit(bits(N) x)
    for i = 0 to N-1
        if x&lt;i> == '1' then return i;
    return N;</del></p></div><div class="ps" psname="shared.functions.crypto.AESInvShiftRows"><a id="shared.functions.crypto.AESInvShiftRows" name="shared.functions.crypto.AESInvShiftRows"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>crypto</ins><del>common</del>/<ins>AESInvShiftRows</ins><del>Max</del></h3><p class="pseudocode"><ins>bits(128)</ins><del>// Max()
// =====

integer</del> <a id="impl-shared.AESInvShiftRows.1" name="impl-shared.AESInvShiftRows.1"></a><ins>AESInvShiftRows(bits(128) op);</ins><del>Max(integer a, integer b)
    return if a >= b then a else b;

// Max()
// =====

real</del><a href="shared_pseudocode.html#impl-shared.Max.2" title="function: integer Max(integer a, integer b)"><del>Max</del></a><del>(real a, real b)
    return if a >= b then a else b;</del></p></div><div class="ps" psname="shared.functions.crypto.AESInvSubBytes"><a id="shared.functions.crypto.AESInvSubBytes" name="shared.functions.crypto.AESInvSubBytes"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>crypto</ins><del>common</del>/<ins>AESInvSubBytes</ins><del>Min</del></h3><p class="pseudocode"><ins>bits(128)</ins><del>// Min()
// =====

integer</del> <a id="impl-shared.AESInvSubBytes.1" name="impl-shared.AESInvSubBytes.1"></a><ins>AESInvSubBytes(bits(128) op);</ins><del>Min(integer a, integer b)
    return if a &lt;= b then a else b;

// Min()
// =====

real</del><a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)"><del>Min</del></a><del>(real a, real b)
    return if a &lt;= b then a else b;</del></p></div><div class="ps" psname="shared.functions.crypto.AESMixColumns"><a id="shared.functions.crypto.AESMixColumns" name="shared.functions.crypto.AESMixColumns"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>crypto</ins><del>common</del>/<ins>AESMixColumns</ins><del>Ones</del></h3><p class="pseudocode"><ins>bits(128)</ins><del>// Ones()
// ======

bits(N)</del> <a id="impl-shared.AESMixColumns.1" name="impl-shared.AESMixColumns.1"></a><ins>AESMixColumns(bits (128) op);</ins><del>Ones(integer N)
    return</del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>('1',N);

// Ones()
// ======

bits(N) </del><a id="impl-shared.Ones.0" name="impl-shared.Ones.0"></a><del>Ones()
    return </del><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a><del>(N);</del></p></div><div class="ps" psname="shared.functions.crypto.AESShiftRows"><a id="shared.functions.crypto.AESShiftRows" name="shared.functions.crypto.AESShiftRows"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>crypto</ins><del>common</del>/<ins>AESShiftRows</ins><del>ROR</del></h3><p class="pseudocode"><ins>bits(128)</ins><del>// ROR()
// =====

bits(N)</del> <a id="impl-shared.AESShiftRows.1" name="impl-shared.AESShiftRows.1"></a><ins>AESShiftRows(bits(128) op);</ins><del>ROR(bits(N) x, integer shift)
    assert shift >= 0;
    if shift == 0 then
        result = x;
    else
        (result, -) =</del><a href="shared_pseudocode.html#impl-shared.ROR_C.2" title="function: (bits(N), bit) ROR_C(bits(N) x, integer shift)"><del>ROR_C</del></a><del>(x, shift);
    return result;</del></p></div><div class="ps" psname="shared.functions.crypto.AESSubBytes"><a id="shared.functions.crypto.AESSubBytes" name="shared.functions.crypto.AESSubBytes"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>crypto</ins><del>common</del>/<ins>AESSubBytes</ins><del>ROR_C</del></h3><p class="pseudocode"><ins>bits(128)</ins><del>// ROR_C()
// =======

(bits(N), bit)</del> <a id="impl-shared.AESSubBytes.1" name="impl-shared.AESSubBytes.1"></a><ins>AESSubBytes(bits(128) op);</ins><del>ROR_C(bits(N) x, integer shift)
    assert shift != 0;
    m = shift MOD N;
    result =</del><a href="shared_pseudocode.html#impl-shared.LSR.2" title="function: bits(N) LSR(bits(N) x, integer shift)"><del>LSR</del></a><del>(x,m) OR </del><a href="shared_pseudocode.html#impl-shared.LSL.2" title="function: bits(N) LSL(bits(N) x, integer shift)"><del>LSL</del></a><del>(x,N-m);
    carry_out = result&lt;N-1>;
    return (result, carry_out);</del></p></div><div class="ps" psname="shared.functions.crypto.HaveAESExt"><a id="shared.functions.crypto.HaveAESExt" name="shared.functions.crypto.HaveAESExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>crypto</ins><del>common</del>/<ins>HaveAESExt</ins><del>Replicate</del></h3><p class="pseudocode"><ins>// HaveAESExt()
// ============
// TRUE if AES cryptographic instructions support is implemented,
// FALSE otherwise.
</ins><del>// Replicate()
// ===========
</del>
<ins>boolean</ins><del>bits(N)</del> <a id="impl-shared.HaveAESExt.0" name="impl-shared.HaveAESExt.0"></a><ins>HaveAESExt()
    return boolean IMPLEMENTATION_DEFINED "Has AES Crypto instructions";</ins><del>Replicate(bits(M) x)
    assert N MOD M == 0;
    return</del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(x, N DIV M);

bits(M*N) </del><a id="impl-shared.Replicate.2" name="impl-shared.Replicate.2"></a><del>Replicate(bits(M) x, integer N);</del></p></div><div class="ps" psname="shared.functions.crypto.HaveBit128PMULLExt"><a id="shared.functions.crypto.HaveBit128PMULLExt" name="shared.functions.crypto.HaveBit128PMULLExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>crypto</ins><del>common</del>/<ins>HaveBit128PMULLExt</ins><del>RoundDown</del></h3><p class="pseudocode"><ins>// HaveBit128PMULLExt()
// ====================
// TRUE if 128 bit form of PMULL instructions support is implemented,
// FALSE otherwise.

boolean</ins><del>integer</del> <a id="impl-shared.HaveBit128PMULLExt.0" name="impl-shared.HaveBit128PMULLExt.0"></a><ins>HaveBit128PMULLExt()
    return boolean IMPLEMENTATION_DEFINED "Has 128-bit form of PMULL instructions";</ins><del>RoundDown(real x);</del></p></div><div class="ps" psname="shared.functions.crypto.HaveSHA1Ext"><a id="shared.functions.crypto.HaveSHA1Ext" name="shared.functions.crypto.HaveSHA1Ext"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>crypto</ins><del>common</del>/<ins>HaveSHA1Ext</ins><del>RoundTowardsZero</del></h3><p class="pseudocode"><ins>// HaveSHA1Ext()
// =============
// TRUE if SHA1 cryptographic instructions support is implemented,
// FALSE otherwise.
</ins><del>// RoundTowardsZero()
// ==================
</del>
<ins>boolean</ins><del>integer</del> <a id="impl-shared.HaveSHA1Ext.0" name="impl-shared.HaveSHA1Ext.0"></a><ins>HaveSHA1Ext()
    return boolean IMPLEMENTATION_DEFINED "Has SHA1 Crypto instructions";</ins><del>RoundTowardsZero(real x)
    return if x == 0.0 then 0 else if x >= 0.0 then</del><a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)"><del>RoundDown</del></a><del>(x) else </del><a href="shared_pseudocode.html#impl-shared.RoundUp.1" title="function: integer RoundUp(real x)"><del>RoundUp</del></a><del>(x);</del></p></div><div class="ps" psname="shared.functions.crypto.HaveSHA256Ext"><a id="shared.functions.crypto.HaveSHA256Ext" name="shared.functions.crypto.HaveSHA256Ext"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>crypto</ins><del>common</del>/<ins>HaveSHA256Ext</ins><del>RoundUp</del></h3><p class="pseudocode"><ins>// HaveSHA256Ext()
// ===============
// TRUE if SHA256 cryptographic instructions support is implemented,
// FALSE otherwise.

boolean</ins><del>integer</del> <a id="impl-shared.HaveSHA256Ext.0" name="impl-shared.HaveSHA256Ext.0"></a><ins>HaveSHA256Ext()
    return boolean IMPLEMENTATION_DEFINED "Has SHA256 Crypto instructions";</ins><del>RoundUp(real x);</del></p></div><div class="ps" psname="shared.functions.crypto.HaveSHA3Ext"><a id="shared.functions.crypto.HaveSHA3Ext" name="shared.functions.crypto.HaveSHA3Ext"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>crypto</ins><del>common</del>/<ins>HaveSHA3Ext</ins><del>SInt</del></h3><p class="pseudocode"><ins>// HaveSHA3Ext()
// =============
// TRUE if SHA3 cryptographic instructions support is implemented,
// and when SHA1 and SHA2 basic cryptographic instructions support is implemented,
// FALSE otherwise.
</ins><del>// SInt()
// ======
</del>
<ins>boolean</ins><del>integer</del> <a id="impl-shared.HaveSHA3Ext.0" name="impl-shared.HaveSHA3Ext.0"></a><ins>HaveSHA3Ext()
    if !</ins><del>SInt(bits(N) x)
    result = 0;
    for i = 0 to N-1
        if x&lt;i> == '1' then result = result + 2^i;
    if x&lt;N-1> == '1' then result = result - 2^N;
    return result;</del><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><ins>HasArchVersion</ins></a><ins>(</ins><a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p2</ins></a><ins>) || !(</ins><a href="shared_pseudocode.html#impl-shared.HaveSHA1Ext.0" title="function: boolean HaveSHA1Ext()"><ins>HaveSHA1Ext</ins></a><ins>() &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.HaveSHA256Ext.0" title="function: boolean HaveSHA256Ext()"><ins>HaveSHA256Ext</ins></a><ins>()) then
        return FALSE;
    return boolean IMPLEMENTATION_DEFINED "Has SHA3 Crypto instructions";</ins></p></div><div class="ps" psname="shared.functions.crypto.HaveSHA512Ext"><a id="shared.functions.crypto.HaveSHA512Ext" name="shared.functions.crypto.HaveSHA512Ext"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>crypto</ins><del>common</del>/<ins>HaveSHA512Ext</ins><del>SignExtend</del></h3><p class="pseudocode"><ins>// HaveSHA512Ext()
// ===============
// TRUE if SHA512 cryptographic instructions support is implemented,
// and when SHA1 and SHA2 basic cryptographic instructions support is implemented,
// FALSE otherwise.
</ins><del>// SignExtend()
// ============
</del>
<ins>boolean</ins><del>bits(N)</del> <a id="impl-shared.HaveSHA512Ext.0" name="impl-shared.HaveSHA512Ext.0"></a><ins>HaveSHA512Ext()
    if !</ins><del>SignExtend(bits(M) x, integer N)
    assert N >= M;
    return</del><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><ins>HasArchVersion</ins></a><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><ins>(</ins><del>(x&lt;M-1>, N-M) : x;

// SignExtend()
// ============

bits(N)</del><a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p2</ins></a><ins>) || !(</ins><del>SignExtend(bits(M) x)
    return</del><a href="shared_pseudocode.html#impl-shared.HaveSHA1Ext.0" title="function: boolean HaveSHA1Ext()"><ins>HaveSHA1Ext</ins></a><a href="shared_pseudocode.html#impl-shared.SignExtend.2" title="function: bits(N) SignExtend(bits(M) x, integer N)"><del>SignExtend</del></a><ins>() &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.HaveSHA256Ext.0" title="function: boolean HaveSHA256Ext()"><ins>HaveSHA256Ext</ins></a><ins>()) then
        return FALSE;
    return boolean IMPLEMENTATION_DEFINED "Has SHA512 Crypto instructions";</ins><del>(x, N);</del></p></div><div class="ps" psname="shared.functions.crypto.HaveSM3Ext"><a id="shared.functions.crypto.HaveSM3Ext" name="shared.functions.crypto.HaveSM3Ext"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>crypto</ins><del>common</del>/<ins>HaveSM3Ext</ins><del>UInt</del></h3><p class="pseudocode"><ins>// HaveSM3Ext()
// ============
// TRUE if SM3 cryptographic instructions support is implemented,
// FALSE otherwise.
</ins><del>// UInt()
// ======
</del>
<ins>boolean</ins><del>integer</del> <a id="impl-shared.HaveSM3Ext.0" name="impl-shared.HaveSM3Ext.0"></a><ins>HaveSM3Ext()
    if !</ins><del>UInt(bits(N) x)
    result = 0;
    for i = 0 to N-1
        if x&lt;i> == '1' then result = result + 2^i;
    return result;</del><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><ins>HasArchVersion</ins></a><ins>(</ins><a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p2</ins></a><ins>) then
        return FALSE;
    return boolean IMPLEMENTATION_DEFINED "Has SM3 Crypto instructions";</ins></p></div><div class="ps" psname="shared.functions.crypto.HaveSM4Ext"><a id="shared.functions.crypto.HaveSM4Ext" name="shared.functions.crypto.HaveSM4Ext"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>crypto</ins><del>common</del>/<ins>HaveSM4Ext</ins><del>ZeroExtend</del></h3><p class="pseudocode"><ins>// HaveSM4Ext()
</ins><del>// ZeroExtend()
</del>// ============
<ins>// TRUE if SM4 cryptographic instructions support is implemented,
// FALSE otherwise.
</ins>
<ins>boolean</ins><del>bits(N)</del> <a id="impl-shared.HaveSM4Ext.0" name="impl-shared.HaveSM4Ext.0"></a><ins>HaveSM4Ext()
    if !</ins><del>ZeroExtend(bits(M) x, integer N)
    assert N >= M;
    return</del><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><ins>HasArchVersion</ins></a><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><ins>(</ins><del>(N-M) : x;

// ZeroExtend()
// ============

bits(N)</del><del>ZeroExtend(bits(M) x)
    return </del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><del>ZeroExtend</del></a><a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p2</ins></a><ins>) then
        return FALSE;
    return boolean IMPLEMENTATION_DEFINED "Has SM4 Crypto instructions";</ins><del>(x, N);</del></p></div><div class="ps" psname="shared.functions.crypto.ROL"><a id="shared.functions.crypto.ROL" name="shared.functions.crypto.ROL"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>crypto</ins><del>common</del>/<ins>ROL</ins><del>Zeros</del></h3><p class="pseudocode"><ins>// ROL()
// =====
</ins><del>// Zeros()
// =======
</del>
bits(N) <a id="impl-shared.ROL.2" name="impl-shared.ROL.2"></a><ins>ROL(bits(N) x, integer shift)
    assert shift >= 0 &amp;&amp; shift &lt;= N;
    if (shift == 0) then
        return x;
</ins><del>Zeros(integer N)
</del>    return <del>('0',N);

// Zeros()
// =======

bits(N) </del><a id="impl-shared.Zeros.0" name="impl-shared.Zeros.0"></a><del>Zeros()
    return </del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><a href="shared_pseudocode.html#impl-shared.ROR.2" title="function: bits(N) ROR(bits(N) x, integer shift)"><ins>ROR</ins></a><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><ins>(x, N-shift);</ins><del>(N);</del></p></div><div class="ps" psname="shared.functions.crypto.SHA256hash"><a id="shared.functions.crypto.SHA256hash" name="shared.functions.crypto.SHA256hash"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>crypto</ins><del>crc</del>/<ins>SHA256hash</ins><del>BitReverse</del></h3><p class="pseudocode"><ins>// SHA256hash()
</ins><del>// BitReverse()
</del>// ============

<ins>bits(128)</ins><del>bits(N)</del> <a id="impl-shared.SHA256hash.4" name="impl-shared.SHA256hash.4"></a><ins>SHA256hash(bits (128) X, bits(128) Y, bits(128) W, boolean part1)
    bits(32) chs, maj, t;

    for e = 0 to 3
        chs =</ins><del>BitReverse(bits(N) data)
    bits(N) result;
    for i = 0 to N-1
        result&lt;N-i-1> = data&lt;i>;
    return result;</del> <a href="shared_pseudocode.html#impl-shared.SHAchoose.3" title="function: bits(32) SHAchoose(bits(32) x, bits(32) y, bits(32) z)"><ins>SHAchoose</ins></a><ins>(Y&lt;31:0>, Y&lt;63:32>, Y&lt;95:64>);
        maj = </ins><a href="shared_pseudocode.html#impl-shared.SHAmajority.3" title="function: bits(32) SHAmajority(bits(32) x, bits(32) y, bits(32) z)"><ins>SHAmajority</ins></a><ins>(X&lt;31:0>, X&lt;63:32>, X&lt;95:64>);
        t = Y&lt;127:96> + </ins><a href="shared_pseudocode.html#impl-shared.SHAhashSIGMA1.1" title="function: bits(32) SHAhashSIGMA1(bits(32) x)"><ins>SHAhashSIGMA1</ins></a><ins>(Y&lt;31:0>) + chs + </ins><a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]"><ins>Elem</ins></a><ins>[W, e, 32];
        X&lt;127:96> = t + X&lt;127:96>;
        Y&lt;127:96> = t + </ins><a href="shared_pseudocode.html#impl-shared.SHAhashSIGMA0.1" title="function: bits(32) SHAhashSIGMA0(bits(32) x)"><ins>SHAhashSIGMA0</ins></a><ins>(X&lt;31:0>) + maj;
        &lt;Y, X> = </ins><a href="shared_pseudocode.html#impl-shared.ROL.2" title="function: bits(N) ROL(bits(N) x, integer shift)"><ins>ROL</ins></a><ins>(Y : X, 32);
    return (if part1 then X else Y);</ins></p></div><div class="ps" psname="shared.functions.crypto.SHAchoose"><a id="shared.functions.crypto.SHAchoose" name="shared.functions.crypto.SHAchoose"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>crypto</ins><del>crc</del>/<ins>SHAchoose</ins><del>HaveCRCExt</del></h3><p class="pseudocode"><ins>// SHAchoose()
// ===========
</ins><del>// HaveCRCExt()
// ============
</del>
<ins>bits(32)</ins><del>boolean</del> <a id="impl-shared.SHAchoose.3" name="impl-shared.SHAchoose.3"></a><ins>SHAchoose(bits(32) x, bits(32) y, bits(32) z)
    return (((y EOR z) AND x) EOR z);</ins><del>HaveCRCExt()
    return</del><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><del>HasArchVersion</del></a><del>(</del><a href="shared_pseudocode.html#ARMv8p1" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p1</del></a><del>) || boolean IMPLEMENTATION_DEFINED "Have CRC extension";</del></p></div><div class="ps" psname="shared.functions.crypto.SHAhashSIGMA0"><a id="shared.functions.crypto.SHAhashSIGMA0" name="shared.functions.crypto.SHAhashSIGMA0"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>crypto</ins><del>crc</del>/<ins>SHAhashSIGMA0</ins><del>Poly32Mod2</del></h3><p class="pseudocode"><ins>// SHAhashSIGMA0()
// ===============
</ins><del>// Poly32Mod2()
// ============

// Poly32Mod2 on a bitstring does a polynomial Modulus over {0,1} operation
</del>
bits(32) <a id="impl-shared.SHAhashSIGMA0.1" name="impl-shared.SHAhashSIGMA0.1"></a><ins>SHAhashSIGMA0(bits(32) x)
    return</ins><del>Poly32Mod2(bits(N) data, bits(32) poly)
    assert N > 32;
    for i = N-1 downto 32
        if data&lt;i> == '1' then
            data&lt;i-1:0> = data&lt;i-1:0> EOR (poly:</del> <a href="shared_pseudocode.html#impl-shared.ROR.2" title="function: bits(N) ROR(bits(N) x, integer shift)"><ins>ROR</ins></a><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><ins>(x, 2) EOR </ins><a href="shared_pseudocode.html#impl-shared.ROR.2" title="function: bits(N) ROR(bits(N) x, integer shift)"><ins>ROR</ins></a><ins>(x, 13) EOR </ins><a href="shared_pseudocode.html#impl-shared.ROR.2" title="function: bits(N) ROR(bits(N) x, integer shift)"><ins>ROR</ins></a><ins>(x, 22);</ins><del>(i-32));
    return data&lt;31:0>;</del></p></div><div class="ps" psname="shared.functions.crypto.SHAhashSIGMA1"><a id="shared.functions.crypto.SHAhashSIGMA1" name="shared.functions.crypto.SHAhashSIGMA1"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/<ins>SHAhashSIGMA1</ins><del>AESInvMixColumns</del></h3><p class="pseudocode"><ins>// SHAhashSIGMA1()
// ===============

bits(32)</ins><del>bits(128)</del> <a id="impl-shared.SHAhashSIGMA1.1" name="impl-shared.SHAhashSIGMA1.1"></a><ins>SHAhashSIGMA1(bits(32) x)
    return</ins><del>AESInvMixColumns(bits (128) op);</del> <a href="shared_pseudocode.html#impl-shared.ROR.2" title="function: bits(N) ROR(bits(N) x, integer shift)"><ins>ROR</ins></a><ins>(x, 6) EOR </ins><a href="shared_pseudocode.html#impl-shared.ROR.2" title="function: bits(N) ROR(bits(N) x, integer shift)"><ins>ROR</ins></a><ins>(x, 11) EOR </ins><a href="shared_pseudocode.html#impl-shared.ROR.2" title="function: bits(N) ROR(bits(N) x, integer shift)"><ins>ROR</ins></a><ins>(x, 25);</ins></p></div><div class="ps" psname="shared.functions.crypto.SHAmajority"><a id="shared.functions.crypto.SHAmajority" name="shared.functions.crypto.SHAmajority"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/<ins>SHAmajority</ins><del>AESInvShiftRows</del></h3><p class="pseudocode"><ins>// SHAmajority()
// =============

bits(32)</ins><del>bits(128)</del> <a id="impl-shared.SHAmajority.3" name="impl-shared.SHAmajority.3"></a><ins>SHAmajority(bits(32) x, bits(32) y, bits(32) z)
    return ((x AND y) OR ((x OR y) AND z));</ins><del>AESInvShiftRows(bits(128) op);</del></p></div><div class="ps" psname="shared.functions.crypto.SHAparity"><a id="shared.functions.crypto.SHAparity" name="shared.functions.crypto.SHAparity"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/<ins>SHAparity</ins><del>AESInvSubBytes</del></h3><p class="pseudocode"><ins>// SHAparity()
// ===========

bits(32)</ins><del>bits(128)</del> <a id="impl-shared.SHAparity.3" name="impl-shared.SHAparity.3"></a><ins>SHAparity(bits(32) x, bits(32) y, bits(32) z)
    return (x EOR y EOR z);</ins><del>AESInvSubBytes(bits(128) op);</del></p></div><div class="ps" psname="shared.functions.crypto.Sbox"><a id="shared.functions.crypto.Sbox" name="shared.functions.crypto.Sbox"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/<ins>Sbox</ins><del>AESMixColumns</del></h3><p class="pseudocode"><ins>// Sbox()
// ======
// Used in SM4E crypto instruction

bits(8)</ins><del>bits(128)</del> <a id="impl-shared.Sbox.1" name="impl-shared.Sbox.1"></a><ins>Sbox(bits(8) sboxin)
    bits(8) sboxout;
    bits(2048) sboxstring = 0xd690e9fecce13db716b614c228fb2c052b679a762abe04c3aa441326498606999c4250f491ef987a33540b43edcfac62e4b31ca9c908e89580df94fa758f3fa64707a7fcf37317ba83593c19e6854fa8686b81b27164da8bf8eb0f4b70569d351e240e5e6358d1a225227c3b01217887d40046579fd327524c3602e7a0c4c89eeabf8ad240c738b5a3f7f2cef96115a1e0ae5da49b341a55ad933230f58cb1e31df6e22e8266ca60c02923ab0d534e6fd5db3745defd8e2f03ff6a726d6c5b518d1baf92bbddbc7f11d95c411f105ad80ac13188a5cd7bbd2d74d012b8e5b4b08969974a0c96777e65b9f109c56ec68418f07dec3adc4d2079ee5f3ed7cb3948&lt;2047:0>;

    sboxout = sboxstring&lt;(255-</ins><del>AESMixColumns(bits (128) op);</del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(sboxin))*8+7:(255-</ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(sboxin))*8>;
    return sboxout;</ins></p></div><div class="ps" psname="shared.functions.exclusive.ClearExclusiveByAddress"><a id="shared.functions.exclusive.ClearExclusiveByAddress" name="shared.functions.exclusive.ClearExclusiveByAddress"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>exclusive</ins><del>crypto</del>/<ins>ClearExclusiveByAddress</ins><del>AESShiftRows</del></h3><p class="pseudocode"><ins>// Clear the global Exclusives monitors for all PEs EXCEPT processorid if they
// record any part of the physical address region of size bytes starting at paddress.
// It is IMPLEMENTATION DEFINED whether the global Exclusives monitor for processorid
// is also cleared if it records any part of the address region.</ins><del>bits(128)</del>
<a id="impl-shared.ClearExclusiveByAddress.3" name="impl-shared.ClearExclusiveByAddress.3"></a><ins>ClearExclusiveByAddress(</ins><del>AESShiftRows(bits(128) op);</del><a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( bits(52) address, bit NS )"><ins>FullAddress</ins></a><ins> paddress, integer processorid, integer size);</ins></p></div><div class="ps" psname="shared.functions.exclusive.ClearExclusiveLocal"><a id="shared.functions.exclusive.ClearExclusiveLocal" name="shared.functions.exclusive.ClearExclusiveLocal"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>exclusive</ins><del>crypto</del>/<ins>ClearExclusiveLocal</ins><del>AESSubBytes</del></h3><p class="pseudocode"><ins>// Clear the local Exclusives monitor for the specified processorid.</ins><del>bits(128)</del>
<a id="impl-shared.ClearExclusiveLocal.1" name="impl-shared.ClearExclusiveLocal.1"></a><ins>ClearExclusiveLocal(integer processorid);</ins><del>AESSubBytes(bits(128) op);</del></p></div><div class="ps" psname="shared.functions.exclusive.ClearExclusiveMonitors"><a id="shared.functions.exclusive.ClearExclusiveMonitors" name="shared.functions.exclusive.ClearExclusiveMonitors"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>exclusive</ins><del>crypto</del>/<ins>ClearExclusiveMonitors</ins><del>HaveAESExt</del></h3><p class="pseudocode"><ins>// ClearExclusiveMonitors()
// ========================
</ins><del>// HaveAESExt()
// ============
// TRUE if AES cryptographic instructions support is implemented,
// FALSE otherwise.
</del>
<ins>// Clear the local Exclusives monitor for the executing PE.</ins><del>boolean</del>

<a id="impl-shared.ClearExclusiveMonitors.0" name="impl-shared.ClearExclusiveMonitors.0"></a><ins>ClearExclusiveMonitors()</ins><del>HaveAESExt()
    return boolean IMPLEMENTATION_DEFINED "Has AES Crypto instructions";</del>
    <a href="shared_pseudocode.html#impl-shared.ClearExclusiveLocal.1" title="function: ClearExclusiveLocal(integer processorid)"><ins>ClearExclusiveLocal</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><ins>ProcessorID</ins></a><ins>());</ins></p></div><div class="ps" psname="shared.functions.exclusive.ExclusiveMonitorsStatus"><a id="shared.functions.exclusive.ExclusiveMonitorsStatus" name="shared.functions.exclusive.ExclusiveMonitorsStatus"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>exclusive</ins><del>crypto</del>/<ins>ExclusiveMonitorsStatus</ins><del>HaveBit128PMULLExt</del></h3><p class="pseudocode"><ins>// Returns '0' to indicate success if the last memory write by this PE was to
// the same physical address region endorsed by ExclusiveMonitorsPass().
// Returns '1' to indicate failure if address translation resulted in a different
// physical address.
bit</ins><del>// HaveBit128PMULLExt()
// ====================
// TRUE if 128 bit form of PMULL instructions support is implemented,
// FALSE otherwise.

boolean</del> <a id="impl-shared.ExclusiveMonitorsStatus.0" name="impl-shared.ExclusiveMonitorsStatus.0"></a><ins>ExclusiveMonitorsStatus();</ins><del>HaveBit128PMULLExt()
    return boolean IMPLEMENTATION_DEFINED "Has 128-bit form of PMULL instructions";</del></p></div><div class="ps" psname="shared.functions.exclusive.IsExclusiveGlobal"><a id="shared.functions.exclusive.IsExclusiveGlobal" name="shared.functions.exclusive.IsExclusiveGlobal"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>exclusive</ins><del>crypto</del>/<ins>IsExclusiveGlobal</ins><del>HaveSHA1Ext</del></h3><p class="pseudocode"><ins>// Return TRUE if the global Exclusives monitor for processorid includes all of
// the physical address region of size bytes starting at paddress.
</ins><del>// HaveSHA1Ext()
// =============
// TRUE if SHA1 cryptographic instructions support is implemented,
// FALSE otherwise.

</del>boolean <a id="impl-shared.IsExclusiveGlobal.3" name="impl-shared.IsExclusiveGlobal.3"></a><ins>IsExclusiveGlobal(</ins><del>HaveSHA1Ext()
    return boolean IMPLEMENTATION_DEFINED "Has SHA1 Crypto instructions";</del><a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( bits(52) address, bit NS )"><ins>FullAddress</ins></a><ins> paddress, integer processorid, integer size);</ins></p></div><div class="ps" psname="shared.functions.exclusive.IsExclusiveLocal"><a id="shared.functions.exclusive.IsExclusiveLocal" name="shared.functions.exclusive.IsExclusiveLocal"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>exclusive</ins><del>crypto</del>/<ins>IsExclusiveLocal</ins><del>HaveSHA256Ext</del></h3><p class="pseudocode"><ins>// Return TRUE if the local Exclusives monitor for processorid includes all of
// the physical address region of size bytes starting at paddress.
</ins><del>// HaveSHA256Ext()
// ===============
// TRUE if SHA256 cryptographic instructions support is implemented,
// FALSE otherwise.

</del>boolean <a id="impl-shared.IsExclusiveLocal.3" name="impl-shared.IsExclusiveLocal.3"></a><ins>IsExclusiveLocal(</ins><del>HaveSHA256Ext()
    return boolean IMPLEMENTATION_DEFINED "Has SHA256 Crypto instructions";</del><a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( bits(52) address, bit NS )"><ins>FullAddress</ins></a><ins> paddress, integer processorid, integer size);</ins></p></div><div class="ps" psname="shared.functions.exclusive.MarkExclusiveGlobal"><a id="shared.functions.exclusive.MarkExclusiveGlobal" name="shared.functions.exclusive.MarkExclusiveGlobal"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>exclusive</ins><del>crypto</del>/<ins>MarkExclusiveGlobal</ins><del>HaveSHA3Ext</del></h3><p class="pseudocode"><ins>// Record the physical address region of size bytes starting at paddress in
// the global Exclusives monitor for processorid.</ins><del>// HaveSHA3Ext()
// =============
// TRUE if SHA3 cryptographic instructions support is implemented,
// and when SHA1 and SHA2 basic cryptographic instructions support is implemented,
// FALSE otherwise.

boolean</del>
<a id="impl-shared.MarkExclusiveGlobal.3" name="impl-shared.MarkExclusiveGlobal.3"></a><ins>MarkExclusiveGlobal(</ins><del>HaveSHA3Ext()
    if !</del><del>(</del><a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p2</del></a><del>) || !(</del><a href="shared_pseudocode.html#impl-shared.HaveSHA1Ext.0" title="function: boolean HaveSHA1Ext()"><del>HaveSHA1Ext</del></a><del>() &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.HaveSHA256Ext.0" title="function: boolean HaveSHA256Ext()"><del>HaveSHA256Ext</del></a><a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( bits(52) address, bit NS )"><ins>FullAddress</ins></a><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><del>HasArchVersion</del></a> <ins>paddress, integer processorid, integer size);</ins><del>()) then
        return FALSE;
    return boolean IMPLEMENTATION_DEFINED "Has SHA3 Crypto instructions";</del></p></div><div class="ps" psname="shared.functions.exclusive.MarkExclusiveLocal"><a id="shared.functions.exclusive.MarkExclusiveLocal" name="shared.functions.exclusive.MarkExclusiveLocal"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>exclusive</ins><del>crypto</del>/<ins>MarkExclusiveLocal</ins><del>HaveSHA512Ext</del></h3><p class="pseudocode"><ins>// Record the physical address region of size bytes starting at paddress in
// the local Exclusives monitor for processorid.</ins><del>// HaveSHA512Ext()
// ===============
// TRUE if SHA512 cryptographic instructions support is implemented,
// and when SHA1 and SHA2 basic cryptographic instructions support is implemented,
// FALSE otherwise.

boolean</del>
<a id="impl-shared.MarkExclusiveLocal.3" name="impl-shared.MarkExclusiveLocal.3"></a><ins>MarkExclusiveLocal(</ins><del>HaveSHA512Ext()
    if !</del><del>(</del><a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p2</del></a><del>) || !(</del><a href="shared_pseudocode.html#impl-shared.HaveSHA1Ext.0" title="function: boolean HaveSHA1Ext()"><del>HaveSHA1Ext</del></a><del>() &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.HaveSHA256Ext.0" title="function: boolean HaveSHA256Ext()"><del>HaveSHA256Ext</del></a><a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( bits(52) address, bit NS )"><ins>FullAddress</ins></a><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><del>HasArchVersion</del></a> <ins>paddress, integer processorid, integer size);</ins><del>()) then
        return FALSE;
    return boolean IMPLEMENTATION_DEFINED "Has SHA512 Crypto instructions";</del></p></div><div class="ps" psname="shared.functions.exclusive.ProcessorID"><a id="shared.functions.exclusive.ProcessorID" name="shared.functions.exclusive.ProcessorID"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>exclusive</ins><del>crypto</del>/<ins>ProcessorID</ins><del>HaveSM3Ext</del></h3><p class="pseudocode"><ins>// Return the ID of the currently executing PE.
integer</ins><del>// HaveSM3Ext()
// ============
// TRUE if SM3 cryptographic instructions support is implemented,
// FALSE otherwise.

boolean</del> <a id="impl-shared.ProcessorID.0" name="impl-shared.ProcessorID.0"></a><ins>ProcessorID();</ins><del>HaveSM3Ext()
    if !</del><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><del>HasArchVersion</del></a><del>(</del><a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p2</del></a><del>) then
        return FALSE;
    return boolean IMPLEMENTATION_DEFINED "Has SM3 Crypto instructions";</del></p></div><div class="ps" psname="shared.functions.extension.AArch32.HaveHPDExt"><a id="shared.functions.extension.AArch32.HaveHPDExt" name="shared.functions.extension.AArch32.HaveHPDExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>extension</ins><del>crypto</del>/<ins>AArch32.HaveHPDExt</ins><del>HaveSM4Ext</del></h3><p class="pseudocode"><ins>// AArch32.HaveHPDExt()
// ====================
</ins><del>// HaveSM4Ext()
// ============
// TRUE if SM4 cryptographic instructions support is implemented,
// FALSE otherwise.
</del>
boolean <a id="AArch32.HaveHPDExt.0" name="AArch32.HaveHPDExt.0"></a><ins>AArch32.HaveHPDExt()
    return</ins><del>HaveSM4Ext()
    if !</del> <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }">ARMv8p2</a><ins>);</ins><del>) then
        return FALSE;
    return boolean IMPLEMENTATION_DEFINED "Has SM4 Crypto instructions";</del></p></div><div class="ps" psname="shared.functions.extension.AArch64.HaveHPDExt"><a id="shared.functions.extension.AArch64.HaveHPDExt" name="shared.functions.extension.AArch64.HaveHPDExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>extension</ins><del>crypto</del>/<ins>AArch64.HaveHPDExt</ins><del>ROL</del></h3><p class="pseudocode"><ins>// AArch64.HaveHPDExt()
// ====================
</ins><del>// ROL()
// =====
</del>
<ins>boolean</ins><del>bits(N)</del> <a id="AArch64.HaveHPDExt.0" name="AArch64.HaveHPDExt.0"></a><ins>AArch64.HaveHPDExt()
</ins><del>ROL(bits(N) x, integer shift)
    assert shift >= 0 &amp;&amp; shift &lt;= N;
    if (shift == 0) then
        return x;
</del>    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><ins>HasArchVersion</ins></a><a href="shared_pseudocode.html#impl-shared.ROR.2" title="function: bits(N) ROR(bits(N) x, integer shift)"><del>ROR</del></a><ins>(</ins><a href="shared_pseudocode.html#ARMv8p1" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p1</ins></a><ins>);</ins><del>(x, N-shift);</del></p></div><div class="ps" psname="shared.functions.extension.Have52BitPAExt"><a id="shared.functions.extension.Have52BitPAExt" name="shared.functions.extension.Have52BitPAExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>extension</ins><del>crypto</del>/<ins>Have52BitPAExt</ins><del>SHA256hash</del></h3><p class="pseudocode"><ins>// Have52BitPAExt()
// ================
</ins><del>// SHA256hash()
// ============
</del>
<ins>boolean</ins><del>bits(128)</del> <a id="impl-shared.Have52BitPAExt.0" name="impl-shared.Have52BitPAExt.0"></a><ins>Have52BitPAExt()
    return</ins><del>SHA256hash(bits (128) X, bits(128) Y, bits(128) W, boolean part1)
    bits(32) chs, maj, t;

    for e = 0 to 3
        chs =</del> <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><ins>HasArchVersion</ins></a><a href="shared_pseudocode.html#impl-shared.SHAchoose.3" title="function: bits(32) SHAchoose(bits(32) x, bits(32) y, bits(32) z)"><del>SHAchoose</del></a><ins>(</ins><del>(Y&lt;31:0>, Y&lt;63:32>, Y&lt;95:64>);
        maj =</del><del>(X&lt;31:0>, X&lt;63:32>, X&lt;95:64>);
        t = Y&lt;127:96> + </del><a href="shared_pseudocode.html#impl-shared.SHAhashSIGMA1.1" title="function: bits(32) SHAhashSIGMA1(bits(32) x)"><del>SHAhashSIGMA1</del></a><del>(Y&lt;31:0>) + chs + </del><a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]"><del>Elem</del></a><del>[W, e, 32];
        X&lt;127:96> = t + X&lt;127:96>;
        Y&lt;127:96> = t + </del><a href="shared_pseudocode.html#impl-shared.SHAhashSIGMA0.1" title="function: bits(32) SHAhashSIGMA0(bits(32) x)"><del>SHAhashSIGMA0</del></a><del>(X&lt;31:0>) + maj;
        &lt;Y, X> = </del><a href="shared_pseudocode.html#impl-shared.ROL.2" title="function: bits(N) ROL(bits(N) x, integer shift)"><del>ROL</del></a><a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p2</ins></a><a href="shared_pseudocode.html#impl-shared.SHAmajority.3" title="function: bits(32) SHAmajority(bits(32) x, bits(32) y, bits(32) z)"><del>SHAmajority</del></a><ins>);</ins><del>(Y : X, 32);
    return (if part1 then X else Y);</del></p></div><div class="ps" psname="shared.functions.extension.Have52BitVAExt"><a id="shared.functions.extension.Have52BitVAExt" name="shared.functions.extension.Have52BitVAExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>extension</ins><del>crypto</del>/<ins>Have52BitVAExt</ins><del>SHAchoose</del></h3><p class="pseudocode"><ins>// Have52BitVAExt()
// ================
</ins><del>// SHAchoose()
// ===========
</del>
<ins>boolean</ins><del>bits(32)</del> <a id="impl-shared.Have52BitVAExt.0" name="impl-shared.Have52BitVAExt.0"></a><ins>Have52BitVAExt()
    return</ins><del>SHAchoose(bits(32) x, bits(32) y, bits(32) z)
    return (((y EOR z) AND x) EOR z);</del> <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><ins>HasArchVersion</ins></a><ins>(</ins><a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p2</ins></a><ins>);</ins></p></div><div class="ps" psname="shared.functions.extension.HaveAtomicExt"><a id="shared.functions.extension.HaveAtomicExt" name="shared.functions.extension.HaveAtomicExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>extension</ins><del>crypto</del>/<ins>HaveAtomicExt</ins><del>SHAhashSIGMA0</del></h3><p class="pseudocode"><ins>// HaveAtomicExt()
</ins><del>// SHAhashSIGMA0()
</del>// ===============

<ins>boolean</ins><del>bits(32)</del> <a id="impl-shared.HaveAtomicExt.0" name="impl-shared.HaveAtomicExt.0"></a><ins>HaveAtomicExt()
</ins><del>SHAhashSIGMA0(bits(32) x)
</del>    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><ins>HasArchVersion</ins></a><a href="shared_pseudocode.html#impl-shared.ROR.2" title="function: bits(N) ROR(bits(N) x, integer shift)"><del>ROR</del></a><ins>(</ins><del>(x, 2) EOR</del><del>(x, 13) EOR </del><a href="shared_pseudocode.html#impl-shared.ROR.2" title="function: bits(N) ROR(bits(N) x, integer shift)"><del>ROR</del></a><a href="shared_pseudocode.html#ARMv8p1" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p1</ins></a><a href="shared_pseudocode.html#impl-shared.ROR.2" title="function: bits(N) ROR(bits(N) x, integer shift)"><del>ROR</del></a><ins>);</ins><del>(x, 22);</del></p></div><div class="ps" psname="shared.functions.extension.HaveBTIExt"><a id="shared.functions.extension.HaveBTIExt" name="shared.functions.extension.HaveBTIExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>extension</ins><del>crypto</del>/<ins>HaveBTIExt</ins><del>SHAhashSIGMA1</del></h3><p class="pseudocode"><ins>// HaveBTIExt()
// ============
// Returns TRUE if BTI implemented and FALSE otherwise
</ins><del>// SHAhashSIGMA1()
// ===============
</del>
<ins>boolean</ins><del>bits(32)</del> <a id="impl-shared.HaveBTIExt.0" name="impl-shared.HaveBTIExt.0"></a><ins>HaveBTIExt()
</ins><del>SHAhashSIGMA1(bits(32) x)
</del>    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><ins>HasArchVersion</ins></a><a href="shared_pseudocode.html#impl-shared.ROR.2" title="function: bits(N) ROR(bits(N) x, integer shift)"><del>ROR</del></a><ins>(</ins><del>(x, 6) EOR</del><del>(x, 11) EOR </del><a href="shared_pseudocode.html#impl-shared.ROR.2" title="function: bits(N) ROR(bits(N) x, integer shift)"><del>ROR</del></a><a href="shared_pseudocode.html#ARMv8p5" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p5</ins></a><a href="shared_pseudocode.html#impl-shared.ROR.2" title="function: bits(N) ROR(bits(N) x, integer shift)"><del>ROR</del></a><ins>);</ins><del>(x, 25);</del></p></div><div class="ps" psname="shared.functions.extension.HaveBlockBBM"><a id="shared.functions.extension.HaveBlockBBM" name="shared.functions.extension.HaveBlockBBM"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>extension</ins><del>crypto</del>/<ins>HaveBlockBBM</ins><del>SHAmajority</del></h3><p class="pseudocode"><ins>// HaveBlockBBM()
// ==============
// Returns TRUE if support for changing block size without requring break-before-make is implemented.
</ins><del>// SHAmajority()
// =============
</del>
<ins>boolean</ins><del>bits(32)</del> <a id="impl-shared.HaveBlockBBM.0" name="impl-shared.HaveBlockBBM.0"></a><ins>HaveBlockBBM()
    return</ins><del>SHAmajority(bits(32) x, bits(32) y, bits(32) z)
    return ((x AND y) OR ((x OR y) AND z));</del> <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><ins>HasArchVersion</ins></a><ins>(</ins><a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p4</ins></a><ins>);</ins></p></div><div class="ps" psname="shared.functions.extension.HaveCommonNotPrivateTransExt"><a id="shared.functions.extension.HaveCommonNotPrivateTransExt" name="shared.functions.extension.HaveCommonNotPrivateTransExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>extension</ins><del>crypto</del>/<ins>HaveCommonNotPrivateTransExt</ins><del>SHAparity</del></h3><p class="pseudocode"><ins>// HaveCommonNotPrivateTransExt()
// ==============================
</ins><del>// SHAparity()
// ===========
</del>
<ins>boolean</ins><del>bits(32)</del> <a id="impl-shared.HaveCommonNotPrivateTransExt.0" name="impl-shared.HaveCommonNotPrivateTransExt.0"></a><ins>HaveCommonNotPrivateTransExt()
    return</ins><del>SHAparity(bits(32) x, bits(32) y, bits(32) z)
    return (x EOR y EOR z);</del> <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><ins>HasArchVersion</ins></a><ins>(</ins><a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p2</ins></a><ins>);</ins></p></div><div class="ps" psname="shared.functions.extension.HaveDITExt"><a id="shared.functions.extension.HaveDITExt" name="shared.functions.extension.HaveDITExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>extension</ins><del>crypto</del>/<ins>HaveDITExt</ins><del>Sbox</del></h3><p class="pseudocode"><ins>// HaveDITExt()
// ============
</ins><del>// Sbox()
// ======
// Used in SM4E crypto instruction
</del>
<ins>boolean</ins><del>bits(8)</del> <a id="impl-shared.HaveDITExt.0" name="impl-shared.HaveDITExt.0"></a><ins>HaveDITExt()
    return</ins><del>Sbox(bits(8) sboxin)
    bits(8) sboxout;
    bits(2048) sboxstring = 0xd690e9fecce13db716b614c228fb2c052b679a762abe04c3aa441326498606999c4250f491ef987a33540b43edcfac62e4b31ca9c908e89580df94fa758f3fa64707a7fcf37317ba83593c19e6854fa8686b81b27164da8bf8eb0f4b70569d351e240e5e6358d1a225227c3b01217887d40046579fd327524c3602e7a0c4c89eeabf8ad240c738b5a3f7f2cef96115a1e0ae5da49b341a55ad933230f58cb1e31df6e22e8266ca60c02923ab0d534e6fd5db3745defd8e2f03ff6a726d6c5b518d1baf92bbddbc7f11d95c411f105ad80ac13188a5cd7bbd2d74d012b8e5b4b08969974a0c96777e65b9f109c56ec68418f07dec3adc4d2079ee5f3ed7cb3948&lt;2047:0>;

    sboxout = sboxstring&lt;(255-</del> <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><ins>HasArchVersion</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>(</ins><del>(sboxin))*8+7:(255-</del><a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p4</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>);</ins><del>(sboxin))*8>;
    return sboxout;</del></p></div><div class="ps" psname="shared.functions.extension.HaveDOTPExt"><a id="shared.functions.extension.HaveDOTPExt" name="shared.functions.extension.HaveDOTPExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>extension</ins><del>exclusive</del>/<ins>HaveDOTPExt</ins><del>ClearExclusiveByAddress</del></h3><p class="pseudocode"><ins>// HaveDOTPExt()
// =============
// Returns TRUE if has Dot Product feature support, and FALSE otherwise.

boolean</ins><del>// Clear the global Exclusives monitors for all PEs EXCEPT processorid if they
// record any part of the physical address region of size bytes starting at paddress.
// It is IMPLEMENTATION DEFINED whether the global Exclusives monitor for processorid
// is also cleared if it records any part of the address region.</del> <a id="impl-shared.HaveDOTPExt.0" name="impl-shared.HaveDOTPExt.0"></a><ins>HaveDOTPExt()
    return</ins><del>ClearExclusiveByAddress(</del> <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><ins>HasArchVersion</ins></a><a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( bits(52) address, bit NS )"><del>FullAddress</del></a><ins>(</ins><a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p4</ins></a><ins>) || (</ins><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><ins>HasArchVersion</ins></a><ins>(</ins><a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p2</ins></a><ins>) &amp;&amp; boolean IMPLEMENTATION_DEFINED "Has Dot Product extension");</ins><del>paddress, integer processorid, integer size);</del></p></div><div class="ps" psname="shared.functions.extension.HaveDoubleFaultExt"><a id="shared.functions.extension.HaveDoubleFaultExt" name="shared.functions.extension.HaveDoubleFaultExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>extension</ins><del>exclusive</del>/<ins>HaveDoubleFaultExt</ins><del>ClearExclusiveLocal</del></h3><p class="pseudocode"><ins>// HaveDoubleFaultExt()
// ====================

boolean</ins><del>// Clear the local Exclusives monitor for the specified processorid.</del> <a id="impl-shared.HaveDoubleFaultExt.0" name="impl-shared.HaveDoubleFaultExt.0"></a><ins>HaveDoubleFaultExt()
    return (</ins><del>ClearExclusiveLocal(integer processorid);</del><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><ins>HasArchVersion</ins></a><ins>(</ins><a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p4</ins></a><ins>) &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.HaveIESB.0" title="function: boolean HaveIESB()"><ins>HaveIESB</ins></a><ins>());</ins></p></div><div class="ps" psname="shared.functions.extension.HaveDoubleLock"><a id="shared.functions.extension.HaveDoubleLock" name="shared.functions.extension.HaveDoubleLock"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>extension</ins><del>exclusive</del>/<ins>HaveDoubleLock</ins><del>ClearExclusiveMonitors</del></h3><p class="pseudocode"><ins>// HaveDoubleLock()
// ================
// Returns TRUE if support for the OS Double Lock is implemented
</ins><del>// ClearExclusiveMonitors()
// ========================
</del>
<ins>boolean</ins><del>// Clear the local Exclusives monitor for the executing PE.</del> <a id="impl-shared.HaveDoubleLock.0" name="impl-shared.HaveDoubleLock.0"></a><ins>HaveDoubleLock()
    return !</ins><del>ClearExclusiveMonitors()</del><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><ins>HasArchVersion</ins></a><a href="shared_pseudocode.html#impl-shared.ClearExclusiveLocal.1" title="function: ClearExclusiveLocal(integer processorid)"><del>ClearExclusiveLocal</del></a>(<a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p4</ins></a><a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()"><del>ProcessorID</del></a><ins>) || boolean IMPLEMENTATION_DEFINED "OS Double Lock is implemented";</ins><del>());</del></p></div><div class="ps" psname="shared.functions.extension.HaveE0PDExt"><a id="shared.functions.extension.HaveE0PDExt" name="shared.functions.extension.HaveE0PDExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>extension</ins><del>exclusive</del>/<ins>HaveE0PDExt</ins><del>ExclusiveMonitorsStatus</del></h3><p class="pseudocode"><ins>// HaveE0PDExt()
// =============
// Returns TRUE if support for constant fault times for unprivileged accesses
// to the memory map is implemented.

boolean</ins><del>// Returns '0' to indicate success if the last memory write by this PE was to
// the same physical address region endorsed by ExclusiveMonitorsPass().
// Returns '1' to indicate failure if address translation resulted in a different
// physical address.
bit</del> <a id="impl-shared.HaveE0PDExt.0" name="impl-shared.HaveE0PDExt.0"></a><ins>HaveE0PDExt()
    return</ins><del>ExclusiveMonitorsStatus();</del> <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><ins>HasArchVersion</ins></a><ins>(</ins><a href="shared_pseudocode.html#ARMv8p5" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p5</ins></a><ins>);</ins></p></div><div class="ps" psname="shared.functions.extension.HaveExtendedCacheSets"><a id="shared.functions.extension.HaveExtendedCacheSets" name="shared.functions.extension.HaveExtendedCacheSets"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>extension</ins><del>exclusive</del>/<ins>HaveExtendedCacheSets</ins><del>IsExclusiveGlobal</del></h3><p class="pseudocode"><ins>// HaveExtendedCacheSets()
// =======================

</ins><del>// Return TRUE if the global Exclusives monitor for processorid includes all of
// the physical address region of size bytes starting at paddress.
</del>boolean <a id="impl-shared.HaveExtendedCacheSets.0" name="impl-shared.HaveExtendedCacheSets.0"></a><ins>HaveExtendedCacheSets()
    return</ins><del>IsExclusiveGlobal(</del> <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><ins>HasArchVersion</ins></a><a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( bits(52) address, bit NS )"><del>FullAddress</del></a><ins>(</ins><a href="shared_pseudocode.html#ARMv8p3" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p3</ins></a><ins>);</ins><del>paddress, integer processorid, integer size);</del></p></div><div class="ps" psname="shared.functions.extension.HaveExtendedECDebugEvents"><a id="shared.functions.extension.HaveExtendedECDebugEvents" name="shared.functions.extension.HaveExtendedECDebugEvents"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>extension</ins><del>exclusive</del>/<ins>HaveExtendedECDebugEvents</ins><del>IsExclusiveLocal</del></h3><p class="pseudocode"><ins>// HaveExtendedECDebugEvents()
// ===========================

</ins><del>// Return TRUE if the local Exclusives monitor for processorid includes all of
// the physical address region of size bytes starting at paddress.
</del>boolean <a id="impl-shared.HaveExtendedECDebugEvents.0" name="impl-shared.HaveExtendedECDebugEvents.0"></a><ins>HaveExtendedECDebugEvents()
    return</ins><del>IsExclusiveLocal(</del> <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><ins>HasArchVersion</ins></a><a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( bits(52) address, bit NS )"><del>FullAddress</del></a><ins>(</ins><a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p2</ins></a><ins>);</ins><del>paddress, integer processorid, integer size);</del></p></div><div class="ps" psname="shared.functions.extension.HaveExtendedExecuteNeverExt"><a id="shared.functions.extension.HaveExtendedExecuteNeverExt" name="shared.functions.extension.HaveExtendedExecuteNeverExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>extension</ins><del>exclusive</del>/<ins>HaveExtendedExecuteNeverExt</ins><del>MarkExclusiveGlobal</del></h3><p class="pseudocode"><ins>// HaveExtendedExecuteNeverExt()
// =============================

boolean</ins><del>// Record the physical address region of size bytes starting at paddress in
// the global Exclusives monitor for processorid.</del> <a id="impl-shared.HaveExtendedExecuteNeverExt.0" name="impl-shared.HaveExtendedExecuteNeverExt.0"></a><ins>HaveExtendedExecuteNeverExt()
    return</ins><del>MarkExclusiveGlobal(</del> <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><ins>HasArchVersion</ins></a><a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( bits(52) address, bit NS )"><del>FullAddress</del></a><ins>(</ins><a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p2</ins></a><ins>);</ins><del>paddress, integer processorid, integer size);</del></p></div><div class="ps" psname="shared.functions.extension.HaveFCADDExt"><a id="shared.functions.extension.HaveFCADDExt" name="shared.functions.extension.HaveFCADDExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>extension</ins><del>exclusive</del>/<ins>HaveFCADDExt</ins><del>MarkExclusiveLocal</del></h3><p class="pseudocode"><ins>// HaveFCADDExt()
// ==============

boolean</ins><del>// Record the physical address region of size bytes starting at paddress in
// the local Exclusives monitor for processorid.</del> <a id="impl-shared.HaveFCADDExt.0" name="impl-shared.HaveFCADDExt.0"></a><ins>HaveFCADDExt()
    return</ins><del>MarkExclusiveLocal(</del> <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><ins>HasArchVersion</ins></a><a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( bits(52) address, bit NS )"><del>FullAddress</del></a><ins>(</ins><a href="shared_pseudocode.html#ARMv8p3" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p3</ins></a><ins>);</ins><del>paddress, integer processorid, integer size);</del></p></div><div class="ps" psname="shared.functions.extension.HaveFJCVTZSExt"><a id="shared.functions.extension.HaveFJCVTZSExt" name="shared.functions.extension.HaveFJCVTZSExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>extension</ins><del>exclusive</del>/<ins>HaveFJCVTZSExt</ins><del>ProcessorID</del></h3><p class="pseudocode"><ins>// HaveFJCVTZSExt()
// ================

boolean</ins><del>// Return the ID of the currently executing PE.
integer</del> <a id="impl-shared.HaveFJCVTZSExt.0" name="impl-shared.HaveFJCVTZSExt.0"></a><ins>HaveFJCVTZSExt()
    return</ins><del>ProcessorID();</del> <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><ins>HasArchVersion</ins></a><ins>(</ins><a href="shared_pseudocode.html#ARMv8p3" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p3</ins></a><ins>);</ins></p></div><div class="ps" psname="shared.functions.extension.HaveFP16MulNoRoundingToFP32Ext"><a id="shared.functions.extension.HaveFP16MulNoRoundingToFP32Ext" name="shared.functions.extension.HaveFP16MulNoRoundingToFP32Ext"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/<ins>HaveFP16MulNoRoundingToFP32Ext</ins><del>AArch32.HaveHPDExt</del></h3><p class="pseudocode"><ins>// HaveFP16MulNoRoundingToFP32Ext()
// ================================
// Returns TRUE if has FP16 multiply with no intermediate rounding accumulate to FP32 instructions,
// and FALSE otherwise
</ins><del>// AArch32.HaveHPDExt()
// ====================
</del>
boolean <a id="impl-shared.HaveFP16MulNoRoundingToFP32Ext.0" name="impl-shared.HaveFP16MulNoRoundingToFP32Ext.0"></a><ins>HaveFP16MulNoRoundingToFP32Ext()

    if !</ins><del>AArch32.HaveHPDExt()
    return</del><a href="shared_pseudocode.html#impl-shared.HaveFP16Ext.0" title="function: boolean HaveFP16Ext()"><ins>HaveFP16Ext</ins></a><ins>() then return FALSE;
    if </ins><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><ins>HasArchVersion</ins></a><ins>(</ins><a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p4</ins></a><ins>) then return TRUE;
    return (</ins><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }">ARMv8p2</a><ins>) &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has accumulate FP16 product into FP32 extension");</ins><del>);</del></p></div><div class="ps" psname="shared.functions.extension.HaveFlagFormatExt"><a id="shared.functions.extension.HaveFlagFormatExt" name="shared.functions.extension.HaveFlagFormatExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/<ins>HaveFlagFormatExt</ins><del>AArch64.HaveHPDExt</del></h3><p class="pseudocode"><ins>// HaveFlagFormatExt()
// ===================
// Returns TRUE if flag format conversion instructions implemented
// and FALSE otherwise
</ins><del>// AArch64.HaveHPDExt()
// ====================
</del>
boolean <a id="impl-shared.HaveFlagFormatExt.0" name="impl-shared.HaveFlagFormatExt.0"></a><ins>HaveFlagFormatExt()
</ins><del>AArch64.HaveHPDExt()
</del>    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p5" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p5</ins></a><a href="shared_pseudocode.html#ARMv8p1" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p1</del></a>);</p></div><div class="ps" psname="shared.functions.extension.HaveFlagManipulateExt"><a id="shared.functions.extension.HaveFlagManipulateExt" name="shared.functions.extension.HaveFlagManipulateExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/<ins>HaveFlagManipulateExt</ins><del>Have52BitPAExt</del></h3><p class="pseudocode"><ins>// HaveFlagManipulateExt()
// =======================
// Returns TRUE if has flag manipulate instructions, and FALSE otherwise
</ins><del>// Have52BitPAExt()
// ================
</del>
boolean <a id="impl-shared.HaveFlagManipulateExt.0" name="impl-shared.HaveFlagManipulateExt.0"></a><ins>HaveFlagManipulateExt()
</ins><del>Have52BitPAExt()
</del>    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p4</ins></a><a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p2</del></a>);</p></div><div class="ps" psname="shared.functions.extension.HaveFrintExt"><a id="shared.functions.extension.HaveFrintExt" name="shared.functions.extension.HaveFrintExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/<ins>HaveFrintExt</ins><del>Have52BitVAExt</del></h3><p class="pseudocode"><ins>// HaveFrintExt()
// ==============
// Returns TRUE if FRINT instructions are implemented and FALSE otherwise
</ins><del>// Have52BitVAExt()
// ================
</del>
boolean <a id="impl-shared.HaveFrintExt.0" name="impl-shared.HaveFrintExt.0"></a><ins>HaveFrintExt()
</ins><del>Have52BitVAExt()
</del>    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p5" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p5</ins></a><a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p2</del></a>);</p></div><div class="ps" psname="shared.functions.extension.HaveHPMDExt"><a id="shared.functions.extension.HaveHPMDExt" name="shared.functions.extension.HaveHPMDExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/<ins>HaveHPMDExt</ins><del>HaveAtomicExt</del></h3><p class="pseudocode"><ins>// HaveHPMDExt()
// =============
</ins><del>// HaveAtomicExt()
// ===============
</del>
boolean <a id="impl-shared.HaveHPMDExt.0" name="impl-shared.HaveHPMDExt.0"></a><ins>HaveHPMDExt()
</ins><del>HaveAtomicExt()
</del>    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p1" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }">ARMv8p1</a>);</p></div><div class="ps" psname="shared.functions.extension.HaveIESB"><a id="shared.functions.extension.HaveIESB" name="shared.functions.extension.HaveIESB"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/<ins>HaveIESB</ins><del>HaveBTIExt</del></h3><p class="pseudocode"><ins>// HaveIESB()
// ==========
</ins><del>// HaveBTIExt()
// ============
// Returns TRUE if BTI implemented and FALSE otherwise
</del>
boolean <a id="impl-shared.HaveIESB.0" name="impl-shared.HaveIESB.0"></a><ins>HaveIESB()
    return (</ins><del>HaveBTIExt()
    return</del><del>(</del><a href="shared_pseudocode.html#ARMv8p5" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p5</del></a><a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()"><ins>HaveRASExt</ins></a><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><del>HasArchVersion</del></a><ins>() &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has Implicit Error Synchronization Barrier");</ins><del>);</del></p></div><div class="ps" psname="shared.functions.extension.HaveMPAMExt"><a id="shared.functions.extension.HaveMPAMExt" name="shared.functions.extension.HaveMPAMExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/<ins>HaveMPAMExt</ins><del>HaveBlockBBM</del></h3><p class="pseudocode"><ins>// HaveMPAMExt()
// =============
// Returns TRUE if MPAM implemented and FALSE otherwise.
</ins><del>// HaveBlockBBM()
// ==============
// Returns TRUE if support for changing block size without requring break-before-make is implemented.
</del>
boolean <a id="impl-shared.HaveMPAMExt.0" name="impl-shared.HaveMPAMExt.0"></a><ins>HaveMPAMExt()
    return (</ins><del>HaveBlockBBM()
    return</del><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p2</ins></a><a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p4</del></a><ins>) &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has MPAM extension");</ins><del>);</del></p></div><div class="ps" psname="shared.functions.extension.HaveMTEExt"><a id="shared.functions.extension.HaveMTEExt" name="shared.functions.extension.HaveMTEExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/<ins>HaveMTEExt</ins><del>HaveCommonNotPrivateTransExt</del></h3><p class="pseudocode"><ins>// HaveMTEExt()
// ============
// Returns TRUE if MTE implemented and FALSE otherwise.
</ins><del>// HaveCommonNotPrivateTransExt()
// ==============================
</del>
boolean <a id="impl-shared.HaveMTEExt.0" name="impl-shared.HaveMTEExt.0"></a><ins>HaveMTEExt()
    if !</ins><del>HaveCommonNotPrivateTransExt()
    return</del><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p5" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p5</ins></a><a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p2</del></a><ins>) then
        return FALSE;
    return boolean IMPLEMENTATION_DEFINED "Has MTE extension";</ins><del>);</del></p></div><div class="ps" psname="shared.functions.extension.HaveNV2Ext"><a id="shared.functions.extension.HaveNV2Ext" name="shared.functions.extension.HaveNV2Ext"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/<ins>HaveNV2Ext</ins><del>HaveDITExt</del></h3><p class="pseudocode"><ins>// HaveNV2Ext()
</ins><del>// HaveDITExt()
</del>// ============

boolean <a id="impl-shared.HaveNV2Ext.0" name="impl-shared.HaveNV2Ext.0"></a><ins>HaveNV2Ext()
</ins><del>HaveDITExt()
</del>    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }">ARMv8p4</a>);</p></div><div class="ps" psname="shared.functions.extension.HaveNVExt"><a id="shared.functions.extension.HaveNVExt" name="shared.functions.extension.HaveNVExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/<ins>HaveNVExt</ins><del>HaveDOTPExt</del></h3><p class="pseudocode"><ins>// HaveNVExt()
// ===========
</ins><del>// HaveDOTPExt()
// =============
// Returns TRUE if has Dot Product feature support, and FALSE otherwise.
</del>
boolean <a id="impl-shared.HaveNVExt.0" name="impl-shared.HaveNVExt.0"></a><ins>HaveNVExt()
</ins><del>HaveDOTPExt()
</del>    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<del>) || (</del><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><del>HasArchVersion</del></a><del>(</del><a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p2</del></a><a href="shared_pseudocode.html#ARMv8p3" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p3</ins></a><a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p4</del></a><ins>);</ins><del>) &amp;&amp; boolean IMPLEMENTATION_DEFINED "Has Dot Product extension");</del></p></div><div class="ps" psname="shared.functions.extension.HaveNoSecurePMUDisableOverride"><a id="shared.functions.extension.HaveNoSecurePMUDisableOverride" name="shared.functions.extension.HaveNoSecurePMUDisableOverride"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/<ins>HaveNoSecurePMUDisableOverride</ins><del>HaveDoubleFaultExt</del></h3><p class="pseudocode"><ins>// HaveNoSecurePMUDisableOverride()
// ================================
</ins><del>// HaveDoubleFaultExt()
// ====================
</del>
boolean <a id="impl-shared.HaveNoSecurePMUDisableOverride.0" name="impl-shared.HaveNoSecurePMUDisableOverride.0"></a><ins>HaveNoSecurePMUDisableOverride()
    return</ins><del>HaveDoubleFaultExt()
    return (</del> <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<del>) &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.HaveIESB.0" title="function: boolean HaveIESB()"><del>HaveIESB</del></a><a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p2</ins></a><a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p4</del></a><ins>);</ins><del>());</del></p></div><div class="ps" psname="shared.functions.extension.HaveNoninvasiveDebugAuth"><a id="shared.functions.extension.HaveNoninvasiveDebugAuth" name="shared.functions.extension.HaveNoninvasiveDebugAuth"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/<ins>HaveNoninvasiveDebugAuth</ins><del>HaveDoubleLock</del></h3><p class="pseudocode"><ins>// HaveNoninvasiveDebugAuth()
// ==========================
// Returns FALSE if support for the removal of the non-invasive Debug controls is implemented.
</ins><del>// HaveDoubleLock()
// ================
// Returns TRUE if support for the OS Double Lock is implemented
</del>
boolean <a id="impl-shared.HaveNoninvasiveDebugAuth.0" name="impl-shared.HaveNoninvasiveDebugAuth.0"></a><ins>HaveNoninvasiveDebugAuth()
</ins><del>HaveDoubleLock()
</del>    return !<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }">ARMv8p4</a><ins>);</ins><del>) || boolean IMPLEMENTATION_DEFINED "OS Double Lock is implemented";</del></p></div><div class="ps" psname="shared.functions.extension.HavePANExt"><a id="shared.functions.extension.HavePANExt" name="shared.functions.extension.HavePANExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/<ins>HavePANExt</ins><del>HaveE0PDExt</del></h3><p class="pseudocode"><ins>// HavePANExt()
// ============
</ins><del>// HaveE0PDExt()
// =============
// Returns TRUE if support for constant fault times for unprivileged accesses
// to the memory map is implemented.
</del>
boolean <a id="impl-shared.HavePANExt.0" name="impl-shared.HavePANExt.0"></a><ins>HavePANExt()
</ins><del>HaveE0PDExt()
</del>    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p1" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p1</ins></a><a href="shared_pseudocode.html#ARMv8p5" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p5</del></a>);</p></div><div class="ps" psname="shared.functions.extension.HavePageBasedHardwareAttributes"><a id="shared.functions.extension.HavePageBasedHardwareAttributes" name="shared.functions.extension.HavePageBasedHardwareAttributes"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/<ins>HavePageBasedHardwareAttributes</ins><del>HaveExtendedCacheSets</del></h3><p class="pseudocode"><ins>// HavePageBasedHardwareAttributes()
// =================================
</ins><del>// HaveExtendedCacheSets()
// =======================
</del>
boolean <a id="impl-shared.HavePageBasedHardwareAttributes.0" name="impl-shared.HavePageBasedHardwareAttributes.0"></a><ins>HavePageBasedHardwareAttributes()
</ins><del>HaveExtendedCacheSets()
</del>    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p2</ins></a><a href="shared_pseudocode.html#ARMv8p3" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p3</del></a>);</p></div><div class="ps" psname="shared.functions.extension.HavePrivATExt"><a id="shared.functions.extension.HavePrivATExt" name="shared.functions.extension.HavePrivATExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/<ins>HavePrivATExt</ins><del>HaveExtendedECDebugEvents</del></h3><p class="pseudocode"><ins>// HavePrivATExt()
// ===============
</ins><del>// HaveExtendedECDebugEvents()
// ===========================
</del>
boolean <a id="impl-shared.HavePrivATExt.0" name="impl-shared.HavePrivATExt.0"></a><ins>HavePrivATExt()
</ins><del>HaveExtendedECDebugEvents()
</del>    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }">ARMv8p2</a>);</p></div><div class="ps" psname="shared.functions.extension.HaveQRDMLAHExt"><a id="shared.functions.extension.HaveQRDMLAHExt" name="shared.functions.extension.HaveQRDMLAHExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/<ins>HaveQRDMLAHExt</ins><del>HaveExtendedExecuteNeverExt</del></h3><p class="pseudocode"><ins>// HaveQRDMLAHExt()
// ================
</ins><del>// HaveExtendedExecuteNeverExt()
// =============================
</del>
boolean <a id="impl-shared.HaveQRDMLAHExt.0" name="impl-shared.HaveQRDMLAHExt.0"></a><ins>HaveQRDMLAHExt()
</ins><del>HaveExtendedExecuteNeverExt()
</del>    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p1" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p1</ins></a><a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p2</del></a><ins>);

boolean </ins><a id="impl-shared.HaveAccessFlagUpdateExt.0" name="impl-shared.HaveAccessFlagUpdateExt.0"></a><ins>HaveAccessFlagUpdateExt()
    return </ins><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><ins>HasArchVersion</ins></a><ins>(</ins><a href="shared_pseudocode.html#ARMv8p1" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p1</ins></a><ins>);

boolean </ins><a id="impl-shared.HaveDirtyBitModifierExt.0" name="impl-shared.HaveDirtyBitModifierExt.0"></a><ins>HaveDirtyBitModifierExt()
    return </ins><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><ins>HasArchVersion</ins></a><ins>(</ins><a href="shared_pseudocode.html#ARMv8p1" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p1</ins></a>);</p></div><div class="ps" psname="shared.functions.extension.HaveRASExt"><a id="shared.functions.extension.HaveRASExt" name="shared.functions.extension.HaveRASExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/<ins>HaveRASExt</ins><del>HaveFCADDExt</del></h3><p class="pseudocode"><ins>// HaveRASExt()
// ============
</ins><del>// HaveFCADDExt()
// ==============
</del>
boolean <a id="impl-shared.HaveRASExt.0" name="impl-shared.HaveRASExt.0"></a><ins>HaveRASExt()
    return (</ins><del>HaveFCADDExt()
    return</del><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p2</ins></a><a href="shared_pseudocode.html#ARMv8p3" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p3</del></a><ins>) ||
            boolean IMPLEMENTATION_DEFINED "Has RAS extension");</ins><del>);</del></p></div><div class="ps" psname="shared.functions.extension.HaveSBExt"><a id="shared.functions.extension.HaveSBExt" name="shared.functions.extension.HaveSBExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/<ins>HaveSBExt</ins><del>HaveFJCVTZSExt</del></h3><p class="pseudocode"><ins>// HaveSBExt()
// ===========
// Returns TRUE if has SB feature support, and FALSE otherwise.
</ins><del>// HaveFJCVTZSExt()
// ================
</del>
boolean <a id="impl-shared.HaveSBExt.0" name="impl-shared.HaveSBExt.0"></a><ins>HaveSBExt()
</ins><del>HaveFJCVTZSExt()
</del>    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p5" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p5</ins></a><a href="shared_pseudocode.html#ARMv8p3" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p3</del></a><ins>) || boolean IMPLEMENTATION_DEFINED "Has SB extension";</ins><del>);</del></p></div><div class="ps" psname="shared.functions.extension.HaveSSBSExt"><a id="shared.functions.extension.HaveSSBSExt" name="shared.functions.extension.HaveSSBSExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/<ins>HaveSSBSExt</ins><del>HaveFP16MulNoRoundingToFP32Ext</del></h3><p class="pseudocode"><ins>// HaveSSBSExt()
// =============
// Returns TRUE if has SSBS feature support, and FALSE otherwise.
</ins><del>// HaveFP16MulNoRoundingToFP32Ext()
// ================================
// Returns TRUE if has FP16 multiply with no intermediate rounding accumulate to FP32 instructions,
// and FALSE otherwise
</del>
boolean <a id="impl-shared.HaveSSBSExt.0" name="impl-shared.HaveSSBSExt.0"></a><ins>HaveSSBSExt()
    return</ins><del>HaveFP16MulNoRoundingToFP32Ext()

    if !</del> <a href="shared_pseudocode.html#impl-shared.HaveFP16Ext.0" title="function: boolean HaveFP16Ext()"><del>HaveFP16Ext</del></a><del>() then return FALSE;
    if </del><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<del>) then return TRUE;
    return (</del><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><del>HasArchVersion</del></a><del>(</del><a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p2</del></a><a href="shared_pseudocode.html#ARMv8p5" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p5</ins></a><a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p4</del></a><ins>) || boolean IMPLEMENTATION_DEFINED "Has SSBS extension";</ins><del>) &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has accumulate FP16 product into FP32 extension");</del></p></div><div class="ps" psname="shared.functions.extension.HaveSecureEL2Ext"><a id="shared.functions.extension.HaveSecureEL2Ext" name="shared.functions.extension.HaveSecureEL2Ext"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/<ins>HaveSecureEL2Ext</ins><del>HaveFlagFormatExt</del></h3><p class="pseudocode"><ins>// HaveSecureEL2Ext()
// ==================
// Returns TRUE if has Secure EL2, and FALSE otherwise
</ins><del>// HaveFlagFormatExt()
// ===================
// Returns TRUE if flag format conversion instructions implemented
// and FALSE otherwise
</del>
boolean <a id="impl-shared.HaveSecureEL2Ext.0" name="impl-shared.HaveSecureEL2Ext.0"></a><ins>HaveSecureEL2Ext()
</ins><del>HaveFlagFormatExt()
</del>    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p4</ins></a><a href="shared_pseudocode.html#ARMv8p5" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p5</del></a>);</p></div><div class="ps" psname="shared.functions.extension.HaveSecureExtDebugView"><a id="shared.functions.extension.HaveSecureExtDebugView" name="shared.functions.extension.HaveSecureExtDebugView"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/<ins>HaveSecureExtDebugView</ins><del>HaveFlagManipulateExt</del></h3><p class="pseudocode"><ins>// HaveSecureExtDebugView()
// ========================
// Returns TRUE if supports Secure and Non-secure views of debug peripherals is implemented.
</ins><del>// HaveFlagManipulateExt()
// =======================
// Returns TRUE if has flag manipulate instructions, and FALSE otherwise
</del>
boolean <a id="impl-shared.HaveSecureExtDebugView.0" name="impl-shared.HaveSecureExtDebugView.0"></a><ins>HaveSecureExtDebugView()
</ins><del>HaveFlagManipulateExt()
</del>    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }">ARMv8p4</a>);</p></div><div class="ps" psname="shared.functions.extension.HaveSelfHostedTrace"><a id="shared.functions.extension.HaveSelfHostedTrace" name="shared.functions.extension.HaveSelfHostedTrace"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/<ins>HaveSelfHostedTrace</ins><del>HaveFrintExt</del></h3><p class="pseudocode"><ins>// HaveSelfHostedTrace()
// =====================
</ins><del>// HaveFrintExt()
// ==============
// Returns TRUE if FRINT instructions are implemented and FALSE otherwise
</del>
boolean <a id="impl-shared.HaveSelfHostedTrace.0" name="impl-shared.HaveSelfHostedTrace.0"></a><ins>HaveSelfHostedTrace()
</ins><del>HaveFrintExt()
</del>    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p4</ins></a><a href="shared_pseudocode.html#ARMv8p5" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p5</del></a>);</p></div><div class="ps" psname="shared.functions.extension.HaveSmallPageTblExt"><a id="shared.functions.extension.HaveSmallPageTblExt" name="shared.functions.extension.HaveSmallPageTblExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/<ins>HaveSmallPageTblExt</ins><del>HaveHPMDExt</del></h3><p class="pseudocode"><ins>// HaveSmallPageTblExt()
// =====================
// Returns TRUE if has Small Page Table Support, and FALSE otherwise
</ins><del>// HaveHPMDExt()
// =============
</del>
boolean <a id="impl-shared.HaveSmallPageTblExt.0" name="impl-shared.HaveSmallPageTblExt.0"></a><ins>HaveSmallPageTblExt()
</ins><del>HaveHPMDExt()
</del>    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p4</ins></a><a href="shared_pseudocode.html#ARMv8p1" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p1</del></a><ins>) &amp;&amp; boolean IMPLEMENTATION_DEFINED "Has Small Page Table extension";</ins><del>);</del></p></div><div class="ps" psname="shared.functions.extension.HaveStage2MemAttrControl"><a id="shared.functions.extension.HaveStage2MemAttrControl" name="shared.functions.extension.HaveStage2MemAttrControl"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/<ins>HaveStage2MemAttrControl</ins><del>HaveIESB</del></h3><p class="pseudocode"><ins>// HaveStage2MemAttrControl()
// ==========================
// Returns TRUE if support for Stage2 control of memory types and cacheability attributes is implemented.
</ins><del>// HaveIESB()
// ==========
</del>
boolean <a id="impl-shared.HaveStage2MemAttrControl.0" name="impl-shared.HaveStage2MemAttrControl.0"></a><ins>HaveStage2MemAttrControl()
    return</ins><del>HaveIESB()
    return (</del> <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><ins>HasArchVersion</ins></a><a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()"><del>HaveRASExt</del></a><ins>(</ins><a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p4</ins></a><ins>);</ins><del>() &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has Implicit Error Synchronization Barrier");</del></p></div><div class="ps" psname="shared.functions.extension.HaveStatisticalProfiling"><a id="shared.functions.extension.HaveStatisticalProfiling" name="shared.functions.extension.HaveStatisticalProfiling"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/<ins>HaveStatisticalProfiling</ins><del>HaveMPAMExt</del></h3><p class="pseudocode"><ins>// HaveStatisticalProfiling()
// ==========================
</ins><del>// HaveMPAMExt()
// =============
// Returns TRUE if MPAM implemented and FALSE otherwise.
</del>
boolean <a id="impl-shared.HaveStatisticalProfiling.0" name="impl-shared.HaveStatisticalProfiling.0"></a><ins>HaveStatisticalProfiling()
    return</ins><del>HaveMPAMExt()
    return (</del> <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }">ARMv8p2</a><ins>);</ins><del>) &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has MPAM extension");</del></p></div><div class="ps" psname="shared.functions.extension.HaveTrapLoadStoreMultipleDeviceExt"><a id="shared.functions.extension.HaveTrapLoadStoreMultipleDeviceExt" name="shared.functions.extension.HaveTrapLoadStoreMultipleDeviceExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/<ins>HaveTrapLoadStoreMultipleDeviceExt</ins><del>HaveMTEExt</del></h3><p class="pseudocode"><ins>// HaveTrapLoadStoreMultipleDeviceExt()
// ====================================
</ins><del>// HaveMTEExt()
// ============
// Returns TRUE if MTE implemented and FALSE otherwise.
</del>
boolean <a id="impl-shared.HaveTrapLoadStoreMultipleDeviceExt.0" name="impl-shared.HaveTrapLoadStoreMultipleDeviceExt.0"></a><ins>HaveTrapLoadStoreMultipleDeviceExt()
    return</ins><del>HaveMTEExt()
    if !</del> <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p2</ins></a><a href="shared_pseudocode.html#ARMv8p5" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p5</del></a><ins>);</ins><del>) then
        return FALSE;
    return boolean IMPLEMENTATION_DEFINED "Has MTE extension";</del></p></div><div class="ps" psname="shared.functions.extension.HaveUA16Ext"><a id="shared.functions.extension.HaveUA16Ext" name="shared.functions.extension.HaveUA16Ext"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/<ins>HaveUA16Ext</ins><del>HaveNV2Ext</del></h3><p class="pseudocode"><ins>// HaveUA16Ext()
// =============
// Returns TRUE if has extended unaligned memory access support, and FALSE otherwise
</ins><del>// HaveNV2Ext()
// ============
</del>
boolean <a id="impl-shared.HaveUA16Ext.0" name="impl-shared.HaveUA16Ext.0"></a><ins>HaveUA16Ext()
</ins><del>HaveNV2Ext()
</del>    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }">ARMv8p4</a>);</p></div><div class="ps" psname="shared.functions.extension.HaveUAOExt"><a id="shared.functions.extension.HaveUAOExt" name="shared.functions.extension.HaveUAOExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/<ins>HaveUAOExt</ins><del>HaveNVExt</del></h3><p class="pseudocode"><ins>// HaveUAOExt()
// ============
</ins><del>// HaveNVExt()
// ===========
</del>
boolean <a id="impl-shared.HaveUAOExt.0" name="impl-shared.HaveUAOExt.0"></a><ins>HaveUAOExt()
</ins><del>HaveNVExt()
</del>    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p2</ins></a><a href="shared_pseudocode.html#ARMv8p3" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p3</del></a>);</p></div><div class="ps" psname="shared.functions.extension.HaveVirtHostExt"><a id="shared.functions.extension.HaveVirtHostExt" name="shared.functions.extension.HaveVirtHostExt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/<ins>HaveVirtHostExt</ins><del>HaveNoSecurePMUDisableOverride</del></h3><p class="pseudocode"><ins>// HaveVirtHostExt()
// =================
</ins><del>// HaveNoSecurePMUDisableOverride()
// ================================
</del>
boolean <a id="impl-shared.HaveVirtHostExt.0" name="impl-shared.HaveVirtHostExt.0"></a><ins>HaveVirtHostExt()
</ins><del>HaveNoSecurePMUDisableOverride()
</del>    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p1" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p1</ins></a><a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p2</del></a>);</p></div><div class="ps" psname="shared.functions.extension.InsertIESBBeforeException"><a id="shared.functions.extension.InsertIESBBeforeException" name="shared.functions.extension.InsertIESBBeforeException"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/<ins>InsertIESBBeforeException</ins><del>HaveNoninvasiveDebugAuth</del></h3><p class="pseudocode"><ins>// If SCTLR_ELx.IESB is 1 when an exception is generated to ELx, any pending Unrecoverable
// SError interrupt must be taken before executing any instructions in the exception handler.
// However, this can be before the branch to the exception handler is made.
</ins><del>// HaveNoninvasiveDebugAuth()
// ==========================
// Returns FALSE if support for the removal of the non-invasive Debug controls is implemented.

</del>boolean <a id="impl-shared.InsertIESBBeforeException.1" name="impl-shared.InsertIESBBeforeException.1"></a><ins>InsertIESBBeforeException(bits(2) el);</ins><del>HaveNoninvasiveDebugAuth()
    return !</del><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><del>HasArchVersion</del></a><del>(</del><a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p4</del></a><del>);</del></p></div><div class="ps" psname="shared.functions.float.fixedtofp.FixedToFP"><a id="shared.functions.float.fixedtofp.FixedToFP" name="shared.functions.float.fixedtofp.FixedToFP"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>float</ins><del>extension</del>/<ins>fixedtofp/FixedToFP</ins><del>HavePANExt</del></h3><p class="pseudocode"><ins>// FixedToFP()
// ===========
</ins><del>// HavePANExt()
// ============
</del>
<ins>// Convert M-bit fixed point OP with FBITS fractional bits to
// N-bit precision floating point, controlled by UNSIGNED and ROUNDING.

bits(N)</ins><del>boolean</del> <a id="impl-shared.FixedToFP.5" name="impl-shared.FixedToFP.5"></a><ins>FixedToFP(bits(M) op, integer fbits, boolean unsigned,</ins><del>HavePANExt()
    return</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><ins>FPCRType</ins></a><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><del>HasArchVersion</del></a> <ins>fpcr,</ins><del>(</del> <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding</ins></a><a href="shared_pseudocode.html#ARMv8p1" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p1</del></a><ins> rounding)
    assert N IN {16,32,64};
    assert M IN {16,32,64};
    bits(N) result;
    assert fbits >= 0;
    assert rounding != </ins><a href="shared_pseudocode.html#FPRounding_ODD" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_ODD</ins></a><ins>;

    // Correct signed-ness
    int_operand = </ins><a href="shared_pseudocode.html#impl-shared.Int.2" title="function: integer Int(bits(N) x, boolean unsigned)"><ins>Int</ins></a><ins>(op, unsigned);

    // Scale by fractional bits and generate a real value
    real_operand = Real(int_operand) / 2.0^fbits;

    if real_operand == 0.0 then
        result = </ins><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><ins>FPZero</ins></a><ins>('0');
    else
        result = </ins><a href="shared_pseudocode.html#impl-shared.FPRound.3" title="function: bits(N) FPRound(real op, FPCRType fpcr, FPRounding rounding)"><ins>FPRound</ins></a><ins>(real_operand, fpcr, rounding);

    return result;</ins><del>);</del></p></div><div class="ps" psname="shared.functions.float.fpabs.FPAbs"><a id="shared.functions.float.fpabs.FPAbs" name="shared.functions.float.fpabs.FPAbs"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>float</ins><del>extension</del>/<ins>fpabs/FPAbs</ins><del>HavePageBasedHardwareAttributes</del></h3><p class="pseudocode"><ins>// FPAbs()
// =======
</ins><del>// HavePageBasedHardwareAttributes()
// =================================
</del>
<ins>bits(N)</ins><del>boolean</del> <a id="impl-shared.FPAbs.1" name="impl-shared.FPAbs.1"></a><ins>FPAbs(bits(N) op)
    assert N IN {16,32,64};
    return '0' : op&lt;N-2:0>;</ins><del>HavePageBasedHardwareAttributes()
    return</del><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><del>HasArchVersion</del></a><del>(</del><a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p2</del></a><del>);</del></p></div><div class="ps" psname="shared.functions.float.fpadd.FPAdd"><a id="shared.functions.float.fpadd.FPAdd" name="shared.functions.float.fpadd.FPAdd"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>float</ins><del>extension</del>/<ins>fpadd/FPAdd</ins><del>HavePrivATExt</del></h3><p class="pseudocode"><ins>// FPAdd()
// =======
</ins><del>// HavePrivATExt()
// ===============
</del>
<ins>bits(N)</ins><del>boolean</del> <a id="impl-shared.FPAdd.3" name="impl-shared.FPAdd.3"></a><ins>FPAdd(bits(N) op1, bits(N) op2,</ins><del>HavePrivATExt()
    return</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><ins>FPCRType</ins></a><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><del>HasArchVersion</del></a> <ins>fpcr)
    assert N IN {16,32,64};
    rounding =</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)"><ins>FPRoundingMode</ins></a><a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p2</del></a><ins>(fpcr);
    (type1,sign1,value1) = </ins><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><ins>(op1, fpcr);
    (type2,sign2,value2) = </ins><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><ins>(op2, fpcr);
    (done,result) = </ins><a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2, FPCRType fpcr)"><ins>FPProcessNaNs</ins></a><ins>(type1, type2, op1, op2, fpcr);
    if !done then
        inf1 = (type1 == </ins><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><ins>);  inf2 = (type2 == </ins><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><ins>);
        zero1 = (type1 == </ins><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><ins>);     zero2 = (type2 == </ins><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><ins>);
        if inf1 &amp;&amp; inf2 &amp;&amp; sign1 == NOT(sign2) then
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.0" title="function: bits(N) FPDefaultNaN()"><ins>FPDefaultNaN</ins></a><ins>();
            </ins><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><ins>(</ins><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_InvalidOp</ins></a><ins>, fpcr);
        elsif (inf1 &amp;&amp; sign1 == '0') || (inf2 &amp;&amp; sign2 == '0') then
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><ins>FPInfinity</ins></a><ins>('0');
        elsif (inf1 &amp;&amp; sign1 == '1') || (inf2 &amp;&amp; sign2 == '1') then
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><ins>FPInfinity</ins></a><ins>('1');
        elsif zero1 &amp;&amp; zero2 &amp;&amp; sign1 == sign2 then
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><ins>FPZero</ins></a><ins>(sign1);
        else
            result_value = value1 + value2;
            if result_value == 0.0 then  // Sign of exact zero result depends on rounding mode
                result_sign = if rounding == </ins><a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_NEGINF</ins></a><ins> then '1' else '0';
                result = </ins><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><ins>FPZero</ins></a><ins>(result_sign);
            else
                result = </ins><a href="shared_pseudocode.html#impl-shared.FPRound.3" title="function: bits(N) FPRound(real op, FPCRType fpcr, FPRounding rounding)"><ins>FPRound</ins></a><ins>(result_value, fpcr, rounding);
    return result;</ins><del>);</del></p></div><div class="ps" psname="shared.functions.float.fpcompare.FPCompare"><a id="shared.functions.float.fpcompare.FPCompare" name="shared.functions.float.fpcompare.FPCompare"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>float</ins><del>extension</del>/<ins>fpcompare/FPCompare</ins><del>HaveQRDMLAHExt</del></h3><p class="pseudocode"><ins>// FPCompare()
// ===========
</ins><del>// HaveQRDMLAHExt()
// ================
</del>
<ins>bits(4)</ins><del>boolean</del> <a id="impl-shared.FPCompare.4" name="impl-shared.FPCompare.4"></a><ins>FPCompare(bits(N) op1, bits(N) op2, boolean signal_nans,</ins><del>HaveQRDMLAHExt()
    return</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><ins>FPCRType</ins></a><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><del>HasArchVersion</del></a> <ins>fpcr)
    assert N IN {16,32,64};
    (type1,sign1,value1) =</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><a href="shared_pseudocode.html#ARMv8p1" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p1</del></a><ins>(op1, fpcr);
    (type2,sign2,value2) =</ins><del>);

boolean</del> <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><ins>(op2, fpcr);
    if type1==</ins><del>HaveAccessFlagUpdateExt()
    return</del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><del>HasArchVersion</del></a> <ins>|| type1==</ins><del>(</del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><a href="shared_pseudocode.html#ARMv8p1" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p1</del></a> <ins>|| type2==</ins><del>);

boolean</del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a> <ins>|| type2==</ins><del>HaveDirtyBitModifierExt()
    return</del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><del>HasArchVersion</del></a> <ins>then
        result = '0011';
        if type1==</ins><del>(</del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><a href="shared_pseudocode.html#ARMv8p1" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p1</del></a><ins> || type2==</ins><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><ins> || signal_nans then
            </ins><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><ins>(</ins><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_InvalidOp</ins></a><ins>, fpcr);
    else
        // All non-NaN cases can be evaluated on the values produced by FPUnpack()
        if value1 == value2 then
            result = '0110';
        elsif value1 &lt; value2 then
            result = '1000';
        else  // value1 > value2
            result = '0010';
    return result;</ins><del>);</del></p></div><div class="ps" psname="shared.functions.float.fpcompareeq.FPCompareEQ"><a id="shared.functions.float.fpcompareeq.FPCompareEQ" name="shared.functions.float.fpcompareeq.FPCompareEQ"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>float</ins><del>extension</del>/<ins>fpcompareeq/FPCompareEQ</ins><del>HaveRASExt</del></h3><p class="pseudocode"><ins>// FPCompareEQ()
// =============
</ins><del>// HaveRASExt()
// ============
</del>
boolean <a id="impl-shared.FPCompareEQ.3" name="impl-shared.FPCompareEQ.3"></a><ins>FPCompareEQ(bits(N) op1, bits(N) op2,</ins><del>HaveRASExt()
    return (</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><ins>FPCRType</ins></a><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><del>HasArchVersion</del></a> <ins>fpcr)
    assert N IN {16,32,64};
    (type1,sign1,value1) =</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p2</del></a><ins>(op1, fpcr);
    (type2,sign2,value2) = </ins><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><ins>(op2, fpcr);
    if type1==</ins><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><ins> || type1==</ins><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><ins> || type2==</ins><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><ins> || type2==</ins><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><ins> then
        result = FALSE;
        if type1==</ins><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><ins> || type2==</ins><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><ins> then
            </ins><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><ins>(</ins><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_InvalidOp</ins></a><ins>, fpcr);
    else
        // All non-NaN cases can be evaluated on the values produced by FPUnpack()
        result = (value1 == value2);
    return result;</ins><del>) ||
            boolean IMPLEMENTATION_DEFINED "Has RAS extension");</del></p></div><div class="ps" psname="shared.functions.float.fpcomparege.FPCompareGE"><a id="shared.functions.float.fpcomparege.FPCompareGE" name="shared.functions.float.fpcomparege.FPCompareGE"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>float</ins><del>extension</del>/<ins>fpcomparege/FPCompareGE</ins><del>HaveSBExt</del></h3><p class="pseudocode"><ins>// FPCompareGE()
// =============
</ins><del>// HaveSBExt()
// ===========
// Returns TRUE if has SB feature support, and FALSE otherwise.
</del>
boolean <a id="impl-shared.FPCompareGE.3" name="impl-shared.FPCompareGE.3"></a><ins>FPCompareGE(bits(N) op1, bits(N) op2,</ins><del>HaveSBExt()
    return</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><ins>FPCRType</ins></a><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><del>HasArchVersion</del></a> <ins>fpcr)
    assert N IN {16,32,64};
    (type1,sign1,value1) =</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><a href="shared_pseudocode.html#ARMv8p5" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p5</del></a><ins>(op1, fpcr);
    (type2,sign2,value2) = </ins><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><ins>(op2, fpcr);
    if type1==</ins><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><ins> || type1==</ins><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><ins> || type2==</ins><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><ins> || type2==</ins><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><ins> then
        result = FALSE;
        </ins><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><ins>(</ins><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_InvalidOp</ins></a><ins>, fpcr);
    else
        // All non-NaN cases can be evaluated on the values produced by FPUnpack()
        result = (value1 >= value2);
    return result;</ins><del>) || boolean IMPLEMENTATION_DEFINED "Has SB extension";</del></p></div><div class="ps" psname="shared.functions.float.fpcomparegt.FPCompareGT"><a id="shared.functions.float.fpcomparegt.FPCompareGT" name="shared.functions.float.fpcomparegt.FPCompareGT"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>float</ins><del>extension</del>/<ins>fpcomparegt/FPCompareGT</ins><del>HaveSSBSExt</del></h3><p class="pseudocode"><ins>// FPCompareGT()
</ins><del>// HaveSSBSExt()
</del>// =============
<del>// Returns TRUE if has SSBS feature support, and FALSE otherwise.
</del>
boolean <a id="impl-shared.FPCompareGT.3" name="impl-shared.FPCompareGT.3"></a><ins>FPCompareGT(bits(N) op1, bits(N) op2,</ins><del>HaveSSBSExt()
    return</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><ins>FPCRType</ins></a><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><del>HasArchVersion</del></a> <ins>fpcr)
    assert N IN {16,32,64};
    (type1,sign1,value1) =</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><a href="shared_pseudocode.html#ARMv8p5" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p5</del></a><ins>(op1, fpcr);
    (type2,sign2,value2) = </ins><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><ins>(op2, fpcr);
    if type1==</ins><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><ins> || type1==</ins><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><ins> || type2==</ins><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><ins> || type2==</ins><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><ins> then
        result = FALSE;
        </ins><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><ins>(</ins><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_InvalidOp</ins></a><ins>, fpcr);
    else
        // All non-NaN cases can be evaluated on the values produced by FPUnpack()
        result = (value1 > value2);
    return result;</ins><del>) || boolean IMPLEMENTATION_DEFINED "Has SSBS extension";</del></p></div><div class="ps" psname="shared.functions.float.fpconvert.FPConvert"><a id="shared.functions.float.fpconvert.FPConvert" name="shared.functions.float.fpconvert.FPConvert"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>float</ins><del>extension</del>/<ins>fpconvert/FPConvert</ins><del>HaveSecureEL2Ext</del></h3><p class="pseudocode"><ins>// FPConvert()
// ===========
</ins><del>// HaveSecureEL2Ext()
// ==================
// Returns TRUE if has Secure EL2, and FALSE otherwise
</del>
<ins>// Convert floating point OP with N-bit precision to M-bit precision,
// with rounding controlled by ROUNDING.
// This is used by the FP-to-FP conversion instructions and so for
// half-precision data ignores FZ16, but observes AHP.

bits(M)</ins><del>boolean</del> <a id="impl-shared.FPConvert.3" name="impl-shared.FPConvert.3"></a><ins>FPConvert(bits(N) op,</ins><del>HaveSecureEL2Ext()
    return</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><ins>FPCRType</ins></a><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><del>HasArchVersion</del></a> <ins>fpcr,</ins><del>(</del> <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding</ins></a><a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p4</del></a><ins> rounding)
    assert M IN {16,32,64};
    assert N IN {16,32,64};
    bits(M) result;

    // Unpack floating-point operand optionally with flush-to-zero.
    (type,sign,value) = </ins><a href="shared_pseudocode.html#impl-shared.FPUnpackCV.2" title="function: (FPType, bit, real) FPUnpackCV(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpackCV</ins></a><ins>(op, fpcr);

    alt_hp = (M == 16) &amp;&amp; (fpcr.AHP == '1');

    if type == </ins><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><ins> || type == </ins><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><ins> then
        if alt_hp then
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><ins>FPZero</ins></a><ins>(sign);
        elsif fpcr.DN == '1' then
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.0" title="function: bits(N) FPDefaultNaN()"><ins>FPDefaultNaN</ins></a><ins>();
        else
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPConvertNaN.1" title="function: bits(M) FPConvertNaN(bits(N) op)"><ins>FPConvertNaN</ins></a><ins>(op);
        if type == </ins><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><ins> || alt_hp then
            </ins><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><ins>(</ins><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_InvalidOp</ins></a><ins>,fpcr);
    elsif type == </ins><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><ins> then
        if alt_hp then
            result = sign:</ins><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><ins>(M-1);
            </ins><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><ins>(</ins><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_InvalidOp</ins></a><ins>, fpcr);
        else
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><ins>FPInfinity</ins></a><ins>(sign);
    elsif type == </ins><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><ins> then
        result = </ins><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><ins>FPZero</ins></a><ins>(sign);
    else
        result = </ins><a href="shared_pseudocode.html#impl-shared.FPRoundCV.3" title="function: bits(N) FPRoundCV(real op, FPCRType fpcr, FPRounding rounding)"><ins>FPRoundCV</ins></a><ins>(value, fpcr, rounding);
    return result;

// FPConvert()
// ===========

bits(M) </ins><a id="impl-shared.FPConvert.2" name="impl-shared.FPConvert.2"></a><ins>FPConvert(bits(N) op, </ins><a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><ins>FPCRType</ins></a><ins> fpcr)
    return </ins><a href="shared_pseudocode.html#impl-shared.FPConvert.3" title="function: bits(M) FPConvert(bits(N) op, FPCRType fpcr, FPRounding rounding)"><ins>FPConvert</ins></a><ins>(op, fpcr, </ins><a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)"><ins>FPRoundingMode</ins></a><ins>(fpcr));</ins><del>);</del></p></div><div class="ps" psname="shared.functions.float.fpconvertnan.FPConvertNaN"><a id="shared.functions.float.fpconvertnan.FPConvertNaN" name="shared.functions.float.fpconvertnan.FPConvertNaN"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>float</ins><del>extension</del>/<ins>fpconvertnan/FPConvertNaN</ins><del>HaveSecureExtDebugView</del></h3><p class="pseudocode"><ins>// FPConvertNaN()
// ==============
</ins><del>// HaveSecureExtDebugView()
// ========================
// Returns TRUE if supports Secure and Non-secure views of debug peripherals is implemented.
</del>
<ins>// Converts a NaN of one floating-point type to another

bits(M)</ins><del>boolean</del> <a id="impl-shared.FPConvertNaN.1" name="impl-shared.FPConvertNaN.1"></a><ins>FPConvertNaN(bits(N) op)
    assert N IN {16,32,64};
    assert M IN {16,32,64};
    bits(M) result;
    bits(51) frac;

    sign = op&lt;N-1>;

    // Unpack payload from input NaN
    case N of
        when 64 frac = op&lt;50:0>;
        when 32 frac = op&lt;21:0>:</ins><del>HaveSecureExtDebugView()
    return</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><del>HasArchVersion</del></a><ins>(29);
        when 16 frac = op&lt;8:0>:</ins><del>(</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p4</del></a><ins>(42);

    // Repack payload into output NaN, while
    // converting an SNaN to a QNaN.
    case M of
        when 64 result = sign:</ins><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><ins>(M-52):frac;
        when 32 result = sign:</ins><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><ins>(M-23):frac&lt;50:29>;
        when 16 result = sign:</ins><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><ins>(M-10):frac&lt;50:42>;

    return result;</ins><del>);</del></p></div><div class="ps" psname="shared.functions.float.fpcrtype.FPCRType"><a id="shared.functions.float.fpcrtype.FPCRType" name="shared.functions.float.fpcrtype.FPCRType"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>float</ins><del>extension</del>/<ins>fpcrtype/FPCRType</ins><del>HaveSelfHostedTrace</del></h3><p class="pseudocode"><ins>type</ins><del>// HaveSelfHostedTrace()
// =====================

boolean</del> <a id="FPCRType" name="FPCRType"></a><ins>FPCRType;</ins><del>HaveSelfHostedTrace()
    return</del><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><del>HasArchVersion</del></a><del>(</del><a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p4</del></a><del>);</del></p></div><div class="ps" psname="shared.functions.float.fpdecoderm.FPDecodeRM"><a id="shared.functions.float.fpdecoderm.FPDecodeRM" name="shared.functions.float.fpdecoderm.FPDecodeRM"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>float</ins><del>extension</del>/<ins>fpdecoderm/FPDecodeRM</ins><del>HaveSmallPageTblExt</del></h3><p class="pseudocode"><ins>// FPDecodeRM()
// ============
</ins><del>// HaveSmallPageTblExt()
// =====================
// Returns TRUE if has Small Page Table Support, and FALSE otherwise
</del>
<ins>// Decode most common AArch32 floating-point rounding encoding.

FPRounding</ins><del>boolean</del> <a id="impl-shared.FPDecodeRM.1" name="impl-shared.FPDecodeRM.1"></a><ins>FPDecodeRM(bits(2) rm)
    case rm of
        when '00' return</ins><del>HaveSmallPageTblExt()
    return</del> <a href="shared_pseudocode.html#FPRounding_TIEAWAY" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_TIEAWAY</ins></a><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><del>HasArchVersion</del></a><ins>; // A
        when '01' return</ins><del>(</del> <a href="shared_pseudocode.html#FPRounding_TIEEVEN" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_TIEEVEN</ins></a><a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p4</del></a><ins>; // N
        when '10' return </ins><a href="shared_pseudocode.html#FPRounding_POSINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_POSINF</ins></a><ins>;  // P
        when '11' return </ins><a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_NEGINF</ins></a><ins>;  // M</ins><del>) &amp;&amp; boolean IMPLEMENTATION_DEFINED "Has Small Page Table extension";</del></p></div><div class="ps" psname="shared.functions.float.fpdecoderounding.FPDecodeRounding"><a id="shared.functions.float.fpdecoderounding.FPDecodeRounding" name="shared.functions.float.fpdecoderounding.FPDecodeRounding"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>float</ins><del>extension</del>/<ins>fpdecoderounding/FPDecodeRounding</ins><del>HaveStage2MemAttrControl</del></h3><p class="pseudocode"><ins>// FPDecodeRounding()
// ==================
</ins><del>// HaveStage2MemAttrControl()
// ==========================
// Returns TRUE if support for Stage2 control of memory types and cacheability attributes is implemented.
</del>
<ins>// Decode floating-point rounding mode and common AArch64 encoding.

FPRounding</ins><del>boolean</del> <a id="impl-shared.FPDecodeRounding.1" name="impl-shared.FPDecodeRounding.1"></a><ins>FPDecodeRounding(bits(2) rmode)
    case rmode of
        when '00' return</ins><del>HaveStage2MemAttrControl()
    return</del> <a href="shared_pseudocode.html#FPRounding_TIEEVEN" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_TIEEVEN</ins></a><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><del>HasArchVersion</del></a><ins>; // N
        when '01' return</ins><del>(</del> <a href="shared_pseudocode.html#FPRounding_POSINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_POSINF</ins></a><a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p4</del></a><ins>;  // P
        when '10' return </ins><a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_NEGINF</ins></a><ins>;  // M
        when '11' return </ins><a href="shared_pseudocode.html#FPRounding_ZERO" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_ZERO</ins></a><ins>;    // Z</ins><del>);</del></p></div><div class="ps" psname="shared.functions.float.fpdefaultnan.FPDefaultNaN"><a id="shared.functions.float.fpdefaultnan.FPDefaultNaN" name="shared.functions.float.fpdefaultnan.FPDefaultNaN"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>float</ins><del>extension</del>/<ins>fpdefaultnan/FPDefaultNaN</ins><del>HaveStatisticalProfiling</del></h3><p class="pseudocode"><ins>// FPDefaultNaN()
// ==============
</ins><del>// HaveStatisticalProfiling()
// ==========================
</del>
<ins>bits(N)</ins><del>boolean</del> <a id="impl-shared.FPDefaultNaN.0" name="impl-shared.FPDefaultNaN.0"></a><ins>FPDefaultNaN()
    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    sign = '0';
    exp  =</ins><del>HaveStatisticalProfiling()
    return</del> <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><del>HasArchVersion</del></a><ins>(E);
    frac = '1':</ins><del>(</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p2</del></a><ins>(F-1);
    return sign : exp : frac;</ins><del>);</del></p></div><div class="ps" psname="shared.functions.float.fpdiv.FPDiv"><a id="shared.functions.float.fpdiv.FPDiv" name="shared.functions.float.fpdiv.FPDiv"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>float</ins><del>extension</del>/<ins>fpdiv/FPDiv</ins><del>HaveTrapLoadStoreMultipleDeviceExt</del></h3><p class="pseudocode"><ins>// FPDiv()
// =======
</ins><del>// HaveTrapLoadStoreMultipleDeviceExt()
// ====================================
</del>
<ins>bits(N)</ins><del>boolean</del> <a id="impl-shared.FPDiv.3" name="impl-shared.FPDiv.3"></a><ins>FPDiv(bits(N) op1, bits(N) op2,</ins><del>HaveTrapLoadStoreMultipleDeviceExt()
    return</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><ins>FPCRType</ins></a><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><del>HasArchVersion</del></a> <ins>fpcr)
    assert N IN {16,32,64};
    (type1,sign1,value1) =</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p2</del></a><ins>(op1, fpcr);
    (type2,sign2,value2) = </ins><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><ins>(op2, fpcr);
    (done,result) = </ins><a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2, FPCRType fpcr)"><ins>FPProcessNaNs</ins></a><ins>(type1, type2, op1, op2, fpcr);
    if !done then
        inf1 = (type1 == </ins><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><ins>);
        inf2 = (type2 == </ins><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><ins>);
        zero1 = (type1 == </ins><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><ins>);
        zero2 = (type2 == </ins><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><ins>);
        if (inf1 &amp;&amp; inf2) || (zero1 &amp;&amp; zero2) then
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.0" title="function: bits(N) FPDefaultNaN()"><ins>FPDefaultNaN</ins></a><ins>();
            </ins><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><ins>(</ins><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_InvalidOp</ins></a><ins>, fpcr);
        elsif inf1 || zero2 then
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><ins>FPInfinity</ins></a><ins>(sign1 EOR sign2);
            if !inf1 then </ins><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><ins>(</ins><a href="shared_pseudocode.html#FPExc_DivideByZero" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_DivideByZero</ins></a><ins>, fpcr);
        elsif zero1 || inf2 then
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><ins>FPZero</ins></a><ins>(sign1 EOR sign2);
        else
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPRound.2" title="function: bits(N) FPRound(real op, FPCRType fpcr)"><ins>FPRound</ins></a><ins>(value1/value2, fpcr);
    return result;</ins><del>);</del></p></div><div class="ps" psname="shared.functions.float.fpexc.FPExc"><a id="shared.functions.float.fpexc.FPExc" name="shared.functions.float.fpexc.FPExc"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>float</ins><del>extension</del>/<ins>fpexc/FPExc</ins><del>HaveUA16Ext</del></h3><p class="pseudocode"><ins>enumeration</ins><del>// HaveUA16Ext()
// =============
// Returns TRUE if has extended unaligned memory access support, and FALSE otherwise

boolean</del> <a id="FPExc" name="FPExc"></a><ins>FPExc       {</ins><del>HaveUA16Ext()
    return</del><a id="FPExc_InvalidOp" name="FPExc_InvalidOp"></a><ins>FPExc_InvalidOp,</ins><del>(</del> <a id="FPExc_DivideByZero" name="FPExc_DivideByZero"></a><ins>FPExc_DivideByZero, </ins><a id="FPExc_Overflow" name="FPExc_Overflow"></a><ins>FPExc_Overflow,
                         </ins><a id="FPExc_Underflow" name="FPExc_Underflow"></a><ins>FPExc_Underflow, </ins><a id="FPExc_Inexact" name="FPExc_Inexact"></a><ins>FPExc_Inexact, </ins><a id="FPExc_InputDenorm" name="FPExc_InputDenorm"></a><ins>FPExc_InputDenorm};</ins><del>);</del></p></div><div class="ps" psname="shared.functions.float.fpinfinity.FPInfinity"><a id="shared.functions.float.fpinfinity.FPInfinity" name="shared.functions.float.fpinfinity.FPInfinity"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>float</ins><del>extension</del>/<ins>fpinfinity/FPInfinity</ins><del>HaveUAOExt</del></h3><p class="pseudocode"><ins>// FPInfinity()
</ins><del>// HaveUAOExt()
</del>// ============

<ins>bits(N)</ins><del>boolean</del> <a id="impl-shared.FPInfinity.1" name="impl-shared.FPInfinity.1"></a><ins>FPInfinity(bit sign)
    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp  =</ins><del>HaveUAOExt()
    return</del> <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><del>HasArchVersion</del></a><ins>(E);
    frac =</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p2</del></a><ins>(F);
    return sign : exp : frac;</ins><del>);</del></p></div><div class="ps" psname="shared.functions.float.fpmax.FPMax"><a id="shared.functions.float.fpmax.FPMax" name="shared.functions.float.fpmax.FPMax"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>float</ins><del>extension</del>/<ins>fpmax/FPMax</ins><del>HaveVirtHostExt</del></h3><p class="pseudocode"><ins>// FPMax()
// =======
</ins><del>// HaveVirtHostExt()
// =================
</del>
<ins>bits(N)</ins><del>boolean</del> <a id="impl-shared.FPMax.3" name="impl-shared.FPMax.3"></a><ins>FPMax(bits(N) op1, bits(N) op2,</ins><del>HaveVirtHostExt()
    return</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><ins>FPCRType</ins></a><a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)"><del>HasArchVersion</del></a> <ins>fpcr)
    assert N IN {16,32,64};
    (type1,sign1,value1) =</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><a href="shared_pseudocode.html#ARMv8p1" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p1</del></a><ins>(op1, fpcr);
    (type2,sign2,value2) = </ins><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><ins>(op2, fpcr);
    (done,result) = </ins><a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2, FPCRType fpcr)"><ins>FPProcessNaNs</ins></a><ins>(type1, type2, op1, op2, fpcr);
    if !done then
        if value1 > value2 then
            (type,sign,value) = (type1,sign1,value1);
        else
            (type,sign,value) = (type2,sign2,value2);
        if type == </ins><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><ins> then
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><ins>FPInfinity</ins></a><ins>(sign);
        elsif type == </ins><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><ins> then
            sign = sign1 AND sign2; // Use most positive sign
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><ins>FPZero</ins></a><ins>(sign);
        else
            // The use of FPRound() covers the case where there is a trapped underflow exception
            // for a denormalized number even though the result is exact.
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPRound.2" title="function: bits(N) FPRound(real op, FPCRType fpcr)"><ins>FPRound</ins></a><ins>(value, fpcr);
    return result;</ins><del>);</del></p></div><div class="ps" psname="shared.functions.float.fpmaxnormal.FPMaxNormal"><a id="shared.functions.float.fpmaxnormal.FPMaxNormal" name="shared.functions.float.fpmaxnormal.FPMaxNormal"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>float</ins><del>extension</del>/<ins>fpmaxnormal/FPMaxNormal</ins><del>InsertIESBBeforeException</del></h3><p class="pseudocode"><ins>// FPMaxNormal()
// =============

bits(N)</ins><del>// If SCTLR_ELx.IESB is 1 when an exception is generated to ELx, any pending Unrecoverable
// SError interrupt must be taken before executing any instructions in the exception handler.
// However, this can be before the branch to the exception handler is made.
boolean</del> <a id="impl-shared.FPMaxNormal.1" name="impl-shared.FPMaxNormal.1"></a><ins>FPMaxNormal(bit sign)
    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp  =</ins><del>InsertIESBBeforeException(bits(2) el);</del> <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><ins>(E-1):'0';
    frac = </ins><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><ins>(F);
    return sign : exp : frac;</ins></p></div><div class="ps" psname="shared.functions.float.fpmaxnum.FPMaxNum"><a id="shared.functions.float.fpmaxnum.FPMaxNum" name="shared.functions.float.fpmaxnum.FPMaxNum"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fpmaxnum</ins><del>fixedtofp</del>/<ins>FPMaxNum</ins><del>FixedToFP</del></h3><p class="pseudocode"><ins>// FPMaxNum()
// ==========
</ins><del>// FixedToFP()
// ===========

// Convert M-bit fixed point OP with FBITS fractional bits to
// N-bit precision floating point, controlled by UNSIGNED and ROUNDING.
</del>
bits(N) <a id="impl-shared.FPMaxNum.3" name="impl-shared.FPMaxNum.3"></a><ins>FPMaxNum(bits(N) op1, bits(N) op2,</ins><del>FixedToFP(bits(M) op, integer fbits, boolean unsigned,</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> <ins>fpcr)
    assert N IN {16,32,64};
    (type1,-,-) =</ins><del>fpcr,</del> <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding</del></a><ins>(op1, fpcr);
    (type2,-,-) =</ins><del>rounding)
    assert N IN {16,32,64};
    assert M IN {16,32,64};
    bits(N) result;
    assert fbits >= 0;
    assert rounding !=</del> <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><a href="shared_pseudocode.html#FPRounding_ODD" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_ODD</del></a><ins>(op2, fpcr);
</ins><del>;
</del>
<ins>    // treat a single quiet-NaN as -Infinity
    if type1 ==</ins><del>    // Correct signed-ness
    int_operand =</del> <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><a href="shared_pseudocode.html#impl-shared.Int.2" title="function: integer Int(bits(N) x, boolean unsigned)"><del>Int</del></a> <ins>&amp;&amp; type2 !=</ins><del>(op, unsigned);

    // Scale by fractional bits and generate a real value
    real_operand = Real(int_operand) / 2.0^fbits;

    if real_operand == 0.0 then
        result =</del> <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><del>FPZero</del></a> <ins>then
        op1 =</ins><del>('0');
    else
        result =</del> <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><ins>FPInfinity</ins></a><a href="shared_pseudocode.html#impl-shared.FPRound.3" title="function: bits(N) FPRound(real op, FPCRType fpcr, FPRounding rounding)"><del>FPRound</del></a><ins>('1');
    elsif type1 != </ins><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><ins> &amp;&amp; type2 == </ins><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><ins> then
        op2 = </ins><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><ins>FPInfinity</ins></a><ins>('1');

    return </ins><a href="shared_pseudocode.html#impl-shared.FPMax.3" title="function: bits(N) FPMax(bits(N) op1, bits(N) op2, FPCRType fpcr)"><ins>FPMax</ins></a><ins>(op1, op2, fpcr);</ins><del>(real_operand, fpcr, rounding);

    return result;</del></p></div><div class="ps" psname="shared.functions.float.fpmin.FPMin"><a id="shared.functions.float.fpmin.FPMin" name="shared.functions.float.fpmin.FPMin"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fpmin</ins><del>fpabs</del>/<ins>FPMin</ins><del>FPAbs</del></h3><p class="pseudocode"><ins>// FPMin()
</ins><del>// FPAbs()
</del>// =======

bits(N) <a id="impl-shared.FPMin.3" name="impl-shared.FPMin.3"></a><ins>FPMin(bits(N) op1, bits(N) op2,</ins><del>FPAbs(bits(N) op)
    assert N IN {16,32,64};
    return '0' : op&lt;N-2:0>;</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><ins>FPCRType</ins></a><ins> fpcr)
    assert N IN {16,32,64};
    (type1,sign1,value1) = </ins><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><ins>(op1, fpcr);
    (type2,sign2,value2) = </ins><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><ins>(op2, fpcr);
    (done,result) = </ins><a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2, FPCRType fpcr)"><ins>FPProcessNaNs</ins></a><ins>(type1, type2, op1, op2, fpcr);
    if !done then
        if value1 &lt; value2 then
            (type,sign,value) = (type1,sign1,value1);
        else
            (type,sign,value) = (type2,sign2,value2);
        if type == </ins><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><ins> then
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><ins>FPInfinity</ins></a><ins>(sign);
        elsif type == </ins><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><ins> then
            sign = sign1 OR sign2; // Use most negative sign
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><ins>FPZero</ins></a><ins>(sign);
        else
            // The use of FPRound() covers the case where there is a trapped underflow exception
            // for a denormalized number even though the result is exact.
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPRound.2" title="function: bits(N) FPRound(real op, FPCRType fpcr)"><ins>FPRound</ins></a><ins>(value, fpcr);
    return result;</ins></p></div><div class="ps" psname="shared.functions.float.fpminnum.FPMinNum"><a id="shared.functions.float.fpminnum.FPMinNum" name="shared.functions.float.fpminnum.FPMinNum"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fpminnum</ins><del>fpadd</del>/<ins>FPMinNum</ins><del>FPAdd</del></h3><p class="pseudocode"><ins>// FPMinNum()
// ==========
</ins><del>// FPAdd()
// =======
</del>
bits(N) <a id="impl-shared.FPMinNum.3" name="impl-shared.FPMinNum.3"></a><ins>FPMinNum(bits(N) op1, bits(N) op2,</ins><del>FPAdd(bits(N) op1, bits(N) op2,</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    assert N IN {16,32,64};
<ins>    (type1,-,-) =</ins><del>    rounding =</del> <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)"><del>FPRoundingMode</del></a><del>(fpcr);
    (type1,sign1,value1) = </del><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op1, fpcr);
<ins>    (type2,-,-) =</ins><del>    (type2,sign2,value2) =</del> <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op2, fpcr);
<ins>
    // Treat a single quiet-NaN as +Infinity
    if type1 ==</ins><del>    (done,result) =</del> <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2, FPCRType fpcr)"><del>FPProcessNaNs</del></a> <ins>&amp;&amp; type2 !=</ins><del>(type1, type2, op1, op2, fpcr);
    if !done then
        inf1 = (type1 ==</del> <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a> <ins>then
        op1 =</ins><del>);  inf2 = (type2 ==</del> <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><ins>FPInfinity</ins></a><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a><ins>('0');
    elsif type1 !=</ins><del>);
        zero1 = (type1 ==</del> <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a> <ins>&amp;&amp; type2 ==</ins><del>);     zero2 = (type2 ==</del> <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a> <ins>then
        op2 =</ins><del>);
        if inf1 &amp;&amp; inf2 &amp;&amp; sign1 == NOT(sign2) then
            result =</del> <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.0" title="function: bits(N) FPDefaultNaN()"><del>FPDefaultNaN</del></a><del>();
            </del><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a><del>(</del><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_InvalidOp</del></a><del>, fpcr);
        elsif (inf1 &amp;&amp; sign1 == '0') || (inf2 &amp;&amp; sign2 == '0') then
            result = </del><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('0');
<ins>
    return</ins><del>        elsif (inf1 &amp;&amp; sign1 == '1') || (inf2 &amp;&amp; sign2 == '1') then
            result =</del> <del>('1');
        elsif zero1 &amp;&amp; zero2 &amp;&amp; sign1 == sign2 then
            result = </del><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><del>FPZero</del></a><del>(sign1);
        else
            result_value = value1 + value2;
            if result_value == 0.0 then  // Sign of exact zero result depends on rounding mode
                result_sign = if rounding == </del><a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_NEGINF</del></a><del> then '1' else '0';
                result = </del><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><del>FPZero</del></a><del>(result_sign);
            else
                result = </del><a href="shared_pseudocode.html#impl-shared.FPRound.3" title="function: bits(N) FPRound(real op, FPCRType fpcr, FPRounding rounding)"><del>FPRound</del></a><a href="shared_pseudocode.html#impl-shared.FPMin.3" title="function: bits(N) FPMin(bits(N) op1, bits(N) op2, FPCRType fpcr)"><ins>FPMin</ins></a><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><del>FPInfinity</del></a><ins>(op1, op2, fpcr);</ins><del>(result_value, fpcr, rounding);
    return result;</del></p></div><div class="ps" psname="shared.functions.float.fpmul.FPMul"><a id="shared.functions.float.fpmul.FPMul" name="shared.functions.float.fpmul.FPMul"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fpmul</ins><del>fpcompare</del>/<ins>FPMul</ins><del>FPCompare</del></h3><p class="pseudocode"><ins>// FPMul()
// =======
</ins><del>// FPCompare()
// ===========
</del>
<ins>bits(N)</ins><del>bits(4)</del> <a id="impl-shared.FPMul.3" name="impl-shared.FPMul.3"></a><ins>FPMul(bits(N) op1, bits(N) op2,</ins><del>FPCompare(bits(N) op1, bits(N) op2, boolean signal_nans,</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    assert N IN {16,32,64};
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op2, fpcr);
<ins>    (done,result) =</ins><del>    if type1==</del> <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2, FPCRType fpcr)"><ins>FPProcessNaNs</ins></a><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><ins>(type1, type2, op1, op2, fpcr);
    if !done then
        inf1 = (type1 ==</ins><del>|| type1==</del> <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><ins>);
        inf2 = (type2 ==</ins><del>|| type2==</del> <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><ins>);
        zero1 = (type1 ==</ins><del>|| type2==</del> <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><ins>);
        zero2 = (type2 ==</ins><del>then
        result = '0011';
        if type1==</del> <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><ins>);
        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            result =</ins><del>|| type2==</del> <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.0" title="function: bits(N) FPDefaultNaN()"><ins>FPDefaultNaN</ins></a><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><ins>();</ins><del>|| signal_nans then</del>
            <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a><ins>, fpcr);
        elsif inf1 || inf2 then
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><ins>FPInfinity</ins></a><ins>(sign1 EOR sign2);
        elsif zero1 || zero2 then
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><ins>FPZero</ins></a><ins>(sign1 EOR sign2);
        else
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPRound.2" title="function: bits(N) FPRound(real op, FPCRType fpcr)"><ins>FPRound</ins></a><ins>(value1*value2, fpcr);
</ins><del>, fpcr);
    else
        // All non-NaN cases can be evaluated on the values produced by FPUnpack()
        if value1 == value2 then
            result = '0110';
        elsif value1 &lt; value2 then
            result = '1000';
        else  // value1 > value2
            result = '0010';
</del>    return result;</p></div><div class="ps" psname="shared.functions.float.fpmuladd.FPMulAdd"><a id="shared.functions.float.fpmuladd.FPMulAdd" name="shared.functions.float.fpmuladd.FPMulAdd"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fpmuladd</ins><del>fpcompareeq</del>/<ins>FPMulAdd</ins><del>FPCompareEQ</del></h3><p class="pseudocode"><ins>// FPMulAdd()
// ==========
//
// Calculates addend + op1*op2 with a single rounding.
</ins><del>// FPCompareEQ()
// =============
</del>
<ins>bits(N)</ins><del>boolean</del> <a id="impl-shared.FPMulAdd.4" name="impl-shared.FPMulAdd.4"></a><ins>FPMulAdd(bits(N) addend, bits(N) op1, bits(N) op2,</ins><del>FPCompareEQ(bits(N) op1, bits(N) op2,</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    assert N IN {16,32,64};
<ins>    rounding =</ins><del>    (type1,sign1,value1) =</del> <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)"><ins>FPRoundingMode</ins></a><ins>(fpcr);
    (typeA,signA,valueA) = </ins><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a><ins>(addend, fpcr);
    (type1,sign1,value1) =</ins><del>(op1, fpcr);
    (type2,sign2,value2) =</del> <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a><ins>(op1, fpcr);
    (type2,sign2,value2) =</ins><del>(op2, fpcr);
    if type1==</del> <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><ins>(op2, fpcr);
    inf1 = (type1 ==</ins><del>|| type1==</del> <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><ins>); zero1 = (type1 ==</ins><del>|| type2==</del> <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><ins>);
    inf2 = (type2 ==</ins><del>|| type2==</del> <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><ins>); zero2 = (type2 == </ins><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><ins>);
    (done,result) = </ins><a href="shared_pseudocode.html#impl-shared.FPProcessNaNs3.7" title="function: (boolean, bits(N)) FPProcessNaNs3(FPType type1, FPType type2, FPType type3, bits(N) op1, bits(N) op2, bits(N) op3, FPCRType fpcr)"><ins>FPProcessNaNs3</ins></a><ins>(typeA, type1, type2, addend, op1, op2, fpcr);

    if typeA == </ins><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}">FPType_QNaN</a> <ins>&amp;&amp; ((inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2)) then
        result =</ins><del>then
        result = FALSE;
        if type1==</del> <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.0" title="function: bits(N) FPDefaultNaN()"><ins>FPDefaultNaN</ins></a><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><ins>();</ins><del>|| type2==</del>
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><ins>(</ins><del>then</del><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_InvalidOp</ins></a><ins>, fpcr);

    if !done then
        infA = (typeA == </ins><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><ins>);  zeroA = (typeA == </ins><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><ins>);

        // Determine sign and type product will have if it does not cause an Invalid
        // Operation.
        signP = sign1 EOR sign2;
        infP  = inf1 || inf2;
        zeroP = zero1 || zero2;

        // Non SNaN-generated Invalid Operation cases are multiplies of zero by infinity and
        // additions of opposite-signed infinities.
        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) || (infA &amp;&amp; infP &amp;&amp; signA != signP) then
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.0" title="function: bits(N) FPDefaultNaN()"><ins>FPDefaultNaN</ins></a><ins>();
            </ins><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a><ins>, fpcr);

        // Other cases involving infinities produce an infinity of the same sign.
        elsif (infA &amp;&amp; signA == '0') || (infP &amp;&amp; signP == '0') then
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><ins>FPInfinity</ins></a><ins>('0');
        elsif (infA &amp;&amp; signA == '1') || (infP &amp;&amp; signP == '1') then
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><ins>FPInfinity</ins></a><ins>('1');

        // Cases where the result is exactly zero and its sign is not determined by the
        // rounding mode are additions of same-signed zeros.
        elsif zeroA &amp;&amp; zeroP &amp;&amp; signA == signP then
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><ins>FPZero</ins></a><ins>(signA);

        // Otherwise calculate numerical result and round it.
        else
            result_value = valueA + (value1 * value2);
            if result_value == 0.0 then  // Sign of exact zero result depends on rounding mode
                result_sign = if rounding == </ins><a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_NEGINF</ins></a><ins> then '1' else '0';
                result = </ins><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><ins>FPZero</ins></a><ins>(result_sign);
            else
                result = </ins><a href="shared_pseudocode.html#impl-shared.FPRound.2" title="function: bits(N) FPRound(real op, FPCRType fpcr)"><ins>FPRound</ins></a><ins>(result_value, fpcr);

</ins><del>, fpcr);
    else
        // All non-NaN cases can be evaluated on the values produced by FPUnpack()
        result = (value1 == value2);
</del>    return result;</p></div><div class="ps" psname="shared.functions.float.fpmuladdh.FPMulAddH"><a id="shared.functions.float.fpmuladdh.FPMulAddH" name="shared.functions.float.fpmuladdh.FPMulAddH"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fpmuladdh</ins><del>fpcomparege</del>/<ins>FPMulAddH</ins><del>FPCompareGE</del></h3><p class="pseudocode"><ins>// FPMulAddH()
// ===========
</ins><del>// FPCompareGE()
// =============
</del>
<ins>bits(N) FPMulAddH(bits(N) addend, bits(N DIV 2) op1, bits(N DIV 2) op2,</ins><del>boolean</del> <a id="impl-shared.FPCompareGE.3" name="impl-shared.FPCompareGE.3"></a><del>FPCompareGE(bits(N) op1, bits(N) op2, </del><a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
<ins>    assert N IN {32,64};
    rounding =</ins><del>    assert N IN {16,32,64};
    (type1,sign1,value1) =</del> <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)"><ins>FPRoundingMode</ins></a><ins>(fpcr);
    (typeA,signA,valueA) = </ins><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a><ins>(addend, fpcr);
    (type1,sign1,value1) =</ins><del>(op1, fpcr);
    (type2,sign2,value2) =</del> <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a><ins>(op1, fpcr);
    (type2,sign2,value2) =</ins><del>(op2, fpcr);
    if type1==</del> <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><ins>(op2, fpcr);
    inf1 = (type1 ==</ins><del>|| type1==</del> <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><ins>); zero1 = (type1 ==</ins><del>|| type2==</del> <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><ins>);
    inf2 = (type2 ==</ins><del>|| type2==</del> <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><ins>); zero2 = (type2 == </ins><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><ins>);
    (done,result) = FPProcessNaNs3H(typeA, type1, type2, addend, op1, op2, fpcr);
    if typeA == </ins><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}">FPType_QNaN</a> <ins>&amp;&amp; ((inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2)) then
        result =</ins><del>then
        result = FALSE;</del> <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.0" title="function: bits(N) FPDefaultNaN()"><ins>FPDefaultNaN</ins></a><ins>();
        </ins><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a><ins>, fpcr);
    if !done then
        infA = (typeA == </ins><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><ins>); zeroA = (typeA == </ins><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><ins>);
        // Determine sign and type product will have if it does not cause an Invalid
        // Operation.
        signP = sign1 EOR sign2;
        infP = inf1 || inf2;
        zeroP = zero1 || zero2;
        // Non SNaN-generated Invalid Operation cases are multiplies of zero by infinity and
        // additions of opposite-signed infinities.
        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) || (infA &amp;&amp; infP &amp;&amp; signA != signP) then
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.0" title="function: bits(N) FPDefaultNaN()"><ins>FPDefaultNaN</ins></a><ins>();
            </ins><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><ins>(</ins><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_InvalidOp</ins></a><ins>, fpcr);
        // Other cases involving infinities produce an infinity of the same sign.
        elsif (infA &amp;&amp; signA == '0') || (infP &amp;&amp; signP == '0') then
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><ins>FPInfinity</ins></a><ins>('0');
        elsif (infA &amp;&amp; signA == '1') || (infP &amp;&amp; signP == '1') then
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><ins>FPInfinity</ins></a><ins>('1');
        // Cases where the result is exactly zero and its sign is not determined by the
        // rounding mode are additions of same-signed zeros.
        elsif zeroA &amp;&amp; zeroP &amp;&amp; signA == signP then
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><ins>FPZero</ins></a><ins>(signA);
        // Otherwise calculate numerical result and round it.
        else
            result_value = valueA + (value1 * value2);
            if result_value == 0.0 then // Sign of exact zero result depends on rounding mode
                result_sign = if rounding == </ins><a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_NEGINF</ins></a><ins> then '1' else '0';
                result = </ins><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><ins>FPZero</ins></a><ins>(result_sign);
            else
                result = </ins><a href="shared_pseudocode.html#impl-shared.FPRound.2" title="function: bits(N) FPRound(real op, FPCRType fpcr)"><ins>FPRound</ins></a><ins>(result_value, fpcr);
</ins><del>, fpcr);
    else
        // All non-NaN cases can be evaluated on the values produced by FPUnpack()
        result = (value1 >= value2);
</del>    return result;</p></div><div class="ps" psname="shared.functions.float.fpmuladdh.FPProcessNaNs3H"><a id="shared.functions.float.fpmuladdh.FPProcessNaNs3H" name="shared.functions.float.fpmuladdh.FPProcessNaNs3H"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fpmuladdh</ins><del>fpcomparegt</del>/<ins>FPProcessNaNs3H</ins><del>FPCompareGT</del></h3><p class="pseudocode"><ins>// FPProcessNaNs3H()
// =================
</ins><del>// FPCompareGT()
// =============
</del>
<ins>(boolean, bits(N)) FPProcessNaNs3H(</ins><del>boolean</del><a href="shared_pseudocode.html#FPType" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType</ins></a> <ins>type1,</ins><del>FPCompareGT(bits(N) op1, bits(N) op2,</del> <a href="shared_pseudocode.html#FPType" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType</ins></a><ins> type2, </ins><a href="shared_pseudocode.html#FPType" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType</ins></a><ins> type3, bits(N) op1, bits(N DIV 2) op2, bits(N DIV 2) op3, </ins><a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
<ins>    assert N IN {32,64};
    bits(N) result;
    if type1 ==</ins><del>    assert N IN {16,32,64};
    (type1,sign1,value1) =</del> <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a> <ins>then
        done = TRUE; result =</ins><del>(op1, fpcr);
    (type2,sign2,value2) =</del> <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><ins>FPProcessNaN</ins></a><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a><ins>(type1, op1, fpcr);
    elsif type2 ==</ins><del>(op2, fpcr);
    if type1==</del> <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}">FPType_SNaN</a> <ins>then
        done = TRUE; result =</ins><del>|| type1==</del> <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.1" title="function: bits(M) FPConvertNaN(bits(N) op)"><ins>FPConvertNaN</ins></a><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><ins>(</ins><del>|| type2==</del><a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><ins>FPProcessNaN</ins></a><ins>(type2, op2, fpcr));
    elsif type3 == </ins><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}">FPType_SNaN</a> <ins>then
        done = TRUE; result =</ins><del>|| type2==</del> <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.1" title="function: bits(M) FPConvertNaN(bits(N) op)"><ins>FPConvertNaN</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><ins>FPProcessNaN</ins></a><ins>(type3, op3, fpcr));
    elsif type1 == </ins><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}">FPType_QNaN</a> then
<ins>        done = TRUE; result =</ins><del>        result = FALSE;</del> <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><ins>FPProcessNaN</ins></a><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a><ins>(type1, op1, fpcr);
    elsif type2 ==</ins><del>(</del> <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_InvalidOp</del></a><ins> then
        done = TRUE; result = </ins><a href="shared_pseudocode.html#impl-shared.FPConvertNaN.1" title="function: bits(M) FPConvertNaN(bits(N) op)"><ins>FPConvertNaN</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><ins>FPProcessNaN</ins></a><ins>(type2, op2, fpcr));
    elsif type3 == </ins><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><ins> then
        done = TRUE; result = </ins><a href="shared_pseudocode.html#impl-shared.FPConvertNaN.1" title="function: bits(M) FPConvertNaN(bits(N) op)"><ins>FPConvertNaN</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><ins>FPProcessNaN</ins></a><ins>(type3, op3, fpcr));
    else
        done = FALSE; result = </ins><a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><ins>Zeros</ins></a><ins>(); // 'Don't care' result
    return (done, result);</ins><del>, fpcr);
    else
        // All non-NaN cases can be evaluated on the values produced by FPUnpack()
        result = (value1 > value2);
    return result;</del></p></div><div class="ps" psname="shared.functions.float.fpmulx.FPMulX"><a id="shared.functions.float.fpmulx.FPMulX" name="shared.functions.float.fpmulx.FPMulX"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fpmulx</ins><del>fpconvert</del>/<ins>FPMulX</ins><del>FPConvert</del></h3><p class="pseudocode"><ins>// FPMulX()
// ========
</ins><del>// FPConvert()
// ===========
</del>
<ins>bits(N)</ins><del>// Convert floating point OP with N-bit precision to M-bit precision,
// with rounding controlled by ROUNDING.
// This is used by the FP-to-FP conversion instructions and so for
// half-precision data ignores FZ16, but observes AHP.

bits(M)</del> <a id="impl-shared.FPMulX.3" name="impl-shared.FPMulX.3"></a><ins>FPMulX(bits(N) op1, bits(N) op2,</ins><del>FPConvert(bits(N) op,</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> <ins>fpcr)
    assert N IN {16,32,64};
    bits(N) result;
    (type1,sign1,value1) =</ins><del>fpcr,</del> <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding</del></a><ins>(op1, fpcr);
    (type2,sign2,value2) =</ins><del>rounding)
    assert M IN {16,32,64};
    assert N IN {16,32,64};
    bits(M) result;

    // Unpack floating-point operand optionally with flush-to-zero.
    (type,sign,value) =</del> <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><a href="shared_pseudocode.html#impl-shared.FPUnpackCV.2" title="function: (FPType, bit, real) FPUnpackCV(bits(N) fpval, FPCRType fpcr)"><del>FPUnpackCV</del></a><ins>(op2, fpcr);
    (done,result) =</ins><del>(op, fpcr);

    alt_hp = (M == 16) &amp;&amp; (fpcr.AHP == '1');

    if type ==</del> <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2, FPCRType fpcr)"><ins>FPProcessNaNs</ins></a><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><ins>(type1, type2, op1, op2, fpcr);
    if !done then
        inf1 = (type1 ==</ins><del>|| type ==</del> <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><ins>);
        inf2 = (type2 ==</ins><del>then
        if alt_hp then
            result =</del> <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><del>FPZero</del></a><del>(sign);
        elsif fpcr.DN == '1' then
            result = </del><a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.0" title="function: bits(N) FPDefaultNaN()"><del>FPDefaultNaN</del></a><del>();
        else
            result = </del><a href="shared_pseudocode.html#impl-shared.FPConvertNaN.1" title="function: bits(M) FPConvertNaN(bits(N) op)"><del>FPConvertNaN</del></a><del>(op);
        if type == </del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><del> || alt_hp then
            </del><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a><del>(</del><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_InvalidOp</del></a><del>,fpcr);
    elsif type == </del><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}">FPType_Infinity</a><ins>);
        zero1 = (type1 ==</ins><del>then
        if alt_hp then
            result = sign:</del> <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a><ins>);
        zero2 = (type2 ==</ins><del>(M-1);</del> <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a><ins>);
        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            result =</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.FPTwo.1" title="function: bits(N) FPTwo(bit sign)"><ins>FPTwo</ins></a><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_InvalidOp</del></a><ins>(sign1 EOR sign2);
        elsif inf1 || inf2 then
</ins><del>, fpcr);
        else
</del>            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a><ins>(sign1 EOR sign2);
        elsif zero1 || zero2 then
            result =</ins><del>(sign);
    elsif type ==</del> <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a><del> then
        result = </del><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a><ins>(sign1 EOR sign2);
        else
            result =</ins><del>(sign);
    else
        result =</del> <del>(value, fpcr, rounding);
    return result;

// FPConvert()
// ===========

bits(M) </del><a id="impl-shared.FPConvert.2" name="impl-shared.FPConvert.2"></a><del>FPConvert(bits(N) op, </del><a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><del>FPCRType</del></a><del> fpcr)
    return </del><a href="shared_pseudocode.html#impl-shared.FPConvert.3" title="function: bits(M) FPConvert(bits(N) op, FPCRType fpcr, FPRounding rounding)"><del>FPConvert</del></a><del>(op, fpcr, </del><a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)"><del>FPRoundingMode</del></a><a href="shared_pseudocode.html#impl-shared.FPRound.2" title="function: bits(N) FPRound(real op, FPCRType fpcr)"><ins>FPRound</ins></a><a href="shared_pseudocode.html#impl-shared.FPRoundCV.3" title="function: bits(N) FPRoundCV(real op, FPCRType fpcr, FPRounding rounding)"><del>FPRoundCV</del></a><ins>(value1*value2, fpcr);
    return result;</ins><del>(fpcr));</del></p></div><div class="ps" psname="shared.functions.float.fpneg.FPNeg"><a id="shared.functions.float.fpneg.FPNeg" name="shared.functions.float.fpneg.FPNeg"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fpneg</ins><del>fpconvertnan</del>/<ins>FPNeg</ins><del>FPConvertNaN</del></h3><p class="pseudocode"><ins>// FPNeg()
// =======
</ins><del>// FPConvertNaN()
// ==============
</del>
<ins>bits(N)</ins><del>// Converts a NaN of one floating-point type to another

bits(M)</del> <a id="impl-shared.FPNeg.1" name="impl-shared.FPNeg.1"></a><ins>FPNeg(bits(N) op)
</ins><del>FPConvertNaN(bits(N) op)
</del>    assert N IN {16,32,64};
<ins>    return NOT(op&lt;N-1>) : op&lt;N-2:0>;</ins><del>    assert M IN {16,32,64};
    bits(M) result;
    bits(51) frac;

    sign = op&lt;N-1>;

    // Unpack payload from input NaN
    case N of
        when 64 frac = op&lt;50:0>;
        when 32 frac = op&lt;21:0>:</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(29);
        when 16 frac = op&lt;8:0>:</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(42);

    // Repack payload into output NaN, while
    // converting an SNaN to a QNaN.
    case M of
        when 64 result = sign:</del><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a><del>(M-52):frac;
        when 32 result = sign:</del><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a><del>(M-23):frac&lt;50:29>;
        when 16 result = sign:</del><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a><del>(M-10):frac&lt;50:42>;

    return result;</del></p></div><div class="ps" psname="shared.functions.float.fponepointfive.FPOnePointFive"><a id="shared.functions.float.fponepointfive.FPOnePointFive" name="shared.functions.float.fponepointfive.FPOnePointFive"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fponepointfive</ins><del>fpcrtype</del>/<ins>FPOnePointFive</ins><del>FPCRType</del></h3><p class="pseudocode"><ins>// FPOnePointFive()
// ================

bits(N)</ins><del>type</del> <a id="impl-shared.FPOnePointFive.1" name="impl-shared.FPOnePointFive.1"></a><ins>FPOnePointFive(bit sign)
    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp  = '0':</ins><del>FPCRType;</del><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><ins>(E-1);
    frac = '1':</ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(F-1);
    return sign : exp : frac;</ins></p></div><div class="ps" psname="shared.functions.float.fpprocessexception.FPProcessException"><a id="shared.functions.float.fpprocessexception.FPProcessException" name="shared.functions.float.fpprocessexception.FPProcessException"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fpprocessexception</ins><del>fpdecoderm</del>/<ins>FPProcessException</ins><del>FPDecodeRM</del></h3><p class="pseudocode"><ins>// FPProcessException()
// ====================
//
// The 'fpcr' argument supplies FPCR control bits. Status information is
// updated directly in the FPSR where appropriate.</ins><del>// FPDecodeRM()
// ============

// Decode most common AArch32 floating-point rounding encoding.

FPRounding</del>

<a id="impl-shared.FPProcessException.2" name="impl-shared.FPProcessException.2"></a><ins>FPProcessException(</ins><del>FPDecodeRM(bits(2) rm)
    case rm of
        when '00' return</del><a href="shared_pseudocode.html#FPExc" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc</ins></a><a href="shared_pseudocode.html#FPRounding_TIEAWAY" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_TIEAWAY</del></a> <ins>exception,</ins><del>; // A
        when '01' return</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><ins>FPCRType</ins></a><a href="shared_pseudocode.html#FPRounding_TIEEVEN" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_TIEEVEN</del></a> <ins>fpcr)
    // Determine the cumulative exception bit number
    case exception of
        when</ins><del>; // N
        when '10' return</del> <a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_InvalidOp</ins></a><a href="shared_pseudocode.html#FPRounding_POSINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_POSINF</del></a>     <ins>cumul = 0;
        when</ins><del>;  // P
        when '11' return</del> <a href="shared_pseudocode.html#FPExc_DivideByZero" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_DivideByZero</ins></a><a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_NEGINF</del></a><ins>  cumul = 1;
        when </ins><a href="shared_pseudocode.html#FPExc_Overflow" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_Overflow</ins></a><ins>      cumul = 2;
        when </ins><a href="shared_pseudocode.html#FPExc_Underflow" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_Underflow</ins></a><ins>     cumul = 3;
        when </ins><a href="shared_pseudocode.html#FPExc_Inexact" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_Inexact</ins></a><ins>       cumul = 4;
        when </ins><a href="shared_pseudocode.html#FPExc_InputDenorm" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_InputDenorm</ins></a><ins>   cumul = 7;
    enable = cumul + 8;
    if fpcr&lt;enable> == '1' then
        // Trapping of the exception enabled.
        // It is IMPLEMENTATION DEFINED whether the enable bit may be set at all, and
        // if so then how exceptions may be accumulated before calling FPTrapException()
        IMPLEMENTATION_DEFINED "floating-point trap handling";
    elsif </ins><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>() then
        // Set the cumulative exception bit
        FPSCR&lt;cumul> = '1';
    else
        // Set the cumulative exception bit
        FPSR&lt;cumul> = '1';
    return;</ins><del>;  // M</del></p></div><div class="ps" psname="shared.functions.float.fpprocessnan.FPProcessNaN"><a id="shared.functions.float.fpprocessnan.FPProcessNaN" name="shared.functions.float.fpprocessnan.FPProcessNaN"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fpprocessnan</ins><del>fpdecoderounding</del>/<ins>FPProcessNaN</ins><del>FPDecodeRounding</del></h3><p class="pseudocode"><ins>// FPProcessNaN()
// ==============
</ins><del>// FPDecodeRounding()
// ==================
</del>
<ins>bits(N)</ins><del>// Decode floating-point rounding mode and common AArch64 encoding.

FPRounding</del> <a id="impl-shared.FPProcessNaN.3" name="impl-shared.FPProcessNaN.3"></a><ins>FPProcessNaN(</ins><del>FPDecodeRounding(bits(2) rmode)
    case rmode of
        when '00' return</del><a href="shared_pseudocode.html#FPType" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType</ins></a><a href="shared_pseudocode.html#FPRounding_TIEEVEN" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_TIEEVEN</del></a> <ins>type, bits(N) op,</ins><del>; // N
        when '01' return</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><ins>FPCRType</ins></a><a href="shared_pseudocode.html#FPRounding_POSINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_POSINF</del></a> <ins>fpcr)
    assert N IN {16,32,64};
    assert type IN {</ins><del>;  // P
        when '10' return</del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_NEGINF</del></a><ins>,</ins><del>;  // M
        when '11' return</del> <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><a href="shared_pseudocode.html#FPRounding_ZERO" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_ZERO</del></a><ins>};

    case N of
        when 16 topfrac =  9;
        when 32 topfrac = 22;
        when 64 topfrac = 51;

    result = op;
    if type == </ins><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><ins> then
        result&lt;topfrac> = '1';
        </ins><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><ins>(</ins><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_InvalidOp</ins></a><ins>, fpcr);
    if fpcr.DN == '1' then  // DefaultNaN requested
        result = </ins><a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.0" title="function: bits(N) FPDefaultNaN()"><ins>FPDefaultNaN</ins></a><ins>();
    return result;</ins><del>;    // Z</del></p></div><div class="ps" psname="shared.functions.float.fpprocessnans.FPProcessNaNs"><a id="shared.functions.float.fpprocessnans.FPProcessNaNs" name="shared.functions.float.fpprocessnans.FPProcessNaNs"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fpprocessnans</ins><del>fpdefaultnan</del>/<ins>FPProcessNaNs</ins><del>FPDefaultNaN</del></h3><p class="pseudocode"><ins>// FPProcessNaNs()
// ===============
//
// The boolean part of the return value says whether a NaN has been found and
// processed. The bits(N) part is only relevant if it has and supplies the
// result of the operation.
//
// The 'fpcr' argument supplies FPCR control bits. Status information is
// updated directly in the FPSR where appropriate.
</ins><del>// FPDefaultNaN()
// ==============
</del>
<ins>(boolean, bits(N))</ins><del>bits(N)</del> <a id="impl-shared.FPProcessNaNs.5" name="impl-shared.FPProcessNaNs.5"></a><ins>FPProcessNaNs(</ins><del>FPDefaultNaN()
    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    sign = '0';
    exp  =</del><a href="shared_pseudocode.html#FPType" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType</ins></a><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a><ins> type1, </ins><a href="shared_pseudocode.html#FPType" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType</ins></a><ins> type2,
                                 bits(N) op1, bits(N) op2,
                                 </ins><a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><ins>FPCRType</ins></a><ins> fpcr)
    assert N IN {16,32,64};
    if type1 == </ins><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><ins> then
        done = TRUE;  result = </ins><a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><ins>FPProcessNaN</ins></a><ins>(type1, op1, fpcr);
    elsif type2 == </ins><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><ins> then
        done = TRUE;  result = </ins><a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><ins>FPProcessNaN</ins></a><ins>(type2, op2, fpcr);
    elsif type1 == </ins><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><ins> then
        done = TRUE;  result = </ins><a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><ins>FPProcessNaN</ins></a><ins>(type1, op1, fpcr);
    elsif type2 == </ins><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><ins> then
        done = TRUE;  result = </ins><a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><ins>FPProcessNaN</ins></a><ins>(type2, op2, fpcr);
    else
        done = FALSE;  result =</ins><del>(E);
    frac = '1':</del> <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a><ins>();  // 'Don't care' result
    return (done, result);</ins><del>(F-1);
    return sign : exp : frac;</del></p></div><div class="ps" psname="shared.functions.float.fpprocessnans3.FPProcessNaNs3"><a id="shared.functions.float.fpprocessnans3.FPProcessNaNs3" name="shared.functions.float.fpprocessnans3.FPProcessNaNs3"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fpprocessnans3</ins><del>fpdiv</del>/<ins>FPProcessNaNs3</ins><del>FPDiv</del></h3><p class="pseudocode"><ins>// FPProcessNaNs3()
// ================
//
// The boolean part of the return value says whether a NaN has been found and
// processed. The bits(N) part is only relevant if it has and supplies the
// result of the operation.
//
// The 'fpcr' argument supplies FPCR control bits. Status information is
// updated directly in the FPSR where appropriate.
</ins><del>// FPDiv()
// =======
</del>
<ins>(boolean, bits(N))</ins><del>bits(N)</del> <a id="impl-shared.FPProcessNaNs3.7" name="impl-shared.FPProcessNaNs3.7"></a><ins>FPProcessNaNs3(</ins><del>FPDiv(bits(N) op1, bits(N) op2,</del><a href="shared_pseudocode.html#FPType" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType</ins></a><a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><del>FPCRType</del></a> <ins>type1,</ins><del>fpcr)
    assert N IN {16,32,64};
    (type1,sign1,value1) =</del> <a href="shared_pseudocode.html#FPType" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType</ins></a><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a> <ins>type2,</ins><del>(op1, fpcr);
    (type2,sign2,value2) =</del> <a href="shared_pseudocode.html#FPType" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType</ins></a><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a> <ins>type3,
                                  bits(N) op1, bits(N) op2, bits(N) op3,</ins><del>(op2, fpcr);
    (done,result) =</del>
                                  <a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><ins>FPCRType</ins></a><a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2, FPCRType fpcr)"><del>FPProcessNaNs</del></a> <ins>fpcr)
    assert N IN {16,32,64};
    if type1 ==</ins><del>(type1, type2, op1, op2, fpcr);
    if !done then
        inf1 = (type1 ==</del> <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a> <ins>then
        done = TRUE;  result =</ins><del>);
        inf2 = (type2 ==</del> <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><ins>FPProcessNaN</ins></a><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a><ins>(type1, op1, fpcr);
    elsif type2 ==</ins><del>);
        zero1 = (type1 ==</del> <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a> <ins>then
        done = TRUE;  result =</ins><del>);
        zero2 = (type2 ==</del> <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><ins>FPProcessNaN</ins></a><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a><ins>(type2, op2, fpcr);
    elsif type3 ==</ins><del>);
        if (inf1 &amp;&amp; inf2) || (zero1 &amp;&amp; zero2) then
            result =</del> <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.0" title="function: bits(N) FPDefaultNaN()"><del>FPDefaultNaN</del></a> <ins>then
        done = TRUE;  result =</ins><del>();</del> <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><ins>FPProcessNaN</ins></a><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a><ins>(type3, op3, fpcr);
    elsif type1 ==</ins><del>(</del> <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_InvalidOp</del></a> <ins>then
        done = TRUE;  result =</ins><del>, fpcr);
        elsif inf1 || zero2 then
            result =</del> <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><ins>FPProcessNaN</ins></a><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><del>FPInfinity</del></a><ins>(type1, op1, fpcr);
    elsif type2 ==</ins><del>(sign1 EOR sign2);
            if !inf1 then</del> <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a> <ins>then
        done = TRUE;  result =</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><ins>FPProcessNaN</ins></a><a href="shared_pseudocode.html#FPExc_DivideByZero" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_DivideByZero</del></a><ins>(type2, op2, fpcr);
    elsif type3 ==</ins><del>, fpcr);
        elsif zero1 || inf2 then
            result =</del> <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><del>FPZero</del></a> <ins>then
        done = TRUE;  result =</ins><del>(sign1 EOR sign2);
        else
            result =</del> <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><ins>FPProcessNaN</ins></a><a href="shared_pseudocode.html#impl-shared.FPRound.2" title="function: bits(N) FPRound(real op, FPCRType fpcr)"><del>FPRound</del></a><ins>(type3, op3, fpcr);
    else
        done = FALSE;  result = </ins><a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><ins>Zeros</ins></a><ins>();  // 'Don't care' result
    return (done, result);</ins><del>(value1/value2, fpcr);
    return result;</del></p></div><div class="ps" psname="shared.functions.float.fprecipestimate.FPRecipEstimate"><a id="shared.functions.float.fprecipestimate.FPRecipEstimate" name="shared.functions.float.fprecipestimate.FPRecipEstimate"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fprecipestimate</ins><del>fpexc</del>/<ins>FPRecipEstimate</ins><del>FPExc</del></h3><p class="pseudocode"><ins>// FPRecipEstimate()
// =================

bits(N)</ins><del>enumeration</del> <a id="impl-shared.FPRecipEstimate.2" name="impl-shared.FPRecipEstimate.2"></a><ins>FPRecipEstimate(bits(N) operand,</ins><del>FPExc       {</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><ins>FPCRType</ins></a> <ins>fpcr)
    assert N IN {16,32,64};
    (type,sign,value) =</ins><del>FPExc_InvalidOp,</del> <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><ins>(operand, fpcr);
    if type ==</ins><del>FPExc_DivideByZero,</del> <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a> <ins>|| type ==</ins><del>FPExc_Overflow,</del> <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a> <ins>then
        result =</ins><del>FPExc_Underflow,</del> <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><ins>FPProcessNaN</ins></a><ins>(type, operand, fpcr);
    elsif type ==</ins><del>FPExc_Inexact,</del> <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><ins> then
        result = </ins><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><ins>FPZero</ins></a><ins>(sign);
    elsif type == </ins><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><ins> then
        result = </ins><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><ins>FPInfinity</ins></a><ins>(sign);
        </ins><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><ins>(</ins><a href="shared_pseudocode.html#FPExc_DivideByZero" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_DivideByZero</ins></a><ins>, fpcr);
    elsif (
            (N == 16 &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.Abs.1" title="function: integer Abs(integer x)"><ins>Abs</ins></a><ins>(value) &lt; 2.0^-16) ||
            (N == 32 &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.Abs.1" title="function: integer Abs(integer x)"><ins>Abs</ins></a><ins>(value) &lt; 2.0^-128) ||
            (N == 64 &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.Abs.1" title="function: integer Abs(integer x)"><ins>Abs</ins></a><ins>(value) &lt; 2.0^-1024)
          ) then
        case </ins><a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)"><ins>FPRoundingMode</ins></a><ins>(fpcr) of
            when </ins><a href="shared_pseudocode.html#FPRounding_TIEEVEN" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_TIEEVEN</ins></a><ins>
                overflow_to_inf = TRUE;
            when </ins><a href="shared_pseudocode.html#FPRounding_POSINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_POSINF</ins></a><ins>
                overflow_to_inf = (sign == '0');
            when </ins><a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_NEGINF</ins></a><ins>
                overflow_to_inf = (sign == '1');
            when </ins><a href="shared_pseudocode.html#FPRounding_ZERO" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_ZERO</ins></a><ins>
                overflow_to_inf = FALSE;
        result = if overflow_to_inf then </ins><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><ins>FPInfinity</ins></a><ins>(sign) else </ins><a href="shared_pseudocode.html#impl-shared.FPMaxNormal.1" title="function: bits(N) FPMaxNormal(bit sign)"><ins>FPMaxNormal</ins></a><ins>(sign);
        </ins><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><ins>(</ins><a href="shared_pseudocode.html#FPExc_Overflow" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_Overflow</ins></a><ins>, fpcr);
        </ins><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><ins>(</ins><a href="shared_pseudocode.html#FPExc_Inexact" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_Inexact</ins></a><ins>, fpcr);
    elsif ((fpcr.FZ == '1' &amp;&amp; N != 16) || (fpcr.FZ16 == '1' &amp;&amp; N == 16))
          &amp;&amp; (
               (N == 16 &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.Abs.1" title="function: integer Abs(integer x)"><ins>Abs</ins></a><ins>(value) >= 2.0^14) ||
               (N == 32 &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.Abs.1" title="function: integer Abs(integer x)"><ins>Abs</ins></a><ins>(value) >= 2.0^126) ||
               (N == 64 &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.Abs.1" title="function: integer Abs(integer x)"><ins>Abs</ins></a><ins>(value) >= 2.0^1022)
             ) then
        // Result flushed to zero of correct sign
        result = </ins><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><ins>FPZero</ins></a><ins>(sign);
        if </ins><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>() then
            FPSCR.UFC = '1';
        else
            FPSR.UFC = '1';
    else
        // Scale to a fixed point value in the range 0.5 &lt;= x &lt; 1.0 in steps of 1/512, and
        // calculate result exponent. Scaled value has copied sign bit,
        // exponent = 1022 = double-precision biased version of -1,
        // fraction = original fraction
        case N of
            when 16
                fraction = operand&lt;9:0> : </ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(42);
                exp = </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(operand&lt;14:10>);
            when 32
                fraction = operand&lt;22:0> : </ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(29);
                exp = </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(operand&lt;30:23>);
            when 64
                fraction = operand&lt;51:0>;
                exp = </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(operand&lt;62:52>);

        if exp == 0 then
            if fraction&lt;51> == 0 then
                exp = -1;
                fraction = fraction&lt;49:0>:'00';
            else
                fraction = fraction&lt;50:0>:'0';

        integer scaled = </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>('1':fraction&lt;51:44>);

        case N of
            when 16 result_exp =   29 - exp; // In range 29-30 = -1 to 29+1 = 30
            when 32 result_exp =  253 - exp; // In range 253-254 = -1 to 253+1 = 254
            when 64 result_exp = 2045 - exp; // In range 2045-2046 = -1 to 2045+1 = 2046

        // scaled is in range 256..511 representing a fixed-point number in range [0.5..1.0)
        estimate = </ins><a href="shared_pseudocode.html#impl-shared.RecipEstimate.1" title="function: integer RecipEstimate(integer a)"><ins>RecipEstimate</ins></a><ins>(scaled);

        // estimate is in the range 256..511 representing a fixed point result in the range [1.0..2.0)
        // Convert to scaled floating point result with copied sign bit,
        // high-order bits from estimate, and exponent calculated above.

        fraction = estimate&lt;7:0> : </ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(44);
        if result_exp == 0 then
            fraction = '1' : fraction&lt;51:1>;
        elsif result_exp == -1 then
            fraction = '01' : fraction&lt;51:2>;
            result_exp = 0;

        case N of
            when 16 result = sign : result_exp&lt;N-12:0> : fraction&lt;51:42>;
            when 32 result = sign : result_exp&lt;N-25:0> : fraction&lt;51:29>;
            when 64 result = sign : result_exp&lt;N-54:0> : fraction&lt;51:0>;

    return result;</ins><del>FPExc_InputDenorm};</del></p></div><div class="ps" psname="shared.functions.float.fprecipestimate.RecipEstimate"><a id="shared.functions.float.fprecipestimate.RecipEstimate" name="shared.functions.float.fprecipestimate.RecipEstimate"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fprecipestimate</ins><del>fpinfinity</del>/<ins>RecipEstimate</ins><del>FPInfinity</del></h3><p class="pseudocode"><ins>// Compute estimate of reciprocal of 9-bit fixed-point number
//
// a is in range 256 .. 511 representing a number in the range 0.5 &lt;= x &lt; 1.0.
// result is in the range 256 .. 511 representing a number in the range in the range 1.0 to 511/256.
</ins><del>// FPInfinity()
// ============
</del>
<ins>integer</ins><del>bits(N)</del> <a id="impl-shared.RecipEstimate.1" name="impl-shared.RecipEstimate.1"></a><ins>RecipEstimate(integer a)
    assert 256 &lt;= a &amp;&amp; a &lt; 512;
    a = a*2+1; // round to nearest
    integer b = (2 ^ 19) DIV a;
    r = (b+1) DIV 2; // round to nearest
    assert 256 &lt;= r &amp;&amp; r &lt; 512;
    return r;</ins><del>FPInfinity(bit sign)
    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp  =</del><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a><del>(E);
    frac = </del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(F);
    return sign : exp : frac;</del></p></div><div class="ps" psname="shared.functions.float.fprecpx.FPRecpX"><a id="shared.functions.float.fprecpx.FPRecpX" name="shared.functions.float.fprecpx.FPRecpX"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fprecpx</ins><del>fpmax</del>/<ins>FPRecpX</ins><del>FPMax</del></h3><p class="pseudocode"><ins>// FPRecpX()
// =========
</ins><del>// FPMax()
// =======
</del>
bits(N) <a id="impl-shared.FPRecpX.2" name="impl-shared.FPRecpX.2"></a><ins>FPRecpX(bits(N) op,</ins><del>FPMax(bits(N) op1, bits(N) op2,</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    assert N IN {16,32,64};
<ins>
    case N of
        when 16 esize =  5;
        when 32 esize =  8;
        when 64 esize = 11;

    bits(N)           result;
    bits(esize)       exp;
    bits(esize)       max_exp;
    bits(N-(esize+1)) frac =</ins><del>    (type1,sign1,value1) =</del> <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><ins>Zeros</ins></a><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a><ins>();

    case N of
        when 16 exp = op&lt;10+esize-1:10>;
        when 32 exp = op&lt;23+esize-1:23>;
        when 64 exp = op&lt;52+esize-1:52>;

    max_exp =</ins><del>(op1, fpcr);
    (type2,sign2,value2) =</del> <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><ins>(esize) - 1;

    (type,sign,value) = </ins><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a><ins>(op, fpcr);
    if type ==</ins><del>(op2, fpcr);
    (done,result) =</del> <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2, FPCRType fpcr)"><del>FPProcessNaNs</del></a> <ins>|| type ==</ins><del>(type1, type2, op1, op2, fpcr);
    if !done then
        if value1 > value2 then
            (type,sign,value) = (type1,sign1,value1);
        else
            (type,sign,value) = (type2,sign2,value2);
        if type ==</del> <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><ins>FPProcessNaN</ins></a><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><del>FPInfinity</del></a><ins>(type, op, fpcr);
    else
        if</ins><del>(sign);
        elsif type ==</del> <del> then
            sign = sign1 AND sign2; // Use most positive sign
            result = </del><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><del>FPZero</del></a><del>(sign);
        else
            // The use of FPRound() covers the case where there is a trapped underflow exception
            // for a denormalized number even though the result is exact.
            result = </del><a href="shared_pseudocode.html#impl-shared.FPRound.2" title="function: bits(N) FPRound(real op, FPCRType fpcr)"><del>FPRound</del></a><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a><ins>(exp) then // Zero and denormals
            result = sign:max_exp:frac;
        else // Infinities and normals
            result = sign:NOT(exp):frac;

</ins><del>(value, fpcr);
</del>    return result;</p></div><div class="ps" psname="shared.functions.float.fpround.FPRound"><a id="shared.functions.float.fpround.FPRound" name="shared.functions.float.fpround.FPRound"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fpround</ins><del>fpmaxnormal</del>/<ins>FPRound</ins><del>FPMaxNormal</del></h3><p class="pseudocode"><ins>// FPRound()
// =========
// Used by data processing and int/fixed &lt;-> FP conversion instructions.
// For half-precision data it ignores AHP, and observes FZ16.
</ins><del>// FPMaxNormal()
// =============
</del>
bits(N) <a id="impl-shared.FPRound.3" name="impl-shared.FPRound.3"></a><ins>FPRound(real op,</ins><del>FPMaxNormal(bit sign)
    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp  =</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><ins>FPCRType</ins></a><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a> <ins>fpcr,</ins><del>(E-1):'0';
    frac =</del> <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding</ins></a><ins> rounding)
    fpcr.AHP = '0';
    return </ins><a href="shared_pseudocode.html#impl-shared.FPRoundBase.3" title="function: bits(N) FPRoundBase(real op, FPCRType fpcr, FPRounding rounding)"><ins>FPRoundBase</ins></a><ins>(op, fpcr, rounding);

// Convert a real number OP into an N-bit floating-point value using the
// supplied rounding mode RMODE.

bits(N) </ins><a id="impl-shared.FPRoundBase.3" name="impl-shared.FPRoundBase.3"></a><ins>FPRoundBase(real op, </ins><a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><ins>FPCRType</ins></a><ins> fpcr, </ins><a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding</ins></a><ins> rounding)
    assert N IN {16,32,64};
    assert op != 0.0;
    assert rounding != </ins><a href="shared_pseudocode.html#FPRounding_TIEAWAY" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_TIEAWAY</ins></a><ins>;
    bits(N) result;

    // Obtain format parameters - minimum exponent, numbers of exponent and fraction bits.
    if N == 16 then
        minimum_exp = -14;  E = 5;  F = 10;
    elsif N == 32 then
        minimum_exp = -126;  E = 8;  F = 23;
    else  // N == 64
        minimum_exp = -1022;  E = 11;  F = 52;

    // Split value into sign, unrounded mantissa and exponent.
    if op &lt; 0.0 then
        sign = '1';  mantissa = -op;
    else
        sign = '0';  mantissa = op;
    exponent = 0;
    while mantissa &lt; 1.0 do
        mantissa = mantissa * 2.0;  exponent = exponent - 1;
    while mantissa >= 2.0 do
        mantissa = mantissa / 2.0;  exponent = exponent + 1;

    // Deal with flush-to-zero.
    if ((fpcr.FZ == '1' &amp;&amp; N != 16) || (fpcr.FZ16 == '1' &amp;&amp; N == 16)) &amp;&amp; exponent &lt; minimum_exp then
        // Flush-to-zero never generates a trapped exception
        if </ins><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>() then
            FPSCR.UFC = '1';
        else
            FPSR.UFC = '1';
        return </ins><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><ins>FPZero</ins></a><ins>(sign);

    // Start creating the exponent value for the result. Start by biasing the actual exponent
    // so that the minimum exponent becomes 1, lower values 0 (indicating possible underflow).
    biased_exp = </ins><a href="shared_pseudocode.html#impl-shared.Max.2" title="function: integer Max(integer a, integer b)"><ins>Max</ins></a><ins>(exponent - minimum_exp + 1, 0);
    if biased_exp == 0 then mantissa = mantissa / 2.0^(minimum_exp - exponent);

    // Get the unrounded mantissa as an integer, and the "units in last place" rounding error.
    int_mant = </ins><a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)"><ins>RoundDown</ins></a><ins>(mantissa * 2.0^F);  // &lt; 2.0^F if biased_exp == 0, >= 2.0^F if not
    error = mantissa * 2.0^F - Real(int_mant);

    // Underflow occurs if exponent is too small before rounding, and result is inexact or
    // the Underflow exception is trapped.
    if biased_exp == 0 &amp;&amp; (error != 0.0 || fpcr.UFE == '1') then
        </ins><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><ins>(</ins><a href="shared_pseudocode.html#FPExc_Underflow" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_Underflow</ins></a><ins>, fpcr);

    // Round result according to rounding mode.
    case rounding of
        when </ins><a href="shared_pseudocode.html#FPRounding_TIEEVEN" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_TIEEVEN</ins></a><ins>
            round_up = (error > 0.5 || (error == 0.5 &amp;&amp; int_mant&lt;0> == '1'));
            overflow_to_inf = TRUE;
        when </ins><a href="shared_pseudocode.html#FPRounding_POSINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_POSINF</ins></a><ins>
            round_up = (error != 0.0 &amp;&amp; sign == '0');
            overflow_to_inf = (sign == '0');
        when </ins><a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_NEGINF</ins></a><ins>
            round_up = (error != 0.0 &amp;&amp; sign == '1');
            overflow_to_inf = (sign == '1');
        when </ins><a href="shared_pseudocode.html#FPRounding_ZERO" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_ZERO</ins></a><ins>, </ins><a href="shared_pseudocode.html#FPRounding_ODD" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_ODD</ins></a><ins>
            round_up = FALSE;
            overflow_to_inf = FALSE;

    if round_up then
        int_mant = int_mant + 1;
        if int_mant == 2^F then      // Rounded up from denormalized to normalized
            biased_exp = 1;
        if int_mant == 2^(F+1) then  // Rounded up to next exponent
            biased_exp = biased_exp + 1;  int_mant = int_mant DIV 2;

    // Handle rounding to odd aka Von Neumann rounding
    if error != 0.0 &amp;&amp; rounding == </ins><a href="shared_pseudocode.html#FPRounding_ODD" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_ODD</ins></a><ins> then
        int_mant&lt;0> = '1';

    // Deal with overflow and generate result.
    if N != 16 || fpcr.AHP == '0' then  // Single, double or IEEE half precision
        if biased_exp >= 2^E - 1 then
            result = if overflow_to_inf then </ins><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><ins>FPInfinity</ins></a><ins>(sign) else </ins><a href="shared_pseudocode.html#impl-shared.FPMaxNormal.1" title="function: bits(N) FPMaxNormal(bit sign)"><ins>FPMaxNormal</ins></a><ins>(sign);
            </ins><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><ins>(</ins><a href="shared_pseudocode.html#FPExc_Overflow" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_Overflow</ins></a><ins>, fpcr);
            error = 1.0;  // Ensure that an Inexact exception occurs
        else
            result = sign : biased_exp&lt;N-F-2:0> : int_mant&lt;F-1:0>;
    else                                     // Alternative half precision
        if biased_exp >= 2^E then
            result = sign : </ins><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a><ins>(N-1);
            </ins><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><ins>(</ins><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_InvalidOp</ins></a><ins>, fpcr);
            error = 0.0;  // Ensure that an Inexact exception does not occur
        else
            result = sign : biased_exp&lt;N-F-2:0> : int_mant&lt;F-1:0>;

    // Deal with Inexact exception.
    if error != 0.0 then
        </ins><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><ins>(</ins><a href="shared_pseudocode.html#FPExc_Inexact" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_Inexact</ins></a><ins>, fpcr);

    return result;

// FPRound()
// =========

bits(N) </ins><a id="impl-shared.FPRound.2" name="impl-shared.FPRound.2"></a><ins>FPRound(real op, </ins><a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><ins>FPCRType</ins></a><ins> fpcr)
    return </ins><a href="shared_pseudocode.html#impl-shared.FPRound.3" title="function: bits(N) FPRound(real op, FPCRType fpcr, FPRounding rounding)"><ins>FPRound</ins></a><ins>(op, fpcr, </ins><a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)"><ins>FPRoundingMode</ins></a><ins>(fpcr));</ins><del>(F);
    return sign : exp : frac;</del></p></div><div class="ps" psname="shared.functions.float.fpround.FPRoundCV"><a id="shared.functions.float.fpround.FPRoundCV" name="shared.functions.float.fpround.FPRoundCV"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fpround</ins><del>fpmaxnum</del>/<ins>FPRoundCV</ins><del>FPMaxNum</del></h3><p class="pseudocode"><ins>// FPRoundCV()
// ===========
// Used for FP &lt;-> FP conversion instructions.
// For half-precision data ignores FZ16 and observes AHP.
</ins><del>// FPMaxNum()
// ==========
</del>
bits(N) <a id="impl-shared.FPRoundCV.3" name="impl-shared.FPRoundCV.3"></a><ins>FPRoundCV(real op,</ins><del>FPMaxNum(bits(N) op1, bits(N) op2,</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> <ins>fpcr,</ins><del>fpcr)
    assert N IN {16,32,64};
    (type1,-,-) =</del> <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding</ins></a><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a> <ins>rounding)
    fpcr.FZ16 = '0';
    return</ins><del>(op1, fpcr);
    (type2,-,-) =</del> <del>(op2, fpcr);

    // treat a single quiet-NaN as -Infinity
    if type1 == </del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><del> &amp;&amp; type2 != </del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><del> then
        op1 = </del><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><del>FPInfinity</del></a><del>('1');
    elsif type1 != </del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><del> &amp;&amp; type2 == </del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><del> then
        op2 = </del><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><del>FPInfinity</del></a><del>('1');

    return </del><a href="shared_pseudocode.html#impl-shared.FPMax.3" title="function: bits(N) FPMax(bits(N) op1, bits(N) op2, FPCRType fpcr)"><del>FPMax</del></a><a href="shared_pseudocode.html#impl-shared.FPRoundBase.3" title="function: bits(N) FPRoundBase(real op, FPCRType fpcr, FPRounding rounding)"><ins>FPRoundBase</ins></a><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a><ins>(op, fpcr, rounding);</ins><del>(op1, op2, fpcr);</del></p></div><div class="ps" psname="shared.functions.float.fprounding.FPRounding"><a id="shared.functions.float.fprounding.FPRounding" name="shared.functions.float.fprounding.FPRounding"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fprounding</ins><del>fpmin</del>/<ins>FPRounding</ins><del>FPMin</del></h3><p class="pseudocode"><ins>enumeration</ins><del>// FPMin()
// =======

bits(N)</del> <a id="FPRounding" name="FPRounding"></a><ins>FPRounding  {</ins><del>FPMin(bits(N) op1, bits(N) op2,</del><a id="FPRounding_TIEEVEN" name="FPRounding_TIEEVEN"></a><ins>FPRounding_TIEEVEN,</ins><del>fpcr)
    assert N IN {16,32,64};
    (type1,sign1,value1) =</del> <a id="FPRounding_POSINF" name="FPRounding_POSINF"></a><ins>FPRounding_POSINF,</ins><del>(op1, fpcr);
    (type2,sign2,value2) =</del>
                         <a id="FPRounding_NEGINF" name="FPRounding_NEGINF"></a><ins>FPRounding_NEGINF,</ins><del>(op2, fpcr);
    (done,result) =</del>  <a id="FPRounding_ZERO" name="FPRounding_ZERO"></a><ins>FPRounding_ZERO,</ins><del>(type1, type2, op1, op2, fpcr);
    if !done then
        if value1 &lt; value2 then
            (type,sign,value) = (type1,sign1,value1);
        else
            (type,sign,value) = (type2,sign2,value2);
        if type ==</del>
                         <a id="FPRounding_TIEAWAY" name="FPRounding_TIEAWAY"></a><ins>FPRounding_TIEAWAY,</ins><del>then
            result =</del> <del>(sign);
        elsif type == </del><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a><del> then
            sign = sign1 OR sign2; // Use most negative sign
            result = </del><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><del>FPZero</del></a><del>(sign);
        else
            // The use of FPRound() covers the case where there is a trapped underflow exception
            // for a denormalized number even though the result is exact.
            result = </del><a href="shared_pseudocode.html#impl-shared.FPRound.2" title="function: bits(N) FPRound(real op, FPCRType fpcr)"><del>FPRound</del></a><a id="FPRounding_ODD" name="FPRounding_ODD"></a><ins>FPRounding_ODD};</ins><del>(value, fpcr);
    return result;</del></p></div><div class="ps" psname="shared.functions.float.fproundingmode.FPRoundingMode"><a id="shared.functions.float.fproundingmode.FPRoundingMode" name="shared.functions.float.fproundingmode.FPRoundingMode"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fproundingmode</ins><del>fpminnum</del>/<ins>FPRoundingMode</ins><del>FPMinNum</del></h3><p class="pseudocode"><ins>// FPRoundingMode()
// ================
</ins><del>// FPMinNum()
// ==========
</del>
<ins>// Return the current floating-point rounding mode.

FPRounding</ins><del>bits(N)</del> <a id="impl-shared.FPRoundingMode.1" name="impl-shared.FPRoundingMode.1"></a><ins>FPRoundingMode(</ins><del>FPMinNum(bits(N) op1, bits(N) op2,</del><a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
<ins>    return</ins><del>    assert N IN {16,32,64};
    (type1,-,-) =</del> <del>(op1, fpcr);
    (type2,-,-) = </del><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a><del>(op2, fpcr);

    // Treat a single quiet-NaN as +Infinity
    if type1 == </del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><del> &amp;&amp; type2 != </del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><del> then
        op1 = </del><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><del>FPInfinity</del></a><del>('0');
    elsif type1 != </del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><del> &amp;&amp; type2 == </del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><del> then
        op2 = </del><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><del>FPInfinity</del></a><del>('0');

    return </del><a href="shared_pseudocode.html#impl-shared.FPMin.3" title="function: bits(N) FPMin(bits(N) op1, bits(N) op2, FPCRType fpcr)"><del>FPMin</del></a><a href="shared_pseudocode.html#impl-shared.FPDecodeRounding.1" title="function: FPRounding FPDecodeRounding(bits(2) rmode)"><ins>FPDecodeRounding</ins></a><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a><ins>(fpcr.RMode);</ins><del>(op1, op2, fpcr);</del></p></div><div class="ps" psname="shared.functions.float.fproundint.FPRoundInt"><a id="shared.functions.float.fproundint.FPRoundInt" name="shared.functions.float.fproundint.FPRoundInt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fproundint</ins><del>fpmul</del>/<ins>FPRoundInt</ins><del>FPMul</del></h3><p class="pseudocode"><ins>// FPRoundInt()
// ============

// Round OP to nearest integral floating point value using rounding mode ROUNDING.
// If EXACT is TRUE, set FPSR.IXC if result is not numerically equal to OP.
</ins><del>// FPMul()
// =======
</del>
bits(N) <a id="impl-shared.FPRoundInt.4" name="impl-shared.FPRoundInt.4"></a><ins>FPRoundInt(bits(N) op,</ins><del>FPMul(bits(N) op1, bits(N) op2,</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> <ins>fpcr,</ins><del>fpcr)
    assert N IN {16,32,64};
    (type1,sign1,value1) =</del> <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding</ins></a><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a> <ins>rounding, boolean exact)
    assert rounding !=</ins><del>(op1, fpcr);
    (type2,sign2,value2) =</del> <a href="shared_pseudocode.html#FPRounding_ODD" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_ODD</ins></a><ins>;
    assert N IN {16,32,64};

    // Unpack using FPCR to determine if subnormals are flushed-to-zero
    (type,sign,value) = </ins><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a><ins>(op, fpcr);

    if type ==</ins><del>(op2, fpcr);
    (done,result) =</del> <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2, FPCRType fpcr)"><del>FPProcessNaNs</del></a> <ins>|| type ==</ins><del>(type1, type2, op1, op2, fpcr);
    if !done then
        inf1 = (type1 ==</del> <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a> <ins>then
        result =</ins><del>);
        inf2 = (type2 ==</del> <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><ins>FPProcessNaN</ins></a><ins>(type, op, fpcr);
    elsif type == </ins><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}">FPType_Infinity</a> <ins>then
        result =</ins><del>);
        zero1 = (type1 ==</del> <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><ins>FPInfinity</ins></a><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a><ins>(sign);
    elsif type ==</ins><del>);
        zero2 = (type2 ==</del> <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}">FPType_Zero</a> <ins>then
        result =</ins><del>);
        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            result =</del> <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><ins>FPZero</ins></a><a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.0" title="function: bits(N) FPDefaultNaN()"><del>FPDefaultNaN</del></a><ins>(sign);
    else
        // extract integer component
        int_result =</ins><del>();</del> <a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)"><ins>RoundDown</ins></a><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a><ins>(value);
        error = value - Real(int_result);

        // Determine whether supplied rounding mode requires an increment
        case rounding of
            when</ins><del>(</del> <a href="shared_pseudocode.html#FPRounding_TIEEVEN" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_TIEEVEN</ins></a><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_InvalidOp</del></a>
                <ins>round_up = (error > 0.5 || (error == 0.5 &amp;&amp; int_result&lt;0> == '1'));
            when</ins><del>, fpcr);
        elsif inf1 || inf2 then
            result =</del> <a href="shared_pseudocode.html#FPRounding_POSINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_POSINF</ins></a><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><del>FPInfinity</del></a>
                <ins>round_up = (error != 0.0);
            when</ins><del>(sign1 EOR sign2);
        elsif zero1 || zero2 then
            result =</del> <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_NEGINF</ins></a><ins>
                round_up = FALSE;
            when </ins><a href="shared_pseudocode.html#FPRounding_ZERO" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_ZERO</ins></a><ins>
                round_up = (error != 0.0 &amp;&amp; int_result &lt; 0);
            when </ins><a href="shared_pseudocode.html#FPRounding_TIEAWAY" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_TIEAWAY</ins></a><ins>
                round_up = (error > 0.5 || (error == 0.5 &amp;&amp; int_result >= 0));

        if round_up then int_result = int_result + 1;

        // Convert integer value into an equivalent real value
        real_result = Real(int_result);

        // Re-encode as a floating-point value, result is always exact
        if real_result == 0.0 then
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a><ins>(sign);
</ins><del>(sign1 EOR sign2);
</del>        else
            result = <a href="shared_pseudocode.html#impl-shared.FPRound.3" title="function: bits(N) FPRound(real op, FPCRType fpcr, FPRounding rounding)">FPRound</a><ins>(real_result, fpcr, </ins><a href="shared_pseudocode.html#FPRounding_ZERO" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_ZERO</ins></a><ins>);

        // Generate inexact exceptions
        if error != 0.0 &amp;&amp; exact then
            </ins><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><ins>(</ins><a href="shared_pseudocode.html#FPExc_Inexact" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_Inexact</ins></a><ins>, fpcr);

</ins><del>(value1*value2, fpcr);
</del>    return result;</p></div><div class="ps" psname="shared.functions.float.fproundintn.FPRoundIntN"><a id="shared.functions.float.fproundintn.FPRoundIntN" name="shared.functions.float.fproundintn.FPRoundIntN"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fproundintn</ins><del>fpmuladd</del>/<ins>FPRoundIntN</ins><del>FPMulAdd</del></h3><p class="pseudocode"><ins>// FPRoundIntN()
// =============
</ins><del>// FPMulAdd()
// ==========
//
// Calculates addend + op1*op2 with a single rounding.
</del>
bits(N) <a id="impl-shared.FPRoundIntN.4" name="impl-shared.FPRoundIntN.4"></a><ins>FPRoundIntN(bits(N) op,</ins><del>FPMulAdd(bits(N) addend, bits(N) op1, bits(N) op2,</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> <ins>fpcr,</ins><del>fpcr)
    assert N IN {16,32,64};
    rounding =</del> <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding</ins></a><a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)"><del>FPRoundingMode</del></a> <ins>rounding, integer intsize)
    assert rounding !=</ins><del>(fpcr);
    (typeA,signA,valueA) =</del> <a href="shared_pseudocode.html#FPRounding_ODD" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_ODD</ins></a><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a><ins>;
    assert N IN {32,64};
    assert intsize IN {32, 64};
    integer exp;
    constant integer E = (if N == 32 then 8 else 11);
    constant integer F = N - (E + 1);

    // Unpack using FPCR to determine if subnormals are flushed-to-zero
    (type,sign,value) =</ins><del>(addend, fpcr);
    (type1,sign1,value1) =</del> <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a><ins>(op, fpcr);

    if type IN {</ins><del>(op1, fpcr);
    (type2,sign2,value2) =</del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a><ins>,</ins><del>(op2, fpcr);
    inf1 = (type1 ==</del> <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><ins>, </ins><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}">FPType_Infinity</a><ins>} then
        if N == 32 then
            exp = 126 + intsize;
            result = '1':exp&lt;(E-1):0>:</ins><del>); zero1 = (type1 ==</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a><ins>(F);
        else
            exp = 1022+intsize;
            result = '1':exp&lt;(E-1):0>:</ins><del>);
    inf2 = (type2 ==</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a><ins>(F);</ins><del>); zero2 = (type2 ==</del>
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><ins>(</ins><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_InvalidOp</ins></a><ins>, fpcr);
    elsif type == </ins><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}">FPType_Zero</a> <ins>then
        result =</ins><del>);
    (done,result) =</del> <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><ins>FPZero</ins></a><a href="shared_pseudocode.html#impl-shared.FPProcessNaNs3.7" title="function: (boolean, bits(N)) FPProcessNaNs3(FPType type1, FPType type2, FPType type3, bits(N) op1, bits(N) op2, bits(N) op3, FPCRType fpcr)"><del>FPProcessNaNs3</del></a><ins>(sign);
    else
        // Extract integer component
        int_result =</ins><del>(typeA, type1, type2, addend, op1, op2, fpcr);

    if typeA ==</del> <a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)"><ins>RoundDown</ins></a><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><ins>(value);
        error = value - Real(int_result);

        // Determine whether supplied rounding mode requires an increment
        case rounding of
            when</ins><del>&amp;&amp; ((inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2)) then
        result =</del> <a href="shared_pseudocode.html#FPRounding_TIEEVEN" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_TIEEVEN</ins></a><a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.0" title="function: bits(N) FPDefaultNaN()"><del>FPDefaultNaN</del></a>
                <ins>round_up = error > 0.5 || (error == 0.5 &amp;&amp; int_result&lt;0> == '1');
            when</ins><del>();</del> <a href="shared_pseudocode.html#FPRounding_POSINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_POSINF</ins></a><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a>
                <ins>round_up = error != 0.0;
            when</ins><del>(</del> <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_NEGINF</ins></a><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_InvalidOp</del></a>
                <ins>round_up = FALSE;
            when</ins><del>, fpcr);

    if !done then
        infA = (typeA ==</del> <a href="shared_pseudocode.html#FPRounding_ZERO" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_ZERO</ins></a><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a>
                <ins>round_up = error != 0.0 &amp;&amp; int_result &lt; 0;
            when</ins><del>);  zeroA = (typeA ==</del> <a href="shared_pseudocode.html#FPRounding_TIEAWAY" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_TIEAWAY</ins></a><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a>
                <ins>round_up = error > 0.5 || (error == 0.5 &amp;&amp; int_result >= 0);
</ins><del>);
</del>
<ins>        if round_up then int_result = int_result + 1;
</ins><del>        // Determine sign and type product will have if it does not cause an Invalid
        // Operation.
        signP = sign1 EOR sign2;
        infP  = inf1 || inf2;
        zeroP = zero1 || zero2;
</del>
<ins>        if int_result > 2^(intsize-1)-1 || int_result &lt; -1*2^(intsize-1) then
            if N == 32 then
                exp = 126 + intsize;
                result = '1':exp&lt;(E-1):0>:</ins><del>        // Non SNaN-generated Invalid Operation cases are multiplies of zero by infinity and
        // additions of opposite-signed infinities.
        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) || (infA &amp;&amp; infP &amp;&amp; signA != signP) then
            result =</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.0" title="function: bits(N) FPDefaultNaN()"><del>FPDefaultNaN</del></a><ins>(F);
            else
                exp = 1022 + intsize;
                result = '1':exp&lt;(E-1):0>:</ins><del>();</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(F);
            </ins><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
<ins>            // this case shouldn't set Inexact
            error = 0.0;
</ins>
<ins>        else
            // Convert integer value into an equivalent real value
            real_result = Real(int_result);

            // Re-encode as a floating-point value, result is always exact
            if real_result == 0.0 then
                result =</ins><del>        // Other cases involving infinities produce an infinity of the same sign.
        elsif (infA &amp;&amp; signA == '0') || (infP &amp;&amp; signP == '0') then
            result =</del> <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><del>FPInfinity</del></a><del>('0');
        elsif (infA &amp;&amp; signA == '1') || (infP &amp;&amp; signP == '1') then
            result = </del><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><del>FPInfinity</del></a><del>('1');

        // Cases where the result is exactly zero and its sign is not determined by the
        // rounding mode are additions of same-signed zeros.
        elsif zeroA &amp;&amp; zeroP &amp;&amp; signA == signP then
            result = </del><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a><ins>(sign);
            else
                result =</ins><del>(signA);

        // Otherwise calculate numerical result and round it.
        else
            result_value = valueA + (value1 * value2);
            if result_value == 0.0 then  // Sign of exact zero result depends on rounding mode
                result_sign = if rounding ==</del> <a href="shared_pseudocode.html#impl-shared.FPRound.3" title="function: bits(N) FPRound(real op, FPCRType fpcr, FPRounding rounding)"><ins>FPRound</ins></a><a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_NEGINF</del></a><ins>(real_result, fpcr,</ins><del>then '1' else '0';
                result =</del> <a href="shared_pseudocode.html#FPRounding_ZERO" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_ZERO</ins></a><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><del>FPZero</del></a><ins>);

        // Generate inexact exceptions
        if error != 0.0 then</ins><del>(result_sign);
            else
                result =</del>
            <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><a href="shared_pseudocode.html#impl-shared.FPRound.2" title="function: bits(N) FPRound(real op, FPCRType fpcr)"><del>FPRound</del></a><ins>(</ins><a href="shared_pseudocode.html#FPExc_Inexact" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_Inexact</ins></a><ins>, fpcr);
</ins><del>(result_value, fpcr);
</del>
    return result;</p></div><div class="ps" psname="shared.functions.float.fprsqrtestimate.FPRSqrtEstimate"><a id="shared.functions.float.fprsqrtestimate.FPRSqrtEstimate" name="shared.functions.float.fprsqrtestimate.FPRSqrtEstimate"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fprsqrtestimate</ins><del>fpmuladdh</del>/<ins>FPRSqrtEstimate</ins><del>FPMulAddH</del></h3><p class="pseudocode"><ins>// FPRSqrtEstimate()
// =================
</ins><del>// FPMulAddH()
// ===========
</del>
<ins>bits(N)</ins><del>bits(N) FPMulAddH(bits(N) addend, bits(N DIV 2) op1, bits(N DIV 2) op2,</del> <a id="impl-shared.FPRSqrtEstimate.2" name="impl-shared.FPRSqrtEstimate.2"></a><ins>FPRSqrtEstimate(bits(N) operand, </ins><a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
<ins>    assert N IN {16,32,64};
    (type,sign,value) =</ins><del>    assert N IN {32,64};
    rounding =</del> <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)"><del>FPRoundingMode</del></a><del>(fpcr);
    (typeA,signA,valueA) = </del><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a><ins>(operand, fpcr);
    if type ==</ins><del>(addend, fpcr);
    (type1,sign1,value1) =</del> <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a> <ins>|| type ==</ins><del>(op1, fpcr);
    (type2,sign2,value2) =</del> <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a> <ins>then
        result =</ins><del>(op2, fpcr);
    inf1 = (type1 ==</del> <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><ins>FPProcessNaN</ins></a><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a><ins>(type, operand, fpcr);
    elsif type ==</ins><del>); zero1 = (type1 ==</del> <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}">FPType_Zero</a> <ins>then
        result =</ins><del>);
    inf2 = (type2 ==</del> <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><ins>FPInfinity</ins></a><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a><ins>(sign);</ins><del>); zero2 = (type2 ==</del>
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a><ins>(</ins><del>);
    (done,result) = FPProcessNaNs3H(typeA, type1, type2, addend, op1, op2, fpcr);
    if typeA ==</del><a href="shared_pseudocode.html#FPExc_DivideByZero" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_DivideByZero</ins></a><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><ins>, fpcr);
    elsif sign == '1' then
</ins><del>&amp;&amp; ((inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2)) then
</del>        result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.0" title="function: bits(N) FPDefaultNaN()">FPDefaultNaN</a>();
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
<ins>    elsif type ==</ins><del>    if !done then
        infA = (typeA ==</del> <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}">FPType_Infinity</a> <ins>then
        result =</ins><del>); zeroA = (typeA ==</del> <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><ins>FPZero</ins></a><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a><ins>('0');
    else
        // Scale to a fixed-point value in the range 0.25 &lt;= x &lt; 1.0 in steps of 512, with the
        // evenness or oddness of the exponent unchanged, and calculate result exponent.
        // Scaled value has copied sign bit, exponent = 1022 or 1021 = double-precision
        // biased version of -1 or -2, fraction = original fraction extended with zeros.

        case N of
            when 16
                fraction = operand&lt;9:0> :</ins><del>);
        // Determine sign and type product will have if it does not cause an Invalid
        // Operation.
        signP = sign1 EOR sign2;
        infP = inf1 || inf2;
        zeroP = zero1 || zero2;
        // Non SNaN-generated Invalid Operation cases are multiplies of zero by infinity and
        // additions of opposite-signed infinities.
        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) || (infA &amp;&amp; infP &amp;&amp; signA != signP) then
            result =</del> <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.0" title="function: bits(N) FPDefaultNaN()"><del>FPDefaultNaN</del></a><ins>(42);
                exp =</ins><del>();</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a><ins>(operand&lt;14:10>);
            when 32
                fraction = operand&lt;22:0> :</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_InvalidOp</del></a><ins>(29);
                exp =</ins><del>, fpcr);
        // Other cases involving infinities produce an infinity of the same sign.
        elsif (infA &amp;&amp; signA == '0') || (infP &amp;&amp; signP == '0') then
            result =</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><del>FPInfinity</del></a><ins>(operand&lt;30:23>);
            when 64
                fraction = operand&lt;51:0>;
                exp =</ins><del>('0');
        elsif (infA &amp;&amp; signA == '1') || (infP &amp;&amp; signP == '1') then
            result =</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><del>FPInfinity</del></a><ins>(operand&lt;62:52>);

        if exp == 0 then
            while fraction&lt;51> == 0 do
                fraction = fraction&lt;50:0> : '0';
                exp = exp - 1;
            fraction = fraction&lt;50:0> : '0';

        if exp&lt;0> == '0' then
            scaled =</ins><del>('1');
        // Cases where the result is exactly zero and its sign is not determined by the
        // rounding mode are additions of same-signed zeros.
        elsif zeroA &amp;&amp; zeroP &amp;&amp; signA == signP then
            result =</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><del>FPZero</del></a><ins>('1':fraction&lt;51:44>);
</ins><del>(signA);
        // Otherwise calculate numerical result and round it.
</del>        else
<ins>            scaled =</ins><del>            result_value = valueA + (value1 * value2);
            if result_value == 0.0 then // Sign of exact zero result depends on rounding mode
                result_sign = if rounding ==</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_NEGINF</del></a><ins>('01':fraction&lt;51:45>);

        case N of
            when 16 result_exp = (  44 - exp) DIV 2;
            when 32 result_exp = ( 380 - exp) DIV 2;
            when 64 result_exp = (3068 - exp) DIV 2;

        estimate =</ins><del>then '1' else '0';
                result =</del> <a href="shared_pseudocode.html#impl-shared.RecipSqrtEstimate.1" title="function: integer RecipSqrtEstimate(integer a)"><ins>RecipSqrtEstimate</ins></a><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><del>FPZero</del></a><ins>(scaled);

        // estimate is in the range 256..511 representing a fixed point result in the range [1.0..2.0)
        // Convert to scaled floating point result with copied sign bit and high-order
        // fraction bits, and exponent calculated above.
        case N of
            when 16 result = '0' : result_exp&lt;N-12:0> : estimate&lt;7:0>:</ins><del>(result_sign);
            else
                result =</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><a href="shared_pseudocode.html#impl-shared.FPRound.2" title="function: bits(N) FPRound(real op, FPCRType fpcr)"><del>FPRound</del></a><ins>( 2);
            when 32 result = '0' : result_exp&lt;N-25:0> : estimate&lt;7:0>:</ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(15);
            when 64 result = '0' : result_exp&lt;N-54:0> : estimate&lt;7:0>:</ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(44);
</ins><del>(result_value, fpcr);
</del>    return result;</p></div><div class="ps" psname="shared.functions.float.fprsqrtestimate.RecipSqrtEstimate"><a id="shared.functions.float.fprsqrtestimate.RecipSqrtEstimate" name="shared.functions.float.fprsqrtestimate.RecipSqrtEstimate"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fprsqrtestimate</ins><del>fpmuladdh</del>/<ins>RecipSqrtEstimate</ins><del>FPProcessNaNs3H</del></h3><p class="pseudocode"><ins>// Compute estimate of reciprocal square root of 9-bit fixed-point number
//
// a is in range 128 .. 511 representing a number in the range 0.25 &lt;= x &lt; 1.0.
// result is in the range 256 .. 511 representing a number in the range in the range 1.0 to 511/256.
</ins><del>// FPProcessNaNs3H()
// =================
</del>
<ins>integer</ins><del>(boolean, bits(N)) FPProcessNaNs3H(</del> <del> type1, </del><a href="shared_pseudocode.html#FPType" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType</del></a><del> type2, </del><a href="shared_pseudocode.html#FPType" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType</del></a><del> type3, bits(N) op1, bits(N DIV 2) op2, bits(N DIV 2) op3, </del><a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><del>FPCRType</del></a><del> fpcr)
    assert N IN {32,64};
    bits(N) result;
    if type1 == </del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><del> then
        done = TRUE; result = </del><a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><del>FPProcessNaN</del></a><del>(type1, op1, fpcr);
    elsif type2 == </del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><del> then
        done = TRUE; result = </del><a href="shared_pseudocode.html#impl-shared.FPConvertNaN.1" title="function: bits(M) FPConvertNaN(bits(N) op)"><del>FPConvertNaN</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><del>FPProcessNaN</del></a><del>(type2, op2, fpcr));
    elsif type3 == </del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><del> then
        done = TRUE; result = </del><a href="shared_pseudocode.html#impl-shared.FPConvertNaN.1" title="function: bits(M) FPConvertNaN(bits(N) op)"><del>FPConvertNaN</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><del>FPProcessNaN</del></a><del>(type3, op3, fpcr));
    elsif type1 == </del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><del> then
        done = TRUE; result = </del><a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><del>FPProcessNaN</del></a><del>(type1, op1, fpcr);
    elsif type2 == </del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><del> then
        done = TRUE; result = </del><a href="shared_pseudocode.html#impl-shared.FPConvertNaN.1" title="function: bits(M) FPConvertNaN(bits(N) op)"><del>FPConvertNaN</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><del>FPProcessNaN</del></a><del>(type2, op2, fpcr));
    elsif type3 == </del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><del> then
        done = TRUE; result = </del><a href="shared_pseudocode.html#impl-shared.FPConvertNaN.1" title="function: bits(M) FPConvertNaN(bits(N) op)"><del>FPConvertNaN</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><del>FPProcessNaN</del></a><del>(type3, op3, fpcr));
    else
        done = FALSE; result = </del><a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><del>Zeros</del></a><a id="impl-shared.RecipSqrtEstimate.1" name="impl-shared.RecipSqrtEstimate.1"></a><ins>RecipSqrtEstimate(integer a)
    assert 128 &lt;= a &amp;&amp; a &lt; 512;
    if a &lt; 256 then // 0.25 .. 0.5
        a = a*2+1;     // a in units of 1/512 rounded to nearest
    else // 0.5 .. 1.0
        a = (a >> 1) &lt;&lt; 1;   // discard bottom bit
        a = (a+1)*2;  // a in units of 1/256 rounded to nearest
    integer b = 512;
    while a*(b+1)*(b+1) &lt; 2^28 do
        b = b+1;
    // b = largest b such that b &lt; 2^14 / sqrt(a) do
    r = (b+1) DIV 2; // round to nearest
    assert 256 &lt;= r &amp;&amp; r &lt; 512;
    return r;</ins><del>(); // 'Don't care' result
    return (done, result);</del></p></div><div class="ps" psname="shared.functions.float.fpsqrt.FPSqrt"><a id="shared.functions.float.fpsqrt.FPSqrt" name="shared.functions.float.fpsqrt.FPSqrt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fpsqrt</ins><del>fpmulx</del>/<ins>FPSqrt</ins><del>FPMulX</del></h3><p class="pseudocode"><ins>// FPSqrt()
</ins><del>// FPMulX()
</del>// ========

bits(N) <a id="impl-shared.FPSqrt.2" name="impl-shared.FPSqrt.2"></a><ins>FPSqrt(bits(N) op,</ins><del>FPMulX(bits(N) op1, bits(N) op2,</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    assert N IN {16,32,64};
<ins>    (type,sign,value) =</ins><del>    bits(N) result;
    (type1,sign1,value1) =</del> <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a><ins>(op, fpcr);
    if type ==</ins><del>(op1, fpcr);
    (type2,sign2,value2) =</del> <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a> <ins>|| type ==</ins><del>(op2, fpcr);
    (done,result) =</del> <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2, FPCRType fpcr)"><del>FPProcessNaNs</del></a> <ins>then
        result =</ins><del>(type1, type2, op1, op2, fpcr);
    if !done then
        inf1 = (type1 ==</del> <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><ins>FPProcessNaN</ins></a><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a><ins>(type, op, fpcr);
    elsif type ==</ins><del>);
        inf2 = (type2 ==</del> <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a><del>);
        zero1 = (type1 == </del><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}">FPType_Zero</a> <ins>then
        result =</ins><del>);
        zero2 = (type2 ==</del> <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><ins>FPZero</ins></a><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a><ins>(sign);
    elsif type ==</ins><del>);
        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            result =</del> <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><a href="shared_pseudocode.html#impl-shared.FPTwo.1" title="function: bits(N) FPTwo(bit sign)"><del>FPTwo</del></a> <ins>&amp;&amp; sign == '0' then
        result =</ins><del>(sign1 EOR sign2);
        elsif inf1 || inf2 then
            result =</del> <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a><ins>(sign);
    elsif sign == '1' then
        result =</ins><del>(sign1 EOR sign2);
        elsif zero1 || zero2 then
            result =</del> <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.0" title="function: bits(N) FPDefaultNaN()"><ins>FPDefaultNaN</ins></a><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><del>FPZero</del></a><ins>();
        </ins><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><ins>(</ins><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_InvalidOp</ins></a><ins>, fpcr);
    else
        result =</ins><del>(sign1 EOR sign2);
        else
            result =</del> <a href="shared_pseudocode.html#impl-shared.FPRound.2" title="function: bits(N) FPRound(real op, FPCRType fpcr)">FPRound</a><ins>(Sqrt(value), fpcr);
</ins><del>(value1*value2, fpcr);
</del>    return result;</p></div><div class="ps" psname="shared.functions.float.fpsub.FPSub"><a id="shared.functions.float.fpsub.FPSub" name="shared.functions.float.fpsub.FPSub"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fpsub</ins><del>fpneg</del>/<ins>FPSub</ins><del>FPNeg</del></h3><p class="pseudocode"><ins>// FPSub()
</ins><del>// FPNeg()
</del>// =======

bits(N) <a id="impl-shared.FPSub.3" name="impl-shared.FPSub.3"></a><ins>FPSub(bits(N) op1, bits(N) op2,</ins><del>FPNeg(bits(N) op)
    assert N IN {16,32,64};
    return NOT(op&lt;N-1>) : op&lt;N-2:0>;</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><ins>FPCRType</ins></a><ins> fpcr)
    assert N IN {16,32,64};
    rounding = </ins><a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)"><ins>FPRoundingMode</ins></a><ins>(fpcr);
    (type1,sign1,value1) = </ins><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><ins>(op1, fpcr);
    (type2,sign2,value2) = </ins><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><ins>(op2, fpcr);
    (done,result) = </ins><a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2, FPCRType fpcr)"><ins>FPProcessNaNs</ins></a><ins>(type1, type2, op1, op2, fpcr);
    if !done then
        inf1 = (type1 == </ins><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><ins>);
        inf2 = (type2 == </ins><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><ins>);
        zero1 = (type1 == </ins><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><ins>);
        zero2 = (type2 == </ins><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><ins>);
        if inf1 &amp;&amp; inf2 &amp;&amp; sign1 == sign2 then
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.0" title="function: bits(N) FPDefaultNaN()"><ins>FPDefaultNaN</ins></a><ins>();
            </ins><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><ins>(</ins><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_InvalidOp</ins></a><ins>, fpcr);
        elsif (inf1 &amp;&amp; sign1 == '0') || (inf2 &amp;&amp; sign2 == '1') then
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><ins>FPInfinity</ins></a><ins>('0');
        elsif (inf1 &amp;&amp; sign1 == '1') || (inf2 &amp;&amp; sign2 == '0') then
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><ins>FPInfinity</ins></a><ins>('1');
        elsif zero1 &amp;&amp; zero2 &amp;&amp; sign1 == NOT(sign2) then
            result = </ins><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><ins>FPZero</ins></a><ins>(sign1);
        else
            result_value = value1 - value2;
            if result_value == 0.0 then  // Sign of exact zero result depends on rounding mode
                result_sign = if rounding == </ins><a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_NEGINF</ins></a><ins> then '1' else '0';
                result = </ins><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><ins>FPZero</ins></a><ins>(result_sign);
            else
                result = </ins><a href="shared_pseudocode.html#impl-shared.FPRound.3" title="function: bits(N) FPRound(real op, FPCRType fpcr, FPRounding rounding)"><ins>FPRound</ins></a><ins>(result_value, fpcr, rounding);
    return result;</ins></p></div><div class="ps" psname="shared.functions.float.fpthree.FPThree"><a id="shared.functions.float.fpthree.FPThree" name="shared.functions.float.fpthree.FPThree"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fpthree</ins><del>fponepointfive</del>/<ins>FPThree</ins><del>FPOnePointFive</del></h3><p class="pseudocode"><ins>// FPThree()
// =========
</ins><del>// FPOnePointFive()
// ================
</del>
bits(N) <a id="impl-shared.FPThree.1" name="impl-shared.FPThree.1"></a><ins>FPThree(bit sign)
</ins><del>FPOnePointFive(bit sign)
</del>    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
<ins>    exp  = '1':</ins><del>    exp  = '0':</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a>(E-1);
    frac = '1':<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(F-1);
    return sign : exp : frac;</p></div><div class="ps" psname="shared.functions.float.fptofixed.FPToFixed"><a id="shared.functions.float.fptofixed.FPToFixed" name="shared.functions.float.fptofixed.FPToFixed"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fptofixed</ins><del>fpprocessexception</del>/<ins>FPToFixed</ins><del>FPProcessException</del></h3><p class="pseudocode"><ins>// FPToFixed()
// ===========

// Convert N-bit precision floating point OP to M-bit fixed point with
// FBITS fractional bits, controlled by UNSIGNED and ROUNDING.

bits(M)</ins><del>// FPProcessException()
// ====================
//
// The 'fpcr' argument supplies FPCR control bits. Status information is
// updated directly in the FPSR where appropriate.</del> <a id="impl-shared.FPToFixed.5" name="impl-shared.FPToFixed.5"></a><ins>FPToFixed(bits(N) op, integer fbits, boolean unsigned,</ins><del>FPProcessException(</del> <a href="shared_pseudocode.html#FPExc" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc</del></a><del> exception, </del><a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> <ins>fpcr,</ins><del>fpcr)
    // Determine the cumulative exception bit number
    case exception of
        when</del> <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding</ins></a><ins> rounding)
    assert N IN {16,32,64};
    assert M IN {16,32,64};
    assert fbits >= 0;
    assert rounding != </ins><a href="shared_pseudocode.html#FPRounding_ODD" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_ODD</ins></a><ins>;

    // Unpack using fpcr to determine if subnormals are flushed-to-zero
    (type,sign,value) = </ins><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><ins>(op, fpcr);

    // If NaN, set cumulative flag or take exception
    if type == </ins><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><ins> || type == </ins><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><ins> then
        </ins><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><ins>(</ins><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a><ins>, fpcr);

    // Scale by fractional bits and produce integer rounded towards minus-infinity
    value = value * 2.0^fbits;
    int_result =</ins><del>cumul = 0;
        when</del> <a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)"><ins>RoundDown</ins></a><a href="shared_pseudocode.html#FPExc_DivideByZero" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_DivideByZero</del></a><ins>(value);
    error = value - Real(int_result);

    // Determine whether supplied rounding mode requires an increment
    case rounding of
</ins><del>cumul = 1;
</del>        when <a href="shared_pseudocode.html#FPRounding_TIEEVEN" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_TIEEVEN</ins></a><a href="shared_pseudocode.html#FPExc_Overflow" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_Overflow</del></a>
            <ins>round_up = (error > 0.5 || (error == 0.5 &amp;&amp; int_result&lt;0> == '1'));
</ins><del>cumul = 2;
</del>        when <a href="shared_pseudocode.html#FPRounding_POSINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_POSINF</ins></a><a href="shared_pseudocode.html#FPExc_Underflow" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_Underflow</del></a>
            <ins>round_up = (error != 0.0);
</ins><del>cumul = 3;
</del>        when <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_NEGINF</ins></a><a href="shared_pseudocode.html#FPExc_Inexact" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_Inexact</del></a>
            <ins>round_up = FALSE;
</ins><del>cumul = 4;
</del>        when <a href="shared_pseudocode.html#FPRounding_ZERO" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_ZERO</ins></a><a href="shared_pseudocode.html#FPExc_InputDenorm" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_InputDenorm</del></a>
            <ins>round_up = (error != 0.0 &amp;&amp; int_result &lt; 0);
        when</ins><del>cumul = 7;
    enable = cumul + 8;
    if fpcr&lt;enable> == '1' then
        // Trapping of the exception enabled.
        // It is IMPLEMENTATION DEFINED whether the enable bit may be set at all, and
        // if so then how exceptions may be accumulated before calling FPTrapException()
        IMPLEMENTATION_DEFINED "floating-point trap handling";
    elsif</del> <a href="shared_pseudocode.html#FPRounding_TIEAWAY" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><ins>FPRounding_TIEAWAY</ins></a><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><ins>
            round_up = (error > 0.5 || (error == 0.5 &amp;&amp; int_result >= 0));

    if round_up then int_result = int_result + 1;

    // Generate saturated result and exceptions
    (result, overflow) = </ins><a href="shared_pseudocode.html#impl-shared.SatQ.3" title="function: (bits(N), boolean) SatQ(integer i, integer N, boolean unsigned)"><ins>SatQ</ins></a><ins>(int_result, M, unsigned);
    if overflow then
        </ins><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><ins>(</ins><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_InvalidOp</ins></a><ins>, fpcr);
    elsif error != 0.0 then
        </ins><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><ins>(</ins><a href="shared_pseudocode.html#FPExc_Inexact" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_Inexact</ins></a><ins>, fpcr);

    return result;</ins><del>() then
        // Set the cumulative exception bit
        FPSCR&lt;cumul> = '1';
    else
        // Set the cumulative exception bit
        FPSR&lt;cumul> = '1';
    return;</del></p></div><div class="ps" psname="shared.functions.float.fptofixedjs.FPToFixedJS"><a id="shared.functions.float.fptofixedjs.FPToFixedJS" name="shared.functions.float.fptofixedjs.FPToFixedJS"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fptofixedjs</ins><del>fpprocessnan</del>/<ins>FPToFixedJS</ins><del>FPProcessNaN</del></h3><p class="pseudocode"><ins>// FPToFixedJS()
// =============

// Converts a double precision floating point input value
// to a signed integer, with rounding to zero.
</ins><del>// FPProcessNaN()
// ==============
</del>
bits(N) <a id="impl-shared.FPToFixedJS.3" name="impl-shared.FPToFixedJS.3"></a><ins>FPToFixedJS(bits(M) op,</ins><del>FPProcessNaN(</del> <a href="shared_pseudocode.html#FPType" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType</del></a><del> type, bits(N) op, </del><a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> <ins>fpcr, boolean Is64)

    assert M == 64 &amp;&amp; N == 32;

    // Unpack using fpcr to determine if subnormals are flushed-to-zero
    (type,sign,value) =</ins><del>fpcr)
    assert N IN {16,32,64};
    assert type IN {</del> <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpack</ins></a><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><ins>(op, fpcr);

    Z = '1';
    // If NaN, set cumulative flag or take exception
    if type ==</ins><del>,</del> <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}">FPType_SNaN</a> <ins>|| type ==</ins><del>};

    case N of
        when 16 topfrac =  9;
        when 32 topfrac = 22;
        when 64 topfrac = 51;

    result = op;
    if type ==</del> <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a> <ins>then</ins><del>then
        result&lt;topfrac> = '1';</del>
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
<ins>        Z = '0';

    int_result =</ins><del>    if fpcr.DN == '1' then  // DefaultNaN requested
        result =</del> <a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)"><ins>RoundDown</ins></a><a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.0" title="function: bits(N) FPDefaultNaN()"><del>FPDefaultNaN</del></a><ins>(value);
    error = value - Real(int_result);

    // Determine whether supplied rounding mode requires an increment

    round_it_up = (error != 0.0 &amp;&amp; int_result &lt; 0);
    if round_it_up then int_result = int_result + 1;

    if int_result &lt; 0 then
        result = int_result - 2^32*</ins><a href="shared_pseudocode.html#impl-shared.RoundUp.1" title="function: integer RoundUp(real x)"><ins>RoundUp</ins></a><ins>(Real(int_result)/Real(2^32));
    else
        result = int_result - 2^32*</ins><a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)"><ins>RoundDown</ins></a><ins>(Real(int_result)/Real(2^32));

    // Generate exceptions
    if int_result &lt; -(2^31) || int_result > (2^31)-1 then
        </ins><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><ins>(</ins><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_InvalidOp</ins></a><ins>, fpcr);
        Z = '0';
    elsif error != 0.0 then
        </ins><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><ins>(</ins><a href="shared_pseudocode.html#FPExc_Inexact" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_Inexact</ins></a><ins>, fpcr);
        Z = '0';
    if sign == '1'&amp;&amp; value == 0.0 then
        Z = '0';

    if type == </ins><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a> <ins>then result = 0;

    if Is64 then
        PSTATE.&lt;N,Z,C,V> = '0':Z:'00';
    else
        FPSCR&lt;31:28> = '0':Z:'00';
    return result&lt;N-1:0>;</ins><del>();
    return result;</del></p></div><div class="ps" psname="shared.functions.float.fptwo.FPTwo"><a id="shared.functions.float.fptwo.FPTwo" name="shared.functions.float.fptwo.FPTwo"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fptwo</ins><del>fpprocessnans</del>/<ins>FPTwo</ins><del>FPProcessNaNs</del></h3><p class="pseudocode"><ins>// FPTwo()
// =======
</ins><del>// FPProcessNaNs()
// ===============
//
// The boolean part of the return value says whether a NaN has been found and
// processed. The bits(N) part is only relevant if it has and supplies the
// result of the operation.
//
// The 'fpcr' argument supplies FPCR control bits. Status information is
// updated directly in the FPSR where appropriate.
</del>
<ins>bits(N)</ins><del>(boolean, bits(N))</del> <a id="impl-shared.FPTwo.1" name="impl-shared.FPTwo.1"></a><ins>FPTwo(bit sign)
    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp  = '1':</ins><del>FPProcessNaNs(</del><del> type1, </del><a href="shared_pseudocode.html#FPType" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType</del></a><del> type2,
                                 bits(N) op1, bits(N) op2,
                                 </del><a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><del>FPCRType</del></a><del> fpcr)
    assert N IN {16,32,64};
    if type1 == </del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><del> then
        done = TRUE;  result = </del><a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><del>FPProcessNaN</del></a><del>(type1, op1, fpcr);
    elsif type2 == </del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><del> then
        done = TRUE;  result = </del><a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><del>FPProcessNaN</del></a><del>(type2, op2, fpcr);
    elsif type1 == </del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><del> then
        done = TRUE;  result = </del><a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><del>FPProcessNaN</del></a><del>(type1, op1, fpcr);
    elsif type2 == </del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><del> then
        done = TRUE;  result = </del><a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><del>FPProcessNaN</del></a><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><a href="shared_pseudocode.html#FPType" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType</del></a><ins>(E-1);
    frac =</ins><del>(type2, op2, fpcr);
    else
        done = FALSE;  result =</del> <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a><ins>(F);
    return sign : exp : frac;</ins><del>();  // 'Don't care' result
    return (done, result);</del></p></div><div class="ps" psname="shared.functions.float.fptype.FPType"><a id="shared.functions.float.fptype.FPType" name="shared.functions.float.fptype.FPType"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fptype</ins><del>fpprocessnans3</del>/<ins>FPType</ins><del>FPProcessNaNs3</del></h3><p class="pseudocode"><ins>enumeration</ins><del>// FPProcessNaNs3()
// ================
//
// The boolean part of the return value says whether a NaN has been found and
// processed. The bits(N) part is only relevant if it has and supplies the
// result of the operation.
//
// The 'fpcr' argument supplies FPCR control bits. Status information is
// updated directly in the FPSR where appropriate.

(boolean, bits(N))</del> <a id="FPType" name="FPType"></a><ins>FPType      {</ins><del>FPProcessNaNs3(</del><a id="FPType_Nonzero" name="FPType_Nonzero"></a><ins>FPType_Nonzero,</ins><del>type1,</del> <a id="FPType_Zero" name="FPType_Zero"></a><ins>FPType_Zero,</ins><del>type2,</del> <a id="FPType_Infinity" name="FPType_Infinity"></a><ins>FPType_Infinity,</ins><del>type3,
                                  bits(N) op1, bits(N) op2, bits(N) op3,</del>
                         <a id="FPType_QNaN" name="FPType_QNaN"></a><ins>FPType_QNaN,</ins><del>fpcr)
    assert N IN {16,32,64};
    if type1 ==</del> <del> then
        done = TRUE;  result = </del><a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><del>FPProcessNaN</del></a><del>(type1, op1, fpcr);
    elsif type2 == </del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><del> then
        done = TRUE;  result = </del><a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><del>FPProcessNaN</del></a><del>(type2, op2, fpcr);
    elsif type3 == </del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><del> then
        done = TRUE;  result = </del><a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><del>FPProcessNaN</del></a><del>(type3, op3, fpcr);
    elsif type1 == </del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><del> then
        done = TRUE;  result = </del><a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><del>FPProcessNaN</del></a><del>(type1, op1, fpcr);
    elsif type2 == </del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><del> then
        done = TRUE;  result = </del><a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><del>FPProcessNaN</del></a><del>(type2, op2, fpcr);
    elsif type3 == </del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><del> then
        done = TRUE;  result = </del><a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><del>FPProcessNaN</del></a><del>(type3, op3, fpcr);
    else
        done = FALSE;  result = </del><a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><del>Zeros</del></a><a id="FPType_SNaN" name="FPType_SNaN"></a><ins>FPType_SNaN};</ins><del>();  // 'Don't care' result
    return (done, result);</del></p></div><div class="ps" psname="shared.functions.float.fpunpack.FPUnpack"><a id="shared.functions.float.fpunpack.FPUnpack" name="shared.functions.float.fpunpack.FPUnpack"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fpunpack</ins><del>fprecipestimate</del>/<ins>FPUnpack</ins><del>FPRecipEstimate</del></h3><p class="pseudocode"><ins>// FPUnpack()
// ==========
//
// Used by data processing and int/fixed &lt;-> FP conversion instructions.
// For half-precision data it ignores AHP, and observes FZ16.
</ins><del>// FPRecipEstimate()
// =================
</del>
<ins>(FPType, bit, real)</ins><del>bits(N)</del> <a id="impl-shared.FPUnpack.2" name="impl-shared.FPUnpack.2"></a><ins>FPUnpack(bits(N) fpval,</ins><del>FPRecipEstimate(bits(N) operand,</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
<ins>    fpcr.AHP = '0';
    (fp_type, sign, value) =</ins><del>    assert N IN {16,32,64};
    (type,sign,value) =</del> <del>(operand, fpcr);
    if type == </del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><del> || type == </del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><del> then
        result = </del><a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><del>FPProcessNaN</del></a><del>(type, operand, fpcr);
    elsif type == </del><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a><del> then
        result = </del><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><del>FPZero</del></a><del>(sign);
    elsif type == </del><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a><del> then
        result = </del><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><del>FPInfinity</del></a><del>(sign);
        </del><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a><del>(</del><a href="shared_pseudocode.html#FPExc_DivideByZero" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_DivideByZero</del></a><del>, fpcr);
    elsif (
            (N == 16 &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.Abs.1" title="function: integer Abs(integer x)"><del>Abs</del></a><del>(value) &lt; 2.0^-16) ||
            (N == 32 &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.Abs.1" title="function: integer Abs(integer x)"><del>Abs</del></a><del>(value) &lt; 2.0^-128) ||
            (N == 64 &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.Abs.1" title="function: integer Abs(integer x)"><del>Abs</del></a><del>(value) &lt; 2.0^-1024)
          ) then
        case </del><a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)"><del>FPRoundingMode</del></a><del>(fpcr) of
            when </del><a href="shared_pseudocode.html#FPRounding_TIEEVEN" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_TIEEVEN</del></a><del>
                overflow_to_inf = TRUE;
            when </del><a href="shared_pseudocode.html#FPRounding_POSINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_POSINF</del></a><del>
                overflow_to_inf = (sign == '0');
            when </del><a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_NEGINF</del></a><del>
                overflow_to_inf = (sign == '1');
            when </del><a href="shared_pseudocode.html#FPRounding_ZERO" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_ZERO</del></a><del>
                overflow_to_inf = FALSE;
        result = if overflow_to_inf then </del><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><del>FPInfinity</del></a><del>(sign) else </del><a href="shared_pseudocode.html#impl-shared.FPMaxNormal.1" title="function: bits(N) FPMaxNormal(bit sign)"><del>FPMaxNormal</del></a><del>(sign);
        </del><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a><del>(</del><a href="shared_pseudocode.html#FPExc_Overflow" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_Overflow</del></a><del>, fpcr);
        </del><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a><del>(</del><a href="shared_pseudocode.html#FPExc_Inexact" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_Inexact</del></a><del>, fpcr);
    elsif ((fpcr.FZ == '1' &amp;&amp; N != 16) || (fpcr.FZ16 == '1' &amp;&amp; N == 16))
          &amp;&amp; (
               (N == 16 &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.Abs.1" title="function: integer Abs(integer x)"><del>Abs</del></a><del>(value) >= 2.0^14) ||
               (N == 32 &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.Abs.1" title="function: integer Abs(integer x)"><del>Abs</del></a><del>(value) >= 2.0^126) ||
               (N == 64 &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.Abs.1" title="function: integer Abs(integer x)"><del>Abs</del></a><del>(value) >= 2.0^1022)
             ) then
        // Result flushed to zero of correct sign
        result = </del><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><del>FPZero</del></a><del>(sign);
        if </del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>() then
            FPSCR.UFC = '1';
        else
            FPSR.UFC = '1';
    else
        // Scale to a fixed point value in the range 0.5 &lt;= x &lt; 1.0 in steps of 1/512, and
        // calculate result exponent. Scaled value has copied sign bit,
        // exponent = 1022 = double-precision biased version of -1,
        // fraction = original fraction
        case N of
            when 16
                fraction = operand&lt;9:0> : </del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(42);
                exp = </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(operand&lt;14:10>);
            when 32
                fraction = operand&lt;22:0> : </del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(29);
                exp = </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(operand&lt;30:23>);
            when 64
                fraction = operand&lt;51:0>;
                exp = </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(operand&lt;62:52>);

        if exp == 0 then
            if fraction&lt;51> == 0 then
                exp = -1;
                fraction = fraction&lt;49:0>:'00';
            else
                fraction = fraction&lt;50:0>:'0';

        integer scaled = </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>('1':fraction&lt;51:44>);

        case N of
            when 16 result_exp =   29 - exp; // In range 29-30 = -1 to 29+1 = 30
            when 32 result_exp =  253 - exp; // In range 253-254 = -1 to 253+1 = 254
            when 64 result_exp = 2045 - exp; // In range 2045-2046 = -1 to 2045+1 = 2046

        // scaled is in range 256..511 representing a fixed-point number in range [0.5..1.0)
        estimate = </del><a href="shared_pseudocode.html#impl-shared.RecipEstimate.1" title="function: integer RecipEstimate(integer a)"><del>RecipEstimate</del></a><del>(scaled);

        // estimate is in the range 256..511 representing a fixed point result in the range [1.0..2.0)
        // Convert to scaled floating point result with copied sign bit,
        // high-order bits from estimate, and exponent calculated above.

        fraction = estimate&lt;7:0> : </del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><a href="shared_pseudocode.html#impl-shared.FPUnpackBase.2" title="function: (FPType, bit, real) FPUnpackBase(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpackBase</ins></a><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a><ins>(fpval, fpcr);
    return (fp_type, sign, value);</ins><del>(44);
        if result_exp == 0 then
            fraction = '1' : fraction&lt;51:1>;
        elsif result_exp == -1 then
            fraction = '01' : fraction&lt;51:2>;
            result_exp = 0;

        case N of
            when 16 result = sign : result_exp&lt;N-12:0> : fraction&lt;51:42>;
            when 32 result = sign : result_exp&lt;N-25:0> : fraction&lt;51:29>;
            when 64 result = sign : result_exp&lt;N-54:0> : fraction&lt;51:0>;

    return result;</del></p></div><div class="ps" psname="shared.functions.float.fpunpack.FPUnpackBase"><a id="shared.functions.float.fpunpack.FPUnpackBase" name="shared.functions.float.fpunpack.FPUnpackBase"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fpunpack</ins><del>fprecipestimate</del>/<ins>FPUnpackBase</ins><del>RecipEstimate</del></h3><p class="pseudocode"><ins>// FPUnpackBase()
// ==============
</ins><del>// Compute estimate of reciprocal of 9-bit fixed-point number
</del>//
<ins>// Unpack a floating-point number into its type, sign bit and the real number
// that it represents. The real number result has the correct sign for numbers
// and infinities, is very large in magnitude for infinities, and is 0.0 for
// NaNs. (These values are chosen to simplify the description of comparisons
// and conversions.)
//
// The 'fpcr' argument supplies FPCR control bits. Status information is
// updated directly in the FPSR where appropriate.
</ins><del>// a is in range 256 .. 511 representing a number in the range 0.5 &lt;= x &lt; 1.0.
// result is in the range 256 .. 511 representing a number in the range in the range 1.0 to 511/256.
</del>
<ins>(FPType, bit, real)</ins><del>integer</del> <a id="impl-shared.FPUnpackBase.2" name="impl-shared.FPUnpackBase.2"></a><ins>FPUnpackBase(bits(N) fpval,</ins><del>RecipEstimate(integer a)
    assert 256 &lt;= a &amp;&amp; a &lt; 512;
    a = a*2+1; // round to nearest
    integer b = (2 ^ 19) DIV a;
    r = (b+1) DIV 2; // round to nearest
    assert 256 &lt;= r &amp;&amp; r &lt; 512;
    return r;</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><ins>FPCRType</ins></a><ins> fpcr)
    assert N IN {16,32,64};

    if N == 16 then
        sign   = fpval&lt;15>;
        exp16  = fpval&lt;14:10>;
        frac16 = fpval&lt;9:0>;
        if </ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(exp16) then
            // Produce zero if value is zero or flush-to-zero is selected
            if </ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(frac16) || fpcr.FZ16 == '1' then
                type = </ins><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><ins>;  value = 0.0;
            else
                type = </ins><a href="shared_pseudocode.html#FPType_Nonzero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Nonzero</ins></a><ins>;  value = 2.0^-14 * (Real(</ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(frac16)) * 2.0^-10);
        elsif </ins><a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)"><ins>IsOnes</ins></a><ins>(exp16) &amp;&amp; fpcr.AHP == '0' then  // Infinity or NaN in IEEE format
            if </ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(frac16) then
                type = </ins><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><ins>;  value = 2.0^1000000;
            else
                type = if frac16&lt;9> == '1' then </ins><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><ins> else </ins><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><ins>;
                value = 0.0;
        else
            type = </ins><a href="shared_pseudocode.html#FPType_Nonzero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Nonzero</ins></a><ins>;
            value = 2.0^(</ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(exp16)-15) * (1.0 + Real(</ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(frac16)) * 2.0^-10);

    elsif N == 32 then

        sign   = fpval&lt;31>;
        exp32  = fpval&lt;30:23>;
        frac32 = fpval&lt;22:0>;
        if </ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(exp32) then
            // Produce zero if value is zero or flush-to-zero is selected.
            if </ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(frac32) || fpcr.FZ == '1' then
                type = </ins><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><ins>;  value = 0.0;
                if !</ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(frac32) then  // Denormalized input flushed to zero
                    </ins><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><ins>(</ins><a href="shared_pseudocode.html#FPExc_InputDenorm" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_InputDenorm</ins></a><ins>, fpcr);
            else
                type = </ins><a href="shared_pseudocode.html#FPType_Nonzero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Nonzero</ins></a><ins>;  value = 2.0^-126 * (Real(</ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(frac32)) * 2.0^-23);
        elsif </ins><a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)"><ins>IsOnes</ins></a><ins>(exp32) then
            if </ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(frac32) then
                type = </ins><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><ins>;  value = 2.0^1000000;
            else
                type = if frac32&lt;22> == '1' then </ins><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><ins> else </ins><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><ins>;
                value = 0.0;
        else
            type = </ins><a href="shared_pseudocode.html#FPType_Nonzero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Nonzero</ins></a><ins>;
            value = 2.0^(</ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(exp32)-127) * (1.0 + Real(</ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(frac32)) * 2.0^-23);

    else // N == 64

        sign   = fpval&lt;63>;
        exp64  = fpval&lt;62:52>;
        frac64 = fpval&lt;51:0>;
        if </ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(exp64) then
            // Produce zero if value is zero or flush-to-zero is selected.
            if </ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(frac64) || fpcr.FZ == '1' then
                type = </ins><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Zero</ins></a><ins>;  value = 0.0;
                if !</ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(frac64) then  // Denormalized input flushed to zero
                    </ins><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><ins>FPProcessException</ins></a><ins>(</ins><a href="shared_pseudocode.html#FPExc_InputDenorm" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><ins>FPExc_InputDenorm</ins></a><ins>, fpcr);
            else
                type = </ins><a href="shared_pseudocode.html#FPType_Nonzero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Nonzero</ins></a><ins>;  value = 2.0^-1022 * (Real(</ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(frac64)) * 2.0^-52);
        elsif </ins><a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)"><ins>IsOnes</ins></a><ins>(exp64) then
            if </ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(frac64) then
                type = </ins><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Infinity</ins></a><ins>;  value = 2.0^1000000;
            else
                type = if frac64&lt;51> == '1' then </ins><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_QNaN</ins></a><ins> else </ins><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_SNaN</ins></a><ins>;
                value = 0.0;
        else
            type = </ins><a href="shared_pseudocode.html#FPType_Nonzero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><ins>FPType_Nonzero</ins></a><ins>;
            value = 2.0^(</ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(exp64)-1023) * (1.0 + Real(</ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(frac64)) * 2.0^-52);

    if sign == '1' then value = -value;
    return (type, sign, value);</ins></p></div><div class="ps" psname="shared.functions.float.fpunpack.FPUnpackCV"><a id="shared.functions.float.fpunpack.FPUnpackCV" name="shared.functions.float.fpunpack.FPUnpackCV"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fpunpack</ins><del>fprecpx</del>/<ins>FPUnpackCV</ins><del>FPRecpX</del></h3><p class="pseudocode"><ins>// FPUnpackCV()
// ============
//
// Used for FP &lt;-> FP conversion instructions.
// For half-precision data ignores FZ16 and observes AHP.
</ins><del>// FPRecpX()
// =========
</del>
<ins>(FPType, bit, real)</ins><del>bits(N)</del> <a id="impl-shared.FPUnpackCV.2" name="impl-shared.FPUnpackCV.2"></a><ins>FPUnpackCV(bits(N) fpval,</ins><del>FPRecpX(bits(N) op,</del> <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
<ins>    fpcr.FZ16 = '0';
    (fp_type, sign, value) =</ins><del>    assert N IN {16,32,64};

    case N of
        when 16 esize =  5;
        when 32 esize =  8;
        when 64 esize = 11;

    bits(N)           result;
    bits(esize)       exp;
    bits(esize)       max_exp;
    bits(N-(esize+1)) frac =</del> <del>();

    case N of
        when 16 exp = op&lt;10+esize-1:10>;
        when 32 exp = op&lt;23+esize-1:23>;
        when 64 exp = op&lt;52+esize-1:52>;

    max_exp = </del><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a><del>(esize) - 1;

    (type,sign,value) = </del><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a><del>(op, fpcr);
    if type == </del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><del> || type == </del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><del> then
        result = </del><a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><del>FPProcessNaN</del></a><del>(type, op, fpcr);
    else
        if </del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><a href="shared_pseudocode.html#impl-shared.FPUnpackBase.2" title="function: (FPType, bit, real) FPUnpackBase(bits(N) fpval, FPCRType fpcr)"><ins>FPUnpackBase</ins></a><a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><del>Zeros</del></a><ins>(fpval, fpcr);
    return (fp_type, sign, value);</ins><del>(exp) then // Zero and denormals
            result = sign:max_exp:frac;
        else // Infinities and normals
            result = sign:NOT(exp):frac;

    return result;</del></p></div><div class="ps" psname="shared.functions.float.fpzero.FPZero"><a id="shared.functions.float.fpzero.FPZero" name="shared.functions.float.fpzero.FPZero"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>fpzero</ins><del>fpround</del>/<ins>FPZero</ins><del>FPRound</del></h3><p class="pseudocode"><ins>// FPZero()
// ========
</ins><del>// FPRound()
// =========
// Used by data processing and int/fixed &lt;-> FP conversion instructions.
// For half-precision data it ignores AHP, and observes FZ16.
</del>
bits(N) <a id="impl-shared.FPZero.1" name="impl-shared.FPZero.1"></a><ins>FPZero(bit sign)
    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp  =</ins><del>FPRound(real op,</del> <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><del>FPCRType</del></a><ins>(E);
    frac =</ins><del>fpcr,</del> <del> rounding)
    fpcr.AHP = '0';
    return </del><a href="shared_pseudocode.html#impl-shared.FPRoundBase.3" title="function: bits(N) FPRoundBase(real op, FPCRType fpcr, FPRounding rounding)"><del>FPRoundBase</del></a><del>(op, fpcr, rounding);

// Convert a real number OP into an N-bit floating-point value using the
// supplied rounding mode RMODE.

bits(N) </del><a id="impl-shared.FPRoundBase.3" name="impl-shared.FPRoundBase.3"></a><del>FPRoundBase(real op, </del><a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><del>FPCRType</del></a><del> fpcr, </del><a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding</del></a><del> rounding)
    assert N IN {16,32,64};
    assert op != 0.0;
    assert rounding != </del><a href="shared_pseudocode.html#FPRounding_TIEAWAY" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_TIEAWAY</del></a><del>;
    bits(N) result;

    // Obtain format parameters - minimum exponent, numbers of exponent and fraction bits.
    if N == 16 then
        minimum_exp = -14;  E = 5;  F = 10;
    elsif N == 32 then
        minimum_exp = -126;  E = 8;  F = 23;
    else  // N == 64
        minimum_exp = -1022;  E = 11;  F = 52;

    // Split value into sign, unrounded mantissa and exponent.
    if op &lt; 0.0 then
        sign = '1';  mantissa = -op;
    else
        sign = '0';  mantissa = op;
    exponent = 0;
    while mantissa &lt; 1.0 do
        mantissa = mantissa * 2.0;  exponent = exponent - 1;
    while mantissa >= 2.0 do
        mantissa = mantissa / 2.0;  exponent = exponent + 1;

    // Deal with flush-to-zero.
    if ((fpcr.FZ == '1' &amp;&amp; N != 16) || (fpcr.FZ16 == '1' &amp;&amp; N == 16)) &amp;&amp; exponent &lt; minimum_exp then
        // Flush-to-zero never generates a trapped exception
        if </del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>() then
            FPSCR.UFC = '1';
        else
            FPSR.UFC = '1';
        return </del><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><del>FPZero</del></a><del>(sign);

    // Start creating the exponent value for the result. Start by biasing the actual exponent
    // so that the minimum exponent becomes 1, lower values 0 (indicating possible underflow).
    biased_exp = </del><a href="shared_pseudocode.html#impl-shared.Max.2" title="function: integer Max(integer a, integer b)"><del>Max</del></a><del>(exponent - minimum_exp + 1, 0);
    if biased_exp == 0 then mantissa = mantissa / 2.0^(minimum_exp - exponent);

    // Get the unrounded mantissa as an integer, and the "units in last place" rounding error.
    int_mant = </del><a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)"><del>RoundDown</del></a><del>(mantissa * 2.0^F);  // &lt; 2.0^F if biased_exp == 0, >= 2.0^F if not
    error = mantissa * 2.0^F - Real(int_mant);

    // Underflow occurs if exponent is too small before rounding, and result is inexact or
    // the Underflow exception is trapped.
    if biased_exp == 0 &amp;&amp; (error != 0.0 || fpcr.UFE == '1') then
        </del><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a><del>(</del><a href="shared_pseudocode.html#FPExc_Underflow" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_Underflow</del></a><del>, fpcr);

    // Round result according to rounding mode.
    case rounding of
        when </del><a href="shared_pseudocode.html#FPRounding_TIEEVEN" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_TIEEVEN</del></a><del>
            round_up = (error > 0.5 || (error == 0.5 &amp;&amp; int_mant&lt;0> == '1'));
            overflow_to_inf = TRUE;
        when </del><a href="shared_pseudocode.html#FPRounding_POSINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_POSINF</del></a><del>
            round_up = (error != 0.0 &amp;&amp; sign == '0');
            overflow_to_inf = (sign == '0');
        when </del><a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_NEGINF</del></a><del>
            round_up = (error != 0.0 &amp;&amp; sign == '1');
            overflow_to_inf = (sign == '1');
        when </del><a href="shared_pseudocode.html#FPRounding_ZERO" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_ZERO</del></a><del>, </del><a href="shared_pseudocode.html#FPRounding_ODD" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_ODD</del></a><del>
            round_up = FALSE;
            overflow_to_inf = FALSE;

    if round_up then
        int_mant = int_mant + 1;
        if int_mant == 2^F then      // Rounded up from denormalized to normalized
            biased_exp = 1;
        if int_mant == 2^(F+1) then  // Rounded up to next exponent
            biased_exp = biased_exp + 1;  int_mant = int_mant DIV 2;

    // Handle rounding to odd aka Von Neumann rounding
    if error != 0.0 &amp;&amp; rounding == </del><a href="shared_pseudocode.html#FPRounding_ODD" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_ODD</del></a><del> then
        int_mant&lt;0> = '1';

    // Deal with overflow and generate result.
    if N != 16 || fpcr.AHP == '0' then  // Single, double or IEEE half precision
        if biased_exp >= 2^E - 1 then
            result = if overflow_to_inf then </del><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><del>FPInfinity</del></a><del>(sign) else </del><a href="shared_pseudocode.html#impl-shared.FPMaxNormal.1" title="function: bits(N) FPMaxNormal(bit sign)"><del>FPMaxNormal</del></a><del>(sign);
            </del><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a><del>(</del><a href="shared_pseudocode.html#FPExc_Overflow" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_Overflow</del></a><del>, fpcr);
            error = 1.0;  // Ensure that an Inexact exception occurs
        else
            result = sign : biased_exp&lt;N-F-2:0> : int_mant&lt;F-1:0>;
    else                                     // Alternative half precision
        if biased_exp >= 2^E then
            result = sign : </del><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a><del>(N-1);
            </del><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a><del>(</del><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_InvalidOp</del></a><del>, fpcr);
            error = 0.0;  // Ensure that an Inexact exception does not occur
        else
            result = sign : biased_exp&lt;N-F-2:0> : int_mant&lt;F-1:0>;

    // Deal with Inexact exception.
    if error != 0.0 then
        </del><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a><del>(</del><a href="shared_pseudocode.html#FPExc_Inexact" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_Inexact</del></a><del>, fpcr);

    return result;

// FPRound()
// =========

bits(N) </del><a id="impl-shared.FPRound.2" name="impl-shared.FPRound.2"></a><del>FPRound(real op, </del><a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><del>FPCRType</del></a><del> fpcr)
    return </del><a href="shared_pseudocode.html#impl-shared.FPRound.3" title="function: bits(N) FPRound(real op, FPCRType fpcr, FPRounding rounding)"><del>FPRound</del></a><del>(op, fpcr, </del><a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)"><del>FPRoundingMode</del></a><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding</del></a><ins>(F);
    return sign : exp : frac;</ins><del>(fpcr));</del></p></div><div class="ps" psname="shared.functions.float.vfpexpandimm.VFPExpandImm"><a id="shared.functions.float.vfpexpandimm.VFPExpandImm" name="shared.functions.float.vfpexpandimm.VFPExpandImm"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/<ins>vfpexpandimm</ins><del>fpround</del>/<ins>VFPExpandImm</ins><del>FPRoundCV</del></h3><p class="pseudocode"><ins>// VFPExpandImm()
// ==============
</ins><del>// FPRoundCV()
// ===========
// Used for FP &lt;-> FP conversion instructions.
// For half-precision data ignores FZ16 and observes AHP.
</del>
bits(N) <a id="impl-shared.VFPExpandImm.1" name="impl-shared.VFPExpandImm.1"></a><ins>VFPExpandImm(bits(8) imm8)
    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - E - 1;
    sign = imm8&lt;7>;
    exp  = NOT(imm8&lt;6>):</ins><del>FPRoundCV(real op,</del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><del>FPCRType</del></a><ins>(imm8&lt;6>,E-3):imm8&lt;5:4>;
    frac = imm8&lt;3:0>:</ins><del>fpcr,</del><del> rounding)
    fpcr.FZ16 = '0';
    return </del><a href="shared_pseudocode.html#impl-shared.FPRoundBase.3" title="function: bits(N) FPRoundBase(real op, FPCRType fpcr, FPRounding rounding)"><del>FPRoundBase</del></a><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding</del></a><ins>(F-4);
    return sign : exp : frac;</ins><del>(op, fpcr, rounding);</del></p></div><div class="ps" psname="shared.functions.integer.AddWithCarry"><a id="shared.functions.integer.AddWithCarry" name="shared.functions.integer.AddWithCarry"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>integer</ins><del>float</del>/<ins>AddWithCarry</ins><del>fprounding/FPRounding</del></h3><p class="pseudocode"><ins>// AddWithCarry()
// ==============
// Integer addition with carry input, returning result and NZCV flags

(bits(N), bits(4))</ins><del>enumeration</del> <a id="impl-shared.AddWithCarry.3" name="impl-shared.AddWithCarry.3"></a><ins>AddWithCarry(bits(N) x, bits(N) y, bit carry_in)
    integer unsigned_sum =</ins><del>FPRounding  {</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(x) +</ins><del>FPRounding_TIEEVEN,</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(y) +</ins><del>FPRounding_POSINF,</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(carry_in);
    integer signed_sum =</ins><del>FPRounding_NEGINF,</del> <a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)"><ins>SInt</ins></a><ins>(x) +</ins><del>FPRounding_ZERO,</del> <a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)"><ins>SInt</ins></a><ins>(y) +</ins><del>FPRounding_TIEAWAY,</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(carry_in);
    bits(N) result = unsigned_sum&lt;N-1:0>; // same value as signed_sum&lt;N-1:0>
    bit n = result&lt;N-1>;
    bit z = if </ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(result) then '1' else '0';
    bit c = if </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(result) == unsigned_sum then '0' else '1';
    bit v = if </ins><a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)"><ins>SInt</ins></a><ins>(result) == signed_sum then '0' else '1';
    return (result, n:z:c:v);</ins><del>FPRounding_ODD};</del></p></div><div class="ps" psname="shared.functions.memory.AArch64.BranchAddr"><a id="shared.functions.memory.AArch64.BranchAddr" name="shared.functions.memory.AArch64.BranchAddr"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>memory</ins><del>float</del>/<ins>AArch64.BranchAddr</ins><del>fproundingmode/FPRoundingMode</del></h3><p class="pseudocode"><ins>// AArch64.BranchAddr()
// ====================
// Return the virtual address with tag bits removed for storing to the program counter.
</ins><del>// FPRoundingMode()
// ================
</del>
<ins>bits(64)</ins><del>// Return the current floating-point rounding mode.

FPRounding</del> <a id="AArch64.BranchAddr.1" name="AArch64.BranchAddr.1"></a><ins>AArch64.BranchAddr(bits(64) vaddress)
    assert !</ins><del>FPRoundingMode(</del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><del>FPCRType</del></a><ins>();
    msbit =</ins><del>fpcr)
    return</del> <a href="shared_pseudocode.html#impl-shared.AddrTop.3" title="function: integer AddrTop(bits(64) address, boolean IsInstr, bits(2) el)"><ins>AddrTop</ins></a><a href="shared_pseudocode.html#impl-shared.FPDecodeRounding.1" title="function: FPRounding FPDecodeRounding(bits(2) rmode)"><del>FPDecodeRounding</del></a><ins>(vaddress, TRUE, PSTATE.EL);
    if msbit == 63 then
        return vaddress;
    elsif (PSTATE.EL IN {</ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>, </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>} || </ins><a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><ins>IsInHost</ins></a><ins>()) &amp;&amp; vaddress&lt;msbit> == '1' then
        return </ins><a href="shared_pseudocode.html#impl-shared.SignExtend.1" title="function: bits(N) SignExtend(bits(M) x)"><ins>SignExtend</ins></a><ins>(vaddress&lt;msbit:0>);
    else
        return </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(vaddress&lt;msbit:0>);</ins><del>(fpcr.RMode);</del></p></div><div class="ps" psname="shared.functions.memory.AccType"><a id="shared.functions.memory.AccType" name="shared.functions.memory.AccType"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>memory</ins><del>float</del>/<ins>AccType</ins><del>fproundint/FPRoundInt</del></h3><p class="pseudocode"><ins>enumeration</ins><del>// FPRoundInt()
// ============

// Round OP to nearest integral floating point value using rounding mode ROUNDING.
// If EXACT is TRUE, set FPSR.IXC if result is not numerically equal to OP.

bits(N)</del> <a id="AccType" name="AccType"></a><ins>AccType {</ins><del>FPRoundInt(bits(N) op,</del><a id="AccType_NORMAL" name="AccType_NORMAL"></a><ins>AccType_NORMAL,</ins><del>fpcr,</del> <a id="AccType_VEC" name="AccType_VEC"></a><ins>AccType_VEC,        // Normal loads and stores</ins><del>rounding, boolean exact)
    assert rounding !=</del>
                     <a id="AccType_STREAM" name="AccType_STREAM"></a><ins>AccType_STREAM,</ins><del>;
    assert N IN {16,32,64};

    // Unpack using FPCR to determine if subnormals are flushed-to-zero
    (type,sign,value) =</del> <a id="AccType_VECSTREAM" name="AccType_VECSTREAM"></a><ins>AccType_VECSTREAM,  // Streaming loads and stores</ins><del>(op, fpcr);

    if type ==</del>
                     <a id="AccType_ATOMIC" name="AccType_ATOMIC"></a><ins>AccType_ATOMIC,</ins><del>|| type ==</del> <a id="AccType_ATOMICRW" name="AccType_ATOMICRW"></a><ins>AccType_ATOMICRW,   // Atomic loads and stores</ins><del>then
        result =</del>
                     <a id="AccType_ORDERED" name="AccType_ORDERED"></a><ins>AccType_ORDERED,</ins><del>(type, op, fpcr);
    elsif type ==</del> <a id="AccType_ORDEREDRW" name="AccType_ORDEREDRW"></a><ins>AccType_ORDEREDRW, // Load-Acquire and Store-Release</ins><del>then
        result =</del>
                     <a id="AccType_ORDEREDATOMIC" name="AccType_ORDEREDATOMIC"></a><ins>AccType_ORDEREDATOMIC,              // Load-Acquire and Store-Release with atomic access</ins><del>(sign);
    elsif type ==</del>
                     <a id="AccType_ORDEREDATOMICRW" name="AccType_ORDEREDATOMICRW"></a><ins>AccType_ORDEREDATOMICRW,</ins><del>then
        result =</del>
                     <a id="AccType_LIMITEDORDERED" name="AccType_LIMITEDORDERED"></a><ins>AccType_LIMITEDORDERED,             // Load-LOAcquire and Store-LORelease</ins><del>(sign);
    else
        // extract integer component
        int_result =</del>
                     <a id="AccType_UNPRIV" name="AccType_UNPRIV"></a><ins>AccType_UNPRIV,                     // Load and store unprivileged</ins><del>(value);
        error = value - Real(int_result);

        // Determine whether supplied rounding mode requires an increment
        case rounding of
            when</del>
                     <a id="AccType_IFETCH" name="AccType_IFETCH"></a><ins>AccType_IFETCH,                     // Instruction fetch</ins><del>round_up = (error > 0.5 || (error == 0.5 &amp;&amp; int_result&lt;0> == '1'));
            when</del>
                     <a id="AccType_PTW" name="AccType_PTW"></a><ins>AccType_PTW,                        // Page table walk</ins><del>round_up = (error != 0.0);
            when</del>
                     <a id="AccType_NONFAULT" name="AccType_NONFAULT"></a><ins>AccType_NONFAULT,                   // Non-faulting loads</ins><del>round_up = FALSE;
            when</del>
                     <a id="AccType_CNOTFIRST" name="AccType_CNOTFIRST"></a><ins>AccType_CNOTFIRST,                  // Contiguous FF load, not first element</ins><del>round_up = (error != 0.0 &amp;&amp; int_result &lt; 0);
            when</del>
                     <a id="AccType_NV2REGISTER" name="AccType_NV2REGISTER"></a><ins>AccType_NV2REGISTER,                // MRS/MSR instruction used at EL1 and which is converted
                                                         // to a memory access that uses the EL2 translation regime
                     // Other operations</ins><del>round_up = (error > 0.5 || (error == 0.5 &amp;&amp; int_result >= 0));

        if round_up then int_result = int_result + 1;

        // Convert integer value into an equivalent real value
        real_result = Real(int_result);

        // Re-encode as a floating-point value, result is always exact
        if real_result == 0.0 then
            result =</del>
                     <a id="AccType_DC" name="AccType_DC"></a><ins>AccType_DC,                         // Data cache maintenance</ins><del>(sign);
        else
            result =</del>
                     <a id="AccType_DC_UNPRIV" name="AccType_DC_UNPRIV"></a><ins>AccType_DC_UNPRIV,                  // Data cache maintenance instruction used at EL0</ins><del>(real_result, fpcr,</del>
                     <a id="AccType_IC" name="AccType_IC"></a><ins>AccType_IC,                         // Instruction cache maintenance</ins><del>);

        // Generate inexact exceptions
        if error != 0.0 &amp;&amp; exact then</del>
                     <a id="AccType_DCZVA" name="AccType_DCZVA"></a><ins>AccType_DCZVA,                      // DC ZVA instructions</ins><del>(</del>
                     <a id="AccType_AT" name="AccType_AT"></a><ins>AccType_AT};                        // Address translation</ins><del>, fpcr);

    return result;</del></p></div><div class="ps" psname="shared.functions.memory.AccessDescriptor"><a id="shared.functions.memory.AccessDescriptor" name="shared.functions.memory.AccessDescriptor"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>memory</ins><del>float</del>/<ins>AccessDescriptor</ins><del>fproundintn/FPRoundIntN</del></h3><p class="pseudocode"><ins>type AccessDescriptor is (</ins><del>// FPRoundIntN()
// =============

bits(N)</del>
    <del>FPRoundIntN(bits(N) op, </del><a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><del>FPCRType</del></a><del> fpcr, </del><a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding</del></a><del> rounding, integer intsize)
    assert rounding != </del><a href="shared_pseudocode.html#FPRounding_ODD" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_ODD</del></a><del>;
    assert N IN {32,64};
    assert intsize IN {32, 64};
    integer exp;
    constant integer E = (if N == 32 then 8 else 11);
    constant integer F = N - (E + 1);

    // Unpack using FPCR to determine if subnormals are flushed-to-zero
    (type,sign,value) = </del><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a><del>(op, fpcr);

    if type IN {</del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><del>, </del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><del>, </del><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a><del>} then
        if N == 32 then
            exp = 126 + intsize;
            result = '1':exp&lt;(E-1):0>:</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(F);
        else
            exp = 1022+intsize;
            result = '1':exp&lt;(E-1):0>:</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(F);
        </del><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a><del>(</del><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_InvalidOp</del></a><del>, fpcr);
    elsif type == </del><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a><del> then
        result = </del><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><del>FPZero</del></a><del>(sign);
    else
        // Extract integer component
        int_result = </del><a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)"><del>RoundDown</del></a><del>(value);
        error = value - Real(int_result);

        // Determine whether supplied rounding mode requires an increment
        case rounding of
            when </del><a href="shared_pseudocode.html#FPRounding_TIEEVEN" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_TIEEVEN</del></a><del>
                round_up = error > 0.5 || (error == 0.5 &amp;&amp; int_result&lt;0> == '1');
            when </del><a href="shared_pseudocode.html#FPRounding_POSINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_POSINF</del></a><del>
                round_up = error != 0.0;
            when </del><a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_NEGINF</del></a><del>
                round_up = FALSE;
            when </del><a href="shared_pseudocode.html#FPRounding_ZERO" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_ZERO</del></a><del>
                round_up = error != 0.0 &amp;&amp; int_result &lt; 0;
            when </del><a href="shared_pseudocode.html#FPRounding_TIEAWAY" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_TIEAWAY</del></a><del>
                round_up = error > 0.5 || (error == 0.5 &amp;&amp; int_result >= 0);

        if round_up then int_result = int_result + 1;

        if int_result > 2^(intsize-1)-1 || int_result &lt; -1*2^(intsize-1) then
            if N == 32 then
                exp = 126 + intsize;
                result = '1':exp&lt;(E-1):0>:</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(F);
            else
                exp = 1022 + intsize;
                result = '1':exp&lt;(E-1):0>:</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(F);
            </del><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a><del>(</del><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_InvalidOp</del></a><del>, fpcr);
            // this case shouldn't set Inexact
            error = 0.0;

        else
            // Convert integer value into an equivalent real value
            real_result = Real(int_result);

            // Re-encode as a floating-point value, result is always exact
            if real_result == 0.0 then
                result = </del><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><del>FPZero</del></a><del>(sign);
            else
                result = </del><a href="shared_pseudocode.html#impl-shared.FPRound.3" title="function: bits(N) FPRound(real op, FPCRType fpcr, FPRounding rounding)"><del>FPRound</del></a><del>(real_result, fpcr, </del><a href="shared_pseudocode.html#FPRounding_ZERO" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_ZERO</del></a><del>);

        // Generate inexact exceptions
        if error != 0.0 then
            </del><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a><del>(</del><a href="shared_pseudocode.html#FPExc_Inexact" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_Inexact</del></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a> <ins>acctype,
    MPAMinfo mpam,
    boolean page_table_walk,
    boolean secondstage,
    boolean s2fs1walk,
    integer level
)</ins><del>, fpcr);

    return result;</del></p></div><div class="ps" psname="shared.functions.memory.AddrTop"><a id="shared.functions.memory.AddrTop" name="shared.functions.memory.AddrTop"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>memory</ins><del>float</del>/<ins>AddrTop</ins><del>fprsqrtestimate/FPRSqrtEstimate</del></h3><p class="pseudocode"><ins>// AddrTop()
// =========
// Return the MSB number of a virtual address in the stage 1 translation regime for "el".
// If EL1 is using AArch64 then addresses from EL0 using AArch32 are zero-extended to 64 bits.
</ins><del>// FPRSqrtEstimate()
// =================
</del>
<ins>integer</ins><del>bits(N)</del> <a id="impl-shared.AddrTop.3" name="impl-shared.AddrTop.3"></a><ins>AddrTop(bits(64) address, boolean IsInstr, bits(2) el)
    assert</ins><del>FPRSqrtEstimate(bits(N) operand,</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><del>FPCRType</del></a><ins>(el);
    regime =</ins><del>fpcr)
    assert N IN {16,32,64};
    (type,sign,value) =</del> <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.1" title="function: bits(2) S1TranslationRegime(bits(2) el)"><ins>S1TranslationRegime</ins></a><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a><ins>(el);
    if</ins><del>(operand, fpcr);
    if type ==</del> <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><ins>(regime) then
        // AArch32 translation regime.
        return 31;
    else
        // AArch64 translation regime.
        case regime of
            when</ins><del>|| type ==</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a>
                <ins>tbi = (if address&lt;55> == '1' then TCR_EL1.TBI1 else TCR_EL1.TBI0);
                if</ins><del>then
        result =</del> <a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()"><ins>HavePACExt</ins></a><a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><del>FPProcessNaN</del></a><ins>() then
                    tbid = if address&lt;55> == '1' then TCR_EL1.TBID1 else TCR_EL1.TBID0;
            when</ins><del>(type, operand, fpcr);
    elsif type ==</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a>
                <ins>if</ins><del>then
        result =</del> <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><ins>HaveVirtHostExt</ins></a><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><del>FPInfinity</del></a><ins>() &amp;&amp;</ins><del>(sign);</del> <a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)"><ins>ELIsInHost</ins></a><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a><ins>(el) then
                    tbi = (if address&lt;55> == '1' then TCR_EL2.TBI1 else TCR_EL2.TBI0);
                    if</ins><del>(</del> <a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()"><ins>HavePACExt</ins></a><a href="shared_pseudocode.html#FPExc_DivideByZero" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_DivideByZero</del></a><ins>() then
                        tbid = if address&lt;55> == '1' then TCR_EL2.TBID1 else TCR_EL2.TBID0;
                else
                    tbi = TCR_EL2.TBI;
                    if</ins><del>, fpcr);
    elsif sign == '1' then
        result =</del> <a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()"><ins>HavePACExt</ins></a><a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.0" title="function: bits(N) FPDefaultNaN()"><del>FPDefaultNaN</del></a><ins>() then tbid = TCR_EL2.TBID;
            when</ins><del>();</del> <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a>
                <ins>tbi = TCR_EL3.TBI;
                if</ins><del>(</del> <a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()"><ins>HavePACExt</ins></a><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_InvalidOp</del></a><ins>() then tbid = TCR_EL3.TBID;

    return (if tbi == '1' &amp;&amp; (!</ins><del>, fpcr);
    elsif type ==</del><del> then
        result = </del><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><del>FPZero</del></a><del>('0');
    else
        // Scale to a fixed-point value in the range 0.25 &lt;= x &lt; 1.0 in steps of 512, with the
        // evenness or oddness of the exponent unchanged, and calculate result exponent.
        // Scaled value has copied sign bit, exponent = 1022 or 1021 = double-precision
        // biased version of -1 or -2, fraction = original fraction extended with zeros.

        case N of
            when 16
                fraction = operand&lt;9:0> : </del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(42);
                exp = </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(operand&lt;14:10>);
            when 32
                fraction = operand&lt;22:0> : </del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(29);
                exp = </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(operand&lt;30:23>);
            when 64
                fraction = operand&lt;51:0>;
                exp = </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(operand&lt;62:52>);

        if exp == 0 then
            while fraction&lt;51> == 0 do
                fraction = fraction&lt;50:0> : '0';
                exp = exp - 1;
            fraction = fraction&lt;50:0> : '0';

        if exp&lt;0> == '0' then
            scaled = </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>('1':fraction&lt;51:44>);
        else
            scaled = </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>('01':fraction&lt;51:45>);

        case N of
            when 16 result_exp = (  44 - exp) DIV 2;
            when 32 result_exp = ( 380 - exp) DIV 2;
            when 64 result_exp = (3068 - exp) DIV 2;

        estimate = </del><a href="shared_pseudocode.html#impl-shared.RecipSqrtEstimate.1" title="function: integer RecipSqrtEstimate(integer a)"><del>RecipSqrtEstimate</del></a><del>(scaled);

        // estimate is in the range 256..511 representing a fixed point result in the range [1.0..2.0)
        // Convert to scaled floating point result with copied sign bit and high-order
        // fraction bits, and exponent calculated above.
        case N of
            when 16 result = '0' : result_exp&lt;N-12:0> : estimate&lt;7:0>:</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>( 2);
            when 32 result = '0' : result_exp&lt;N-25:0> : estimate&lt;7:0>:</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(15);
            when 64 result = '0' : result_exp&lt;N-54:0> : estimate&lt;7:0>:</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()"><ins>HavePACExt</ins></a><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a><ins>() || tbid == '0' || !IsInstr ) then 55 else 63);</ins><del>(44);
    return result;</del></p></div><div class="ps" psname="shared.functions.memory.AddressDescriptor"><a id="shared.functions.memory.AddressDescriptor" name="shared.functions.memory.AddressDescriptor"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>memory</ins><del>float</del>/<ins>AddressDescriptor</ins><del>fprsqrtestimate/RecipSqrtEstimate</del></h3><p class="pseudocode"><ins>type</ins><del>// Compute estimate of reciprocal square root of 9-bit fixed-point number
//
// a is in range 128 .. 511 representing a number in the range 0.25 &lt;= x &lt; 1.0.
// result is in the range 256 .. 511 representing a number in the range in the range 1.0 to 511/256.

integer</del> <a id="AddressDescriptor" name="AddressDescriptor"></a><ins>AddressDescriptor is (</ins><del>RecipSqrtEstimate(integer a)
    assert 128 &lt;= a &amp;&amp; a &lt; 512;
    if a &lt; 256 then // 0.25 .. 0.5
        a = a*2+1;     // a in units of 1/512 rounded to nearest
    else // 0.5 .. 1.0
        a = (a >> 1) &lt;&lt; 1;   // discard bottom bit
        a = (a+1)*2;  // a in units of 1/256 rounded to nearest
    integer b = 512;
    while a*(b+1)*(b+1) &lt; 2^28 do
        b = b+1;
    // b = largest b such that b &lt; 2^14 / sqrt(a) do
    r = (b+1) DIV 2; // round to nearest
    assert 256 &lt;= r &amp;&amp; r &lt; 512;
    return r;</del>
    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><ins>FaultRecord</ins></a><ins>      fault,      // fault.type indicates whether the address is valid
    </ins><a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType type, DeviceType device, MemAttrHints inner, MemAttrHints outer, boolean tagged, boolean shareable, boolean outershareable )"><ins>MemoryAttributes</ins></a><ins> memattrs,
    </ins><a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( bits(52) address, bit NS )"><ins>FullAddress</ins></a><ins>      paddress,
    bits(64)         vaddress
)</ins></p></div><div class="ps" psname="shared.functions.memory.AddressWithAllocationTag"><a id="shared.functions.memory.AddressWithAllocationTag" name="shared.functions.memory.AddressWithAllocationTag"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>memory</ins><del>float</del>/<ins>AddressWithAllocationTag</ins><del>fpsqrt/FPSqrt</del></h3><p class="pseudocode"><ins>// AddressWithAllocationTag()
// ==========================
// Generate a 64-bit value containing a Logical Address Tag from a 64-bit
// virtual address and an Allocation Tag.
// If the extension is disabled, treats the Allocation Tag as â0000â.
</ins><del>// FPSqrt()
// ========
</del>
<ins>bits(64)</ins><del>bits(N)</del> <a id="impl-shared.AddressWithAllocationTag.2_3" name="impl-shared.AddressWithAllocationTag.2_3"></a><ins>AddressWithAllocationTag(bits(64) address, bits(4) allocation_tag)
    bits(64) result = address;
    bits(4) tag = allocation_tag - ('000':address&lt;55>);
    result&lt;59:56> = tag;
    return result;</ins><del>FPSqrt(bits(N) op,</del><a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><del>FPCRType</del></a><del> fpcr)
    assert N IN {16,32,64};
    (type,sign,value) = </del><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a><del>(op, fpcr);
    if type == </del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><del> || type == </del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><del> then
        result = </del><a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType type, bits(N) op, FPCRType fpcr)"><del>FPProcessNaN</del></a><del>(type, op, fpcr);
    elsif type == </del><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a><del> then
        result = </del><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><del>FPZero</del></a><del>(sign);
    elsif type == </del><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a><del> &amp;&amp; sign == '0' then
        result = </del><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><del>FPInfinity</del></a><del>(sign);
    elsif sign == '1' then
        result = </del><a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.0" title="function: bits(N) FPDefaultNaN()"><del>FPDefaultNaN</del></a><del>();
        </del><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a><del>(</del><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_InvalidOp</del></a><del>, fpcr);
    else
        result = </del><a href="shared_pseudocode.html#impl-shared.FPRound.2" title="function: bits(N) FPRound(real op, FPCRType fpcr)"><del>FPRound</del></a><del>(Sqrt(value), fpcr);
    return result;</del></p></div><div class="ps" psname="shared.functions.memory.Allocation"><a id="shared.functions.memory.Allocation" name="shared.functions.memory.Allocation"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>memory</ins><del>float</del>/<ins>Allocation</ins><del>fpsub/FPSub</del></h3><p class="pseudocode"><ins>constant bits(2)</ins><del>// FPSub()
// =======

bits(N)</del> <a id="MemHint_No" name="MemHint_No"></a><ins>MemHint_No = '00';     // No Read-Allocate, No Write-Allocate
constant bits(2)</ins><del>FPSub(bits(N) op1, bits(N) op2,</del> <a id="MemHint_WA" name="MemHint_WA"></a><ins>MemHint_WA = '01';     // No Read-Allocate, Write-Allocate
constant bits(2)</ins><del>fpcr)
    assert N IN {16,32,64};
    rounding =</del> <a id="MemHint_RA" name="MemHint_RA"></a><ins>MemHint_RA = '10';     // Read-Allocate, No Write-Allocate
constant bits(2)</ins><del>(fpcr);
    (type1,sign1,value1) =</del> <del>(op1, fpcr);
    (type2,sign2,value2) = </del><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a><del>(op2, fpcr);
    (done,result) = </del><a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2, FPCRType fpcr)"><del>FPProcessNaNs</del></a><del>(type1, type2, op1, op2, fpcr);
    if !done then
        inf1 = (type1 == </del><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a><del>);
        inf2 = (type2 == </del><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a><del>);
        zero1 = (type1 == </del><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a><del>);
        zero2 = (type2 == </del><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a><del>);
        if inf1 &amp;&amp; inf2 &amp;&amp; sign1 == sign2 then
            result = </del><a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.0" title="function: bits(N) FPDefaultNaN()"><del>FPDefaultNaN</del></a><del>();
            </del><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a><del>(</del><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_InvalidOp</del></a><del>, fpcr);
        elsif (inf1 &amp;&amp; sign1 == '0') || (inf2 &amp;&amp; sign2 == '1') then
            result = </del><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><del>FPInfinity</del></a><del>('0');
        elsif (inf1 &amp;&amp; sign1 == '1') || (inf2 &amp;&amp; sign2 == '0') then
            result = </del><a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)"><del>FPInfinity</del></a><del>('1');
        elsif zero1 &amp;&amp; zero2 &amp;&amp; sign1 == NOT(sign2) then
            result = </del><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><del>FPZero</del></a><del>(sign1);
        else
            result_value = value1 - value2;
            if result_value == 0.0 then  // Sign of exact zero result depends on rounding mode
                result_sign = if rounding == </del><a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_NEGINF</del></a><del> then '1' else '0';
                result = </del><a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)"><del>FPZero</del></a><del>(result_sign);
            else
                result = </del><a href="shared_pseudocode.html#impl-shared.FPRound.3" title="function: bits(N) FPRound(real op, FPCRType fpcr, FPRounding rounding)"><del>FPRound</del></a><a id="MemHint_RWA" name="MemHint_RWA"></a><ins>MemHint_RWA = '11';    // Read-Allocate, Write-Allocate</ins><del>(result_value, fpcr, rounding);
    return result;</del></p></div><div class="ps" psname="shared.functions.memory.AllocationTagFromAddress"><a id="shared.functions.memory.AllocationTagFromAddress" name="shared.functions.memory.AllocationTagFromAddress"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>memory</ins><del>float</del>/<ins>AllocationTagFromAddress</ins><del>fpthree/FPThree</del></h3><p class="pseudocode"><ins>// AllocationTagFromAddress()
// ==========================
// Generate a Tag from a 64-bit value containing a Logical Address Tag.
// If access to Allocation Tags is disabled, this function returns â0000â.
</ins><del>// FPThree()
// =========
</del>
<ins>bits(4)</ins><del>bits(N)</del> <a id="impl-shared.AllocationTagFromAddress.1_3" name="impl-shared.AllocationTagFromAddress.1_3"></a><ins>AllocationTagFromAddress(bits(64) tagged_address)
    bits(4) logical_tag = tagged_address&lt;59:56>;
    bits(4) tag = logical_tag + ('000':tagged_address&lt;55>);
    return tag;</ins><del>FPThree(bit sign)
    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp  = '1':</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(E-1);
    frac = '1':</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(F-1);
    return sign : exp : frac;</del></p></div><div class="ps" psname="shared.functions.memory.BigEndian"><a id="shared.functions.memory.BigEndian" name="shared.functions.memory.BigEndian"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>memory</ins><del>float</del>/<ins>BigEndian</ins><del>fptofixed/FPToFixed</del></h3><p class="pseudocode"><ins>// BigEndian()
</ins><del>// FPToFixed()
</del>// ===========

<ins>boolean</ins><del>// Convert N-bit precision floating point OP to M-bit fixed point with
// FBITS fractional bits, controlled by UNSIGNED and ROUNDING.

bits(M)</del> <a id="impl-shared.BigEndian.0" name="impl-shared.BigEndian.0"></a><ins>BigEndian()
    boolean bigend;
    if</ins><del>FPToFixed(bits(N) op, integer fbits, boolean unsigned,</del> <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><del>FPCRType</del></a><ins>() then
        bigend = (PSTATE.E != '0');
    elsif PSTATE.EL ==</ins><del>fpcr,</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding</del></a> <ins>then
        bigend = (</ins><del>rounding)
    assert N IN {16,32,64};
    assert M IN {16,32,64};
    assert fbits >= 0;
    assert rounding !=</del><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><ins>SCTLR</ins></a><a href="shared_pseudocode.html#FPRounding_ODD" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_ODD</del></a><ins>[].E0E != '0');
    else
        bigend = (</ins><del>;

    // Unpack using fpcr to determine if subnormals are flushed-to-zero
    (type,sign,value) =</del><del>(op, fpcr);

    // If NaN, set cumulative flag or take exception
    if type == </del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><del> || type == </del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><del> then
        </del><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a><del>(</del><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_InvalidOp</del></a><del>, fpcr);

    // Scale by fractional bits and produce integer rounded towards minus-infinity
    value = value * 2.0^fbits;
    int_result = </del><a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)"><del>RoundDown</del></a><del>(value);
    error = value - Real(int_result);

    // Determine whether supplied rounding mode requires an increment
    case rounding of
        when </del><a href="shared_pseudocode.html#FPRounding_TIEEVEN" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_TIEEVEN</del></a><del>
            round_up = (error > 0.5 || (error == 0.5 &amp;&amp; int_result&lt;0> == '1'));
        when </del><a href="shared_pseudocode.html#FPRounding_POSINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_POSINF</del></a><del>
            round_up = (error != 0.0);
        when </del><a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_NEGINF</del></a><del>
            round_up = FALSE;
        when </del><a href="shared_pseudocode.html#FPRounding_ZERO" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_ZERO</del></a><del>
            round_up = (error != 0.0 &amp;&amp; int_result &lt; 0);
        when </del><a href="shared_pseudocode.html#FPRounding_TIEAWAY" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF, FPRounding_NEGINF,  FPRounding_ZERO, FPRounding_TIEAWAY, FPRounding_ODD}"><del>FPRounding_TIEAWAY</del></a><del>
            round_up = (error > 0.5 || (error == 0.5 &amp;&amp; int_result >= 0));

    if round_up then int_result = int_result + 1;

    // Generate saturated result and exceptions
    (result, overflow) = </del><a href="shared_pseudocode.html#impl-shared.SatQ.3" title="function: (bits(N), boolean) SatQ(integer i, integer N, boolean unsigned)"><del>SatQ</del></a><del>(int_result, M, unsigned);
    if overflow then
        </del><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a><del>(</del><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_InvalidOp</del></a><del>, fpcr);
    elsif error != 0.0 then
        </del><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a><del>(</del><a href="shared_pseudocode.html#FPExc_Inexact" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_Inexact</del></a><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><ins>SCTLR</ins></a><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a><ins>[].EE != '0');
    return bigend;</ins><del>, fpcr);

    return result;</del></p></div><div class="ps" psname="shared.functions.memory.BigEndianReverse"><a id="shared.functions.memory.BigEndianReverse" name="shared.functions.memory.BigEndianReverse"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>memory</ins><del>float</del>/<ins>BigEndianReverse</ins><del>fptofixedjs/FPToFixedJS</del></h3><p class="pseudocode"><ins>// BigEndianReverse()
// ==================
</ins><del>// FPToFixedJS()
// =============
</del>
<ins>bits(width)</ins><del>// Converts a double precision floating point input value
// to a signed integer, with rounding to zero.

bits(N)</del> <a id="impl-shared.BigEndianReverse.1" name="impl-shared.BigEndianReverse.1"></a><ins>BigEndianReverse (bits(width) value)
    assert width IN {8, 16, 32, 64, 128};
    integer half = width DIV 2;
    if width == 8 then return value;
    return</ins><del>FPToFixedJS(bits(M) op,</del> <a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)"><ins>BigEndianReverse</ins></a><a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><del>FPCRType</del></a><ins>(value&lt;half-1:0>) :</ins><del>fpcr, boolean Is64)

    assert M == 64 &amp;&amp; N == 32;

    // Unpack using fpcr to determine if subnormals are flushed-to-zero
    (type,sign,value) =</del> <del>(op, fpcr);

    Z = '1';
    // If NaN, set cumulative flag or take exception
    if type == </del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><del> || type == </del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><del> then
        </del><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a><del>(</del><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_InvalidOp</del></a><del>, fpcr);
        Z = '0';

    int_result = </del><a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)"><del>RoundDown</del></a><del>(value);
    error = value - Real(int_result);

    // Determine whether supplied rounding mode requires an increment

    round_it_up = (error != 0.0 &amp;&amp; int_result &lt; 0);
    if round_it_up then int_result = int_result + 1;

    if int_result &lt; 0 then
        result = int_result - 2^32*</del><a href="shared_pseudocode.html#impl-shared.RoundUp.1" title="function: integer RoundUp(real x)"><del>RoundUp</del></a><del>(Real(int_result)/Real(2^32));
    else
        result = int_result - 2^32*</del><a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)"><del>RoundDown</del></a><del>(Real(int_result)/Real(2^32));

    // Generate exceptions
    if int_result &lt; -(2^31) || int_result > (2^31)-1 then
        </del><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a><del>(</del><a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_InvalidOp</del></a><del>, fpcr);
        Z = '0';
    elsif error != 0.0 then
        </del><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a><del>(</del><a href="shared_pseudocode.html#FPExc_Inexact" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_Inexact</del></a><del>, fpcr);
        Z = '0';
    if sign == '1'&amp;&amp; value == 0.0 then
        Z = '0';

    if type == </del><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a><a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)"><ins>BigEndianReverse</ins></a><a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)"><del>FPUnpack</del></a><ins>(value&lt;width-1:half>);</ins><del>then result = 0;

    if Is64 then
        PSTATE.&lt;N,Z,C,V> = '0':Z:'00';
    else
        FPSCR&lt;31:28> = '0':Z:'00';

    return result&lt;N-1:0>;</del></p></div><div class="ps" psname="shared.functions.memory.Cacheability"><a id="shared.functions.memory.Cacheability" name="shared.functions.memory.Cacheability"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>memory</ins><del>float</del>/<ins>Cacheability</ins><del>fptwo/FPTwo</del></h3><p class="pseudocode"><ins>constant bits(2)</ins><del>// FPTwo()
// =======

bits(N)</del> <a id="MemAttr_NC" name="MemAttr_NC"></a><ins>MemAttr_NC = '00';     // Non-cacheable
constant bits(2)</ins><del>FPTwo(bit sign)
    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp  = '1':</del> <a id="MemAttr_WT" name="MemAttr_WT"></a><ins>MemAttr_WT = '10';     // Write-through
constant bits(2)</ins><del>(E-1);
    frac =</del> <a id="MemAttr_WB" name="MemAttr_WB"></a><ins>MemAttr_WB = '11';     // Write-back</ins><del>(F);
    return sign : exp : frac;</del></p></div><div class="ps" psname="shared.functions.memory.CheckTag"><a id="shared.functions.memory.CheckTag" name="shared.functions.memory.CheckTag"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>memory</ins><del>float</del>/<ins>CheckTag</ins><del>fptype/FPType</del></h3><p class="pseudocode"><ins>// CheckTag()
// ==========
// Performs a Tag Check operation for a memory access and returns
// whether the check passed

boolean</ins><del>enumeration</del> <a id="impl-shared.CheckTag.3_3" name="impl-shared.CheckTag.3_3"></a><ins>CheckTag(</ins><del>FPType      {</del><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><ins>AddressDescriptor</ins></a> <ins>memaddrdesc, bits(4) ptag, boolean write)
    if memaddrdesc.memattrs.tagged then
        bits(64) paddress =</ins><del>FPType_Nonzero,</del> <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(memaddrdesc.paddress.address);
        return ptag ==</ins><del>FPType_Zero,</del> <del>FPType_Infinity,
                         </del><a id="FPType_QNaN" name="FPType_QNaN"></a><del>FPType_QNaN, </del><a id="FPType_SNaN" name="FPType_SNaN"></a><a href="shared_pseudocode.html#impl-aarch64.MemTag.read.1" title="accessor: bits(4) MemTag[bits(64) address]"><ins>MemTag</ins></a><ins>[paddress];
    else
        return TRUE;</ins><del>FPType_SNaN};</del></p></div><div class="ps" psname="shared.functions.memory.CreateAccessDescriptor"><a id="shared.functions.memory.CreateAccessDescriptor" name="shared.functions.memory.CreateAccessDescriptor"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>memory</ins><del>float</del>/<ins>CreateAccessDescriptor</ins><del>fpunpack/FPUnpack</del></h3><p class="pseudocode"><ins>// CreateAccessDescriptor()
// ========================
</ins><del>// FPUnpack()
// ==========
//
// Used by data processing and int/fixed &lt;-> FP conversion instructions.
// For half-precision data it ignores AHP, and observes FZ16.
</del>
<ins>AccessDescriptor CreateAccessDescriptor(</ins><del>(FPType, bit, real)</del><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a> <ins>acctype)
    AccessDescriptor accdesc;
    accdesc.acctype = acctype;
    accdesc.mpam = GenMPAMcurEL(acctype IN {</ins><del>FPUnpack(bits(N) fpval,</del><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><del>FPCRType</del></a><ins>,</ins><del>fpcr)
    fpcr.AHP = '0';
    (fp_type, sign, value) =</del> <a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IC</ins></a><a href="shared_pseudocode.html#impl-shared.FPUnpackBase.2" title="function: (FPType, bit, real) FPUnpackBase(bits(N) fpval, FPCRType fpcr)"><del>FPUnpackBase</del></a><ins>});
    accdesc.page_table_walk = FALSE;
    return accdesc;</ins><del>(fpval, fpcr);
    return (fp_type, sign, value);</del></p></div><div class="ps" psname="shared.functions.memory.CreateAccessDescriptorPTW"><a id="shared.functions.memory.CreateAccessDescriptorPTW" name="shared.functions.memory.CreateAccessDescriptorPTW"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>memory</ins><del>float</del>/<ins>CreateAccessDescriptorPTW</ins><del>fpunpack/FPUnpackBase</del></h3><p class="pseudocode"><ins>// CreateAccessDescriptorPTW()
// ===========================
</ins><del>// FPUnpackBase()
// ==============
//
// Unpack a floating-point number into its type, sign bit and the real number
// that it represents. The real number result has the correct sign for numbers
// and infinities, is very large in magnitude for infinities, and is 0.0 for
// NaNs. (These values are chosen to simplify the description of comparisons
// and conversions.)
//
// The 'fpcr' argument supplies FPCR control bits. Status information is
// updated directly in the FPSR where appropriate.
</del>
<ins>AccessDescriptor CreateAccessDescriptorPTW(</ins><del>(FPType, bit, real)</del><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a> <ins>acctype, boolean secondstage,
                                           boolean s2fs1walk, integer level)
    AccessDescriptor accdesc;
    accdesc.acctype = acctype;
    accdesc.mpam = GenMPAMcurEL(acctype IN {</ins><del>FPUnpackBase(bits(N) fpval,</del><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><del>FPCRType</del></a><ins>,</ins><del>fpcr)
    assert N IN {16,32,64};

    if N == 16 then
        sign   = fpval&lt;15>;
        exp16  = fpval&lt;14:10>;
        frac16 = fpval&lt;9:0>;
        if</del> <del>(exp16) then
            // Produce zero if value is zero or flush-to-zero is selected
            if </del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(frac16) || fpcr.FZ16 == '1' then
                type = </del><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a><del>;  value = 0.0;
            else
                type = </del><a href="shared_pseudocode.html#FPType_Nonzero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Nonzero</del></a><del>;  value = 2.0^-14 * (Real(</del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(frac16)) * 2.0^-10);
        elsif </del><a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)"><del>IsOnes</del></a><del>(exp16) &amp;&amp; fpcr.AHP == '0' then  // Infinity or NaN in IEEE format
            if </del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(frac16) then
                type = </del><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a><del>;  value = 2.0^1000000;
            else
                type = if frac16&lt;9> == '1' then </del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><del> else </del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><del>;
                value = 0.0;
        else
            type = </del><a href="shared_pseudocode.html#FPType_Nonzero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Nonzero</del></a><del>;
            value = 2.0^(</del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(exp16)-15) * (1.0 + Real(</del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(frac16)) * 2.0^-10);

    elsif N == 32 then

        sign   = fpval&lt;31>;
        exp32  = fpval&lt;30:23>;
        frac32 = fpval&lt;22:0>;
        if </del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(exp32) then
            // Produce zero if value is zero or flush-to-zero is selected.
            if </del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(frac32) || fpcr.FZ == '1' then
                type = </del><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a><del>;  value = 0.0;
                if !</del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(frac32) then  // Denormalized input flushed to zero
                    </del><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a><del>(</del><a href="shared_pseudocode.html#FPExc_InputDenorm" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_InputDenorm</del></a><del>, fpcr);
            else
                type = </del><a href="shared_pseudocode.html#FPType_Nonzero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Nonzero</del></a><del>;  value = 2.0^-126 * (Real(</del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(frac32)) * 2.0^-23);
        elsif </del><a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)"><del>IsOnes</del></a><del>(exp32) then
            if </del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(frac32) then
                type = </del><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a><del>;  value = 2.0^1000000;
            else
                type = if frac32&lt;22> == '1' then </del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><del> else </del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><del>;
                value = 0.0;
        else
            type = </del><a href="shared_pseudocode.html#FPType_Nonzero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Nonzero</del></a><del>;
            value = 2.0^(</del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(exp32)-127) * (1.0 + Real(</del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(frac32)) * 2.0^-23);

    else // N == 64

        sign   = fpval&lt;63>;
        exp64  = fpval&lt;62:52>;
        frac64 = fpval&lt;51:0>;
        if </del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(exp64) then
            // Produce zero if value is zero or flush-to-zero is selected.
            if </del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(frac64) || fpcr.FZ == '1' then
                type = </del><a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Zero</del></a><del>;  value = 0.0;
                if !</del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(frac64) then  // Denormalized input flushed to zero
                    </del><a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)"><del>FPProcessException</del></a><del>(</del><a href="shared_pseudocode.html#FPExc_InputDenorm" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow, FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}"><del>FPExc_InputDenorm</del></a><del>, fpcr);
            else
                type = </del><a href="shared_pseudocode.html#FPType_Nonzero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Nonzero</del></a><del>;  value = 2.0^-1022 * (Real(</del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(frac64)) * 2.0^-52);
        elsif </del><a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)"><del>IsOnes</del></a><del>(exp64) then
            if </del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(frac64) then
                type = </del><a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Infinity</del></a><del>;  value = 2.0^1000000;
            else
                type = if frac64&lt;51> == '1' then </del><a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_QNaN</del></a><del> else </del><a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_SNaN</del></a><del>;
                value = 0.0;
        else
            type = </del><a href="shared_pseudocode.html#FPType_Nonzero" title="enumeration FPType      {FPType_Nonzero, FPType_Zero, FPType_Infinity, FPType_QNaN, FPType_SNaN}"><del>FPType_Nonzero</del></a><del>;
            value = 2.0^(</del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(exp64)-1023) * (1.0 + Real(</del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IC</ins></a><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><ins>});
    accdesc.page_table_walk = TRUE;
    accdesc.secondstage = s2fs1walk;
    accdesc.secondstage = secondstage;
    accdesc.level = level;
    return accdesc;</ins><del>(frac64)) * 2.0^-52);

    if sign == '1' then value = -value;
    return (type, sign, value);</del></p></div><div class="ps" psname="shared.functions.memory.DataMemoryBarrier"><a id="shared.functions.memory.DataMemoryBarrier" name="shared.functions.memory.DataMemoryBarrier"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>memory</ins><del>float</del>/<ins>DataMemoryBarrier</ins><del>fpunpack/FPUnpackCV</del></h3><p class="pseudocode"><del>// FPUnpackCV()
// ============
//
// Used for FP &lt;-> FP conversion instructions.
// For half-precision data ignores FZ16 and observes AHP.

(FPType, bit, real) </del><a id="impl-shared.DataMemoryBarrier.2" name="impl-shared.DataMemoryBarrier.2"></a><ins>DataMemoryBarrier(</ins><del>FPUnpackCV(bits(N) fpval,</del><a href="shared_pseudocode.html#MBReqDomain" title="enumeration MBReqDomain    {MBReqDomain_Nonshareable, MBReqDomain_InnerShareable, MBReqDomain_OuterShareable, MBReqDomain_FullSystem}"><ins>MBReqDomain</ins></a><a href="shared_pseudocode.html#FPCRType" title="type FPCRType"><del>FPCRType</del></a> <ins>domain,</ins><del>fpcr)
    fpcr.FZ16 = '0';
    (fp_type, sign, value) =</del> <a href="shared_pseudocode.html#MBReqTypes" title="enumeration MBReqTypes     {MBReqTypes_Reads, MBReqTypes_Writes, MBReqTypes_All}"><ins>MBReqTypes</ins></a><a href="shared_pseudocode.html#impl-shared.FPUnpackBase.2" title="function: (FPType, bit, real) FPUnpackBase(bits(N) fpval, FPCRType fpcr)"><del>FPUnpackBase</del></a> <ins>types);</ins><del>(fpval, fpcr);
    return (fp_type, sign, value);</del></p></div><div class="ps" psname="shared.functions.memory.DataSynchronizationBarrier"><a id="shared.functions.memory.DataSynchronizationBarrier" name="shared.functions.memory.DataSynchronizationBarrier"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>memory</ins><del>float</del>/<ins>DataSynchronizationBarrier</ins><del>fpzero/FPZero</del></h3><p class="pseudocode"><del>// FPZero()
// ========

bits(N) </del><a id="impl-shared.DataSynchronizationBarrier.2" name="impl-shared.DataSynchronizationBarrier.2"></a><ins>DataSynchronizationBarrier(</ins><del>FPZero(bit sign)
    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp  =</del><a href="shared_pseudocode.html#MBReqDomain" title="enumeration MBReqDomain    {MBReqDomain_Nonshareable, MBReqDomain_InnerShareable, MBReqDomain_OuterShareable, MBReqDomain_FullSystem}"><ins>MBReqDomain</ins></a><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a> <ins>domain,</ins><del>(E);
    frac =</del> <a href="shared_pseudocode.html#MBReqTypes" title="enumeration MBReqTypes     {MBReqTypes_Reads, MBReqTypes_Writes, MBReqTypes_All}"><ins>MBReqTypes</ins></a><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a> <ins>types);</ins><del>(F);
    return sign : exp : frac;</del></p></div><div class="ps" psname="shared.functions.memory.DescriptorUpdate"><a id="shared.functions.memory.DescriptorUpdate" name="shared.functions.memory.DescriptorUpdate"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>memory</ins><del>float</del>/<ins>DescriptorUpdate</ins><del>vfpexpandimm/VFPExpandImm</del></h3><p class="pseudocode"><ins>type</ins><del>// VFPExpandImm()
// ==============

bits(N)</del> <a id="DescriptorUpdate" name="DescriptorUpdate"></a><ins>DescriptorUpdate is (
    boolean AF,                  // AF needs to be set
    boolean AP,                  // AP[2] / S2AP[2] will be modified</ins><del>VFPExpandImm(bits(8) imm8)
    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - E - 1;
    sign = imm8&lt;7>;
    exp  = NOT(imm8&lt;6>):</del>
    <del>(imm8&lt;6>,E-3):imm8&lt;5:4>;
    frac = imm8&lt;3:0>:</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><ins>AddressDescriptor</ins></a><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a> <ins>descaddr   // Descriptor to be updated
)</ins><del>(F-4);
    return sign : exp : frac;</del></p></div><div class="ps" psname="shared.functions.memory.DeviceType"><a id="shared.functions.memory.DeviceType" name="shared.functions.memory.DeviceType"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>memory</ins><del>integer</del>/<ins>DeviceType</ins><del>AddWithCarry</del></h3><p class="pseudocode"><ins>enumeration</ins><del>// AddWithCarry()
// ==============
// Integer addition with carry input, returning result and NZCV flags

(bits(N), bits(4))</del> <a id="DeviceType" name="DeviceType"></a><ins>DeviceType {</ins><del>AddWithCarry(bits(N) x, bits(N) y, bit carry_in)
    integer unsigned_sum =</del><a id="DeviceType_GRE" name="DeviceType_GRE"></a><ins>DeviceType_GRE,</ins><del>(x) +</del> <a id="DeviceType_nGRE" name="DeviceType_nGRE"></a><ins>DeviceType_nGRE,</ins><del>(y) +</del> <a id="DeviceType_nGnRE" name="DeviceType_nGnRE"></a><ins>DeviceType_nGnRE,</ins><del>(carry_in);
    integer signed_sum =</del> <del>(x) + </del><a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)"><del>SInt</del></a><del>(y) + </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(carry_in);
    bits(N) result = unsigned_sum&lt;N-1:0>; // same value as signed_sum&lt;N-1:0>
    bit n = result&lt;N-1>;
    bit z = if </del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(result) then '1' else '0';
    bit c = if </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(result) == unsigned_sum then '0' else '1';
    bit v = if </del><a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)"><del>SInt</del></a><a id="DeviceType_nGnRnE" name="DeviceType_nGnRnE"></a><ins>DeviceType_nGnRnE};</ins><del>(result) == signed_sum then '0' else '1';
    return (result, n:z:c:v);</del></p></div><div class="ps" psname="shared.functions.memory.EffectiveTBI"><a id="shared.functions.memory.EffectiveTBI" name="shared.functions.memory.EffectiveTBI"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/<ins>EffectiveTBI</ins><del>AArch64.BranchAddr</del></h3><p class="pseudocode"><ins>// EffectiveTBI()
// ==============
// Returns the effective TBI in the AArch64 stage 1 translation regime for "el".
</ins><del>// AArch64.BranchAddr()
// ====================
// Return the virtual address with tag bits removed for storing to the program counter.
</del>
<ins>bit</ins><del>bits(64)</del> <a id="impl-shared.EffectiveTBI.3" name="impl-shared.EffectiveTBI.3"></a><ins>EffectiveTBI(bits(64) address, boolean IsInstr, bits(2) el)
    assert</ins><del>AArch64.BranchAddr(bits(64) vaddress)
    assert !</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><ins>(el);
    regime =</ins><del>();
    msbit =</del> <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.1" title="function: bits(2) S1TranslationRegime(bits(2) el)"><ins>S1TranslationRegime</ins></a><a href="shared_pseudocode.html#impl-shared.AddrTop.3" title="function: integer AddrTop(bits(64) address, boolean IsInstr, bits(2) el)"><del>AddrTop</del></a><ins>(el);
    assert(!</ins><del>(vaddress, TRUE, PSTATE.EL);
    if msbit == 63 then
        return vaddress;
    elsif (PSTATE.EL IN {</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>(regime));

    case regime of
        when</ins><del>,</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            <ins>tbi = if address&lt;55> == '1' then TCR_EL1.TBI1 else TCR_EL1.TBI0;
            if</ins><del>} ||</del> <a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()"><ins>HavePACExt</ins></a><a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><del>IsInHost</del></a><ins>() then
                tbid = if address&lt;55> == '1' then TCR_EL1.TBID1 else TCR_EL1.TBID0;
        when</ins><del>()) &amp;&amp; vaddress&lt;msbit> == '1' then
        return</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-shared.SignExtend.1" title="function: bits(N) SignExtend(bits(M) x)"><del>SignExtend</del></a>
            <ins>if</ins><del>(vaddress&lt;msbit:0>);
    else
        return</del> <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><ins>HaveVirtHostExt</ins></a><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><ins>() &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)"><ins>ELIsInHost</ins></a><ins>(el) then
                tbi = if address&lt;55> == '1' then TCR_EL2.TBI1 else TCR_EL2.TBI0;
                if </ins><a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()"><ins>HavePACExt</ins></a><ins>() then
                    tbid = if address&lt;55> == '1' then TCR_EL2.TBID1 else TCR_EL2.TBID0;
            else
                tbi = TCR_EL2.TBI;
                if </ins><a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()"><ins>HavePACExt</ins></a><ins>() then tbid = TCR_EL2.TBID;
        when </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>
            tbi = TCR_EL3.TBI;
            if </ins><a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()"><ins>HavePACExt</ins></a><ins>() then tbid = TCR_EL3.TBID;

    return (if tbi == '1' &amp;&amp; (!</ins><a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()"><ins>HavePACExt</ins></a><ins>() || tbid == '0' || !IsInstr) then '1' else '0');</ins><del>(vaddress&lt;msbit:0>);</del></p></div><div class="ps" psname="shared.functions.memory.EffectiveTCMA"><a id="shared.functions.memory.EffectiveTCMA" name="shared.functions.memory.EffectiveTCMA"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/<ins>EffectiveTCMA</ins><del>AccType</del></h3><p class="pseudocode"><ins>// EffectiveTCMA()
// ===============
// Returns the effective TCMA of a virtual address in the stage 1 translation regime for "el".

bit</ins><del>enumeration</del> <a id="impl-shared.EffectiveTCMA.2" name="impl-shared.EffectiveTCMA.2"></a><ins>EffectiveTCMA(bits(64) address, bits(2) el)
    assert</ins><del>AccType {</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(el);
    regime =</ins><del>AccType_NORMAL,</del> <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.1" title="function: bits(2) S1TranslationRegime(bits(2) el)"><ins>S1TranslationRegime</ins></a><ins>(el);
    assert(!</ins><del>AccType_VEC,        // Normal loads and stores</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(regime));

    case regime of
        when</ins><del>AccType_STREAM,</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a>
            <ins>tcma = if address&lt;55> == '1' then TCR_EL1.TCMA1 else TCR_EL1.TCMA0;
        when</ins><del>AccType_VECSTREAM,  // Streaming loads and stores</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a>
            <ins>if</ins><del>AccType_ATOMIC,</del> <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><ins>HaveVirtHostExt</ins></a><ins>() &amp;&amp;</ins><del>AccType_ATOMICRW,   // Atomic loads and stores</del> <a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)"><ins>ELIsInHost</ins></a><ins>(el) then
                tcma = if address&lt;55> == '1' then TCR_EL2.TCMA1 else TCR_EL2.TCMA0;
            else
                tcma = TCR_EL2.TCMA;
        when</ins><del>AccType_ORDERED,</del> <del>AccType_ORDEREDRW, // Load-Acquire and Store-Release
                     </del><a id="AccType_ORDEREDATOMIC" name="AccType_ORDEREDATOMIC"></a><del>AccType_ORDEREDATOMIC,              // Load-Acquire and Store-Release with atomic access
                     </del><a id="AccType_ORDEREDATOMICRW" name="AccType_ORDEREDATOMICRW"></a><del>AccType_ORDEREDATOMICRW,
                     </del><a id="AccType_LIMITEDORDERED" name="AccType_LIMITEDORDERED"></a><del>AccType_LIMITEDORDERED,             // Load-LOAcquire and Store-LORelease
                     </del><a id="AccType_UNPRIV" name="AccType_UNPRIV"></a><del>AccType_UNPRIV,                     // Load and store unprivileged
                     </del><a id="AccType_IFETCH" name="AccType_IFETCH"></a><del>AccType_IFETCH,                     // Instruction fetch
                     </del><a id="AccType_PTW" name="AccType_PTW"></a><del>AccType_PTW,                        // Page table walk
                     </del><a id="AccType_NONFAULT" name="AccType_NONFAULT"></a><del>AccType_NONFAULT,                   // Non-faulting loads
                     </del><a id="AccType_CNOTFIRST" name="AccType_CNOTFIRST"></a><del>AccType_CNOTFIRST,                  // Contiguous FF load, not first element
                     </del><a id="AccType_NV2REGISTER" name="AccType_NV2REGISTER"></a><del>AccType_NV2REGISTER,                // MRS/MSR instruction used at EL1 and which is converted
                                                         // to a memory access that uses the EL2 translation regime
                     // Other operations
                     </del><a id="AccType_DC" name="AccType_DC"></a><del>AccType_DC,                         // Data cache maintenance
                     </del><a id="AccType_DC_UNPRIV" name="AccType_DC_UNPRIV"></a><del>AccType_DC_UNPRIV,                  // Data cache maintenance instruction used at EL0
                     </del><a id="AccType_IC" name="AccType_IC"></a><del>AccType_IC,                         // Instruction cache maintenance
                     </del><a id="AccType_DCZVA" name="AccType_DCZVA"></a><del>AccType_DCZVA,                      // DC ZVA instructions
                     </del><a id="AccType_AT" name="AccType_AT"></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a>
            <ins>tcma = TCR_EL3.TCMA;

    return tcma;</ins><del>AccType_AT};                        // Address translation</del></p></div><div class="ps" psname="shared.functions.memory.Fault"><a id="shared.functions.memory.Fault" name="shared.functions.memory.Fault"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/<ins>Fault</ins><del>AccessDescriptor</del></h3><p class="pseudocode"><ins>enumeration</ins><del>type AccessDescriptor is (</del> <a id="Fault" name="Fault"></a><ins>Fault {</ins><a id="Fault_None" name="Fault_None"></a><ins>Fault_None,
                   </ins><a id="Fault_AccessFlag" name="Fault_AccessFlag"></a><ins>Fault_AccessFlag,
                   </ins><a id="Fault_Alignment" name="Fault_Alignment"></a><ins>Fault_Alignment,
                   </ins><a id="Fault_Background" name="Fault_Background"></a><ins>Fault_Background,
                   </ins><a id="Fault_Domain" name="Fault_Domain"></a><ins>Fault_Domain,
                   </ins><a id="Fault_Permission" name="Fault_Permission"></a><ins>Fault_Permission,
                   </ins><a id="Fault_Translation" name="Fault_Translation"></a><ins>Fault_Translation,
                   </ins><a id="Fault_AddressSize" name="Fault_AddressSize"></a><ins>Fault_AddressSize,
                   </ins><a id="Fault_SyncExternal" name="Fault_SyncExternal"></a><ins>Fault_SyncExternal,
                   </ins><a id="Fault_SyncExternalOnWalk" name="Fault_SyncExternalOnWalk"></a><ins>Fault_SyncExternalOnWalk,
                   </ins><a id="Fault_SyncParity" name="Fault_SyncParity"></a><ins>Fault_SyncParity,
                   </ins><a id="Fault_SyncParityOnWalk" name="Fault_SyncParityOnWalk"></a><ins>Fault_SyncParityOnWalk,
                   </ins><a id="Fault_AsyncParity" name="Fault_AsyncParity"></a><ins>Fault_AsyncParity,
                   </ins><a id="Fault_AsyncExternal" name="Fault_AsyncExternal"></a><ins>Fault_AsyncExternal,
                   </ins><a id="Fault_Debug" name="Fault_Debug"></a><ins>Fault_Debug,
                   </ins><a id="Fault_TLBConflict" name="Fault_TLBConflict"></a><ins>Fault_TLBConflict,
                   </ins><a id="Fault_BranchTarget" name="Fault_BranchTarget"></a><ins>Fault_BranchTarget,
                   </ins><a id="Fault_HWUpdateAccessFlag" name="Fault_HWUpdateAccessFlag"></a><ins>Fault_HWUpdateAccessFlag,
                   </ins><a id="Fault_Lockdown" name="Fault_Lockdown"></a><ins>Fault_Lockdown,
                   </ins><a id="Fault_Exclusive" name="Fault_Exclusive"></a><ins>Fault_Exclusive,
                   </ins><a id="Fault_ICacheMaint" name="Fault_ICacheMaint"></a><ins>Fault_ICacheMaint};</ins><del>acctype,
    MPAMinfo mpam,
    boolean page_table_walk,
    boolean secondstage,
    boolean s2fs1walk,
    integer level
)</del></p></div><div class="ps" psname="shared.functions.memory.FaultRecord"><a id="shared.functions.memory.FaultRecord" name="shared.functions.memory.FaultRecord"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/<ins>FaultRecord</ins><del>AddrTop</del></h3><p class="pseudocode"><ins>type</ins><del>// AddrTop()
// =========
// Return the MSB number of a virtual address in the stage 1 translation regime for "el".
// If EL1 is using AArch64 then addresses from EL0 using AArch32 are zero-extended to 64 bits.

integer</del> <a id="FaultRecord" name="FaultRecord"></a><ins>FaultRecord is (</ins><del>AddrTop(bits(64) address, boolean IsInstr, bits(2) el)
    assert</del><a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><ins>Fault</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a>    <ins>type,         // Fault Status</ins><del>(el);
    regime =</del>
                     <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.1" title="function: bits(2) S1TranslationRegime(bits(2) el)"><del>S1TranslationRegime</del></a>  <ins>acctype,      // Type of access that faulted</ins><del>(el);
    if</del>
                     <del>(regime) then
        // AArch32 translation regime.
        return 31;
    else
        // AArch64 translation regime.
        case regime of
            when </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>
                tbi = (if address&lt;55> == '1' then TCR_EL1.TBI1 else TCR_EL1.TBI0);
                if </del><a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()"><del>HavePACExt</del></a><del>() then
                    tbid = if address&lt;55> == '1' then TCR_EL1.TBID1 else TCR_EL1.TBID0;
            when </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>
                if </del><a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><del>HaveVirtHostExt</del></a><del>() &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)"><del>ELIsInHost</del></a><del>(el) then
                    tbi = (if address&lt;55> == '1' then TCR_EL2.TBI1 else TCR_EL2.TBI0);
                    if </del><a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()"><del>HavePACExt</del></a><del>() then
                        tbid = if address&lt;55> == '1' then TCR_EL2.TBID1 else TCR_EL2.TBID0;
                else
                    tbi = TCR_EL2.TBI;
                    if </del><a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()"><del>HavePACExt</del></a><del>() then tbid = TCR_EL2.TBID;
            when </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>
                tbi = TCR_EL3.TBI;
                if </del><a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()"><del>HavePACExt</del></a><del>() then tbid = TCR_EL3.TBID;

    return (if tbi == '1' &amp;&amp; (!</del><a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()"><del>HavePACExt</del></a><a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( bits(52) address, bit NS )"><ins>FullAddress</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a> <ins>ipaddress, // Intermediate physical address
                     boolean  s2fs1walk,    // Is on a Stage 1 page table walk
                     boolean  write,        // TRUE for a write, FALSE for a read
                     integer  level,        // For translation, access flag and permission faults
                     bit      extflag,      // IMPLEMENTATION DEFINED syndrome for external aborts
                     boolean  secondstage,  // Is a Stage 2 abort
                     bits(4)  domain,       // Domain number, AArch32 only
                     bits(2)  errortype,    // [Armv8.2 RAS] AArch32 AET or AArch64 SET
                     bits(4)  debugmoe)     // Debug method of entry, from AArch32 only

type PARTIDtype = bits(16);
type PMGtype = bits(8);

type MPAMinfo is (
     bit mpam_ns,
     PARTIDtype partid,
     PMGtype pmg
)</ins><del>() || tbid == '0' || !IsInstr ) then 55 else 63);</del></p></div><div class="ps" psname="shared.functions.memory.FullAddress"><a id="shared.functions.memory.FullAddress" name="shared.functions.memory.FullAddress"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/<ins>FullAddress</ins><del>AddressDescriptor</del></h3><p class="pseudocode">type <a id="FullAddress" name="FullAddress"></a><ins>FullAddress is (
    bits(52) address,
    bit      NS                  // '0' = Secure, '1' = Non-secure
)</ins><del>AddressDescriptor is (</del><a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault type, AccType acctype, FullAddress ipaddress, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)"><del>FaultRecord</del></a><del>      fault,      // fault.type indicates whether the address is valid
    </del><a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType type, DeviceType device, MemAttrHints inner, MemAttrHints outer, boolean tagged, boolean shareable, boolean outershareable )"><del>MemoryAttributes</del></a><del> memattrs,
    </del><a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( bits(52) address, bit NS )"><del>FullAddress</del></a><del>      paddress,
    bits(64)         vaddress
)</del></p></div><div class="ps" psname="shared.functions.memory.Hint_Prefetch"><a id="shared.functions.memory.Hint_Prefetch" name="shared.functions.memory.Hint_Prefetch"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/<ins>Hint_Prefetch</ins><del>AddressWithAllocationTag</del></h3><p class="pseudocode"><ins>// Signals the memory system that memory accesses of type HINT to or from the specified address are
// likely in the near future. The memory system may take some action to speed up the memory
// accesses when they do occur, such as pre-loading the the specified address into one or more
// caches as indicated by the innermost cache level target (0=L1, 1=L2, etc) and non-temporal hint
// stream. Any or all prefetch hints may be treated as a NOP. A prefetch hint must not cause a
// synchronous abort due to Alignment or Translation faults and the like. Its only effect on
// software-visible state should be on caches and TLBs associated with address, which must be
// accessible by reads, writes or execution, as defined in the translation regime of the current
// Exception level. It is guaranteed not to access Device memory.
// A Prefetch_EXEC hint must not result in an access that could not be performed by a speculative
// instruction fetch, therefore if all associated MMUs are disabled, then it cannot access any
// memory location that cannot be accessed by instruction fetches.</ins><del>// AddressWithAllocationTag()
// ==========================
// Generate a 64-bit value containing a Logical Address Tag from a 64-bit
// virtual address and an Allocation Tag.
// If the extension is disabled, treats the Allocation Tag as â0000â.

bits(64)</del>
<a id="impl-shared.Hint_Prefetch.4" name="impl-shared.Hint_Prefetch.4"></a><ins>Hint_Prefetch(bits(64) address,</ins><del>AddressWithAllocationTag(bits(64) address, bits(4) allocation_tag)
    bits(64) result = address;
    bits(4) tag = allocation_tag - ('000':address&lt;55>);
    result&lt;59:56> = tag;
    return result;</del> <a href="shared_pseudocode.html#PrefetchHint" title="enumeration PrefetchHint {Prefetch_READ, Prefetch_WRITE, Prefetch_EXEC}"><ins>PrefetchHint</ins></a><ins> hint, integer target, boolean stream);</ins></p></div><div class="ps" psname="shared.functions.memory.MBReqDomain"><a id="shared.functions.memory.MBReqDomain" name="shared.functions.memory.MBReqDomain"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/<ins>MBReqDomain</ins><del>Allocation</del></h3><p class="pseudocode"><ins>enumeration</ins><del>constant bits(2)</del> <a id="MBReqDomain" name="MBReqDomain"></a><ins>MBReqDomain    {</ins><del>MemHint_No = '00';     // No Read-Allocate, No Write-Allocate
constant bits(2)</del><a id="MBReqDomain_Nonshareable" name="MBReqDomain_Nonshareable"></a><ins>MBReqDomain_Nonshareable,</ins><del>MemHint_WA = '01';     // No Read-Allocate, Write-Allocate
constant bits(2)</del> <a id="MBReqDomain_InnerShareable" name="MBReqDomain_InnerShareable"></a><ins>MBReqDomain_InnerShareable,</ins><del>MemHint_RA = '10';     // Read-Allocate, No Write-Allocate
constant bits(2)</del>
                            <a id="MBReqDomain_OuterShareable" name="MBReqDomain_OuterShareable"></a><ins>MBReqDomain_OuterShareable,</ins><del>MemHint_RWA = '11';    // Read-Allocate, Write-Allocate</del> <a id="MBReqDomain_FullSystem" name="MBReqDomain_FullSystem"></a><ins>MBReqDomain_FullSystem};</ins></p></div><div class="ps" psname="shared.functions.memory.MBReqTypes"><a id="shared.functions.memory.MBReqTypes" name="shared.functions.memory.MBReqTypes"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/<ins>MBReqTypes</ins><del>AllocationTagFromAddress</del></h3><p class="pseudocode"><ins>enumeration</ins><del>// AllocationTagFromAddress()
// ==========================
// Generate a Tag from a 64-bit value containing a Logical Address Tag.
// If access to Allocation Tags is disabled, this function returns â0000â.

bits(4)</del> <a id="MBReqTypes" name="MBReqTypes"></a><ins>MBReqTypes     {</ins><del>AllocationTagFromAddress(bits(64) tagged_address)
    bits(4) logical_tag = tagged_address&lt;59:56>;
    bits(4) tag = logical_tag + ('000':tagged_address&lt;55>);
    return tag;</del><a id="MBReqTypes_Reads" name="MBReqTypes_Reads"></a><ins>MBReqTypes_Reads, </ins><a id="MBReqTypes_Writes" name="MBReqTypes_Writes"></a><ins>MBReqTypes_Writes, </ins><a id="MBReqTypes_All" name="MBReqTypes_All"></a><ins>MBReqTypes_All};</ins></p></div><div class="ps" psname="shared.functions.memory.MemAttrHints"><a id="shared.functions.memory.MemAttrHints" name="shared.functions.memory.MemAttrHints"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/<ins>MemAttrHints</ins><del>BigEndian</del></h3><p class="pseudocode"><ins>type</ins><del>// BigEndian()
// ===========

boolean</del> <a id="MemAttrHints" name="MemAttrHints"></a><ins>MemAttrHints is (
    bits(2) attrs,  // See MemAttr_*, Cacheability attributes
    bits(2) hints,  // See MemHint_*, Allocation hints
    boolean transient
)</ins><del>BigEndian()
    boolean bigend;
    if</del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>() then
        bigend = (PSTATE.E != '0');
    elsif PSTATE.EL == </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del> then
        bigend = (</del><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><del>SCTLR</del></a><del>[].E0E != '0');
    else
        bigend = (</del><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><del>SCTLR</del></a><del>[].EE != '0');
    return bigend;</del></p></div><div class="ps" psname="shared.functions.memory.MemTag"><a id="shared.functions.memory.MemTag" name="shared.functions.memory.MemTag"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/<ins>MemTag</ins><del>BigEndianReverse</del></h3><p class="pseudocode"><ins>// MemTag[] - non-assignment (read) form
// =====================================
// Load an Allocation Tag from memory.
</ins><del>// BigEndianReverse()
// ==================
</del>
<ins>bits(4)</ins><del>bits(width)</del> <a id="impl-shared.MemTag.read.1_3" name="impl-shared.MemTag.read.1_3"></a><ins>MemTag[bits(64) address]</ins><del>BigEndianReverse (bits(width) value)
    assert width IN {8, 16, 32, 64, 128};
    integer half = width DIV 2;
    if width == 8 then return value;
    return</del>
    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><ins>AddressDescriptor</ins></a><a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)"><del>BigEndianReverse</del></a> <ins>memaddrdesc;
    bits(4) value;
    iswrite = FALSE;

    memaddrdesc =</ins><del>(value&lt;half-1:0>) :</del> <a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><ins>AArch64.TranslateAddress</ins></a><a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)"><del>BigEndianReverse</del></a><ins>(address, </ins><a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NORMAL</ins></a><ins>, iswrite, TRUE, TAG_GRANULE);
    // Check for aborts or debug exceptions
    if </ins><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><ins>(memaddrdesc) then
        </ins><a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)"><ins>AArch64.Abort</ins></a><ins>(address, memaddrdesc.fault);

    // Return the granule tag if tagging is enabled...
    if </ins><a href="shared_pseudocode.html#impl-shared.AllocationTagAccessIsEnabled.0" title="function: boolean AllocationTagAccessIsEnabled()"><ins>AllocationTagAccessIsEnabled</ins></a><ins>() &amp;&amp; memaddrdesc.memattrs.tagged then
        return _MemTag[memaddrdesc];
    else
        // ...otherwise read tag as zero.
        return '0000';

// MemTag[] - assignment (write) form
// ==================================
// Store an Allocation Tag to memory.

</ins><a id="impl-shared.MemTag.write.1_3" name="impl-shared.MemTag.write.1_3"></a><ins>MemTag[bits(64) address] = bits(4) value
    </ins><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><ins>AddressDescriptor</ins></a><ins> memaddrdesc;
    iswrite = TRUE;

    // Stores of allocation tags must be aligned
    if address != </ins><a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)"><ins>Align</ins></a><ins>(address, TAG_GRANULE) then
        boolean secondstage = FALSE;
        </ins><a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)"><ins>AArch64.Abort</ins></a><ins>(address, </ins><a href="shared_pseudocode.html#AArch64.AlignmentFault.3" title="function: FaultRecord AArch64.AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)"><ins>AArch64.AlignmentFault</ins></a><ins>(</ins><a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NORMAL</ins></a><ins>, iswrite, secondstage));

    wasaligned = TRUE;
    memaddrdesc = </ins><a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><ins>AArch64.TranslateAddress</ins></a><ins>(address, </ins><a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NORMAL</ins></a><ins>, iswrite, wasaligned, TAG_GRANULE);

    // Check for aborts or debug exceptions
    if </ins><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><ins>(memaddrdesc) then
        </ins><a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)"><ins>AArch64.Abort</ins></a><ins>(address, memaddrdesc.fault);

    // Memory array access
    if </ins><a href="shared_pseudocode.html#impl-shared.AllocationTagAccessIsEnabled.0" title="function: boolean AllocationTagAccessIsEnabled()"><ins>AllocationTagAccessIsEnabled</ins></a><ins>() &amp;&amp; memaddrdesc.memattrs.tagged then
        _MemTag[memaddrdesc] = value;</ins><del>(value&lt;width-1:half>);</del></p></div><div class="ps" psname="shared.functions.memory.MemType"><a id="shared.functions.memory.MemType" name="shared.functions.memory.MemType"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/<ins>MemType</ins><del>Cacheability</del></h3><p class="pseudocode"><ins>enumeration</ins><del>constant bits(2)</del> <a id="MemType" name="MemType"></a><ins>MemType {</ins><del>MemAttr_NC = '00';     // Non-cacheable
constant bits(2)</del><a id="MemType_Normal" name="MemType_Normal"></a><ins>MemType_Normal,</ins><del>MemAttr_WT = '10';     // Write-through
constant bits(2)</del> <a id="MemType_Device" name="MemType_Device"></a><ins>MemType_Device};</ins><del>MemAttr_WB = '11';     // Write-back</del></p></div><div class="ps" psname="shared.functions.memory.MemoryAttributes"><a id="shared.functions.memory.MemoryAttributes" name="shared.functions.memory.MemoryAttributes"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/<ins>MemoryAttributes</ins><del>CheckTag</del></h3><p class="pseudocode"><ins>type</ins><del>// CheckTag()
// ==========
// Performs a Tag Check operation for a memory access and returns
// whether the check passed

boolean</del> <a id="MemoryAttributes" name="MemoryAttributes"></a><ins>MemoryAttributes is (</ins><del>CheckTag(</del>
    <a href="shared_pseudocode.html#MemType" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType</ins></a><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><del>AddressDescriptor</del></a>      <ins>type,</ins><del>memaddrdesc, bits(4) ptag, boolean write)
    if memaddrdesc.memattrs.tagged then
        bits(64) paddress =</del>

    <a href="shared_pseudocode.html#DeviceType" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType</ins></a><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a>   <ins>device,     // For Device memory types</ins><del>(memaddrdesc.paddress.address);
        return ptag ==</del>
    <a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )"><ins>MemAttrHints</ins></a><a href="shared_pseudocode.html#impl-aarch64.MemTag.read.1" title="accessor: bits(4) MemTag[bits(64) address]"><del>MemTag</del></a><ins> inner,      // Inner hints and attributes
    </ins><a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )"><ins>MemAttrHints</ins></a> <ins>outer,      // Outer hints and attributes
    boolean      tagged,     // Tagged access
    boolean      shareable,
    boolean      outershareable
)</ins><del>[paddress];
    else
        return TRUE;</del></p></div><div class="ps" psname="shared.functions.memory.Permissions"><a id="shared.functions.memory.Permissions" name="shared.functions.memory.Permissions"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/<ins>Permissions</ins><del>CreateAccessDescriptor</del></h3><p class="pseudocode"><ins>type</ins><del>// CreateAccessDescriptor()
// ========================

AccessDescriptor CreateAccessDescriptor(</del> <del> acctype)
    AccessDescriptor accdesc;
    accdesc.acctype = acctype;
    accdesc.mpam = GenMPAMcurEL(acctype IN {</del><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IFETCH</del></a><del>, </del><a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IC</del></a><a id="Permissions" name="Permissions"></a><ins>Permissions is (
    bits(3) ap,   // Access permission bits
    bit     xn,   // Execute-never bit
    bit     xxn,  // [Armv8.2] Extended execute-never bit for stage 2
    bit     pxn   // Privileged execute-never bit
)</ins><del>});
    accdesc.page_table_walk = FALSE;
    return accdesc;</del></p></div><div class="ps" psname="shared.functions.memory.PrefetchHint"><a id="shared.functions.memory.PrefetchHint" name="shared.functions.memory.PrefetchHint"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/<ins>PrefetchHint</ins><del>CreateAccessDescriptorPTW</del></h3><p class="pseudocode"><ins>enumeration</ins><del>// CreateAccessDescriptorPTW()
// ===========================

AccessDescriptor CreateAccessDescriptorPTW(</del> <a id="PrefetchHint" name="PrefetchHint"></a><ins>PrefetchHint {</ins><del>acctype, boolean secondstage,
                                           boolean s2fs1walk, integer level)
    AccessDescriptor accdesc;
    accdesc.acctype = acctype;
    accdesc.mpam = GenMPAMcurEL(acctype IN {</del><a id="Prefetch_READ" name="Prefetch_READ"></a><ins>Prefetch_READ,</ins><del>,</del> <a id="Prefetch_WRITE" name="Prefetch_WRITE"></a><ins>Prefetch_WRITE, </ins><a id="Prefetch_EXEC" name="Prefetch_EXEC"></a><ins>Prefetch_EXEC};</ins><del>});
    accdesc.page_table_walk = TRUE;
    accdesc.secondstage = s2fs1walk;
    accdesc.secondstage = secondstage;
    accdesc.level = level;
    return accdesc;</del></p></div><div class="ps" psname="shared.functions.memory.SpeculativeStoreBypassBarrierToPA"><a id="shared.functions.memory.SpeculativeStoreBypassBarrierToPA" name="shared.functions.memory.SpeculativeStoreBypassBarrierToPA"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/<ins>SpeculativeStoreBypassBarrierToPA</ins><del>DataMemoryBarrier</del></h3><p class="pseudocode"><a id="impl-shared.SpeculativeStoreBypassBarrierToPA.0" name="impl-shared.SpeculativeStoreBypassBarrierToPA.0"></a><ins>SpeculativeStoreBypassBarrierToPA();</ins><del>DataMemoryBarrier(</del><a href="shared_pseudocode.html#MBReqDomain" title="enumeration MBReqDomain    {MBReqDomain_Nonshareable, MBReqDomain_InnerShareable, MBReqDomain_OuterShareable, MBReqDomain_FullSystem}"><del>MBReqDomain</del></a><del> domain, </del><a href="shared_pseudocode.html#MBReqTypes" title="enumeration MBReqTypes     {MBReqTypes_Reads, MBReqTypes_Writes, MBReqTypes_All}"><del>MBReqTypes</del></a><del> types);</del></p></div><div class="ps" psname="shared.functions.memory.SpeculativeStoreBypassBarrierToVA"><a id="shared.functions.memory.SpeculativeStoreBypassBarrierToVA" name="shared.functions.memory.SpeculativeStoreBypassBarrierToVA"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/<ins>SpeculativeStoreBypassBarrierToVA</ins><del>DataSynchronizationBarrier</del></h3><p class="pseudocode"><a id="impl-shared.SpeculativeStoreBypassBarrierToVA.0" name="impl-shared.SpeculativeStoreBypassBarrierToVA.0"></a><ins>SpeculativeStoreBypassBarrierToVA();</ins><del>DataSynchronizationBarrier(</del><a href="shared_pseudocode.html#MBReqDomain" title="enumeration MBReqDomain    {MBReqDomain_Nonshareable, MBReqDomain_InnerShareable, MBReqDomain_OuterShareable, MBReqDomain_FullSystem}"><del>MBReqDomain</del></a><del> domain, </del><a href="shared_pseudocode.html#MBReqTypes" title="enumeration MBReqTypes     {MBReqTypes_Reads, MBReqTypes_Writes, MBReqTypes_All}"><del>MBReqTypes</del></a><del> types);</del></p></div><div class="ps" psname="shared.functions.memory.TLBRecord"><a id="shared.functions.memory.TLBRecord" name="shared.functions.memory.TLBRecord"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/<ins>TLBRecord</ins><del>DescriptorUpdate</del></h3><p class="pseudocode">type <a id="TLBRecord" name="TLBRecord"></a><ins>TLBRecord is (</ins><del>DescriptorUpdate is (
    boolean AF,                  // AF needs to be set
    boolean AP,                  // AP[2] / S2AP[2] will be modified</del>
    <a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(3) ap, bit xn, bit xxn, bit pxn )"><ins>Permissions</ins></a><ins>       perms,
    bit               nG,             // '0' = Global, '1' = not Global
    bits(4)           domain,         // AArch32 only
    bit               GP,             // Guarded Page
    boolean           contiguous,     // Contiguous bit from page table
    integer           level,          // AArch32 Short-descriptor format: Indicates Section/Page
    integer           blocksize,      // Describes size of memory translated in KBytes
    </ins><a href="shared_pseudocode.html#DescriptorUpdate" title="type DescriptorUpdate is ( boolean AF, boolean AP, AddressDescriptor descaddr )"><ins>DescriptorUpdate</ins></a><ins>  descupdate,     // [Armv8.1] Context for h/w update of table descriptor
    bit               CnP,            // [Armv8.2] TLB entry can be shared between different PEs
    </ins><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> <ins>addrdesc
</ins><del>descaddr   // Descriptor to be updated
</del>)</p></div><div class="ps" psname="shared.functions.memory.TransformTag"><a id="shared.functions.memory.TransformTag" name="shared.functions.memory.TransformTag"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/<ins>TransformTag</ins><del>DeviceType</del></h3><p class="pseudocode"><ins>// TransformTag()
// ==============
// Apply tag transformation rules.

bits(4)</ins><del>enumeration</del> <a id="impl-shared.TransformTag.1_3" name="impl-shared.TransformTag.1_3"></a><ins>TransformTag(bits(64) vaddr)
    bits(4) vtag = vaddr&lt;59:56>;
    bits(4) tagdelta =</ins><del>DeviceType {</del> <del>DeviceType_GRE, </del><a id="DeviceType_nGRE" name="DeviceType_nGRE"></a><del>DeviceType_nGRE, </del><a id="DeviceType_nGnRE" name="DeviceType_nGnRE"></a><del>DeviceType_nGnRE, </del><a id="DeviceType_nGnRnE" name="DeviceType_nGnRnE"></a><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(vaddr&lt;55>);
    bits(4) ptag = vtag + tagdelta;
    return ptag;</ins><del>DeviceType_nGnRnE};</del></p></div><div class="ps" psname="shared.functions.memory._Mem"><a id="shared.functions.memory._Mem" name="shared.functions.memory._Mem"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/<ins>_Mem</ins><del>EffectiveTBI</del></h3><p class="pseudocode"><ins>// These two _Mem[] accessors are the hardware operations which perform single-copy atomic,
// aligned, little-endian memory accesses of size bytes from/to the underlying physical
// memory array of bytes.
//
// The functions address the array using desc.paddress which supplies:
// * A 52-bit physical address
// * A single NS bit to select between Secure and Non-secure parts of the array.
//
// The accdesc descriptor describes the access type: normal, exclusive, ordered, streaming,
// etc and other parameters required to access the physical memory or for setting syndrome
// register in the event of an external abort.
bits(8*size) _Mem[</ins><del>// EffectiveTBI()
// ==============
// Returns the effective TBI in the AArch64 stage 1 translation regime for "el".

bit</del><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><ins>AddressDescriptor</ins></a> <ins>desc, integer size, AccessDescriptor accdesc];

_Mem[</ins><del>EffectiveTBI(bits(64) address, boolean IsInstr, bits(2) el)
    assert</del><del>(el);
    regime = </del><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.1" title="function: bits(2) S1TranslationRegime(bits(2) el)"><del>S1TranslationRegime</del></a><del>(el);
    assert(!</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(regime));

    case regime of
        when </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>
            tbi = if address&lt;55> == '1' then TCR_EL1.TBI1 else TCR_EL1.TBI0;
            if </del><a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()"><del>HavePACExt</del></a><del>() then
                tbid = if address&lt;55> == '1' then TCR_EL1.TBID1 else TCR_EL1.TBID0;
        when </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>
            if </del><a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><del>HaveVirtHostExt</del></a><del>() &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)"><del>ELIsInHost</del></a><del>(el) then
                tbi = if address&lt;55> == '1' then TCR_EL2.TBI1 else TCR_EL2.TBI0;
                if </del><a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()"><del>HavePACExt</del></a><del>() then
                    tbid = if address&lt;55> == '1' then TCR_EL2.TBID1 else TCR_EL2.TBID0;
            else
                tbi = TCR_EL2.TBI;
                if </del><a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()"><del>HavePACExt</del></a><del>() then tbid = TCR_EL2.TBID;
        when </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>
            tbi = TCR_EL3.TBI;
            if </del><a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()"><del>HavePACExt</del></a><del>() then tbid = TCR_EL3.TBID;

    return (if tbi == '1' &amp;&amp; (!</del><a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()"><del>HavePACExt</del></a><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><ins>AddressDescriptor</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a> <ins>desc, integer size, AccessDescriptor accdesc] = bits(8*size) value;</ins><del>() || tbid == '0' || !IsInstr) then '1' else '0');</del></p></div><div class="ps" psname="shared.functions.memory.boolean"><a id="shared.functions.memory.boolean" name="shared.functions.memory.boolean"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/<ins>boolean</ins><del>EffectiveTCMA</del></h3><p class="pseudocode"><ins>// boolean AccessIsTagChecked()
// ============================
// TRUE if a given access is tag-checked, FALSE otherwise.
</ins><del>// EffectiveTCMA()
// ===============
// Returns the effective TCMA of a virtual address in the stage 1 translation regime for "el".
</del>
<ins>boolean</ins><del>bit</del> <a id="impl-shared.AccessIsTagChecked.2_3" name="impl-shared.AccessIsTagChecked.2_3"></a><ins>AccessIsTagChecked(bits(64) vaddr,</ins><del>EffectiveTCMA(bits(64) address, bits(2) el)
    assert</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a> <ins>acctype)
    if PSTATE.M&lt;4> == '1' then return FALSE;

    if</ins><del>(el);
    regime =</del> <a href="shared_pseudocode.html#impl-shared.EffectiveTBI.3" title="function: bit EffectiveTBI(bits(64) address, boolean IsInstr, bits(2) el)"><ins>EffectiveTBI</ins></a><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.1" title="function: bits(2) S1TranslationRegime(bits(2) el)"><del>S1TranslationRegime</del></a><ins>(vaddr, FALSE, PSTATE.EL) == '0' then
        return FALSE;

    if</ins><del>(el);
    assert(!</del> <a href="shared_pseudocode.html#impl-shared.EffectiveTCMA.2" title="function: bit EffectiveTCMA(bits(64) address, bits(2) el)"><ins>EffectiveTCMA</ins></a><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><ins>(vaddr, PSTATE.EL) == '1' &amp;&amp; (vaddr&lt;59:55> == '00000' || vaddr&lt;59:55> == '11111') then
        return FALSE;
</ins><del>(regime));
</del>
<ins>    if !</ins><del>    case regime of
        when</del><a href="shared_pseudocode.html#impl-shared.AllocationTagAccessIsEnabled.0" title="function: boolean AllocationTagAccessIsEnabled()"><ins>AllocationTagAccessIsEnabled</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>() then
        return FALSE;

    if acctype IN {</ins><del>tcma = if address&lt;55> == '1' then TCR_EL1.TCMA1 else TCR_EL1.TCMA0;
        when</del><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>,</ins><del>if</del> <a href="shared_pseudocode.html#AccType_PTW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_PTW</ins></a><a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><del>HaveVirtHostExt</del></a><ins>} then
        return FALSE;

    if acctype ==</ins><del>() &amp;&amp;</del> <del>(el) then
                tcma = if address&lt;55> == '1' then TCR_EL2.TCMA1 else TCR_EL2.TCMA0;
            else
                tcma = TCR_EL2.TCMA;
        when </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NV2REGISTER</ins></a><a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)"><del>ELIsInHost</del></a> <ins>then
        return FALSE;
</ins><del>tcma = TCR_EL3.TCMA;
</del>
<ins>    if PSTATE.TCO=='1' then
        return FALSE;

    if IsNonTagCheckedInstruction() then
        return FALSE;

    return TRUE;</ins><del>    return tcma;</del></p></div><div class="ps" psname="shared.functions.mpam.DefaultMPAMinfo"><a id="shared.functions.mpam.DefaultMPAMinfo" name="shared.functions.mpam.DefaultMPAMinfo"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>mpam</ins><del>memory</del>/<ins>DefaultMPAMinfo</ins><del>Fault</del></h3><p class="pseudocode"><ins>// DefaultMPAMinfo
// ===============
// Returns default MPAM info.  If secure is TRUE return default Secure
// MPAMinfo, otherwise return default Non-secure MPAMinfo.

MPAMinfo DefaultMPAMinfo(boolean secure)
    MPAMinfo DefaultInfo;
    DefaultInfo.mpam_ns = if secure then '0' else '1';
    DefaultInfo.partid  = DefaultPARTID;
    DefaultInfo.pmg     = DefaultPMG;
    return DefaultInfo;</ins><del>enumeration</del><a id="Fault" name="Fault"></a><del>Fault {</del><a id="Fault_None" name="Fault_None"></a><del>Fault_None,
                   </del><a id="Fault_AccessFlag" name="Fault_AccessFlag"></a><del>Fault_AccessFlag,
                   </del><a id="Fault_Alignment" name="Fault_Alignment"></a><del>Fault_Alignment,
                   </del><a id="Fault_Background" name="Fault_Background"></a><del>Fault_Background,
                   </del><a id="Fault_Domain" name="Fault_Domain"></a><del>Fault_Domain,
                   </del><a id="Fault_Permission" name="Fault_Permission"></a><del>Fault_Permission,
                   </del><a id="Fault_Translation" name="Fault_Translation"></a><del>Fault_Translation,
                   </del><a id="Fault_AddressSize" name="Fault_AddressSize"></a><del>Fault_AddressSize,
                   </del><a id="Fault_SyncExternal" name="Fault_SyncExternal"></a><del>Fault_SyncExternal,
                   </del><a id="Fault_SyncExternalOnWalk" name="Fault_SyncExternalOnWalk"></a><del>Fault_SyncExternalOnWalk,
                   </del><a id="Fault_SyncParity" name="Fault_SyncParity"></a><del>Fault_SyncParity,
                   </del><a id="Fault_SyncParityOnWalk" name="Fault_SyncParityOnWalk"></a><del>Fault_SyncParityOnWalk,
                   </del><a id="Fault_AsyncParity" name="Fault_AsyncParity"></a><del>Fault_AsyncParity,
                   </del><a id="Fault_AsyncExternal" name="Fault_AsyncExternal"></a><del>Fault_AsyncExternal,
                   </del><a id="Fault_Debug" name="Fault_Debug"></a><del>Fault_Debug,
                   </del><a id="Fault_TLBConflict" name="Fault_TLBConflict"></a><del>Fault_TLBConflict,
                   </del><a id="Fault_BranchTarget" name="Fault_BranchTarget"></a><del>Fault_BranchTarget,
                   </del><a id="Fault_HWUpdateAccessFlag" name="Fault_HWUpdateAccessFlag"></a><del>Fault_HWUpdateAccessFlag,
                   </del><a id="Fault_Lockdown" name="Fault_Lockdown"></a><del>Fault_Lockdown,
                   </del><a id="Fault_Exclusive" name="Fault_Exclusive"></a><del>Fault_Exclusive,
                   </del><a id="Fault_ICacheMaint" name="Fault_ICacheMaint"></a><del>Fault_ICacheMaint};</del></p></div><div class="ps" psname="shared.functions.mpam.DefaultPARTID"><a id="shared.functions.mpam.DefaultPARTID" name="shared.functions.mpam.DefaultPARTID"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>mpam</ins><del>memory</del>/<ins>DefaultPARTID</ins><del>FaultRecord</del></h3><p class="pseudocode"><ins>constant PARTIDtype DefaultPARTID = 0&lt;15:0>;</ins><del>type</del><a id="FaultRecord" name="FaultRecord"></a><del>FaultRecord is (</del><a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None, Fault_AccessFlag, Fault_Alignment, Fault_Background, Fault_Domain, Fault_Permission, Fault_Translation, Fault_AddressSize, Fault_SyncExternal, Fault_SyncExternalOnWalk, Fault_SyncParity, Fault_SyncParityOnWalk, Fault_AsyncParity, Fault_AsyncExternal, Fault_Debug, Fault_TLBConflict, Fault_BranchTarget, Fault_HWUpdateAccessFlag, Fault_Lockdown, Fault_Exclusive, Fault_ICacheMaint}"><del>Fault</del></a><del>    type,         // Fault Status
                     </del><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><del>  acctype,      // Type of access that faulted
                     </del><a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( bits(52) address, bit NS )"><del>FullAddress</del></a><del> ipaddress, // Intermediate physical address
                     boolean  s2fs1walk,    // Is on a Stage 1 page table walk
                     boolean  write,        // TRUE for a write, FALSE for a read
                     integer  level,        // For translation, access flag and permission faults
                     bit      extflag,      // IMPLEMENTATION DEFINED syndrome for external aborts
                     boolean  secondstage,  // Is a Stage 2 abort
                     bits(4)  domain,       // Domain number, AArch32 only
                     bits(2)  errortype,    // [ARMv8.2 RAS] AArch32 AET or AArch64 SET
                     bits(4)  debugmoe)     // Debug method of entry, from AArch32 only

type PARTIDtype = bits(16);
type PMGtype = bits(8);

type MPAMinfo is (
     bit mpam_ns,
     PARTIDtype partid,
     PMGtype pmg
)</del></p></div><div class="ps" psname="shared.functions.mpam.DefaultPMG"><a id="shared.functions.mpam.DefaultPMG" name="shared.functions.mpam.DefaultPMG"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>mpam</ins><del>memory</del>/<ins>DefaultPMG</ins><del>FullAddress</del></h3><p class="pseudocode"><ins>constant PMGtype    DefaultPMG = 0&lt;7:0>;</ins><del>type</del><a id="FullAddress" name="FullAddress"></a><del>FullAddress is (
    bits(52) address,
    bit      NS                  // '0' = Secure, '1' = Non-secure
)</del></p></div><div class="ps" psname="shared.functions.mpam.GenMPAMcurEL"><a id="shared.functions.mpam.GenMPAMcurEL" name="shared.functions.mpam.GenMPAMcurEL"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>mpam</ins><del>memory</del>/<ins>GenMPAMcurEL</ins><del>Hint_Prefetch</del></h3><p class="pseudocode"><ins>// GenMPAMcurEL
// ============
// Returns MPAMinfo for the current EL and security state.
// InD is TRUE instruction access and FALSE otherwise.
// May be called if MPAM is not implemented (but in an version that supports
// MPAM), MPAM is disabled, or in AArch32.  In AArch32, convert the mode to
// EL if can and use that to drive MPAM information generation.  If mode
// cannot be converted, MPAM is not implemented, or MPAM is disabled return
// default MPAM information for the current security state.

MPAMinfo GenMPAMcurEL(boolean InD)
    bits(2) mpamel;
    boolean validEL;
    boolean secure =</ins><del>// Signals the memory system that memory accesses of type HINT to or from the specified address are
// likely in the near future. The memory system may take some action to speed up the memory
// accesses when they do occur, such as pre-loading the the specified address into one or more
// caches as indicated by the innermost cache level target (0=L1, 1=L2, etc) and non-temporal hint
// stream. Any or all prefetch hints may be treated as a NOP. A prefetch hint must not cause a
// synchronous abort due to Alignment or Translation faults and the like. Its only effect on
// software-visible state should be on caches and TLBs associated with address, which must be
// accessible by reads, writes or execution, as defined in the translation regime of the current
// Exception level. It is guaranteed not to access Device memory.
// A Prefetch_EXEC hint must not result in an access that could not be performed by a speculative
// instruction fetch, therefore if all associated MMUs are disabled, then it cannot access any
// memory location that cannot be accessed by instruction fetches.</del> <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>();
    if</ins><del>Hint_Prefetch(bits(64) address,</del> <a href="shared_pseudocode.html#impl-shared.HaveMPAMExt.0" title="function: boolean HaveMPAMExt()"><ins>HaveMPAMExt</ins></a><a href="shared_pseudocode.html#PrefetchHint" title="enumeration PrefetchHint {Prefetch_READ, Prefetch_WRITE, Prefetch_EXEC}"><del>PrefetchHint</del></a><ins>() &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.MPAMisEnabled.0" title="function: boolean MPAMisEnabled()"><ins>MPAMisEnabled</ins></a><ins>() then
        if </ins><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>() then
            (validEL, mpamel) = </ins><a href="shared_pseudocode.html#impl-shared.ELFromM32.1" title="function: (boolean,bits(2)) ELFromM32(bits(5) mode)"><ins>ELFromM32</ins></a><ins>(PSTATE.M);
        else
            validEL = TRUE;
            mpamel = PSTATE.EL;
        if validEL then
            return genMPAM(</ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(mpamel), InD, secure);
    return DefaultMPAMinfo(secure);</ins><del>hint, integer target, boolean stream);</del></p></div><div class="ps" psname="shared.functions.mpam.MAP_vPARTID"><a id="shared.functions.mpam.MAP_vPARTID" name="shared.functions.mpam.MAP_vPARTID"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>mpam</ins><del>memory</del>/<ins>MAP_vPARTID</ins><del>MBReqDomain</del></h3><p class="pseudocode"><ins>// MAP_vPARTID
// ===========
// Performs conversion of virtual PARTID into physical PARTID
// Contains all of the error checking and implementation
// choices for the conversion.

(PARTIDtype, boolean) MAP_vPARTID(PARTIDtype vpartid)
    // should not ever be called if EL2 is not implemented
    // or is implemented but not enabled in the current
    // security state.
    PARTIDtype ret;
    boolean err;
    integer virt    =</ins><del>enumeration</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>( vpartid );
    integer vmprmax =</ins><del>MBReqDomain    {</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>( MPAMIDR_EL1.VPMR_MAX );

    // vpartid_max is largest vpartid supported
    integer vpartid_max = 4 * vmprmax + 3;

    // One of many ways to reduce vpartid to value less than vpartid_max.
    if virt > vpartid_max then
        virt = virt MOD (vpartid_max+1);

    // Check for valid mapping entry.
    if MPAMVPMV_EL2&lt;virt> == '1' then
        // vpartid has a valid mapping so access the map.
        ret = mapvpmw(virt);
        err = FALSE;

    // Is the default virtual PARTID valid?
    elsif MPAMVPMV_EL2&lt;0> == '1' then
        // Yes, so use default mapping for vpartid == 0.
        ret = MPAMVPM0_EL2&lt;0 +: 16>;
        err = FALSE;

    // Neither is valid so use default physical PARTID.
    else
        ret = DefaultPARTID;
        err = TRUE;

    // Check that the physical PARTID is in-range.
    // This physical PARTID came from a virtual mapping entry.
    integer partid_max =</ins><del>MBReqDomain_Nonshareable,</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>( MPAMIDR_EL1.PARTID_MAX );
    if</ins><del>MBReqDomain_InnerShareable,</del> <del>MBReqDomain_OuterShareable, </del><a id="MBReqDomain_FullSystem" name="MBReqDomain_FullSystem"></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(ret) > partid_max then
        // Out of range, so return default physical PARTID
        ret = DefaultPARTID;
        err = TRUE;
    return (ret, err);</ins><del>MBReqDomain_FullSystem};</del></p></div><div class="ps" psname="shared.functions.mpam.MPAMisEnabled"><a id="shared.functions.mpam.MPAMisEnabled" name="shared.functions.mpam.MPAMisEnabled"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>mpam</ins><del>memory</del>/<ins>MPAMisEnabled</ins><del>MBReqTypes</del></h3><p class="pseudocode"><ins>// MPAMisEnabled
// =============
// Returns TRUE if MPAMisEnabled.

boolean</ins><del>enumeration</del> <a id="impl-shared.MPAMisEnabled.0" name="impl-shared.MPAMisEnabled.0"></a><ins>MPAMisEnabled()
    el =</ins><del>MBReqTypes     {</del> <a href="shared_pseudocode.html#impl-shared.HighestEL.0" title="function: bits(2) HighestEL()"><ins>HighestEL</ins></a><ins>();
    case el of
        when</ins><del>MBReqTypes_Reads,</del> <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a> <ins>return MPAM3_EL3.MPAMEN == '1';
        when</ins><del>MBReqTypes_Writes,</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins> return MPAM2_EL2.MPAMEN == '1';
        when </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a> <ins>return MPAM1_EL1.MPAMEN == '1';</ins><del>MBReqTypes_All};</del></p></div><div class="ps" psname="shared.functions.mpam.MPAMisVirtual"><a id="shared.functions.mpam.MPAMisVirtual" name="shared.functions.mpam.MPAMisVirtual"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>mpam</ins><del>memory</del>/<ins>MPAMisVirtual</ins><del>MemAttrHints</del></h3><p class="pseudocode"><ins>// MPAMisVirtual
// =============
// Returns TRUE if MPAM is configured to be virtual at EL.

boolean</ins><del>type</del> <a id="impl-shared.MPAMisVirtual.1" name="impl-shared.MPAMisVirtual.1"></a><ins>MPAMisVirtual(integer el)
    return (MPAMIDR_EL1.HAS_HCR == '1' &amp;&amp;</ins><del>MemAttrHints is (
    bits(2) attrs,  // See MemAttr_*, Cacheability attributes
    bits(2) hints,  // See MemHint_*, Allocation hints
    boolean transient
)</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>() &amp;&amp;
            (( el == 0 &amp;&amp; MPAMHCR_EL2.EL0_VPMEN == '1' ) ||
             ( el == 1 &amp;&amp; MPAMHCR_EL2.EL1_VPMEN == '1')));</ins></p></div><div class="ps" psname="shared.functions.mpam.genMPAM"><a id="shared.functions.mpam.genMPAM" name="shared.functions.mpam.genMPAM"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>mpam</ins><del>memory</del>/<ins>genMPAM</ins><del>MemTag</del></h3><p class="pseudocode"><ins>// genMPAM
// =======
// Returns MPAMinfo for exception level el.
// If InD is TRUE returns MPAM information using PARTID_I and PMG_I fields
// of MPAMel_ELx register and otherwise using PARTID_D and PMG_D fields.
// Produces a Secure PARTID if Secure is TRUE and a Non-secure PARTID otherwise.
</ins><del>// MemTag[] - non-assignment (read) form
// =====================================
// Load an Allocation Tag from memory.
</del>
<ins>MPAMinfo genMPAM(integer el, boolean InD, boolean secure)
    MPAMinfo returnInfo;
    PARTIDtype partidel;
    boolean perr;
    boolean gstplk = (el == 0 &amp;&amp;</ins><del>bits(4)</del> <del>MemTag[bits(64) address]
    </del><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><del>AddressDescriptor</del></a><del> memaddrdesc;
    bits(4) value;
    iswrite = FALSE;

    memaddrdesc = </del><a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><del>AArch64.TranslateAddress</del></a><del>(address, </del><a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NORMAL</del></a><del>, iswrite, TRUE, TAG_GRANULE);
    // Check for aborts or debug exceptions
    if </del><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><del>(memaddrdesc) then
        </del><a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)"><del>AArch64.Abort</del></a><del>(address, memaddrdesc.fault);

    // Return the granule tag if tagging is enabled...
    if </del><a href="shared_pseudocode.html#impl-shared.AllocationTagAccessIsEnabled.0" title="function: boolean AllocationTagAccessIsEnabled()"><del>AllocationTagAccessIsEnabled</del></a><del>() then
        return _MemTag[memaddrdesc];
    else
        // ...otherwise read tag as zero.
        return '0000';

// MemTag[] - assignment (write) form
// ==================================
// Store an Allocation Tag to memory.

</del><a id="impl-shared.MemTag.write.1_3" name="impl-shared.MemTag.write.1_3"></a><del>MemTag[bits(64) address] = bits(4) value
    </del><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><del>AddressDescriptor</del></a><del> memaddrdesc;
    iswrite = TRUE;

    // Stores of allocation tags must be aligned
    if address != </del><a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)"><del>Align</del></a><del>(address, TAG_GRANULE) then
        boolean secondstage = FALSE;
        </del><a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)"><del>AArch64.Abort</del></a><del>(address, </del><a href="shared_pseudocode.html#AArch64.AlignmentFault.3" title="function: FaultRecord AArch64.AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)"><del>AArch64.AlignmentFault</del></a><del>(</del><a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NORMAL</del></a><del>, iswrite, secondstage));

    wasaligned = TRUE;
    memaddrdesc = </del><a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) vaddress, AccType acctype, boolean iswrite, boolean wasaligned, integer size)"><del>AArch64.TranslateAddress</del></a><del>(address, </del><a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NORMAL</del></a><del>, iswrite, wasaligned, TAG_GRANULE);

    // Check for aborts or debug exceptions
    if </del><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><del>(memaddrdesc) then
        </del><a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)"><del>AArch64.Abort</del></a><del>(address, memaddrdesc.fault);

    // Memory array access
    if </del><a href="shared_pseudocode.html#impl-shared.AllocationTagAccessIsEnabled.0" title="function: boolean AllocationTagAccessIsEnabled()"><del>AllocationTagAccessIsEnabled</del></a><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>() &amp;&amp;
                      MPAMHCR_EL2.GSTAPP_PLK == '1' &amp;&amp; HCR_EL2.TGE == '0');
    integer eff_el = if gstplk then 1 else el;
    (partidel, perr) = genPARTID(eff_el, InD);
    PMGtype groupel  = genPMG(eff_el, InD, perr);
    returnInfo.mpam_ns = if secure then '0' else '1';
    returnInfo.partid  = partidel;
    returnInfo.pmg     = groupel;
    return returnInfo;</ins><del>() then
        _MemTag[memaddrdesc] = value;</del></p></div><div class="ps" psname="shared.functions.mpam.genMPAMel"><a id="shared.functions.mpam.genMPAMel" name="shared.functions.mpam.genMPAMel"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>mpam</ins><del>memory</del>/<ins>genMPAMel</ins><del>MemType</del></h3><p class="pseudocode"><ins>// genMPAMel
// =========
// Returns MPAMinfo for specified EL in the current security state.
// InD is TRUE for instruction access and FALSE otherwise.

MPAMinfo genMPAMel(bits(2) el, boolean InD)
    boolean secure =</ins><del>enumeration</del> <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><ins>IsSecure</ins></a><ins>();
    if</ins><del>MemType {</del> <a href="shared_pseudocode.html#impl-shared.HaveMPAMExt.0" title="function: boolean HaveMPAMExt()"><ins>HaveMPAMExt</ins></a><ins>() &amp;&amp;</ins><del>MemType_Normal,</del> <a href="shared_pseudocode.html#impl-shared.MPAMisEnabled.0" title="function: boolean MPAMisEnabled()"><ins>MPAMisEnabled</ins></a><ins>() then
        return genMPAM(</ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(el), InD, secure);
    return DefaultMPAMinfo(secure);</ins><del>MemType_Device};</del></p></div><div class="ps" psname="shared.functions.mpam.genPARTID"><a id="shared.functions.mpam.genPARTID" name="shared.functions.mpam.genPARTID"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>mpam</ins><del>memory</del>/<ins>genPARTID</ins><del>MemoryAttributes</del></h3><p class="pseudocode"><ins>// genPARTID
// =========
// Returns physical PARTID and error boolean for exception level el.
// If InD is TRUE then PARTID is from MPAMel_ELx.PARTID_I and
// otherwise from MPAMel_ELx.PARTID_D.

(PARTIDtype, boolean) genPARTID(integer el, boolean InD)
    PARTIDtype partidel = getMPAM_PARTID(el, InD);

    integer partid_max =</ins><del>type</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(MPAMIDR_EL1.PARTID_MAX);
    if</ins><del>MemoryAttributes is (</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#MemType" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType</del></a><ins>(partidel) > partid_max then
        return (DefaultPARTID, TRUE);

    if</ins><del>type,</del> <del>   device,     // For Device memory types
    </del><a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )"><del>MemAttrHints</del></a><del> inner,      // Inner hints and attributes
    </del><a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )"><del>MemAttrHints</del></a><a href="shared_pseudocode.html#impl-shared.MPAMisVirtual.1" title="function: boolean MPAMisVirtual(integer el)"><ins>MPAMisVirtual</ins></a><a href="shared_pseudocode.html#DeviceType" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType</del></a><ins>(el) then
        return MAP_vPARTID(partidel);
    else
        return (partidel, FALSE);</ins><del>outer,      // Outer hints and attributes
    boolean      tagged,     // Tagged access
    boolean      shareable,
    boolean      outershareable
)</del></p></div><div class="ps" psname="shared.functions.mpam.genPMG"><a id="shared.functions.mpam.genPMG" name="shared.functions.mpam.genPMG"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>mpam</ins><del>memory</del>/<ins>genPMG</ins><del>Permissions</del></h3><p class="pseudocode"><ins>// genPMG
// ======
// Returns PMG for exception level el and I- or D-side (InD).
// If PARTID generation (genPARTID) encountered an error, genPMG() should be
// called with partid_err as TRUE.

PMGtype genPMG(integer el, boolean InD, boolean partid_err)
    integer pmg_max =</ins><del>type</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(MPAMIDR_EL1.PMG_MAX);

    // It is CONSTRAINED UNPREDICTABLE whether partid_err forces PMG to
    // use the default or if it uses the PMG from getMPAM_PMG.
    if partid_err then
        return DefaultPMG;
    PMGtype groupel = getMPAM_PMG(el, InD);
    if </ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(groupel) &lt;= pmg_max then
        return groupel;
    return DefaultPMG;</ins><del>Permissions is (
    bits(3) ap,   // Access permission bits
    bit     xn,   // Execute-never bit
    bit     xxn,  // [ARMv8.2] Extended execute-never bit for stage 2
    bit     pxn   // Privileged execute-never bit
)</del></p></div><div class="ps" psname="shared.functions.mpam.getMPAM_PARTID"><a id="shared.functions.mpam.getMPAM_PARTID" name="shared.functions.mpam.getMPAM_PARTID"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>mpam</ins><del>memory</del>/<ins>getMPAM_PARTID</ins><del>PrefetchHint</del></h3><p class="pseudocode"><ins>// getMPAM_PARTID
// ==============
// Returns a PARTID from one of the MPAMn_ELx registers.
// MPAMn selects the MPAMn_ELx register used.
// If InD is TRUE, selects the PARTID_I field of that
// register.  Otherwise, selects the PARTID_D field.

PARTIDtype getMPAM_PARTID(integer MPAMn, boolean InD)
    PARTIDtype partid;
    boolean el2avail =</ins><del>enumeration</del> <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>();

    if InD then
        case MPAMn of
            when 3 partid = MPAM3_EL3.PARTID_I;
            when 2 partid = if el2avail then MPAM2_EL2.PARTID_I else</ins><del>PrefetchHint {</del> <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><ins>Zeros</ins></a><ins>();
            when 1 partid = MPAM1_EL1.PARTID_I;
            when 0 partid = MPAM0_EL1.PARTID_I;
            otherwise partid = PARTIDtype UNKNOWN;
    else
        case MPAMn of
            when 3 partid = MPAM3_EL3.PARTID_D;
            when 2 partid = if el2avail then MPAM2_EL2.PARTID_D else</ins><del>Prefetch_READ,</del> <del>Prefetch_WRITE, </del><a id="Prefetch_EXEC" name="Prefetch_EXEC"></a><a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><ins>Zeros</ins></a><ins>();
            when 1 partid = MPAM1_EL1.PARTID_D;
            when 0 partid = MPAM0_EL1.PARTID_D;
            otherwise partid = PARTIDtype UNKNOWN;
    return partid;</ins><del>Prefetch_EXEC};</del></p></div><div class="ps" psname="shared.functions.mpam.getMPAM_PMG"><a id="shared.functions.mpam.getMPAM_PMG" name="shared.functions.mpam.getMPAM_PMG"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>mpam</ins><del>memory</del>/<ins>getMPAM_PMG</ins><del>SpeculativeSynchronizationBarrierToPA</del></h3><p class="pseudocode"><a id="impl-shared.SpeculativeSynchronizationBarrierToPA.0" name="impl-shared.SpeculativeSynchronizationBarrierToPA.0"></a><ins>// getMPAM_PMG
// ===========
// Returns a PMG from one of the MPAMn_ELx registers.
// MPAMn selects the MPAMn_ELx register used.
// If InD is TRUE, selects the PMG_I field of that
// register.  Otherwise, selects the PMG_D field.

PMGtype getMPAM_PMG(integer MPAMn, boolean InD)
    PMGtype pmg;
    boolean el2avail = </ins><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><ins>();

    if InD then
        case MPAMn of
            when 3 pmg = MPAM3_EL3.PMG_I;
            when 2 pmg = if el2avail then MPAM2_EL2.PMG_I else </ins><a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><ins>Zeros</ins></a><ins>();
            when 1 pmg = MPAM1_EL1.PMG_I;
            when 0 pmg = MPAM0_EL1.PMG_I;
            otherwise pmg = PMGtype UNKNOWN;
    else
        case MPAMn of
            when 3 pmg = MPAM3_EL3.PMG_D;
            when 2 pmg = if el2avail then MPAM2_EL2.PMG_D else </ins><a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><ins>Zeros</ins></a><ins>();
            when 1 pmg = MPAM1_EL1.PMG_D;
            when 0 pmg = MPAM0_EL1.PMG_D;
            otherwise pmg = PMGtype UNKNOWN;
    return pmg;</ins><del>SpeculativeSynchronizationBarrierToPA();</del></p></div><div class="ps" psname="shared.functions.mpam.mapvpmw"><a id="shared.functions.mpam.mapvpmw" name="shared.functions.mpam.mapvpmw"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>mpam</ins><del>memory</del>/<ins>mapvpmw</ins><del>SpeculativeSynchronizationBarrierToVA</del></h3><p class="pseudocode"><a id="impl-shared.SpeculativeSynchronizationBarrierToVA.0" name="impl-shared.SpeculativeSynchronizationBarrierToVA.0"></a><ins>// mapvpmw
// =======
// Map a virtual PARTID into a physical PARTID using
// the MPAMVPMn_EL2 registers.
// vpartid is now assumed in-range and valid (checked by caller)
// returns physical PARTID from mapping entry.

PARTIDtype mapvpmw(integer vpartid)
    bits(64) vpmw;
    integer wd = vpartid DIV 4;
    case wd of
        when 0 vpmw = MPAMVPM0_EL2;
        when 1 vpmw = MPAMVPM1_EL2;
        when 2 vpmw = MPAMVPM2_EL2;
        when 3 vpmw = MPAMVPM3_EL2;
        when 4 vpmw = MPAMVPM4_EL2;
        when 5 vpmw = MPAMVPM5_EL2;
        when 6 vpmw = MPAMVPM6_EL2;
        when 7 vpmw = MPAMVPM7_EL2;
        otherwise vpmw = </ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(64);
    // vpme_lsb selects LSB of field within register
    integer vpme_lsb = (vpartid REM 4) * 16;
    return vpmw&lt;vpme_lsb +: 16>;</ins><del>SpeculativeSynchronizationBarrierToVA();</del></p></div><div class="ps" psname="shared.functions.registers.BranchTo"><a id="shared.functions.registers.BranchTo" name="shared.functions.registers.BranchTo"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>registers</ins><del>memory</del>/<ins>BranchTo</ins><del>TLBRecord</del></h3><p class="pseudocode"><ins>// BranchTo()
// ==========

// Set program counter to a new address, with a branch type
// In AArch64 state the address might include a tag in the top eight bits.</ins><del>type</del>

<a id="impl-shared.BranchTo.2" name="impl-shared.BranchTo.2"></a><ins>BranchTo(bits(N) target,</ins><del>TLBRecord is (</del> <a href="shared_pseudocode.html#BranchType" title="enumeration BranchType { BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}"><ins>BranchType</ins></a><a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(3) ap, bit xn, bit xxn, bit pxn )"><del>Permissions</del></a> <ins>branch_type)</ins><del>perms,
    bit               nG,             // '0' = Global, '1' = not Global
    bits(4)           domain,         // AArch32 only
    bit               GP,             // Guarded Page
    boolean           contiguous,     // Contiguous bit from page table
    integer           level,          // AArch32 Short-descriptor format: Indicates Section/Page
    integer           blocksize,      // Describes size of memory translated in KBytes</del>
    <a href="shared_pseudocode.html#impl-shared.Hint_Branch.1" title="function: Hint_Branch(BranchType hint)"><ins>Hint_Branch</ins></a><a href="shared_pseudocode.html#DescriptorUpdate" title="type DescriptorUpdate is ( boolean AF, boolean AP, AddressDescriptor descaddr )"><del>DescriptorUpdate</del></a><ins>(branch_type);
    if N == 32 then
        assert</ins><del>descupdate,     // [ARMv8.1] Context for h/w update of table descriptor
    bit               CnP,            // [ARMv8.2] TLB entry can be shared between different PEs</del> <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><del>AddressDescriptor</del></a><ins>();
        _PC = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><ins>ZeroExtend</ins></a><ins>(target);
    else
        assert N == 64 &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>();
        _PC = </ins><a href="shared_pseudocode.html#AArch64.BranchAddr.1" title="function: bits(64) AArch64.BranchAddr(bits(64) vaddress)"><ins>AArch64.BranchAddr</ins></a><ins>(target&lt;63:0>);
    return;</ins><del>addrdesc
)</del></p></div><div class="ps" psname="shared.functions.registers.BranchToAddr"><a id="shared.functions.registers.BranchToAddr" name="shared.functions.registers.BranchToAddr"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>registers</ins><del>memory</del>/<ins>BranchToAddr</ins><del>TransformTag</del></h3><p class="pseudocode"><ins>// BranchToAddr()
</ins><del>// TransformTag()
</del>// ==============
<del>// Apply tag transformation rules.
</del>
<ins>// Set program counter to a new address, with a branch type
// In AArch64 state the address does not include a tag in the top eight bits.</ins><del>bits(4)</del>

<a id="impl-shared.BranchToAddr.2" name="impl-shared.BranchToAddr.2"></a><ins>BranchToAddr(bits(N) target,</ins><del>TransformTag(bits(64) vaddr)
    bits(4) vtag = vaddr&lt;59:56>;
    bits(4) tagdelta =</del> <a href="shared_pseudocode.html#BranchType" title="enumeration BranchType { BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}"><ins>BranchType</ins></a><ins> branch_type)
    </ins><a href="shared_pseudocode.html#impl-shared.Hint_Branch.1" title="function: Hint_Branch(BranchType hint)"><ins>Hint_Branch</ins></a><ins>(branch_type);
    if N == 32 then
        assert </ins><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>();
        _PC = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a><ins>(target);
    else
        assert N == 64 &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>();
        _PC = target&lt;63:0>;
    return;</ins><del>(vaddr&lt;55>);
    bits(4) ptag = vtag + tagdelta;
    return ptag;</del></p></div><div class="ps" psname="shared.functions.registers.BranchType"><a id="shared.functions.registers.BranchType" name="shared.functions.registers.BranchType"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>registers</ins><del>memory</del>/<ins>BranchType</ins><del>_Mem</del></h3><p class="pseudocode"><ins>enumeration</ins><del>// These two _Mem[] accessors are the hardware operations which perform single-copy atomic,
// aligned, little-endian memory accesses of size bytes from/to the underlying physical
// memory array of bytes.
//
// The functions address the array using desc.paddress which supplies:
// * A 52-bit physical address
// * A single NS bit to select between Secure and Non-secure parts of the array.
//
// The accdesc descriptor describes the access type: normal, exclusive, ordered, streaming,
// etc and other parameters required to access the physical memory or for setting syndrome
// register in the event of an external abort.
bits(8*size) _Mem[</del> <a id="BranchType" name="BranchType"></a><ins>BranchType {</ins><del>desc, integer size, AccessDescriptor accdesc];

_Mem[</del>
    <a id="BranchType_DIRCALL" name="BranchType_DIRCALL"></a><ins>BranchType_DIRCALL,     // Direct Branch with link
    </ins><a id="BranchType_INDCALL" name="BranchType_INDCALL"></a><ins>BranchType_INDCALL,     // Indirect Branch with link
    </ins><a id="BranchType_ERET" name="BranchType_ERET"></a><ins>BranchType_ERET,        // Exception return (indirect)
    </ins><a id="BranchType_DBGEXIT" name="BranchType_DBGEXIT"></a><ins>BranchType_DBGEXIT,     // Exit from Debug state
    </ins><a id="BranchType_RET" name="BranchType_RET"></a><ins>BranchType_RET,         // Indirect branch with function return hint
    </ins><a id="BranchType_DIR" name="BranchType_DIR"></a><ins>BranchType_DIR,         // Direct branch
    </ins><a id="BranchType_INDIR" name="BranchType_INDIR"></a><ins>BranchType_INDIR,       // Indirect branch
    </ins><a id="BranchType_EXCEPTION" name="BranchType_EXCEPTION"></a><ins>BranchType_EXCEPTION,   // Exception entry
    </ins><a id="BranchType_RESET" name="BranchType_RESET"></a><ins>BranchType_RESET,       // Reset
    </ins><a id="BranchType_UNKNOWN" name="BranchType_UNKNOWN"></a><ins>BranchType_UNKNOWN};    // Other</ins><del>desc, integer size, AccessDescriptor accdesc] = bits(8*size) value;</del></p></div><div class="ps" psname="shared.functions.registers.Hint_Branch"><a id="shared.functions.registers.Hint_Branch" name="shared.functions.registers.Hint_Branch"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>registers</ins><del>memory</del>/<ins>Hint_Branch</ins><del>boolean</del></h3><p class="pseudocode"><ins>// Report the hint passed to BranchTo() and BranchToAddr(), for consideration when processing
// the next instruction.</ins><del>// boolean AccessIsTagChecked()
// ============================
// TRUE if a given access is tag-checked, FALSE otherwise.

boolean</del>
<a id="impl-shared.Hint_Branch.1" name="impl-shared.Hint_Branch.1"></a><ins>Hint_Branch(</ins><del>AccessIsTagChecked(bits(64) vaddr,</del><del> acctype)
    if PSTATE.M&lt;4> == '1' then return FALSE;

    if </del><a href="shared_pseudocode.html#impl-shared.EffectiveTBI.3" title="function: bit EffectiveTBI(bits(64) address, boolean IsInstr, bits(2) el)"><del>EffectiveTBI</del></a><del>(vaddr, FALSE, PSTATE.EL) == '0' then
        return FALSE;

    if </del><a href="shared_pseudocode.html#impl-shared.EffectiveTCMA.2" title="function: bit EffectiveTCMA(bits(64) address, bits(2) el)"><del>EffectiveTCMA</del></a><del>(vaddr, PSTATE.EL) == '1' &amp;&amp; (vaddr&lt;59:55> == '00000' || vaddr&lt;59:55> == '11111') then
        return FALSE;

    if !</del><a href="shared_pseudocode.html#impl-shared.AllocationTagAccessIsEnabled.0" title="function: boolean AllocationTagAccessIsEnabled()"><del>AllocationTagAccessIsEnabled</del></a><del>() then
        return FALSE;

    if acctype IN {</del><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IFETCH</del></a><del>, </del><a href="shared_pseudocode.html#AccType_PTW" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_PTW</del></a><del>} then
        return FALSE;

    if acctype == </del><a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NV2REGISTER</del></a><a href="shared_pseudocode.html#BranchType" title="enumeration BranchType { BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}"><ins>BranchType</ins></a><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a> <ins>hint);</ins><del>then
        return FALSE;

    if PSTATE.TCO=='1' then
        return FALSE;

    if IsNonTagCheckedInstruction() then
        return FALSE;

    return TRUE;</del></p></div><div class="ps" psname="shared.functions.registers.NextInstrAddr"><a id="shared.functions.registers.NextInstrAddr" name="shared.functions.registers.NextInstrAddr"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>registers</ins><del>mpam</del>/<ins>NextInstrAddr</ins><del>DefaultMPAMinfo</del></h3><p class="pseudocode"><ins>// Return address of the sequentially next instruction.
bits(N)</ins><del>// DefaultMPAMinfo
// ===============
// Returns default MPAM info.  If secure is TRUE return default Secure
// MPAMinfo, otherwise return default Non-secure MPAMinfo.

MPAMinfo DefaultMPAMinfo(boolean secure)
    MPAMinfo DefaultInfo;
    DefaultInfo.mpam_ns = if secure then '0' else '1';
    DefaultInfo.partid  = DefaultPARTID;
    DefaultInfo.pmg     = DefaultPMG;
    return DefaultInfo;</del> <a id="impl-shared.NextInstrAddr.0" name="impl-shared.NextInstrAddr.0"></a><ins>NextInstrAddr();</ins></p></div><div class="ps" psname="shared.functions.registers.ResetExternalDebugRegisters"><a id="shared.functions.registers.ResetExternalDebugRegisters" name="shared.functions.registers.ResetExternalDebugRegisters"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>registers</ins><del>mpam</del>/<ins>ResetExternalDebugRegisters</ins><del>DefaultPARTID</del></h3><p class="pseudocode"><ins>// Reset the External Debug registers in the Core power domain.</ins><del>constant PARTIDtype DefaultPARTID = 0&lt;15:0>;</del>
<a id="impl-shared.ResetExternalDebugRegisters.1" name="impl-shared.ResetExternalDebugRegisters.1"></a><ins>ResetExternalDebugRegisters(boolean cold_reset);</ins></p></div><div class="ps" psname="shared.functions.registers.ThisInstrAddr"><a id="shared.functions.registers.ThisInstrAddr" name="shared.functions.registers.ThisInstrAddr"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>registers</ins><del>mpam</del>/<ins>ThisInstrAddr</ins><del>DefaultPMG</del></h3><p class="pseudocode"><ins>// ThisInstrAddr()
// ===============
// Return address of the current instruction.

bits(N)</ins><del>constant PMGtype    DefaultPMG = 0&lt;7:0>;</del> <a id="impl-shared.ThisInstrAddr.0" name="impl-shared.ThisInstrAddr.0"></a><ins>ThisInstrAddr()
    assert N == 64 || (N == 32 &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>());
    return _PC&lt;N-1:0>;</ins></p></div><div class="ps" psname="shared.functions.registers._PC"><a id="shared.functions.registers._PC" name="shared.functions.registers._PC"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>registers</ins><del>mpam</del>/<ins>_PC</ins><del>GenMPAMcurEL</del></h3><p class="pseudocode"><ins>bits(64) _PC;</ins><del>// GenMPAMcurEL
// ============
// Returns MPAMinfo for the current EL and security state.
// InD is TRUE instruction access and FALSE otherwise.
// May be called if MPAM is not implemented (but in an version that supports
// MPAM), MPAM is disabled, or in AArch32.  In AArch32, convert the mode to
// EL if can and use that to drive MPAM information generation.  If mode
// cannot be converted, MPAM is not implemented, or MPAM is disabled return
// default MPAM information for the current security state.

MPAMinfo GenMPAMcurEL(boolean InD)
    bits(2) mpamel;
    boolean validEL;
    boolean secure =</del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>();
    if </del><a href="shared_pseudocode.html#impl-shared.HaveMPAMExt.0" title="function: boolean HaveMPAMExt()"><del>HaveMPAMExt</del></a><del>() &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.MPAMisEnabled.0" title="function: boolean MPAMisEnabled()"><del>MPAMisEnabled</del></a><del>() then
        if </del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>() then
            (validEL, mpamel) = </del><a href="shared_pseudocode.html#impl-shared.ELFromM32.1" title="function: (boolean,bits(2)) ELFromM32(bits(5) mode)"><del>ELFromM32</del></a><del>(PSTATE.M);
        else
            validEL = TRUE;
            mpamel = PSTATE.EL;
        if validEL then
            return genMPAM(</del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(mpamel), InD, secure);
    return DefaultMPAMinfo(secure);</del></p></div><div class="ps" psname="shared.functions.registers._R"><a id="shared.functions.registers._R" name="shared.functions.registers._R"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>registers</ins><del>mpam</del>/<ins>_R</ins><del>MAP_vPARTID</del></h3><p class="pseudocode"><ins>array bits(64) _R[0..30];</ins><del>// MAP_vPARTID
// ===========
// Performs conversion of virtual PARTID into physical PARTID
// Contains all of the error checking and implementation
// choices for the conversion.

(PARTIDtype, boolean) MAP_vPARTID(PARTIDtype vpartid)
    // should not ever be called if EL2 is not implemented
    // or is implemented but not enabled in the current
    // security state.
    PARTIDtype ret;
    boolean err;
    integer virt    =</del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>( vpartid );
    integer vmprmax = </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>( MPAMIDR_EL1.VPMR_MAX );

    // vpartid_max is largest vpartid supported
    integer vpartid_max = 4 * vmprmax + 3;

    // One of many ways to reduce vpartid to value less than vpartid_max.
    if virt > vpartid_max then
        virt = virt MOD (vpartid_max+1);

    // Check for valid mapping entry.
    if MPAMVPMV_EL2&lt;virt> == '1' then
        // vpartid has a valid mapping so access the map.
        ret = mapvpmw(virt);
        err = FALSE;

    // Is the default virtual PARTID valid?
    elsif MPAMVPMV_EL2&lt;0> == '1' then
        // Yes, so use default mapping for vpartid == 0.
        ret = MPAMVPM0_EL2&lt;0 +: 16>;
        err = FALSE;

    // Neither is valid so use default physical PARTID.
    else
        ret = DefaultPARTID;
        err = TRUE;

    // Check that the physical PARTID is in-range.
    // This physical PARTID came from a virtual mapping entry.
    integer partid_max = </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>( MPAMIDR_EL1.PARTID_MAX );
    if </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(ret) > partid_max then
        // Out of range, so return default physical PARTID
        ret = DefaultPARTID;
        err = TRUE;
    return (ret, err);</del></p></div><div class="ps" psname="shared.functions.registers._V"><a id="shared.functions.registers._V" name="shared.functions.registers._V"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>registers</ins><del>mpam</del>/<ins>_V</ins><del>MPAMisEnabled</del></h3><p class="pseudocode"><ins>array bits(128) _V[0..31];</ins><del>// MPAMisEnabled
// =============
// Returns TRUE if MPAMisEnabled.

boolean</del><a id="impl-shared.MPAMisEnabled.0" name="impl-shared.MPAMisEnabled.0"></a><del>MPAMisEnabled()
    el = </del><a href="shared_pseudocode.html#impl-shared.HighestEL.0" title="function: bits(2) HighestEL()"><del>HighestEL</del></a><del>();
    case el of
        when </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del> return MPAM3_EL3.MPAMEN == '1';
        when </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del> return MPAM2_EL2.MPAMEN == '1';
        when </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del> return MPAM1_EL1.MPAMEN == '1';</del></p></div><div class="ps" psname="shared.functions.sysregisters.SPSR"><a id="shared.functions.sysregisters.SPSR" name="shared.functions.sysregisters.SPSR"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>sysregisters</ins><del>mpam</del>/<ins>SPSR</ins><del>MPAMisVirtual</del></h3><p class="pseudocode"><ins>// SPSR[] - non-assignment form
// ============================
</ins><del>// MPAMisVirtual
// =============
// Returns TRUE if MPAM is configured to be virtual at EL.
</del>
<ins>bits(32)</ins><del>boolean</del> <a id="impl-shared.SPSR.read.0" name="impl-shared.SPSR.read.0"></a><ins>SPSR[]
    bits(32) result;
    if</ins><del>MPAMisVirtual(integer el)
    return (MPAMIDR_EL1.HAS_HCR == '1' &amp;&amp;</del> <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><ins>() then
        case PSTATE.M of
            when </ins><a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'"><ins>M32_FIQ</ins></a><ins>      result = SPSR_fiq;
            when </ins><a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'"><ins>M32_IRQ</ins></a><ins>      result = SPSR_irq;
            when </ins><a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'"><ins>M32_Svc</ins></a><ins>      result = SPSR_svc;
            when </ins><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><ins>M32_Monitor</ins></a><ins>  result = SPSR_mon;
            when </ins><a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'"><ins>M32_Abort</ins></a><ins>    result = SPSR_abt;
            when </ins><a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'"><ins>M32_Hyp</ins></a><ins>      result = SPSR_hyp;
            when </ins><a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'"><ins>M32_Undef</ins></a><ins>    result = SPSR_und;
            otherwise         </ins><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><ins>Unreachable</ins></a><ins>();
    else
        case PSTATE.EL of
            when </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>          result = SPSR_EL1;
            when </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>          result = SPSR_EL2;
            when </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>          result = SPSR_EL3;
            otherwise         </ins><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><ins>Unreachable</ins></a><ins>();
    return result;

// SPSR[] - assignment form
// ========================

</ins><a id="impl-shared.SPSR.write.0" name="impl-shared.SPSR.write.0"></a><ins>SPSR[] = bits(32) value
    if </ins><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>() then
        case PSTATE.M of
            when </ins><a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'"><ins>M32_FIQ</ins></a><ins>      SPSR_fiq = value;
            when </ins><a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'"><ins>M32_IRQ</ins></a><ins>      SPSR_irq = value;
            when </ins><a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'"><ins>M32_Svc</ins></a><ins>      SPSR_svc = value;
            when </ins><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><ins>M32_Monitor</ins></a><ins>  SPSR_mon = value;
            when </ins><a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'"><ins>M32_Abort</ins></a><ins>    SPSR_abt = value;
            when </ins><a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'"><ins>M32_Hyp</ins></a><ins>      SPSR_hyp = value;
            when </ins><a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'"><ins>M32_Undef</ins></a><ins>    SPSR_und = value;
            otherwise         </ins><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><ins>Unreachable</ins></a><ins>();
    else
        case PSTATE.EL of
            when </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>          SPSR_EL1 = value;
            when </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>          SPSR_EL2 = value;
            when </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>          SPSR_EL3 = value;
            otherwise         </ins><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><ins>Unreachable</ins></a><ins>();
    return;</ins><del>() &amp;&amp;
            (( el == 0 &amp;&amp; MPAMHCR_EL2.EL0_VPMEN == '1' ) ||
             ( el == 1 &amp;&amp; MPAMHCR_EL2.EL1_VPMEN == '1')));</del></p></div><div class="ps" psname="shared.functions.system.AllocationTagAccessIsEnabled"><a id="shared.functions.system.AllocationTagAccessIsEnabled" name="shared.functions.system.AllocationTagAccessIsEnabled"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>system</ins><del>mpam</del>/<ins>AllocationTagAccessIsEnabled</ins><del>genMPAM</del></h3><p class="pseudocode"><ins>// AllocationTagAccessIsEnabled()
// ==============================
// Check whether access to Allocation Tags is enabled.
</ins><del>// genMPAM
// =======
// Returns MPAMinfo for exception level el.
// If InD is TRUE returns MPAM information using PARTID_I and PMG_I fields
// of MPAMel_ELx register and otherwise using PARTID_D and PMG_D fields.
// Produces a Secure PARTID if Secure is TRUE and a Non-secure PARTID otherwise.
</del>
<ins>boolean</ins><del>MPAMinfo genMPAM(integer el, boolean InD, boolean secure)
    MPAMinfo returnInfo;
    PARTIDtype partidel;
    boolean perr;
    boolean gstplk = (el == 0 &amp;&amp;</del> <a id="impl-shared.AllocationTagAccessIsEnabled.0" name="impl-shared.AllocationTagAccessIsEnabled.0"></a><ins>AllocationTagAccessIsEnabled()
    if SCR_EL3.ATA == '0' &amp;&amp; PSTATE.EL IN {</ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>, </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>, </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>} then
        return FALSE;
    elsif HCR_EL2.ATA == '0' &amp;&amp; HCR_EL2.&lt;E2H,TGE> != '11' &amp;&amp; PSTATE.EL IN {</ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>, </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>} then
        return FALSE;
    elsif SCTLR_EL3.ATA == '0' &amp;&amp; PSTATE.EL == </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins> then
        return FALSE;
    elsif SCTLR_EL2.ATA == '0' &amp;&amp; PSTATE.EL == </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins> then
        return FALSE;
    elsif SCTLR_EL1.ATA == '0' &amp;&amp; PSTATE.EL == </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins> then
        return FALSE;
    elsif SCTLR_EL2.ATA0 == '0' &amp;&amp; HCR_EL2.&lt;E2H,TGE> == '11' &amp;&amp; PSTATE.EL == </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins> then
        return FALSE;
    elsif SCTLR_EL1.ATA0 == '0' &amp;&amp; HCR_EL2.&lt;E2H,TGE> != '11' &amp;&amp; PSTATE.EL == </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a> <ins>then
        return FALSE;
    else
        return TRUE;</ins><del>() &amp;&amp;
                      MPAMHCR_EL2.GSTAPP_PLK == '1' &amp;&amp; HCR_EL2.TGE == '0');
    integer eff_el = if gstplk then 1 else el;
    (partidel, perr) = genPARTID(eff_el, InD);
    PMGtype groupel  = genPMG(eff_el, InD, perr);
    returnInfo.mpam_ns = if secure then '0' else '1';
    returnInfo.partid  = partidel;
    returnInfo.pmg     = groupel;
    return returnInfo;</del></p></div><div class="ps" psname="shared.functions.system.ArchVersion"><a id="shared.functions.system.ArchVersion" name="shared.functions.system.ArchVersion"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>system</ins><del>mpam</del>/<ins>ArchVersion</ins><del>genMPAMel</del></h3><p class="pseudocode"><ins>enumeration</ins><del>// genMPAMel
// =========
// Returns MPAMinfo for specified EL in the current security state.
// InD is TRUE for instruction access and FALSE otherwise.

MPAMinfo genMPAMel(bits(2) el, boolean InD)
    boolean secure =</del> <a id="ArchVersion" name="ArchVersion"></a><ins>ArchVersion {</ins><del>();
    if</del>
    <a id="ARMv8p0" name="ARMv8p0"></a><ins>ARMv8p0
    ,</ins><del>() &amp;&amp;</del> <a id="ARMv8p1" name="ARMv8p1"></a><ins>ARMv8p1
    ,</ins><del>() then
        return genMPAM(</del> <a id="ARMv8p2" name="ARMv8p2"></a><ins>ARMv8p2
    , </ins><a id="ARMv8p3" name="ARMv8p3"></a><ins>ARMv8p3
    , </ins><a id="ARMv8p4" name="ARMv8p4"></a><ins>ARMv8p4
    , </ins><a id="ARMv8p5" name="ARMv8p5"></a><ins>ARMv8p5
};</ins><del>(el), InD, secure);
    return DefaultMPAMinfo(secure);</del></p></div><div class="ps" psname="shared.functions.system.BranchTargetCheck"><a id="shared.functions.system.BranchTargetCheck" name="shared.functions.system.BranchTargetCheck"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>system</ins><del>mpam</del>/<ins>BranchTargetCheck</ins><del>genPARTID</del></h3><p class="pseudocode"><ins>// BranchTargetCheck()
// ===================
// This function is executed checks if the current instruction is a valid target for a branch
// taken into, or inside, a guarded page. It is executed on every cycle once the current
// instruction has been decoded and the values of InGuardedPage and BTypeCompatible have been
// determined for the current instruction.</ins><del>// genPARTID
// =========
// Returns physical PARTID and error boolean for exception level el.
// If InD is TRUE then PARTID is from MPAMel_ELx.PARTID_I and
// otherwise from MPAMel_ELx.PARTID_D.

(PARTIDtype, boolean) genPARTID(integer el, boolean InD)
    PARTIDtype partidel = getMPAM_PARTID(el, InD);

    integer partid_max =</del>

<a id="impl-shared.BranchTargetCheck.0" name="impl-shared.BranchTargetCheck.0"></a><ins>BranchTargetCheck()

    assert</ins><del>(MPAMIDR_EL1.PARTID_MAX);
    if</del> <a href="shared_pseudocode.html#impl-shared.HaveBTIExt.0" title="function: boolean HaveBTIExt()"><ins>HaveBTIExt</ins></a><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><ins>() &amp;&amp; !</ins><del>(partidel) > partid_max then
        return (DefaultPARTID, TRUE);

    if</del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><a href="shared_pseudocode.html#impl-shared.MPAMisVirtual.1" title="function: boolean MPAMisVirtual(integer el)"><del>MPAMisVirtual</del></a><ins>();

    // The branch target check considers two state variables:
    // * InGuardedPage, which is evaluated during instruction fetch.
    // * BTypeCompatible, which is evaluated during instruction decode.
    if InGuardedPage &amp;&amp; PSTATE.BTYPE != '00' &amp;&amp; !BTypeCompatible &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><ins>Halted</ins></a><ins>() then
        bits(64) pc = </ins><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><ins>ThisInstrAddr</ins></a><ins>();
        </ins><a href="shared_pseudocode.html#AArch64.BranchTargetException.1" title="function: AArch64.BranchTargetException(bits(52) vaddress)"><ins>AArch64.BranchTargetException</ins></a><ins>(pc&lt;51:0>);

    boolean branch_instr = </ins><a href="shared_pseudocode.html#AArch64.ExecutingBROrBLROrRetInstr.0" title="function: boolean AArch64.ExecutingBROrBLROrRetInstr()"><ins>AArch64.ExecutingBROrBLROrRetInstr</ins></a><ins>();
    boolean bti_instr    = </ins><a href="shared_pseudocode.html#AArch64.ExecutingBTIInstr.0" title="function: boolean AArch64.ExecutingBTIInstr()"><ins>AArch64.ExecutingBTIInstr</ins></a><ins>();

    // PSTATE.BTYPE defaults to 00 for instructions that don't explictly set BTYPE.
    if !(branch_instr || bti_instr) then
        BTypeNext = '00';</ins><del>(el) then
        return MAP_vPARTID(partidel);
    else
        return (partidel, FALSE);</del></p></div><div class="ps" psname="shared.functions.system.ChooseNonExcludedTag"><a id="shared.functions.system.ChooseNonExcludedTag" name="shared.functions.system.ChooseNonExcludedTag"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>system</ins><del>mpam</del>/<ins>ChooseNonExcludedTag</ins><del>genPMG</del></h3><p class="pseudocode"><ins>// ChooseNonExcludedTag()
// ======================
// Return a tag derived from the start and the offset values, excluding
// any tags in the given mask.
</ins><del>// genPMG
// ======
// Returns PMG for exception level el and I- or D-side (InD).
// If PARTID generation (genPARTID) encountered an error, genPMG() should be
// called with partid_err as TRUE.
</del>
<ins>bits(4)</ins><del>PMGtype genPMG(integer el, boolean InD, boolean partid_err)
    integer pmg_max =</del> <a id="impl-shared.ChooseNonExcludedTag.3" name="impl-shared.ChooseNonExcludedTag.3"></a><ins>ChooseNonExcludedTag(bits(4) tag, bits(4) offset, bits(16) exclude)

    if </ins><a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)"><ins>IsOnes</ins></a><ins>(exclude) then
        return tag;

    if offset == '0000' then
        while exclude&lt;</ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a><ins>(tag)> == '1' do
            tag = tag + '0001';
</ins><del>(MPAMIDR_EL1.PMG_MAX);
</del>
<ins>    while offset != '0000' do
        offset = offset - '0001';
        tag = tag + '0001';
        while exclude&lt;</ins><del>    // It is CONSTRAINED UNPREDICTABLE whether partid_err forces PMG to
    // use the default or if it uses the PMG from getMPAM_PMG.
    if partid_err then
        return DefaultPMG;
    PMGtype groupel = getMPAM_PMG(el, InD);
    if</del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a><ins>(tag)> == '1' do
            tag = tag + '0001';

    return tag;</ins><del>(groupel) &lt;= pmg_max then
        return groupel;
    return DefaultPMG;</del></p></div><div class="ps" psname="shared.functions.system.ClearEventRegister"><a id="shared.functions.system.ClearEventRegister" name="shared.functions.system.ClearEventRegister"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>system</ins><del>mpam</del>/<ins>ClearEventRegister</ins><del>getMPAM_PARTID</del></h3><p class="pseudocode"><ins>// ClearEventRegister()
// ====================
// Clear the Event Register of this PE</ins><del>// getMPAM_PARTID
// ==============
// Returns a PARTID from one of the MPAMn_ELx registers.
// MPAMn selects the MPAMn_ELx register used.
// If InD is TRUE, selects the PARTID_I field of that
// register.  Otherwise, selects the PARTID_D field.

PARTIDtype getMPAM_PARTID(integer MPAMn, boolean InD)
    PARTIDtype partid;
    boolean el2avail =</del>

<del>();

    if InD then
        case MPAMn of
            when 3 partid = MPAM3_EL3.PARTID_I;
            when 2 partid = if el2avail then MPAM2_EL2.PARTID_I else </del><a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><del>Zeros</del></a><del>();
            when 1 partid = MPAM1_EL1.PARTID_I;
            when 0 partid = MPAM0_EL1.PARTID_I;
            otherwise partid = PARTIDtype UNKNOWN;
    else
        case MPAMn of
            when 3 partid = MPAM3_EL3.PARTID_D;
            when 2 partid = if el2avail then MPAM2_EL2.PARTID_D else </del><a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><del>Zeros</del></a><a id="impl-shared.ClearEventRegister.0" name="impl-shared.ClearEventRegister.0"></a><ins>ClearEventRegister()
    EventRegister = '0';
    return;</ins><del>();
            when 1 partid = MPAM1_EL1.PARTID_D;
            when 0 partid = MPAM0_EL1.PARTID_D;
            otherwise partid = PARTIDtype UNKNOWN;
    return partid;</del></p></div><div class="ps" psname="shared.functions.system.ClearPendingPhysicalSError"><a id="shared.functions.system.ClearPendingPhysicalSError" name="shared.functions.system.ClearPendingPhysicalSError"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>system</ins><del>mpam</del>/<ins>ClearPendingPhysicalSError</ins><del>getMPAM_PMG</del></h3><p class="pseudocode"><ins>// Clear a pending physical SError interrupt</ins><del>// getMPAM_PMG
// ===========
// Returns a PMG from one of the MPAMn_ELx registers.
// MPAMn selects the MPAMn_ELx register used.
// If InD is TRUE, selects the PMG_I field of that
// register.  Otherwise, selects the PMG_D field.

PMGtype getMPAM_PMG(integer MPAMn, boolean InD)
    PMGtype pmg;
    boolean el2avail =</del>
<del>();

    if InD then
        case MPAMn of
            when 3 pmg = MPAM3_EL3.PMG_I;
            when 2 pmg = if el2avail then MPAM2_EL2.PMG_I else </del><a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><del>Zeros</del></a><del>();
            when 1 pmg = MPAM1_EL1.PMG_I;
            when 0 pmg = MPAM0_EL1.PMG_I;
            otherwise pmg = PMGtype UNKNOWN;
    else
        case MPAMn of
            when 3 pmg = MPAM3_EL3.PMG_D;
            when 2 pmg = if el2avail then MPAM2_EL2.PMG_D else </del><a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><del>Zeros</del></a><a id="impl-shared.ClearPendingPhysicalSError.0" name="impl-shared.ClearPendingPhysicalSError.0"></a><ins>ClearPendingPhysicalSError();</ins><del>();
            when 1 pmg = MPAM1_EL1.PMG_D;
            when 0 pmg = MPAM0_EL1.PMG_D;
            otherwise pmg = PMGtype UNKNOWN;
    return pmg;</del></p></div><div class="ps" psname="shared.functions.system.ClearPendingVirtualSError"><a id="shared.functions.system.ClearPendingVirtualSError" name="shared.functions.system.ClearPendingVirtualSError"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>system</ins><del>mpam</del>/<ins>ClearPendingVirtualSError</ins><del>mapvpmw</del></h3><p class="pseudocode"><ins>// Clear a pending virtual SError interrupt</ins><del>// mapvpmw
// =======
// Map a virtual PARTID into a physical PARTID using
// the MPAMVPMn_EL2 registers.
// vpartid is now assumed in-range and valid (checked by caller)
// returns physical PARTID from mapping entry.

PARTIDtype mapvpmw(integer vpartid)
    bits(64) vpmw;
    integer wd = vpartid DIV 4;
    case wd of
        when 0 vpmw = MPAMVPM0_EL2;
        when 1 vpmw = MPAMVPM1_EL2;
        when 2 vpmw = MPAMVPM2_EL2;
        when 3 vpmw = MPAMVPM3_EL2;
        when 4 vpmw = MPAMVPM4_EL2;
        when 5 vpmw = MPAMVPM5_EL2;
        when 6 vpmw = MPAMVPM6_EL2;
        when 7 vpmw = MPAMVPM7_EL2;
        otherwise vpmw =</del>
<a id="impl-shared.ClearPendingVirtualSError.0" name="impl-shared.ClearPendingVirtualSError.0"></a><ins>ClearPendingVirtualSError();</ins><del>(64);
    // vpme_lsb selects LSB of field within register
    integer vpme_lsb = (vpartid REM 4) * 16;
    return vpmw&lt;vpme_lsb +: 16>;</del></p></div><div class="ps" psname="shared.functions.system.ConditionHolds"><a id="shared.functions.system.ConditionHolds" name="shared.functions.system.ConditionHolds"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>system</ins><del>registers</del>/<ins>ConditionHolds</ins><del>BranchTo</del></h3><p class="pseudocode"><ins>// ConditionHolds()
// ================
</ins><del>// BranchTo()
// ==========
</del>
<ins>// Return TRUE iff COND currently holds

boolean</ins><del>// Set program counter to a new address, with a branch type
// In AArch64 state the address might include a tag in the top eight bits.</del> <a id="impl-shared.ConditionHolds.1" name="impl-shared.ConditionHolds.1"></a><ins>ConditionHolds(bits(4) cond)
    // Evaluate base condition.
    case cond&lt;3:1> of
        when '000' result = (PSTATE.Z == '1');                          // EQ or NE
        when '001' result = (PSTATE.C == '1');                          // CS or CC
        when '010' result = (PSTATE.N == '1');                          // MI or PL
        when '011' result = (PSTATE.V == '1');                          // VS or VC
        when '100' result = (PSTATE.C == '1' &amp;&amp; PSTATE.Z == '0');       // HI or LS
        when '101' result = (PSTATE.N == PSTATE.V);                     // GE or LT
        when '110' result = (PSTATE.N == PSTATE.V &amp;&amp; PSTATE.Z == '0');  // GT or LE
        when '111' result = TRUE;                                       // AL

    // Condition flag values in the set '111x' indicate always true
    // Otherwise, invert condition if necessary.
    if cond&lt;0> == '1' &amp;&amp; cond != '1111' then
        result = !result;

    return result;</ins><del>BranchTo(bits(N) target,</del><a href="shared_pseudocode.html#BranchType" title="enumeration BranchType { BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}"><del>BranchType</del></a><del> branch_type)
    </del><a href="shared_pseudocode.html#impl-shared.Hint_Branch.1" title="function: Hint_Branch(BranchType hint)"><del>Hint_Branch</del></a><del>(branch_type);
    if N == 32 then
        assert </del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>();
        _PC = </del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><del>(target);
    else
        assert N == 64 &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>();
        _PC = </del><a href="shared_pseudocode.html#AArch64.BranchAddr.1" title="function: bits(64) AArch64.BranchAddr(bits(64) vaddress)"><del>AArch64.BranchAddr</del></a><del>(target&lt;63:0>);
    return;</del></p></div><div class="ps" psname="shared.functions.system.ConsumptionOfSpeculativeDataBarrier"><a id="shared.functions.system.ConsumptionOfSpeculativeDataBarrier" name="shared.functions.system.ConsumptionOfSpeculativeDataBarrier"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>system</ins><del>registers</del>/<ins>ConsumptionOfSpeculativeDataBarrier</ins><del>BranchToAddr</del></h3><p class="pseudocode"><del>// BranchToAddr()
// ==============

// Set program counter to a new address, with a branch type
// In AArch64 state the address does not include a tag in the top eight bits.

</del><a id="impl-shared.ConsumptionOfSpeculativeDataBarrier.0" name="impl-shared.ConsumptionOfSpeculativeDataBarrier.0"></a><del>BranchToAddr(bits(N) target, </del><a href="shared_pseudocode.html#BranchType" title="enumeration BranchType { BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}"><del>BranchType</del></a><del> branch_type)
    </del><a href="shared_pseudocode.html#impl-shared.Hint_Branch.1" title="function: Hint_Branch(BranchType hint)"><del>Hint_Branch</del></a><del>(branch_type);
    if N == 32 then
        assert </del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>();
        _PC = </del><a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)"><del>ZeroExtend</del></a><del>(target);
    else
        assert N == 64 &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><ins>ConsumptionOfSpeculativeDataBarrier();</ins><del>();
        _PC = target&lt;63:0>;
    return;</del></p></div><div class="ps" psname="shared.functions.system.CurrentInstrSet"><a id="shared.functions.system.CurrentInstrSet" name="shared.functions.system.CurrentInstrSet"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>system</ins><del>registers</del>/<ins>CurrentInstrSet</ins><del>BranchType</del></h3><p class="pseudocode"><ins>// CurrentInstrSet()
// =================

InstrSet</ins><del>enumeration</del> <a id="impl-shared.CurrentInstrSet.0" name="impl-shared.CurrentInstrSet.0"></a><ins>CurrentInstrSet()

    if</ins><del>BranchType {</del> <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>() then
        result = if PSTATE.T == '0' then</ins><del>BranchType_DIRCALL,     // Direct Branch with link</del> <a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><ins>InstrSet_A32</ins></a> <ins>else</ins><del>BranchType_INDCALL,     // Indirect Branch with link</del> <a href="shared_pseudocode.html#InstrSet_T32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><ins>InstrSet_T32</ins></a><ins>;
        // PSTATE.J is RES0. Implementation of T32EE or Jazelle state not permitted.
    else
        result =</ins><del>BranchType_ERET,        // Exception return (indirect)</del> <del>BranchType_DBGEXIT,     // Exit from Debug state
    </del><a id="BranchType_RET" name="BranchType_RET"></a><del>BranchType_RET,         // Indirect branch with function return hint
    </del><a id="BranchType_DIR" name="BranchType_DIR"></a><del>BranchType_DIR,         // Direct branch
    </del><a id="BranchType_INDIR" name="BranchType_INDIR"></a><del>BranchType_INDIR,       // Indirect branch
    </del><a id="BranchType_EXCEPTION" name="BranchType_EXCEPTION"></a><del>BranchType_EXCEPTION,   // Exception entry
    </del><a id="BranchType_RESET" name="BranchType_RESET"></a><del>BranchType_RESET,       // Reset
    </del><a id="BranchType_UNKNOWN" name="BranchType_UNKNOWN"></a><a href="shared_pseudocode.html#InstrSet_A64" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><ins>InstrSet_A64</ins></a><ins>;
    return result;</ins><del>BranchType_UNKNOWN};    // Other</del></p></div><div class="ps" psname="shared.functions.system.CurrentPL"><a id="shared.functions.system.CurrentPL" name="shared.functions.system.CurrentPL"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>system</ins><del>registers</del>/<ins>CurrentPL</ins><del>Hint_Branch</del></h3><p class="pseudocode"><ins>// CurrentPL()
// ===========

PrivilegeLevel</ins><del>// Report the hint passed to BranchTo() and BranchToAddr(), for consideration when processing
// the next instruction.</del> <a id="impl-shared.CurrentPL.0" name="impl-shared.CurrentPL.0"></a><ins>CurrentPL()
    return</ins><del>Hint_Branch(</del> <a href="shared_pseudocode.html#impl-shared.PLOfEL.1" title="function: PrivilegeLevel PLOfEL(bits(2) el)"><ins>PLOfEL</ins></a><a href="shared_pseudocode.html#BranchType" title="enumeration BranchType { BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_RESET, BranchType_UNKNOWN}"><del>BranchType</del></a><ins>(PSTATE.EL);</ins><del>hint);</del></p></div><div class="ps" psname="shared.functions.system.EL0"><a id="shared.functions.system.EL0" name="shared.functions.system.EL0"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>system</ins><del>registers</del>/<ins>EL0</ins><del>NextInstrAddr</del></h3><p class="pseudocode"><ins>constant bits(2)</ins><del>// Return address of the sequentially next instruction.
bits(N)</del> <a id="EL3" name="EL3"></a><ins>EL3 = '11';
constant bits(2)</ins><del>NextInstrAddr();</del> <a id="EL2" name="EL2"></a><ins>EL2 = '10';
constant bits(2) </ins><a id="EL1" name="EL1"></a><ins>EL1 = '01';
constant bits(2) </ins><a id="EL0" name="EL0"></a><ins>EL0 = '00';</ins></p></div><div class="ps" psname="shared.functions.system.EL2Enabled"><a id="shared.functions.system.EL2Enabled" name="shared.functions.system.EL2Enabled"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>system</ins><del>registers</del>/<ins>EL2Enabled</ins><del>ResetExternalDebugRegisters</del></h3><p class="pseudocode"><ins>// EL2Enabled()
// ============
// Returns TRUE if EL2 is present and executing in either non-Secure state when Secure EL2 is not implemented,
// or in Secure state when Secure EL2 is implemented, FALSE otherwise

boolean</ins><del>// Reset the External Debug registers in the Core power domain.</del> <a id="impl-shared.EL2Enabled.0" name="impl-shared.EL2Enabled.0"></a><ins>EL2Enabled()
    is_secure =</ins><del>ResetExternalDebugRegisters(boolean cold_reset);</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; SCR_EL3.NS == '0';
    return </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) &amp;&amp; (!is_secure || </ins><a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()"><ins>IsSecureEL2Enabled</ins></a><ins>());</ins></p></div><div class="ps" psname="shared.functions.system.ELFromM32"><a id="shared.functions.system.ELFromM32" name="shared.functions.system.ELFromM32"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>system</ins><del>registers</del>/<ins>ELFromM32</ins><del>ThisInstrAddr</del></h3><p class="pseudocode"><ins>// ELFromM32()
// ===========
</ins><del>// ThisInstrAddr()
// ===============
// Return address of the current instruction.
</del>
<ins>(boolean,bits(2))</ins><del>bits(N)</del> <a id="impl-shared.ELFromM32.1" name="impl-shared.ELFromM32.1"></a><ins>ELFromM32(bits(5) mode)
    // Convert an AArch32 mode encoding to an Exception level.
    // Returns (valid,EL):
    //   'valid' is TRUE if 'mode&lt;4:0>' encodes a mode that is both valid for this implementation
    //           and the current value of SCR.NS/SCR_EL3.NS.
    //   'EL'    is the Exception level decoded from 'mode'.
    bits(2) el;
    boolean valid = !</ins><del>ThisInstrAddr()
    assert N == 64 || (N == 32 &amp;&amp;</del><a href="shared_pseudocode.html#impl-aarch32.BadMode.1" title="function: boolean BadMode(bits(5) mode)"><ins>BadMode</ins></a><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><ins>(mode);  // Check for modes that are not valid for this implementation
    case mode of
        when </ins><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><ins>M32_Monitor</ins></a><ins>
            el = </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>;
        when </ins><a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'"><ins>M32_Hyp</ins></a><ins>
            el = </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>;
            valid = valid &amp;&amp; (!</ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) || </ins><a href="shared_pseudocode.html#impl-shared.SCR_GEN.read.0" title="accessor: SCRType SCR_GEN[]"><ins>SCR_GEN</ins></a><ins>[].NS == '1');
        when </ins><a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'"><ins>M32_FIQ</ins></a><ins>, </ins><a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'"><ins>M32_IRQ</ins></a><ins>, </ins><a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'"><ins>M32_Svc</ins></a><ins>, </ins><a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'"><ins>M32_Abort</ins></a><ins>, </ins><a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'"><ins>M32_Undef</ins></a><ins>, </ins><a href="shared_pseudocode.html#M32_System" title="constant bits(5) M32_System = '11111'"><ins>M32_System</ins></a><ins>
            // If EL3 is implemented and using AArch32, then these modes are EL3 modes in Secure
            // state, and EL1 modes in Non-secure state. If EL3 is not implemented or is using
            // AArch64, then these modes are EL1 modes.
            el = (if </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.HighestELUsingAArch32.0" title="function: boolean HighestELUsingAArch32()"><ins>HighestELUsingAArch32</ins></a><ins>() &amp;&amp; SCR.NS == '0' then </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins> else </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>);
        when </ins><a href="shared_pseudocode.html#M32_User" title="constant bits(5) M32_User = '10000'"><ins>M32_User</ins></a><ins>
            el = </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>;
        otherwise
            valid = FALSE;           // Passed an illegal mode value
    if !valid then el = bits(2) UNKNOWN;
    return (valid, el);</ins><del>());
    return _PC&lt;N-1:0>;</del></p></div><div class="ps" psname="shared.functions.system.ELFromSPSR"><a id="shared.functions.system.ELFromSPSR" name="shared.functions.system.ELFromSPSR"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>system</ins><del>registers</del>/<ins>ELFromSPSR</ins><del>_PC</del></h3><p class="pseudocode"><ins>// ELFromSPSR()
// ============

// Convert an SPSR value encoding to an Exception level.
// Returns (valid,EL):
//   'valid' is TRUE if 'spsr&lt;4:0>' encodes a valid mode for the current state.
//   'EL'    is the Exception level decoded from 'spsr'.

(boolean,bits(2))</ins><del>bits(64) _PC;</del> <a id="impl-shared.ELFromSPSR.1" name="impl-shared.ELFromSPSR.1"></a><ins>ELFromSPSR(bits(32) spsr)
    if spsr&lt;4> == '0' then                      // AArch64 state
        el = spsr&lt;3:2>;
        if </ins><a href="shared_pseudocode.html#impl-shared.HighestELUsingAArch32.0" title="function: boolean HighestELUsingAArch32()"><ins>HighestELUsingAArch32</ins></a><ins>() then         // No AArch64 support
            valid = FALSE;
        elsif !</ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(el) then                  // Exception level not implemented
            valid = FALSE;
        elsif spsr&lt;1> == '1' then               // M[1] must be 0
            valid = FALSE;
        elsif el == </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins> &amp;&amp; spsr&lt;0> == '1' then  // for EL0, M[0] must be 0
            valid = FALSE;
        elsif el == </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins> &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()"><ins>IsSecureEL2Enabled</ins></a><ins>() &amp;&amp; SCR_EL3.NS == '0' then
            valid = FALSE;                      // Unless Secure EL2 is enabled, EL2 only valid in Non-secure state
        else
            valid = TRUE;
    elsif </ins><a href="shared_pseudocode.html#impl-shared.HaveAnyAArch32.0" title="function: boolean HaveAnyAArch32()"><ins>HaveAnyAArch32</ins></a><ins>() then                // AArch32 state
        (valid, el) = </ins><a href="shared_pseudocode.html#impl-shared.ELFromM32.1" title="function: (boolean,bits(2)) ELFromM32(bits(5) mode)"><ins>ELFromM32</ins></a><ins>(spsr&lt;4:0>);
    else
        valid = FALSE;

    if !valid then el = bits(2) UNKNOWN;
    return (valid,el);</ins></p></div><div class="ps" psname="shared.functions.system.ELIsInHost"><a id="shared.functions.system.ELIsInHost" name="shared.functions.system.ELIsInHost"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>system</ins><del>registers</del>/<ins>ELIsInHost</ins><del>_R</del></h3><p class="pseudocode"><ins>// ELIsInHost()
// ============

boolean</ins><del>array bits(64) _R[0..30];</del> <a id="impl-shared.ELIsInHost.1" name="impl-shared.ELIsInHost.1"></a><ins>ELIsInHost(bits(2) el)
    return ((</ins><a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()"><ins>IsSecureEL2Enabled</ins></a><ins>() || !</ins><a href="shared_pseudocode.html#impl-shared.IsSecureBelowEL3.0" title="function: boolean IsSecureBelowEL3()"><ins>IsSecureBelowEL3</ins></a><ins>()) &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><ins>HaveVirtHostExt</ins></a><ins>() &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) &amp;&amp;
            HCR_EL2.E2H == '1' &amp;&amp; (el == </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins> || (el == </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins> &amp;&amp; HCR_EL2.TGE == '1')));</ins></p></div><div class="ps" psname="shared.functions.system.ELStateUsingAArch32"><a id="shared.functions.system.ELStateUsingAArch32" name="shared.functions.system.ELStateUsingAArch32"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>system</ins><del>registers</del>/<ins>ELStateUsingAArch32</ins><del>_V</del></h3><p class="pseudocode"><ins>// ELStateUsingAArch32()
// =====================

boolean</ins><del>array bits(128) _V[0..31];</del> <a id="impl-shared.ELStateUsingAArch32.2" name="impl-shared.ELStateUsingAArch32.2"></a><ins>ELStateUsingAArch32(bits(2) el, boolean secure)
    // See ELStateUsingAArch32K() for description. Must only be called in circumstances where
    // result is valid (typically, that means 'el IN {EL1,EL2,EL3}').
    (known, aarch32) = </ins><a href="shared_pseudocode.html#impl-shared.ELStateUsingAArch32K.2" title="function: (boolean,boolean) ELStateUsingAArch32K(bits(2) el, boolean secure)"><ins>ELStateUsingAArch32K</ins></a><ins>(el, secure);
    assert known;
    return aarch32;</ins></p></div><div class="ps" psname="shared.functions.system.ELStateUsingAArch32K"><a id="shared.functions.system.ELStateUsingAArch32K" name="shared.functions.system.ELStateUsingAArch32K"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>system</ins><del>sysregisters</del>/<ins>ELStateUsingAArch32K</ins><del>SPSR</del></h3><p class="pseudocode"><ins>// ELStateUsingAArch32K()
// ======================
</ins><del>// SPSR[] - non-assignment form
// ============================
</del>
<ins>(boolean,boolean)</ins><del>bits(32)</del> <a id="impl-shared.ELStateUsingAArch32K.2" name="impl-shared.ELStateUsingAArch32K.2"></a><ins>ELStateUsingAArch32K(bits(2) el, boolean secure)
    // Returns (known, aarch32):
    //   'known'   is FALSE for EL0 if the current Exception level is not EL0 and EL1 is
    //             using AArch64, since it cannot determine the state of EL0; TRUE otherwise.
    //   'aarch32' is TRUE if the specified Exception level is using AArch32; FALSE otherwise.
    boolean aarch32;
    known = TRUE;
    if !</ins><del>SPSR[]
    bits(32) result;
    if</del><a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)"><ins>HaveAArch32EL</ins></a><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><ins>(el) then
        aarch32 = FALSE;                           // Exception level is using AArch64
    elsif</ins><del>() then
        case PSTATE.M of
            when</del> <a href="shared_pseudocode.html#impl-shared.HighestELUsingAArch32.0" title="function: boolean HighestELUsingAArch32()"><ins>HighestELUsingAArch32</ins></a><a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'"><del>M32_FIQ</del></a><ins>() then
        aarch32 = TRUE;                            // All levels are using AArch32
    else
        aarch32_below_el3 =</ins><del>result = SPSR_fiq;
            when</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'"><del>M32_IRQ</del></a><ins>(</ins><del>result = SPSR_irq;
            when</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'"><del>M32_Svc</del></a><ins>) &amp;&amp; SCR_EL3.RW == '0';

        aarch32_at_el1 = (aarch32_below_el3 || (</ins><del>result = SPSR_svc;
            when</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><del>M32_Monitor</del></a><ins>(</ins><del>result = SPSR_mon;
            when</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'"><del>M32_Abort</del></a><ins>) &amp;&amp;
                         ((</ins><del>result = SPSR_abt;
            when</del><a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()"><ins>HaveSecureEL2Ext</ins></a><a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'"><del>M32_Hyp</del></a><ins>() &amp;&amp; SCR_EL3.EEL2 == '1') || !secure) &amp;&amp; HCR_EL2.RW == '0' &amp;&amp;
                         !(HCR_EL2.E2H == '1' &amp;&amp; HCR_EL2.TGE == '1' &amp;&amp;</ins><del>result = SPSR_hyp;
            when</del> <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><ins>HaveVirtHostExt</ins></a><a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'"><del>M32_Undef</del></a><ins>())));
        if el ==</ins><del>result = SPSR_und;
            otherwise</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><del>Unreachable</del></a> <ins>&amp;&amp; !aarch32_at_el1 then       // Only know if EL0 using AArch32 from PSTATE
            if PSTATE.EL ==</ins><del>();
    else
        case PSTATE.EL of
            when</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a> <ins>then
                aarch32 = PSTATE.nRW == '1';       // EL0 controlled by PSTATE
            else
                known = FALSE;                     // EL0 state is UNKNOWN
        else
            aarch32 = (aarch32_below_el3 &amp;&amp; el !=</ins><del>result = SPSR_EL1;
            when</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>          result = SPSR_EL2;
            when </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a><ins>) || (aarch32_at_el1 &amp;&amp; el IN {</ins><del>result = SPSR_EL3;
            otherwise</del><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><del>Unreachable</del></a><del>();

    return result;

// SPSR[] - assignment form
// ========================

</del><a id="impl-shared.SPSR.write.0" name="impl-shared.SPSR.write.0"></a><del>SPSR[] = bits(32) value
    if </del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>() then
        case PSTATE.M of
            when </del><a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'"><del>M32_FIQ</del></a><del>      SPSR_fiq = value;
            when </del><a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'"><del>M32_IRQ</del></a><del>      SPSR_irq = value;
            when </del><a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'"><del>M32_Svc</del></a><del>      SPSR_svc = value;
            when </del><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><del>M32_Monitor</del></a><del>  SPSR_mon = value;
            when </del><a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'"><del>M32_Abort</del></a><del>    SPSR_abt = value;
            when </del><a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'"><del>M32_Hyp</del></a><del>      SPSR_hyp = value;
            when </del><a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'"><del>M32_Undef</del></a><del>    SPSR_und = value;
            otherwise         </del><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><del>Unreachable</del></a><del>();
    else
        case PSTATE.EL of
            when </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a><ins>,</ins><del>SPSR_EL1 = value;
            when</del><del>          SPSR_EL2 = value;
            when </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>          SPSR_EL3 = value;
            otherwise         </del><a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()"><del>Unreachable</del></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>});
    if !known then aarch32 = boolean UNKNOWN;
    return (known, aarch32);</ins><del>();

    return;</del></p></div><div class="ps" psname="shared.functions.system.ELUsingAArch32"><a id="shared.functions.system.ELUsingAArch32" name="shared.functions.system.ELUsingAArch32"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>ELUsingAArch32</ins><del>AllocationTagAccessIsEnabled</del></h3><p class="pseudocode"><ins>// ELUsingAArch32()
// ================
</ins><del>// AllocationTagAccessIsEnabled()
// ==============================
// Check whether access to Allocation Tags is enabled.
</del>
boolean <a id="impl-shared.ELUsingAArch32.1" name="impl-shared.ELUsingAArch32.1"></a><ins>ELUsingAArch32(bits(2) el)
    return</ins><del>AllocationTagAccessIsEnabled()
    if SCR_EL3.ATA == '0' &amp;&amp; PSTATE.EL IN {</del> <a href="shared_pseudocode.html#impl-shared.ELStateUsingAArch32.2" title="function: boolean ELStateUsingAArch32(bits(2) el, boolean secure)"><ins>ELStateUsingAArch32</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>(el,</ins><del>,</del> <del>, </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>} then
        return FALSE;
    elsif HCR_EL2.ATA == '0' &amp;&amp; HCR_EL2.&lt;E2H,TGE> != '11' &amp;&amp; PSTATE.EL IN {</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>, </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>} then
        return FALSE;
    elsif SCTLR_EL3.ATA == '0' &amp;&amp; PSTATE.EL == </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del> then
        return FALSE;
    elsif SCTLR_EL2.ATA == '0' &amp;&amp; PSTATE.EL == </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del> then
        return FALSE;
    elsif SCTLR_EL1.ATA == '0' &amp;&amp; PSTATE.EL == </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del> then
        return FALSE;
    elsif SCTLR_EL2.ATA0 == '0' &amp;&amp; HCR_EL2.&lt;E2H,TGE> == '11' &amp;&amp; PSTATE.EL == </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del> then
        return FALSE;
    elsif SCTLR_EL1.ATA0 == '0' &amp;&amp; HCR_EL2.&lt;E2H,TGE> != '11' &amp;&amp; PSTATE.EL == </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><a href="shared_pseudocode.html#impl-shared.IsSecureBelowEL3.0" title="function: boolean IsSecureBelowEL3()"><ins>IsSecureBelowEL3</ins></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><ins>());</ins><del>then
        return FALSE;
    else
        return TRUE;</del></p></div><div class="ps" psname="shared.functions.system.ELUsingAArch32K"><a id="shared.functions.system.ELUsingAArch32K" name="shared.functions.system.ELUsingAArch32K"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>ELUsingAArch32K</ins><del>ArchVersion</del></h3><p class="pseudocode"><ins>// ELUsingAArch32K()
// =================

(boolean,boolean)</ins><del>enumeration</del> <a id="impl-shared.ELUsingAArch32K.1" name="impl-shared.ELUsingAArch32K.1"></a><ins>ELUsingAArch32K(bits(2) el)
    return</ins><del>ArchVersion {</del> <a href="shared_pseudocode.html#impl-shared.ELStateUsingAArch32K.2" title="function: (boolean,boolean) ELStateUsingAArch32K(bits(2) el, boolean secure)"><ins>ELStateUsingAArch32K</ins></a><ins>(el,</ins><del>ARMv8p0
    ,</del> <del>ARMv8p1
    , </del><a id="ARMv8p2" name="ARMv8p2"></a><del>ARMv8p2
    , </del><a id="ARMv8p3" name="ARMv8p3"></a><del>ARMv8p3
    , </del><a id="ARMv8p4" name="ARMv8p4"></a><del>ARMv8p4
    , </del><a id="ARMv8p5" name="ARMv8p5"></a><a href="shared_pseudocode.html#impl-shared.IsSecureBelowEL3.0" title="function: boolean IsSecureBelowEL3()"><ins>IsSecureBelowEL3</ins></a><ins>());</ins><del>ARMv8p5
};</del></p></div><div class="ps" psname="shared.functions.system.EndOfInstruction"><a id="shared.functions.system.EndOfInstruction" name="shared.functions.system.EndOfInstruction"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>EndOfInstruction</ins><del>BranchTargetCheck</del></h3><p class="pseudocode"><ins>// Terminate processing of the current instruction.</ins><del>// BranchTargetCheck()
// ===================
// This function is executed checks if the current instruction is a valid target for a branch
// taken into, or inside, a guarded page. It is executed on every cycle once the current
// instruction has been decoded and the values of InGuardedPage and BTypeCompatible have been
// determined for the current instruction.</del>
<a id="impl-shared.EndOfInstruction.0" name="impl-shared.EndOfInstruction.0"></a><ins>EndOfInstruction();</ins><del>BranchTargetCheck()

    assert</del><a href="shared_pseudocode.html#impl-shared.HaveBTIExt.0" title="function: boolean HaveBTIExt()"><del>HaveBTIExt</del></a><del>() &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>();

    // The branch target check considers two state variables:
    // * InGuardedPage, which is evaluated during instruction fetch.
    // * BTypeCompatible, which is evaluated during instruction decode.
    if InGuardedPage &amp;&amp; PSTATE.BTYPE != '00' &amp;&amp; !BTypeCompatible &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()"><del>Halted</del></a><del>() then
        bits(64) pc = </del><a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()"><del>ThisInstrAddr</del></a><del>();
        </del><a href="shared_pseudocode.html#AArch64.BranchTargetException.1" title="function: AArch64.BranchTargetException(bits(52) vaddress)"><del>AArch64.BranchTargetException</del></a><del>(pc&lt;51:0>);

    boolean branch_instr = </del><a href="shared_pseudocode.html#AArch64.ExecutingBROrBLROrRetInstr.0" title="function: boolean AArch64.ExecutingBROrBLROrRetInstr()"><del>AArch64.ExecutingBROrBLROrRetInstr</del></a><del>();
    boolean bti_instr    = </del><a href="shared_pseudocode.html#AArch64.ExecutingBTIInstr.0" title="function: boolean AArch64.ExecutingBTIInstr()"><del>AArch64.ExecutingBTIInstr</del></a><del>();

    // PSTATE.BTYPE defaults to 00 for instructions that don't explictly set BTYPE.
    if !(branch_instr || bti_instr) then
        BTypeNext = '00';</del></p></div><div class="ps" psname="shared.functions.system.EnterLowPowerState"><a id="shared.functions.system.EnterLowPowerState" name="shared.functions.system.EnterLowPowerState"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>EnterLowPowerState</ins><del>ChooseNonExcludedTag</del></h3><p class="pseudocode"><ins>// PE enters a low-power state</ins><del>// ChooseNonExcludedTag()
// ======================
// Return a tag derived from the start and the offset values, excluding
// any tags in the given mask.

bits(4)</del>
<a id="impl-shared.EnterLowPowerState.0" name="impl-shared.EnterLowPowerState.0"></a><ins>EnterLowPowerState();</ins><del>ChooseNonExcludedTag(bits(4) tag, bits(4) offset, bits(16) exclude)

    if exclude ==</del><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a><del>(16) then
        return tag;

    while offset != '0000' do
        offset = offset - '0001';
        tag = tag + '0001';
        while exclude&lt;</del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(tag)> == '1' do
            tag = tag + '0001';

    return tag;</del></p></div><div class="ps" psname="shared.functions.system.EventRegister"><a id="shared.functions.system.EventRegister" name="shared.functions.system.EventRegister"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>EventRegister</ins><del>ClearEventRegister</del></h3><p class="pseudocode"><ins>bits(1) EventRegister;</ins><del>// ClearEventRegister()
// ====================
// Clear the Event Register of this PE</del><a id="impl-shared.ClearEventRegister.0" name="impl-shared.ClearEventRegister.0"></a><del>ClearEventRegister()
    EventRegister = '0';
    return;</del></p></div><div class="ps" psname="shared.functions.system.GetPSRFromPSTATE"><a id="shared.functions.system.GetPSRFromPSTATE" name="shared.functions.system.GetPSRFromPSTATE"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>GetPSRFromPSTATE</ins><del>ClearPendingPhysicalSError</del></h3><p class="pseudocode"><ins>// GetPSRFromPSTATE()
// ==================
// Return a PSR value which represents the current PSTATE

bits(32)</ins><del>// Clear a pending physical SError interrupt</del> <a id="impl-shared.GetPSRFromPSTATE.0" name="impl-shared.GetPSRFromPSTATE.0"></a><ins>GetPSRFromPSTATE()
    bits(32) spsr =</ins><del>ClearPendingPhysicalSError();</del> <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><ins>Zeros</ins></a><ins>();
    spsr&lt;31:28> = PSTATE.&lt;N,Z,C,V>;
    if </ins><a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()"><ins>HavePANExt</ins></a><ins>() then spsr&lt;22> = PSTATE.PAN;
    spsr&lt;20>    = PSTATE.IL;
    if PSTATE.nRW == '1' then // AArch32 state
        spsr&lt;27>    = PSTATE.Q;
        spsr&lt;26:25> = PSTATE.IT&lt;1:0>;
        if </ins><a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()"><ins>HaveSSBSExt</ins></a><ins>() then spsr&lt;23> = PSTATE.SSBS;
        if </ins><a href="shared_pseudocode.html#impl-shared.HaveDITExt.0" title="function: boolean HaveDITExt()"><ins>HaveDITExt</ins></a><ins>() then spsr&lt;21> = PSTATE.DIT;
        spsr&lt;19:16> = PSTATE.GE;
        spsr&lt;15:10> = PSTATE.IT&lt;7:2>;
        spsr&lt;9>     = PSTATE.E;
        spsr&lt;8:6>   = PSTATE.&lt;A,I,F>;                   // No PSTATE.D in AArch32 state
        spsr&lt;5>     = PSTATE.T;
        assert PSTATE.M&lt;4> == PSTATE.nRW;               // bit [4] is the discriminator
        spsr&lt;4:0>   = PSTATE.M;
    else // AArch64 state
        if </ins><a href="shared_pseudocode.html#impl-shared.HaveDITExt.0" title="function: boolean HaveDITExt()"><ins>HaveDITExt</ins></a><ins>() then spsr&lt;24> = PSTATE.DIT;
        if </ins><a href="shared_pseudocode.html#impl-shared.HaveUAOExt.0" title="function: boolean HaveUAOExt()"><ins>HaveUAOExt</ins></a><ins>() then spsr&lt;23> = PSTATE.UAO;
        spsr&lt;21>    = PSTATE.SS;
        if </ins><a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()"><ins>HaveSSBSExt</ins></a><ins>() then spsr&lt;12> = PSTATE.SSBS;
        if </ins><a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()"><ins>HaveMTEExt</ins></a><ins>() then spsr&lt;25> = PSTATE.TCO;
        if </ins><a href="shared_pseudocode.html#impl-shared.HaveBTIExt.0" title="function: boolean HaveBTIExt()"><ins>HaveBTIExt</ins></a><ins>() then spsr&lt;11:10> = PSTATE.BTYPE;
        spsr&lt;9:6>   = PSTATE.&lt;D,A,I,F>;
        spsr&lt;4>     = PSTATE.nRW;
        spsr&lt;3:2>   = PSTATE.EL;
        spsr&lt;0>     = PSTATE.SP;
    return spsr;</ins></p></div><div class="ps" psname="shared.functions.system.HasArchVersion"><a id="shared.functions.system.HasArchVersion" name="shared.functions.system.HasArchVersion"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>HasArchVersion</ins><del>ClearPendingVirtualSError</del></h3><p class="pseudocode"><ins>// HasArchVersion()
// ================
// Return TRUE if the implemented architecture includes the extensions defined in the specified
// architecture version.

boolean</ins><del>// Clear a pending virtual SError interrupt</del> <a id="impl-shared.HasArchVersion.1" name="impl-shared.HasArchVersion.1"></a><ins>HasArchVersion(</ins><del>ClearPendingVirtualSError();</del><a href="shared_pseudocode.html#ArchVersion" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ArchVersion</ins></a><ins> version)
    return version == </ins><a href="shared_pseudocode.html#ARMv8p0" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><ins>ARMv8p0</ins></a><ins> || boolean IMPLEMENTATION_DEFINED;</ins></p></div><div class="ps" psname="shared.functions.system.HaveAArch32EL"><a id="shared.functions.system.HaveAArch32EL" name="shared.functions.system.HaveAArch32EL"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>HaveAArch32EL</ins><del>ConditionHolds</del></h3><p class="pseudocode"><ins>// HaveAArch32EL()
// ===============
</ins><del>// ConditionHolds()
// ================

// Return TRUE iff COND currently holds
</del>
boolean <a id="impl-shared.HaveAArch32EL.1" name="impl-shared.HaveAArch32EL.1"></a><ins>HaveAArch32EL(bits(2) el)
    // Return TRUE if Exception level 'el' supports AArch32 in this implementation
    if !</ins><del>ConditionHolds(bits(4) cond)
    // Evaluate base condition.
    case cond&lt;3:1> of
        when '000' result = (PSTATE.Z == '1');                          // EQ or NE
        when '001' result = (PSTATE.C == '1');                          // CS or CC
        when '010' result = (PSTATE.N == '1');                          // MI or PL
        when '011' result = (PSTATE.V == '1');                          // VS or VC
        when '100' result = (PSTATE.C == '1' &amp;&amp; PSTATE.Z == '0');       // HI or LS
        when '101' result = (PSTATE.N == PSTATE.V);                     // GE or LT
        when '110' result = (PSTATE.N == PSTATE.V &amp;&amp; PSTATE.Z == '0');  // GT or LE
        when '111' result = TRUE;                                       // AL

    // Condition flag values in the set '111x' indicate always true
    // Otherwise, invert condition if necessary.
    if cond&lt;0> == '1' &amp;&amp; cond != '1111' then
        result = !result;

    return result;</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(el) then
        return FALSE;                    // The Exception level is not implemented
    elsif !</ins><a href="shared_pseudocode.html#impl-shared.HaveAnyAArch32.0" title="function: boolean HaveAnyAArch32()"><ins>HaveAnyAArch32</ins></a><ins>() then
        return FALSE;                    // No Exception level can use AArch32
    elsif </ins><a href="shared_pseudocode.html#impl-shared.HighestELUsingAArch32.0" title="function: boolean HighestELUsingAArch32()"><ins>HighestELUsingAArch32</ins></a><ins>() then
        return TRUE;                     // All Exception levels are using AArch32
    elsif el == </ins><a href="shared_pseudocode.html#impl-shared.HighestEL.0" title="function: bits(2) HighestEL()"><ins>HighestEL</ins></a><ins>() then
        return FALSE;                    // The highest Exception level is using AArch64
    elsif el == </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins> then
        return TRUE;                     // EL0 must support using AArch32 if any AArch32
    return boolean IMPLEMENTATION_DEFINED;</ins></p></div><div class="ps" psname="shared.functions.system.HaveAnyAArch32"><a id="shared.functions.system.HaveAnyAArch32" name="shared.functions.system.HaveAnyAArch32"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>HaveAnyAArch32</ins><del>ConsumptionOfSpeculativeDataBarrier</del></h3><p class="pseudocode"><ins>// HaveAnyAArch32()
// ================
// Return TRUE if AArch32 state is supported at any Exception level

boolean </ins><a id="impl-shared.HaveAnyAArch32.0" name="impl-shared.HaveAnyAArch32.0"></a><ins>HaveAnyAArch32()
    return boolean IMPLEMENTATION_DEFINED;</ins><del>ConsumptionOfSpeculativeDataBarrier();</del></p></div><div class="ps" psname="shared.functions.system.HaveAnyAArch64"><a id="shared.functions.system.HaveAnyAArch64" name="shared.functions.system.HaveAnyAArch64"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>HaveAnyAArch64</ins><del>CurrentInstrSet</del></h3><p class="pseudocode"><ins>// HaveAnyAArch64()
// ================
// Return TRUE if AArch64 state is supported at any Exception level
</ins><del>// CurrentInstrSet()
// =================
</del>
<ins>boolean</ins><del>InstrSet</del> <a id="impl-shared.HaveAnyAArch64.0" name="impl-shared.HaveAnyAArch64.0"></a><ins>HaveAnyAArch64()
    return !</ins><del>CurrentInstrSet()

    if</del><del>() then
        result = if PSTATE.T == '0' then </del><a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><del>InstrSet_A32</del></a><del> else </del><a href="shared_pseudocode.html#InstrSet_T32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><del>InstrSet_T32</del></a><del>;
        // PSTATE.J is RES0. Implementation of T32EE or Jazelle state not permitted.
    else
        result = </del><a href="shared_pseudocode.html#InstrSet_A64" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}"><del>InstrSet_A64</del></a><a href="shared_pseudocode.html#impl-shared.HighestELUsingAArch32.0" title="function: boolean HighestELUsingAArch32()"><ins>HighestELUsingAArch32</ins></a><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><ins>();</ins><del>;
    return result;</del></p></div><div class="ps" psname="shared.functions.system.HaveEL"><a id="shared.functions.system.HaveEL" name="shared.functions.system.HaveEL"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>HaveEL</ins><del>CurrentPL</del></h3><p class="pseudocode"><ins>// HaveEL()
// ========
// Return TRUE if Exception level 'el' is supported
</ins><del>// CurrentPL()
// ===========
</del>
<ins>boolean</ins><del>PrivilegeLevel</del> <a id="impl-shared.HaveEL.1" name="impl-shared.HaveEL.1"></a><ins>HaveEL(bits(2) el)
    if el IN {</ins><del>CurrentPL()
    return</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#impl-shared.PLOfEL.1" title="function: PrivilegeLevel PLOfEL(bits(2) el)"><del>PLOfEL</del></a><ins>,</ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins>} then
        return TRUE;                             // EL1 and EL0 must exist
    return boolean IMPLEMENTATION_DEFINED;</ins><del>(PSTATE.EL);</del></p></div><div class="ps" psname="shared.functions.system.HaveFP16Ext"><a id="shared.functions.system.HaveFP16Ext" name="shared.functions.system.HaveFP16Ext"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>HaveFP16Ext</ins><del>EL0</del></h3><p class="pseudocode"><ins>// HaveFP16Ext()
// =============
// Return TRUE if FP16 extension is supported

boolean</ins><del>constant bits(2)</del> <a id="impl-shared.HaveFP16Ext.0" name="impl-shared.HaveFP16Ext.0"></a><ins>HaveFP16Ext()
    return boolean IMPLEMENTATION_DEFINED;</ins><del>EL3 = '11';
constant bits(2)</del><a id="EL2" name="EL2"></a><del>EL2 = '10';
constant bits(2) </del><a id="EL1" name="EL1"></a><del>EL1 = '01';
constant bits(2) </del><a id="EL0" name="EL0"></a><del>EL0 = '00';</del></p></div><div class="ps" psname="shared.functions.system.HighestEL"><a id="shared.functions.system.HighestEL" name="shared.functions.system.HighestEL"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>HighestEL</ins><del>EL2Enabled</del></h3><p class="pseudocode"><ins>// HighestEL()
// ===========
// Returns the highest implemented Exception level.
</ins><del>// EL2Enabled()
// ============
// Returns TRUE if EL2 is present and executing in either non-Secure state when Secure EL2 is not implemented,
// or in Secure state when Secure EL2 is implemented, FALSE otherwise
</del>
<ins>bits(2)</ins><del>boolean</del> <a id="impl-shared.HighestEL.0" name="impl-shared.HighestEL.0"></a><ins>HighestEL()
    if</ins><del>EL2Enabled()
    return</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()"><del>IsSecureEL2Enabled</del></a><ins>(</ins><del>() || (</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) then
        return </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>;
    elsif </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a><ins>) then
        return</ins><del>) &amp;&amp; !</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><ins>;
    else
        return </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>;</ins><del>());</del></p></div><div class="ps" psname="shared.functions.system.HighestELUsingAArch32"><a id="shared.functions.system.HighestELUsingAArch32" name="shared.functions.system.HighestELUsingAArch32"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>HighestELUsingAArch32</ins><del>ELFromM32</del></h3><p class="pseudocode"><ins>// HighestELUsingAArch32()
// =======================
// Return TRUE if configured to boot into AArch32 operation
</ins><del>// ELFromM32()
// ===========
</del>
<ins>boolean</ins><del>(boolean,bits(2))</del> <a id="impl-shared.HighestELUsingAArch32.0" name="impl-shared.HighestELUsingAArch32.0"></a><ins>HighestELUsingAArch32()
    if !</ins><del>ELFromM32(bits(5) mode)
    // Convert an AArch32 mode encoding to an Exception level.
    // Returns (valid,EL):
    //   'valid' is TRUE if 'mode&lt;4:0>' encodes a mode that is both valid for this implementation
    //           and the current value of SCR.NS/SCR_EL3.NS.
    //   'EL'    is the Exception level decoded from 'mode'.
    bits(2) el;
    boolean valid = !</del><del>(mode);  // Check for modes that are not valid for this implementation
    case mode of
        when </del><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><del>M32_Monitor</del></a><del>
            el = </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>;
        when </del><a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'"><del>M32_Hyp</del></a><del>
            el = </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>;
            valid = valid &amp;&amp; (!</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) || </del><a href="shared_pseudocode.html#impl-shared.SCR_GEN.read.0" title="accessor: SCRType SCR_GEN[]"><del>SCR_GEN</del></a><del>[].NS == '1');
        when </del><a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'"><del>M32_FIQ</del></a><del>, </del><a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'"><del>M32_IRQ</del></a><del>, </del><a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'"><del>M32_Svc</del></a><del>, </del><a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'"><del>M32_Abort</del></a><del>, </del><a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'"><del>M32_Undef</del></a><del>, </del><a href="shared_pseudocode.html#M32_System" title="constant bits(5) M32_System = '11111'"><del>M32_System</del></a><del>
            // If EL3 is implemented and using AArch32, then these modes are EL3 modes in Secure
            // state, and EL1 modes in Non-secure state. If EL3 is not implemented or is using
            // AArch64, then these modes are EL1 modes.
            el = (if </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.HighestELUsingAArch32.0" title="function: boolean HighestELUsingAArch32()"><del>HighestELUsingAArch32</del></a><del>() &amp;&amp; SCR.NS == '0' then </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del> else </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>);
        when </del><a href="shared_pseudocode.html#M32_User" title="constant bits(5) M32_User = '10000'"><del>M32_User</del></a><del>
            el = </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><a href="shared_pseudocode.html#impl-shared.HaveAnyAArch32.0" title="function: boolean HaveAnyAArch32()"><ins>HaveAnyAArch32</ins></a><a href="shared_pseudocode.html#impl-aarch32.BadMode.1" title="function: boolean BadMode(bits(5) mode)"><del>BadMode</del></a><ins>() then return FALSE;
    return boolean IMPLEMENTATION_DEFINED;       // e.g. CFG32SIGNAL == HIGH</ins><del>;
        otherwise
            valid = FALSE;           // Passed an illegal mode value
    if !valid then el = bits(2) UNKNOWN;
    return (valid, el);</del></p></div><div class="ps" psname="shared.functions.system.Hint_Yield"><a id="shared.functions.system.Hint_Yield" name="shared.functions.system.Hint_Yield"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>Hint_Yield</ins><del>ELFromSPSR</del></h3><p class="pseudocode"><del>// ELFromSPSR()
// ============

// Convert an SPSR value encoding to an Exception level.
// Returns (valid,EL):
//   'valid' is TRUE if 'spsr&lt;4:0>' encodes a valid mode for the current state.
//   'EL'    is the Exception level decoded from 'spsr'.

(boolean,bits(2)) </del><a id="impl-shared.Hint_Yield.0" name="impl-shared.Hint_Yield.0"></a><del>ELFromSPSR(bits(32) spsr)
    if spsr&lt;4> == '0' then                      // AArch64 state
        el = spsr&lt;3:2>;
        if </del><a href="shared_pseudocode.html#impl-shared.HighestELUsingAArch32.0" title="function: boolean HighestELUsingAArch32()"><del>HighestELUsingAArch32</del></a><del>() then         // No AArch64 support
            valid = FALSE;
        elsif !</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(el) then                  // Exception level not implemented
            valid = FALSE;
        elsif spsr&lt;1> == '1' then               // M[1] must be 0
            valid = FALSE;
        elsif el == </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del> &amp;&amp; spsr&lt;0> == '1' then  // for EL0, M[0] must be 0
            valid = FALSE;
        elsif el == </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del> &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()"><del>IsSecureEL2Enabled</del></a><del>() &amp;&amp; SCR_EL3.NS == '0' then
            valid = FALSE;                      // Unless Secure EL2 is enabled, EL2 only valid in Non-secure state
        else
            valid = TRUE;
    elsif !</del><a href="shared_pseudocode.html#impl-shared.HaveAnyAArch32.0" title="function: boolean HaveAnyAArch32()"><del>HaveAnyAArch32</del></a><del>() then                // AArch32 not supported
        valid = FALSE;
    else                                                // AArch32 state
        (valid, el) = </del><a href="shared_pseudocode.html#impl-shared.ELFromM32.1" title="function: (boolean,bits(2)) ELFromM32(bits(5) mode)"><del>ELFromM32</del></a><ins>Hint_Yield();</ins><del>(spsr&lt;4:0>);
    if !valid then el = bits(2) UNKNOWN;
    return (valid,el);</del></p></div><div class="ps" psname="shared.functions.system.IllegalExceptionReturn"><a id="shared.functions.system.IllegalExceptionReturn" name="shared.functions.system.IllegalExceptionReturn"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>IllegalExceptionReturn</ins><del>ELIsInHost</del></h3><p class="pseudocode"><ins>// IllegalExceptionReturn()
// ========================
</ins><del>// ELIsInHost()
// ============
</del>
boolean <a id="impl-shared.IllegalExceptionReturn.1" name="impl-shared.IllegalExceptionReturn.1"></a><ins>IllegalExceptionReturn(bits(32) spsr)

    // Check for illegal return:
    //   * To an unimplemented Exception level.
    //   * To EL2 in Secure state, when SecureEL2 is not enabled.
    //   * To EL0 using AArch64 state, with SPSR.M[0]==1.
    //   * To AArch64 state with SPSR.M[1]==1.
    //   * To AArch32 state with an illegal value of SPSR.M.
    (valid, target) =</ins><del>ELIsInHost(bits(2) el)
    return ((</del> <a href="shared_pseudocode.html#impl-shared.ELFromSPSR.1" title="function: (boolean,bits(2)) ELFromSPSR(bits(32) spsr)"><ins>ELFromSPSR</ins></a><a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()"><del>IsSecureEL2Enabled</del></a><ins>(spsr);
    if !valid then return TRUE;

    // Check for return to higher Exception level
    if</ins><del>() || !</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#impl-shared.IsSecureBelowEL3.0" title="function: boolean IsSecureBelowEL3()"><del>IsSecureBelowEL3</del></a><ins>(target) ></ins><del>()) &amp;&amp;</del> <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><del>HaveVirtHostExt</del></a><ins>(PSTATE.EL) then return TRUE;

    spsr_mode_is_aarch32 = (spsr&lt;4> == '1');

    // Check for illegal return:
    //   * To EL1, EL2 or EL3 with register width specified in the SPSR different from the
    //     Execution state used in the Exception level being returned to, as determined by
    //     the SCR_EL3.RW or HCR_EL2.RW bits, or as configured from reset.
    //   * To EL0 using AArch64 state when EL1 is using AArch32 state as determined by the
    //     SCR_EL3.RW or HCR_EL2.RW bits or as configured from reset.
    //   * To AArch64 state from AArch32 state (should be caught by above)
    (known, target_el_is_aarch32) =</ins><del>() &amp;&amp; !</del> <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32K.1" title="function: (boolean,boolean) ELUsingAArch32K(bits(2) el)"><ins>ELUsingAArch32K</ins></a><ins>(target);
    assert known || (target == </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins> &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>));
    if known &amp;&amp; spsr_mode_is_aarch32 != target_el_is_aarch32 then return TRUE;

    // Check for illegal return from AArch32 to AArch64
    if</ins><del>) &amp;&amp;
            HCR_EL2.E2H == '1' &amp;&amp; (el ==</del> <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>() &amp;&amp; !spsr_mode_is_aarch32 then return TRUE;

    // Check for illegal return to EL1 when HCR.TGE is set and when either of
    // * SecureEL2 is enabled.
    // * SecureEL2 is not enabled and EL1 is in Non-secure state.
    if </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a><ins>) &amp;&amp; target ==</ins><del>|| (el ==</del> <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins> &amp;&amp; HCR_EL2.TGE == '1' then
        if (!</ins><a href="shared_pseudocode.html#impl-shared.IsSecureBelowEL3.0" title="function: boolean IsSecureBelowEL3()"><ins>IsSecureBelowEL3</ins></a><ins>() || </ins><a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()"><ins>IsSecureEL2Enabled</ins></a><ins>()) then return TRUE;
    return FALSE;</ins><del>&amp;&amp; HCR_EL2.TGE == '1')));</del></p></div><div class="ps" psname="shared.functions.system.InstrSet"><a id="shared.functions.system.InstrSet" name="shared.functions.system.InstrSet"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>InstrSet</ins><del>ELStateUsingAArch32</del></h3><p class="pseudocode"><ins>enumeration</ins><del>// ELStateUsingAArch32()
// =====================

boolean</del> <a id="InstrSet" name="InstrSet"></a><ins>InstrSet {</ins><del>ELStateUsingAArch32(bits(2) el, boolean secure)
    // See ELStateUsingAArch32K() for description. Must only be called in circumstances where
    // result is valid (typically, that means 'el IN {EL1,EL2,EL3}').
    (known, aarch32) =</del><a id="InstrSet_A64" name="InstrSet_A64"></a><ins>InstrSet_A64, </ins><a id="InstrSet_A32" name="InstrSet_A32"></a><ins>InstrSet_A32, </ins><a id="InstrSet_T32" name="InstrSet_T32"></a><ins>InstrSet_T32};</ins><del>(el, secure);
    assert known;
    return aarch32;</del></p></div><div class="ps" psname="shared.functions.system.InstructionSynchronizationBarrier"><a id="shared.functions.system.InstructionSynchronizationBarrier" name="shared.functions.system.InstructionSynchronizationBarrier"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>InstructionSynchronizationBarrier</ins><del>ELStateUsingAArch32K</del></h3><p class="pseudocode"><del>// ELStateUsingAArch32K()
// ======================

(boolean,boolean) </del><a id="impl-shared.InstructionSynchronizationBarrier.0" name="impl-shared.InstructionSynchronizationBarrier.0"></a><del>ELStateUsingAArch32K(bits(2) el, boolean secure)
    // Returns (known, aarch32):
    //   'known'   is FALSE for EL0 if the current Exception level is not EL0 and EL1 is
    //             using AArch64, since it cannot determine the state of EL0; TRUE otherwise.
    //   'aarch32' is TRUE if the specified Exception level is using AArch32; FALSE otherwise.
    boolean aarch32;
    known = TRUE;
    if !</del><a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)"><del>HaveAArch32EL</del></a><del>(el) then
        aarch32 = FALSE;                           // Exception level is using AArch64
    elsif </del><a href="shared_pseudocode.html#impl-shared.HighestELUsingAArch32.0" title="function: boolean HighestELUsingAArch32()"><del>HighestELUsingAArch32</del></a><del>() then
        aarch32 = TRUE;                            // All levels are using AArch32
    else
        aarch32_below_el3 = </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; SCR_EL3.RW == '0';

        aarch32_at_el1 = (aarch32_below_el3 || (</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) &amp;&amp;
                         ((</del><a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()"><del>HaveSecureEL2Ext</del></a><del>() &amp;&amp; SCR_EL3.EEL2 == '1') || !secure) &amp;&amp; HCR_EL2.RW == '0' &amp;&amp;
                         !(HCR_EL2.E2H == '1' &amp;&amp; HCR_EL2.TGE == '1' &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><del>HaveVirtHostExt</del></a><del>())));
        if el == </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del> &amp;&amp; !aarch32_at_el1 then       // Only know if EL0 using AArch32 from PSTATE
            if PSTATE.EL == </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del> then
                aarch32 = PSTATE.nRW == '1';       // EL0 controlled by PSTATE
            else
                known = FALSE;                     // EL0 state is UNKNOWN
        else
            aarch32 = (aarch32_below_el3 &amp;&amp; el != </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) || (aarch32_at_el1 &amp;&amp; el IN {</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>,</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>InstructionSynchronizationBarrier();</ins><del>});
    if !known then aarch32 = boolean UNKNOWN;
    return (known, aarch32);</del></p></div><div class="ps" psname="shared.functions.system.InterruptPending"><a id="shared.functions.system.InterruptPending" name="shared.functions.system.InterruptPending"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>InterruptPending</ins><del>ELUsingAArch32</del></h3><p class="pseudocode"><ins>// InterruptPending()
// ==================
// Return TRUE if there are any pending physical or virtual interrupts, and FALSE otherwise
</ins><del>// ELUsingAArch32()
// ================
</del>
boolean <a id="impl-shared.InterruptPending.0" name="impl-shared.InterruptPending.0"></a><ins>InterruptPending()
</ins><del>ELUsingAArch32(bits(2) el)
</del>    return <a href="shared_pseudocode.html#impl-shared.IsPhysicalSErrorPending.0" title="function: boolean IsPhysicalSErrorPending()"><ins>IsPhysicalSErrorPending</ins></a><a href="shared_pseudocode.html#impl-shared.ELStateUsingAArch32.2" title="function: boolean ELStateUsingAArch32(bits(2) el, boolean secure)"><del>ELStateUsingAArch32</del></a><ins>() ||</ins><del>(el,</del> <a href="shared_pseudocode.html#impl-shared.IsVirtualSErrorPending.0" title="function: boolean IsVirtualSErrorPending()"><ins>IsVirtualSErrorPending</ins></a><a href="shared_pseudocode.html#impl-shared.IsSecureBelowEL3.0" title="function: boolean IsSecureBelowEL3()"><del>IsSecureBelowEL3</del></a><ins>();</ins><del>());</del></p></div><div class="ps" psname="shared.functions.system.IsEventRegisterSet"><a id="shared.functions.system.IsEventRegisterSet" name="shared.functions.system.IsEventRegisterSet"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>IsEventRegisterSet</ins><del>ELUsingAArch32K</del></h3><p class="pseudocode"><ins>// IsEventRegisterSet()
// ====================
// Return TRUE if the Event Register of this PE is set, and FALSE otherwise
</ins><del>// ELUsingAArch32K()
// =================
</del>
<ins>boolean</ins><del>(boolean,boolean)</del> <a id="impl-shared.IsEventRegisterSet.0" name="impl-shared.IsEventRegisterSet.0"></a><ins>IsEventRegisterSet()
    return EventRegister == '1';</ins><del>ELUsingAArch32K(bits(2) el)
    return</del><a href="shared_pseudocode.html#impl-shared.ELStateUsingAArch32K.2" title="function: (boolean,boolean) ELStateUsingAArch32K(bits(2) el, boolean secure)"><del>ELStateUsingAArch32K</del></a><del>(el, </del><a href="shared_pseudocode.html#impl-shared.IsSecureBelowEL3.0" title="function: boolean IsSecureBelowEL3()"><del>IsSecureBelowEL3</del></a><del>());</del></p></div><div class="ps" psname="shared.functions.system.IsHighestEL"><a id="shared.functions.system.IsHighestEL" name="shared.functions.system.IsHighestEL"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>IsHighestEL</ins><del>EndOfInstruction</del></h3><p class="pseudocode"><ins>// IsHighestEL()
// =============
// Returns TRUE if given exception level is the highest exception level implemented

boolean</ins><del>// Terminate processing of the current instruction.</del> <a id="impl-shared.IsHighestEL.1" name="impl-shared.IsHighestEL.1"></a><ins>IsHighestEL(bits(2) el)
    return</ins><del>EndOfInstruction();</del> <a href="shared_pseudocode.html#impl-shared.HighestEL.0" title="function: bits(2) HighestEL()"><ins>HighestEL</ins></a><ins>() == el;</ins></p></div><div class="ps" psname="shared.functions.system.IsInHost"><a id="shared.functions.system.IsInHost" name="shared.functions.system.IsInHost"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>IsInHost</ins><del>EnterLowPowerState</del></h3><p class="pseudocode"><ins>// IsInHost()
// ==========

boolean</ins><del>// PE enters a low-power state</del> <a id="impl-shared.IsInHost.0" name="impl-shared.IsInHost.0"></a><ins>IsInHost()
    return</ins><del>EnterLowPowerState();</del> <a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)"><ins>ELIsInHost</ins></a><ins>(PSTATE.EL);</ins></p></div><div class="ps" psname="shared.functions.system.IsPhysicalSErrorPending"><a id="shared.functions.system.IsPhysicalSErrorPending" name="shared.functions.system.IsPhysicalSErrorPending"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>IsPhysicalSErrorPending</ins><del>EventRegister</del></h3><p class="pseudocode"><ins>// Return TRUE if a physical SError interrupt is pending
boolean</ins><del>bits(1) EventRegister;</del> <a id="impl-shared.IsPhysicalSErrorPending.0" name="impl-shared.IsPhysicalSErrorPending.0"></a><ins>IsPhysicalSErrorPending();</ins></p></div><div class="ps" psname="shared.functions.system.IsSecure"><a id="shared.functions.system.IsSecure" name="shared.functions.system.IsSecure"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>IsSecure</ins><del>GetPSRFromPSTATE</del></h3><p class="pseudocode"><ins>// IsSecure()
// ==========
</ins><del>// GetPSRFromPSTATE()
// ==================
// Return a PSR value which represents the current PSTATE
</del>
<ins>boolean</ins><del>bits(32)</del> <a id="impl-shared.IsSecure.0" name="impl-shared.IsSecure.0"></a><ins>IsSecure()
    // Return TRUE if current Exception level is in Secure state.
    if</ins><del>GetPSRFromPSTATE()
    bits(32) spsr =</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()"><del>Zeros</del></a><ins>(</ins><del>();
    spsr&lt;31:28> = PSTATE.&lt;N,Z,C,V>;
    if</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-shared.HaveDITExt.0" title="function: boolean HaveDITExt()"><del>HaveDITExt</del></a><ins>) &amp;&amp; !</ins><del>() then spsr&lt;24> = PSTATE.DIT;
    if</del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()"><del>HavePANExt</del></a><ins>() &amp;&amp; PSTATE.EL ==</ins><del>() then spsr&lt;22> = PSTATE.PAN;
    spsr&lt;21>    = PSTATE.SS;
    spsr&lt;20>    = PSTATE.IL;
    if PSTATE.nRW == '1' then // AArch32 state
        spsr&lt;27>    = PSTATE.Q;
        spsr&lt;26:25> = PSTATE.IT&lt;1:0>;
        if</del> <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()"><del>HaveSSBSExt</del></a> <ins>then
        return TRUE;
    elsif</ins><del>() then spsr&lt;23> = PSTATE.SSBS;
        spsr&lt;19:16> = PSTATE.GE;
        spsr&lt;15:10> = PSTATE.IT&lt;7:2>;
        spsr&lt;9>     = PSTATE.E;
        spsr&lt;8:6>   = PSTATE.&lt;A,I,F>;                   // No PSTATE.D in AArch32 state
        spsr&lt;5>     = PSTATE.T;
        assert PSTATE.M&lt;4> == PSTATE.nRW;               // bit [4] is the discriminator
        spsr&lt;4:0>   = PSTATE.M;
    else // AArch64 state
        if</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-shared.HaveUAOExt.0" title="function: boolean HaveUAOExt()"><del>HaveUAOExt</del></a><ins>(</ins><del>() then spsr&lt;23> = PSTATE.UAO;
        if</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()"><del>HaveSSBSExt</del></a><ins>) &amp;&amp;</ins><del>() then spsr&lt;12> = PSTATE.SSBS;
        if</del> <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()"><del>HaveMTEExt</del></a><ins>() &amp;&amp; PSTATE.M ==</ins><del>() then spsr&lt;25> = PSTATE.TCO;
        if</del> <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><ins>M32_Monitor</ins></a><a href="shared_pseudocode.html#impl-shared.HaveBTIExt.0" title="function: boolean HaveBTIExt()"><del>HaveBTIExt</del></a><ins> then
        return TRUE;
    return </ins><a href="shared_pseudocode.html#impl-shared.IsSecureBelowEL3.0" title="function: boolean IsSecureBelowEL3()"><ins>IsSecureBelowEL3</ins></a><ins>();</ins><del>() then spsr&lt;11:10> = PSTATE.BTYPE;
        spsr&lt;9:6>   = PSTATE.&lt;D,A,I,F>;
        spsr&lt;4>     = PSTATE.nRW;
        spsr&lt;3:2>   = PSTATE.EL;
        spsr&lt;0>     = PSTATE.SP;
    return spsr;</del></p></div><div class="ps" psname="shared.functions.system.IsSecureBelowEL3"><a id="shared.functions.system.IsSecureBelowEL3" name="shared.functions.system.IsSecureBelowEL3"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>IsSecureBelowEL3</ins><del>HasArchVersion</del></h3><p class="pseudocode"><ins>// IsSecureBelowEL3()
// ==================

// Return TRUE if an Exception level below EL3 is in Secure state
// or would be following an exception return to that level.
//
// Differs from IsSecure in that it ignores the current EL or Mode
// in considering security state.
// That is, if at AArch64 EL3 or in AArch32 Monitor mode, whether an
// exception return would pass to Secure or Non-secure state.
</ins><del>// HasArchVersion()
// ================
// Return TRUE if the implemented architecture includes the extensions defined in the specified
// architecture version.
</del>
boolean <a id="impl-shared.IsSecureBelowEL3.0" name="impl-shared.IsSecureBelowEL3.0"></a><ins>IsSecureBelowEL3()
    if</ins><del>HasArchVersion(</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#ArchVersion" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ArchVersion</del></a><ins>(</ins><del>version)
    return version ==</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#ARMv8p0" title="enumeration ArchVersion { ARMv8p0 , ARMv8p1 , ARMv8p2 , ARMv8p3 , ARMv8p4 , ARMv8p5 }"><del>ARMv8p0</del></a><ins>) then
        return </ins><a href="shared_pseudocode.html#impl-shared.SCR_GEN.read.0" title="accessor: SCRType SCR_GEN[]"><ins>SCR_GEN</ins></a><ins>[].NS == '0';
    elsif </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>) &amp;&amp; (!</ins><a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()"><ins>HaveSecureEL2Ext</ins></a><ins>() || </ins><a href="shared_pseudocode.html#impl-shared.HighestELUsingAArch32.0" title="function: boolean HighestELUsingAArch32()"><ins>HighestELUsingAArch32</ins></a><ins>()) then
        // If Secure EL2 is not an architecture option then we must be Non-secure.
        return FALSE;
    else
        // TRUE if processor is Secure or FALSE if Non-secure.
        return boolean IMPLEMENTATION_DEFINED "Secure-only implementation";</ins><del>|| boolean IMPLEMENTATION_DEFINED;</del></p></div><div class="ps" psname="shared.functions.system.IsSecureEL2Enabled"><a id="shared.functions.system.IsSecureEL2Enabled" name="shared.functions.system.IsSecureEL2Enabled"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>IsSecureEL2Enabled</ins><del>HaveAArch32EL</del></h3><p class="pseudocode"><ins>// IsSecureEL2Enabled()
// ====================
// Returns TRUE if Secure EL2 is enabled, FALSE otherwise
</ins><del>// HaveAArch32EL()
// ===============
</del>
boolean <a id="impl-shared.IsSecureEL2Enabled.0" name="impl-shared.IsSecureEL2Enabled.0"></a><ins>IsSecureEL2Enabled()
    return (</ins><del>HaveAArch32EL(bits(2) el)
    // Return TRUE if Exception level 'el' supports AArch32 in this implementation
    if !</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a><ins>(</ins><del>(el) then
        return FALSE;                    // The Exception level is not implemented
    elsif !</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-shared.HaveAnyAArch32.0" title="function: boolean HaveAnyAArch32()"><del>HaveAnyAArch32</del></a><ins>) &amp;&amp;</ins><del>() then
        return FALSE;                    // No Exception level can use AArch32
    elsif</del>
            <a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()"><ins>HaveSecureEL2Ext</ins></a><a href="shared_pseudocode.html#impl-shared.HighestELUsingAArch32.0" title="function: boolean HighestELUsingAArch32()"><del>HighestELUsingAArch32</del></a><ins>() &amp;&amp;
            !</ins><del>() then
        return TRUE;                     // All Exception levels are using AArch32
    elsif el ==</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><a href="shared_pseudocode.html#impl-shared.HighestEL.0" title="function: bits(2) HighestEL()"><del>HighestEL</del></a><ins>(</ins><del>() then
        return FALSE;                    // The highest Exception level is using AArch64
    elsif el ==</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><ins>) &amp;&amp;
            SCR_EL3.EEL2 == '1');</ins><del>then
        return TRUE;                     // EL0 must support using AArch32 if any AArch32
    return boolean IMPLEMENTATION_DEFINED;</del></p></div><div class="ps" psname="shared.functions.system.IsVirtualSErrorPending"><a id="shared.functions.system.IsVirtualSErrorPending" name="shared.functions.system.IsVirtualSErrorPending"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>IsVirtualSErrorPending</ins><del>HaveAnyAArch32</del></h3><p class="pseudocode"><ins>// Return TRUE if a virtual SError interrupt is pending
</ins><del>// HaveAnyAArch32()
// ================
// Return TRUE if AArch32 state is supported at any Exception level

</del>boolean <a id="impl-shared.IsVirtualSErrorPending.0" name="impl-shared.IsVirtualSErrorPending.0"></a><ins>IsVirtualSErrorPending();</ins><del>HaveAnyAArch32()
    return boolean IMPLEMENTATION_DEFINED;</del></p></div><div class="ps" psname="shared.functions.system.Mode_Bits"><a id="shared.functions.system.Mode_Bits" name="shared.functions.system.Mode_Bits"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>Mode_Bits</ins><del>HaveAnyAArch64</del></h3><p class="pseudocode"><ins>constant bits(5)</ins><del>// HaveAnyAArch64()
// ================
// Return TRUE if AArch64 state is supported at any Exception level

boolean</del> <a id="M32_User" name="M32_User"></a><ins>M32_User    = '10000';
constant bits(5)</ins><del>HaveAnyAArch64()
    return !</del> <a id="M32_FIQ" name="M32_FIQ"></a><ins>M32_FIQ     = '10001';
constant bits(5) </ins><a id="M32_IRQ" name="M32_IRQ"></a><ins>M32_IRQ     = '10010';
constant bits(5) </ins><a id="M32_Svc" name="M32_Svc"></a><ins>M32_Svc     = '10011';
constant bits(5) </ins><a id="M32_Monitor" name="M32_Monitor"></a><ins>M32_Monitor = '10110';
constant bits(5) </ins><a id="M32_Abort" name="M32_Abort"></a><ins>M32_Abort   = '10111';
constant bits(5) </ins><a id="M32_Hyp" name="M32_Hyp"></a><ins>M32_Hyp     = '11010';
constant bits(5) </ins><a id="M32_Undef" name="M32_Undef"></a><ins>M32_Undef   = '11011';
constant bits(5) </ins><a id="M32_System" name="M32_System"></a><ins>M32_System  = '11111';</ins><del>();</del></p></div><div class="ps" psname="shared.functions.system.PLOfEL"><a id="shared.functions.system.PLOfEL" name="shared.functions.system.PLOfEL"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>PLOfEL</ins><del>HaveEL</del></h3><p class="pseudocode"><ins>// PLOfEL()
</ins><del>// HaveEL()
</del>// ========
<del>// Return TRUE if Exception level 'el' is supported
</del>
<ins>PrivilegeLevel</ins><del>boolean</del> <a id="impl-shared.PLOfEL.1" name="impl-shared.PLOfEL.1"></a><ins>PLOfEL(bits(2) el)
    case el of
        when</ins><del>HaveEL(bits(2) el)
    if el IN {</del> <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>  return if </ins><a href="shared_pseudocode.html#impl-shared.HighestELUsingAArch32.0" title="function: boolean HighestELUsingAArch32()"><ins>HighestELUsingAArch32</ins></a><ins>() then </ins><a href="shared_pseudocode.html#PL1" title="enumeration PrivilegeLevel {PL3, PL2, PL1, PL0}"><ins>PL1</ins></a><ins> else </ins><a href="shared_pseudocode.html#PL3" title="enumeration PrivilegeLevel {PL3, PL2, PL1, PL0}"><ins>PL3</ins></a><ins>;
        when </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>  return </ins><a href="shared_pseudocode.html#PL2" title="enumeration PrivilegeLevel {PL3, PL2, PL1, PL0}"><ins>PL2</ins></a><ins>;
        when </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  <ins>return</ins><del>,</del> <a href="shared_pseudocode.html#PL1" title="enumeration PrivilegeLevel {PL3, PL2, PL1, PL0}"><ins>PL1</ins></a><ins>;
        when </ins><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a><ins>  return </ins><a href="shared_pseudocode.html#PL0" title="enumeration PrivilegeLevel {PL3, PL2, PL1, PL0}"><ins>PL0</ins></a><ins>;</ins><del>} then
        return TRUE;                             // EL1 and EL0 must exist
    return boolean IMPLEMENTATION_DEFINED;</del></p></div><div class="ps" psname="shared.functions.system.PSTATE"><a id="shared.functions.system.PSTATE" name="shared.functions.system.PSTATE"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>PSTATE</ins><del>HaveFP16Ext</del></h3><p class="pseudocode"><del>// HaveFP16Ext()
// =============
// Return TRUE if FP16 extension is supported

boolean </del><a id="impl-shared.HaveFP16Ext.0" name="impl-shared.HaveFP16Ext.0"></a><a href="shared_pseudocode.html#ProcState" title="type ProcState is ( bits (1) N, bits (1) Z, bits (1) C, bits (1) V, bits (1) D, bits (1) A, bits (1) I, bits (1) F, bits (1) PAN, bits (1) UAO, bits (1) DIT, bits (1) TCO, bits (2) BTYPE, bits (1) SS, bits (1) IL, bits (2) EL, bits (1) nRW, bits (1) SP, bits (1) Q, bits (4) GE, bits (1) SSBS, bits (8) IT, bits (1) J, bits (1) T, bits (1) E, bits (5) M )"><ins>ProcState</ins></a> <ins>PSTATE;</ins><del>HaveFP16Ext()
    return boolean IMPLEMENTATION_DEFINED;</del></p></div><div class="ps" psname="shared.functions.system.PrivilegeLevel"><a id="shared.functions.system.PrivilegeLevel" name="shared.functions.system.PrivilegeLevel"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>PrivilegeLevel</ins><del>HighestEL</del></h3><p class="pseudocode"><ins>enumeration</ins><del>// HighestEL()
// ===========
// Returns the highest implemented Exception level.

bits(2)</del> <a id="PrivilegeLevel" name="PrivilegeLevel"></a><ins>PrivilegeLevel {</ins><del>HighestEL()
    if</del><a id="PL3" name="PL3"></a><ins>PL3,</ins><del>(</del> <a id="PL2" name="PL2"></a><ins>PL2,</ins><del>) then
        return</del> <a id="PL1" name="PL1"></a><ins>PL1,</ins><del>;
    elsif</del> <del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) then
        return </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>;
    else
        return </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><a id="PL0" name="PL0"></a><ins>PL0};</ins><del>;</del></p></div><div class="ps" psname="shared.functions.system.ProcState"><a id="shared.functions.system.ProcState" name="shared.functions.system.ProcState"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>ProcState</ins><del>HighestELUsingAArch32</del></h3><p class="pseudocode"><ins>type</ins><del>// HighestELUsingAArch32()
// =======================
// Return TRUE if configured to boot into AArch32 operation

boolean</del> <a id="ProcState" name="ProcState"></a><ins>ProcState is (
    bits (1) N,        // Negative condition flag
    bits (1) Z,        // Zero condition flag
    bits (1) C,        // Carry condition flag
    bits (1) V,        // oVerflow condition flag
    bits (1) D,        // Debug mask bit                     [AArch64 only]
    bits (1) A,        // SError interrupt mask bit
    bits (1) I,        // IRQ mask bit
    bits (1) F,        // FIQ mask bit
    bits (1) PAN,      // Privileged Access Never Bit        [v8.1]
    bits (1) UAO,      // User Access Override               [v8.2]
    bits (1) DIT,      // Data Independent Timing            [v8.4]
    bits (1) TCO,      // Tag Check Override                 [v8.5, AArch64 only]
    bits (2) BTYPE,    // Branch Type                        [v8.5]
    bits (1) SS,       // Software step bit
    bits (1) IL,       // Illegal Execution state bit
    bits (2) EL,       // Exception Level
    bits (1) nRW,      // not Register Width: 0=64, 1=32
    bits (1)</ins><del>HighestELUsingAArch32()
    if !</del> <a href="shared_pseudocode.html#impl-aarch32.SP.write.none" title="accessor: SP = bits(32) value"><ins>SP</ins></a><a href="shared_pseudocode.html#impl-shared.HaveAnyAArch32.0" title="function: boolean HaveAnyAArch32()"><del>HaveAnyAArch32</del></a><ins>,       // Stack pointer select: 0=SP0, 1=SPx [AArch64 only]
    bits (1) Q,        // Cumulative saturation flag         [AArch32 only]
    bits (4) GE,       // Greater than or Equal flags        [AArch32 only]
    bits (1) SSBS,     // Speculative Store Bypass Safe
    bits (8) IT,       // If-then bits, RES0 in CPSR         [AArch32 only]
    bits (1) J,        // J bit, RES0                        [AArch32 only, RES0 in SPSR and CPSR]
    bits (1) T,        // T32 bit, RES0 in CPSR              [AArch32 only]
    bits (1) E,        // Endianness bit                     [AArch32 only]
    bits (5) M         // Mode field                         [AArch32 only]
)</ins><del>() then return FALSE;
    return boolean IMPLEMENTATION_DEFINED;       // e.g. CFG32SIGNAL == HIGH</del></p></div><div class="ps" psname="shared.functions.system.RandomTag"><a id="shared.functions.system.RandomTag" name="shared.functions.system.RandomTag"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>RandomTag</ins><del>Hint_Yield</del></h3><p class="pseudocode"><ins>// RandomTag()
// ===========
// Generate a random Allocation Tag.

bits(4) </ins><a id="impl-shared.RandomTag.0" name="impl-shared.RandomTag.0"></a><ins>RandomTag()
    bits(4) tag;
    for i = 0 to 3
        tag&lt;i> = </ins><a href="shared_pseudocode.html#impl-shared.NextRandomTagBit.0" title="function: bit NextRandomTagBit()"><ins>NextRandomTagBit</ins></a><ins>();
    return tag;</ins><del>Hint_Yield();</del></p></div><div class="ps" psname="shared.functions.system.RandomTagBit"><a id="shared.functions.system.RandomTagBit" name="shared.functions.system.RandomTagBit"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>RandomTagBit</ins><del>IllegalExceptionReturn</del></h3><p class="pseudocode"><ins>// RandomTagBit()
// ==============
// Generate a random bit suitable for generating a random Allocation Tag.
</ins><del>// IllegalExceptionReturn()
// ========================
</del>
<ins>bit</ins><del>boolean</del> <a id="impl-shared.NextRandomTagBit.0" name="impl-shared.NextRandomTagBit.0"></a><ins>NextRandomTagBit()
    bits(16) lfsr = RGSR_EL1.SEED;
    bit top = lfsr&lt;5> EOR lfsr&lt;3> EOR lfsr&lt;2> EOR lfsr&lt;0>;
    RGSR_EL1.SEED = top:lfsr&lt;15:1>;
    return top;</ins><del>IllegalExceptionReturn(bits(32) spsr)

    // Check for illegal return:
    //   * To an unimplemented Exception level.
    //   * To EL2 in Secure state, when SecureEL2 is not enabled.
    //   * To EL0 using AArch64 state, with SPSR.M[0]==1.
    //   * To AArch64 state with SPSR.M[1]==1.
    //   * To AArch32 state with an illegal value of SPSR.M.
    (valid, target) =</del><a href="shared_pseudocode.html#impl-shared.ELFromSPSR.1" title="function: (boolean,bits(2)) ELFromSPSR(bits(32) spsr)"><del>ELFromSPSR</del></a><del>(spsr);
    if !valid then return TRUE;

    // Check for return to higher Exception level
    if </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(target) > </del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(PSTATE.EL) then return TRUE;

    spsr_mode_is_aarch32 = (spsr&lt;4> == '1');

    // Check for illegal return:
    //   * To EL1, EL2 or EL3 with register width specified in the SPSR different from the
    //     Execution state used in the Exception level being returned to, as determined by
    //     the SCR_EL3.RW or HCR_EL2.RW bits, or as configured from reset.
    //   * To EL0 using AArch64 state when EL1 is using AArch32 state as determined by the
    //     SCR_EL3.RW or HCR_EL2.RW bits or as configured from reset.
    //   * To AArch64 state from AArch32 state (should be caught by above)
    (known, target_el_is_aarch32) = </del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32K.1" title="function: (boolean,boolean) ELUsingAArch32K(bits(2) el)"><del>ELUsingAArch32K</del></a><del>(target);
    assert known || (target == </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del> &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>));
    if known &amp;&amp; spsr_mode_is_aarch32 != target_el_is_aarch32 then return TRUE;

    // Check for illegal return from AArch32 to AArch64
    if </del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>() &amp;&amp; !spsr_mode_is_aarch32 then return TRUE;

    // Check for illegal return to EL1 when HCR.TGE is set and when either of
    // * SecureEL2 is enabled.
    // * SecureEL2 is not enabled and EL1 is in Non-secure state.
    if </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) &amp;&amp; target == </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del> &amp;&amp; HCR_EL2.TGE == '1' then
        if (!</del><a href="shared_pseudocode.html#impl-shared.IsSecureBelowEL3.0" title="function: boolean IsSecureBelowEL3()"><del>IsSecureBelowEL3</del></a><del>() || </del><a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()"><del>IsSecureEL2Enabled</del></a><del>()) then return TRUE;
    return FALSE;</del></p></div><div class="ps" psname="shared.functions.system.RestoredITBits"><a id="shared.functions.system.RestoredITBits" name="shared.functions.system.RestoredITBits"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>RestoredITBits</ins><del>InstrSet</del></h3><p class="pseudocode"><ins>// RestoredITBits()
// ================
// Get the value of PSTATE.IT to be restored on this exception return.

bits(8)</ins><del>enumeration</del> <a id="impl-shared.RestoredITBits.1" name="impl-shared.RestoredITBits.1"></a><ins>RestoredITBits(bits(32) spsr)
    it = spsr&lt;15:10,26:25>;

    // When PSTATE.IL is set, it is CONSTRAINED UNPREDICTABLE whether the IT bits are each set
    // to zero or copied from the SPSR.
    if PSTATE.IL == '1' then
        if</ins><del>InstrSet {</del> <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><ins>ConstrainUnpredictableBool</ins></a><ins>(</ins><del>InstrSet_A64,</del><a href="shared_pseudocode.html#Unpredictable_ILZEROIT" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_ILZEROIT</ins></a><ins>) then return '00000000';
        else return it;

    // The IT bits are forced to zero when they are set to a reserved value.
    if !</ins><del>InstrSet_A32,</del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(it&lt;7:4>) &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(it&lt;3:0>) then
        return '00000000';

    // The IT bits are forced to zero when returning to A32 state, or when returning to an EL
    // with the ITD bit set to 1, and the IT bits are describing a multi-instruction block.
    itd = if PSTATE.EL == </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins> then HSCTLR.ITD else SCTLR.ITD;
    if (spsr&lt;5> == '0' &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(it)) || (itd == '1' &amp;&amp; !</ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(it&lt;2:0>)) then
        return '00000000';
    else
        return it;</ins><del>InstrSet_T32};</del></p></div><div class="ps" psname="shared.functions.system.SCRType"><a id="shared.functions.system.SCRType" name="shared.functions.system.SCRType"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>SCRType</ins><del>InstructionSynchronizationBarrier</del></h3><p class="pseudocode"><ins>type </ins><a id="SCRType" name="SCRType"></a><ins>SCRType;</ins><del>InstructionSynchronizationBarrier();</del></p></div><div class="ps" psname="shared.functions.system.SCR_GEN"><a id="shared.functions.system.SCR_GEN" name="shared.functions.system.SCR_GEN"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>SCR_GEN</ins><del>InterruptPending</del></h3><p class="pseudocode"><ins>// SCR_GEN[]
// =========
</ins><del>// InterruptPending()
// ==================
// Return TRUE if there are any pending physical or virtual interrupts, and FALSE otherwise
</del>
<ins>SCRType</ins><del>boolean</del> <a id="impl-shared.SCR_GEN.read.0" name="impl-shared.SCR_GEN.read.0"></a><ins>SCR_GEN[]
    // AArch32 secure &amp; AArch64 EL3 registers are not architecturally mapped
    assert</ins><del>InterruptPending()
    return</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-shared.IsPhysicalSErrorPending.0" title="function: boolean IsPhysicalSErrorPending()"><del>IsPhysicalSErrorPending</del></a><ins>(</ins><del>() ||</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><a href="shared_pseudocode.html#impl-shared.IsVirtualSErrorPending.0" title="function: boolean IsVirtualSErrorPending()"><del>IsVirtualSErrorPending</del></a><ins>);
    bits(32) r;
    if </ins><a href="shared_pseudocode.html#impl-shared.HighestELUsingAArch32.0" title="function: boolean HighestELUsingAArch32()"><ins>HighestELUsingAArch32</ins></a><ins>() then
        r = SCR;
    else
        r = SCR_EL3;
    return r;</ins><del>();</del></p></div><div class="ps" psname="shared.functions.system.SendEvent"><a id="shared.functions.system.SendEvent" name="shared.functions.system.SendEvent"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>SendEvent</ins><del>IsEventRegisterSet</del></h3><p class="pseudocode"><ins>// Signal an event to all PEs in a multiprocessor system to set their Event Registers.
// When a PE executes the SEV instruction, it causes this function to be executed</ins><del>// IsEventRegisterSet()
// ====================
// Return TRUE if the Event Register of this PE is set, and FALSE otherwise

boolean</del>
<a id="impl-shared.SendEvent.0" name="impl-shared.SendEvent.0"></a><ins>SendEvent();</ins><del>IsEventRegisterSet()
    return EventRegister == '1';</del></p></div><div class="ps" psname="shared.functions.system.SendEventLocal"><a id="shared.functions.system.SendEventLocal" name="shared.functions.system.SendEventLocal"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>SendEventLocal</ins><del>IsHighestEL</del></h3><p class="pseudocode"><ins>// SendEventLocal()
// ================
// Set the local Event Register of this PE.
// When a PE executes the SEVL instruction, it causes this function to be executed</ins><del>// IsHighestEL()
// =============
// Returns TRUE if given exception level is the highest exception level implemented

boolean</del>

<a id="impl-shared.SendEventLocal.0" name="impl-shared.SendEventLocal.0"></a><ins>SendEventLocal()
    EventRegister = '1';
    return;</ins><del>IsHighestEL(bits(2) el)
    return</del><a href="shared_pseudocode.html#impl-shared.HighestEL.0" title="function: bits(2) HighestEL()"><del>HighestEL</del></a><del>() == el;</del></p></div><div class="ps" psname="shared.functions.system.SetPSTATEFromPSR"><a id="shared.functions.system.SetPSTATEFromPSR" name="shared.functions.system.SetPSTATEFromPSR"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>SetPSTATEFromPSR</ins><del>IsInHost</del></h3><p class="pseudocode"><ins>// SetPSTATEFromPSR()
// ==================
// Set PSTATE based on a PSR value</ins><del>// IsInHost()
// ==========

boolean</del>

<a id="impl-shared.SetPSTATEFromPSR.1" name="impl-shared.SetPSTATEFromPSR.1"></a><ins>SetPSTATEFromPSR(bits(32) spsr)
    PSTATE.SS =</ins><del>IsInHost()
    return</del> <a href="shared_pseudocode.html#impl-shared.DebugExceptionReturnSS.1" title="function: bit DebugExceptionReturnSS(bits(32) spsr)"><ins>DebugExceptionReturnSS</ins></a><a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)"><del>ELIsInHost</del></a><ins>(spsr);
    if </ins><a href="shared_pseudocode.html#impl-shared.IllegalExceptionReturn.1" title="function: boolean IllegalExceptionReturn(bits(32) spsr)"><ins>IllegalExceptionReturn</ins></a><ins>(spsr) then
        PSTATE.IL = '1';
    else
        // State that is reinstated only on a legal exception return
        PSTATE.IL = spsr&lt;20>;
        if spsr&lt;4> == '1' then                    // AArch32 state
            </ins><a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)"><ins>AArch32.WriteMode</ins></a><ins>(spsr&lt;4:0>);         // Sets PSTATE.EL correctly
        else                                      // AArch64 state
            PSTATE.nRW = '0';
            PSTATE.EL  = spsr&lt;3:2>;
            PSTATE.SP  = spsr&lt;0>;

    // If PSTATE.IL is set and returning to AArch32 state, it is CONSTRAINED UNPREDICTABLE whether
    // the T bit is set to zero or copied from SPSR.
    if PSTATE.IL == '1' &amp;&amp; PSTATE.nRW == '1' then
        if </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><ins>ConstrainUnpredictableBool</ins></a><ins>(</ins><a href="shared_pseudocode.html#Unpredictable_ILZEROT" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_ILZEROT</ins></a><ins>) then spsr&lt;5> = '0';

    // State that is reinstated regardless of illegal exception return
    PSTATE.&lt;N,Z,C,V> = spsr&lt;31:28>;
    if </ins><a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()"><ins>HavePANExt</ins></a><ins>() then PSTATE.PAN = spsr&lt;22>;
    if PSTATE.nRW == '1' then                     // AArch32 state
        PSTATE.Q         = spsr&lt;27>;
        PSTATE.IT        = </ins><a href="shared_pseudocode.html#impl-shared.RestoredITBits.1" title="function: bits(8) RestoredITBits(bits(32) spsr)"><ins>RestoredITBits</ins></a><ins>(spsr);
        ShouldAdvanceIT  = FALSE;
        if </ins><a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()"><ins>HaveSSBSExt</ins></a><ins>() then PSTATE.SSBS = spsr&lt;23>;
        if </ins><a href="shared_pseudocode.html#impl-shared.HaveDITExt.0" title="function: boolean HaveDITExt()"><ins>HaveDITExt</ins></a><ins>() then PSTATE.DIT = (if </ins><a href="shared_pseudocode.html#impl-shared.Restarting.0" title="function: boolean Restarting()"><ins>Restarting</ins></a><ins>() then spsr&lt;24> else spsr&lt;21>);
        PSTATE.GE        = spsr&lt;19:16>;
        PSTATE.E         = spsr&lt;9>;
        PSTATE.&lt;A,I,F>   = spsr&lt;8:6>;             // No PSTATE.D in AArch32 state
        PSTATE.T         = spsr&lt;5>;               // PSTATE.J is RES0
    else                                          // AArch64 state
        if </ins><a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()"><ins>HaveMTEExt</ins></a><ins>() then PSTATE.TCO = spsr&lt;25>;
        if </ins><a href="shared_pseudocode.html#impl-shared.HaveDITExt.0" title="function: boolean HaveDITExt()"><ins>HaveDITExt</ins></a><ins>() then PSTATE.DIT = spsr&lt;24>;
        if </ins><a href="shared_pseudocode.html#impl-shared.HaveUAOExt.0" title="function: boolean HaveUAOExt()"><ins>HaveUAOExt</ins></a><ins>() then PSTATE.UAO = spsr&lt;23>;
        if </ins><a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()"><ins>HaveSSBSExt</ins></a><ins>() then PSTATE.SSBS = spsr&lt;12>;
        if </ins><a href="shared_pseudocode.html#impl-shared.HaveBTIExt.0" title="function: boolean HaveBTIExt()"><ins>HaveBTIExt</ins></a><ins>() then PSTATE.BTYPE = spsr&lt;11:10>;
        PSTATE.&lt;D,A,I,F> = spsr&lt;9:6>;             // No PSTATE.&lt;Q,IT,GE,E,T> in AArch64 state

    return;</ins><del>(PSTATE.EL);</del></p></div><div class="ps" psname="shared.functions.system.ShouldAdvanceIT"><a id="shared.functions.system.ShouldAdvanceIT" name="shared.functions.system.ShouldAdvanceIT"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>ShouldAdvanceIT</ins><del>IsPhysicalSErrorPending</del></h3><p class="pseudocode"><ins>boolean ShouldAdvanceIT;</ins><del>// Return TRUE if a physical SError interrupt is pending
boolean</del><a id="impl-shared.IsPhysicalSErrorPending.0" name="impl-shared.IsPhysicalSErrorPending.0"></a><del>IsPhysicalSErrorPending();</del></p></div><div class="ps" psname="shared.functions.system.SpeculationBarrier"><a id="shared.functions.system.SpeculationBarrier" name="shared.functions.system.SpeculationBarrier"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>SpeculationBarrier</ins><del>IsSecure</del></h3><p class="pseudocode"><del>// IsSecure()
// ==========

boolean </del><a id="impl-shared.SpeculationBarrier.0" name="impl-shared.SpeculationBarrier.0"></a><del>IsSecure()
    // Return TRUE if current Exception level is in Secure state.
    if </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>() &amp;&amp; PSTATE.EL == </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del> then
        return TRUE;
    elsif </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>() &amp;&amp; PSTATE.M == </del><a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'"><del>M32_Monitor</del></a><del> then
        return TRUE;
    return </del><a href="shared_pseudocode.html#impl-shared.IsSecureBelowEL3.0" title="function: boolean IsSecureBelowEL3()"><del>IsSecureBelowEL3</del></a><ins>SpeculationBarrier();</ins><del>();</del></p></div><div class="ps" psname="shared.functions.system.SynchronizeContext"><a id="shared.functions.system.SynchronizeContext" name="shared.functions.system.SynchronizeContext"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>SynchronizeContext</ins><del>IsSecureBelowEL3</del></h3><p class="pseudocode"><del>// IsSecureBelowEL3()
// ==================

// Return TRUE if an Exception level below EL3 is in Secure state
// or would be following an exception return to that level.
//
// Differs from IsSecure in that it ignores the current EL or Mode
// in considering security state.
// That is, if at AArch64 EL3 or in AArch32 Monitor mode, whether an
// exception return would pass to Secure or Non-secure state.

boolean </del><a id="impl-shared.SynchronizeContext.0" name="impl-shared.SynchronizeContext.0"></a><del>IsSecureBelowEL3()
    if </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) then
        return </del><a href="shared_pseudocode.html#impl-shared.SCR_GEN.read.0" title="accessor: SCRType SCR_GEN[]"><del>SCR_GEN</del></a><del>[].NS == '0';
    elsif </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) &amp;&amp; (!</del><a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()"><del>HaveSecureEL2Ext</del></a><del>() || </del><a href="shared_pseudocode.html#impl-shared.HighestELUsingAArch32.0" title="function: boolean HighestELUsingAArch32()"><del>HighestELUsingAArch32</del></a><ins>SynchronizeContext();</ins><del>()) then
        // If Secure EL2 is not an architecture option then we must be Non-secure.
        return FALSE;
    else
        // TRUE if processor is Secure or FALSE if Non-secure.
        return boolean IMPLEMENTATION_DEFINED "Secure-only implementation";</del></p></div><div class="ps" psname="shared.functions.system.SynchronizeErrors"><a id="shared.functions.system.SynchronizeErrors" name="shared.functions.system.SynchronizeErrors"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>SynchronizeErrors</ins><del>IsSecureEL2Enabled</del></h3><p class="pseudocode"><ins>// Implements the error synchronization event.</ins><del>// IsSecureEL2Enabled()
// ====================
// Returns TRUE if Secure EL2 is enabled, FALSE otherwise

boolean</del>
<a id="impl-shared.SynchronizeErrors.0" name="impl-shared.SynchronizeErrors.0"></a><ins>SynchronizeErrors();</ins><del>IsSecureEL2Enabled()
    return (</del><a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()"><del>HaveSecureEL2Ext</del></a><del>() &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) &amp;&amp;
     ((</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; SCR_EL3.EEL2 == '1') ||
      (!</del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()"><del>IsSecure</del></a><del>())) );</del></p></div><div class="ps" psname="shared.functions.system.TakeUnmaskedPhysicalSErrorInterrupts"><a id="shared.functions.system.TakeUnmaskedPhysicalSErrorInterrupts" name="shared.functions.system.TakeUnmaskedPhysicalSErrorInterrupts"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>TakeUnmaskedPhysicalSErrorInterrupts</ins><del>IsVirtualSErrorPending</del></h3><p class="pseudocode"><ins>// Take any pending unmasked physical SError interrupt</ins><del>// Return TRUE if a virtual SError interrupt is pending
boolean</del>
<a id="impl-shared.TakeUnmaskedPhysicalSErrorInterrupts.1" name="impl-shared.TakeUnmaskedPhysicalSErrorInterrupts.1"></a><ins>TakeUnmaskedPhysicalSErrorInterrupts(boolean iesb_req);</ins><del>IsVirtualSErrorPending();</del></p></div><div class="ps" psname="shared.functions.system.TakeUnmaskedSErrorInterrupts"><a id="shared.functions.system.TakeUnmaskedSErrorInterrupts" name="shared.functions.system.TakeUnmaskedSErrorInterrupts"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>TakeUnmaskedSErrorInterrupts</ins><del>Mode_Bits</del></h3><p class="pseudocode"><ins>// Take any pending unmasked physical SError interrupt or unmasked virtual SError
// interrupt.</ins><del>constant bits(5)</del>
<a id="impl-shared.TakeUnmaskedSErrorInterrupts.0" name="impl-shared.TakeUnmaskedSErrorInterrupts.0"></a><ins>TakeUnmaskedSErrorInterrupts();</ins><del>M32_User    = '10000';
constant bits(5)</del><a id="M32_FIQ" name="M32_FIQ"></a><del>M32_FIQ     = '10001';
constant bits(5) </del><a id="M32_IRQ" name="M32_IRQ"></a><del>M32_IRQ     = '10010';
constant bits(5) </del><a id="M32_Svc" name="M32_Svc"></a><del>M32_Svc     = '10011';
constant bits(5) </del><a id="M32_Monitor" name="M32_Monitor"></a><del>M32_Monitor = '10110';
constant bits(5) </del><a id="M32_Abort" name="M32_Abort"></a><del>M32_Abort   = '10111';
constant bits(5) </del><a id="M32_Hyp" name="M32_Hyp"></a><del>M32_Hyp     = '11010';
constant bits(5) </del><a id="M32_Undef" name="M32_Undef"></a><del>M32_Undef   = '11011';
constant bits(5) </del><a id="M32_System" name="M32_System"></a><del>M32_System  = '11111';</del></p></div><div class="ps" psname="shared.functions.system.ThisInstr"><a id="shared.functions.system.ThisInstr" name="shared.functions.system.ThisInstr"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>ThisInstr</ins><del>PLOfEL</del></h3><p class="pseudocode"><ins>bits(32)</ins><del>// PLOfEL()
// ========

PrivilegeLevel</del> <a id="impl-shared.ThisInstr.0" name="impl-shared.ThisInstr.0"></a><ins>ThisInstr();</ins><del>PLOfEL(bits(2) el)
    case el of
        when</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>  return if </del><a href="shared_pseudocode.html#impl-shared.HighestELUsingAArch32.0" title="function: boolean HighestELUsingAArch32()"><del>HighestELUsingAArch32</del></a><del>() then </del><a href="shared_pseudocode.html#PL1" title="enumeration PrivilegeLevel {PL3, PL2, PL1, PL0}"><del>PL1</del></a><del> else </del><a href="shared_pseudocode.html#PL3" title="enumeration PrivilegeLevel {PL3, PL2, PL1, PL0}"><del>PL3</del></a><del>;
        when </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>  return </del><a href="shared_pseudocode.html#PL2" title="enumeration PrivilegeLevel {PL3, PL2, PL1, PL0}"><del>PL2</del></a><del>;
        when </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>  return </del><a href="shared_pseudocode.html#PL1" title="enumeration PrivilegeLevel {PL3, PL2, PL1, PL0}"><del>PL1</del></a><del>;
        when </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>  return </del><a href="shared_pseudocode.html#PL0" title="enumeration PrivilegeLevel {PL3, PL2, PL1, PL0}"><del>PL0</del></a><del>;</del></p></div><div class="ps" psname="shared.functions.system.ThisInstrLength"><a id="shared.functions.system.ThisInstrLength" name="shared.functions.system.ThisInstrLength"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>ThisInstrLength</ins><del>PSTATE</del></h3><p class="pseudocode"><a href="shared_pseudocode.html#ProcState" title="type ProcState is ( bits (1) N, bits (1) Z, bits (1) C, bits (1) V, bits (1) D, bits (1) A, bits (1) I, bits (1) F, bits (1) PAN, bits (1) UAO, bits (1) DIT, bits (1) TCO, bits (2) BTYPE, bits (1) SS, bits (1) IL, bits (2) EL, bits (1) nRW, bits (1) SP, bits (1) Q, bits (4) GE, bits (1) SSBS, bits (8) IT, bits (1) J, bits (1) T, bits (1) E, bits (5) M )"><del>ProcState</del></a><ins>integer </ins><a id="impl-shared.ThisInstrLength.0" name="impl-shared.ThisInstrLength.0"></a><ins>ThisInstrLength();</ins><del>PSTATE;</del></p></div><div class="ps" psname="shared.functions.system.Unreachable"><a id="shared.functions.system.Unreachable" name="shared.functions.system.Unreachable"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>Unreachable</ins><del>PrivilegeLevel</del></h3><p class="pseudocode"><del>enumeration </del><a id="PrivilegeLevel" name="PrivilegeLevel"></a><del>PrivilegeLevel {</del><a id="PL3" name="PL3"></a><del>PL3, </del><a id="PL2" name="PL2"></a><del>PL2, </del><a id="PL1" name="PL1"></a><del>PL1, </del><a id="impl-shared.Unreachable.0" name="impl-shared.Unreachable.0"></a><ins>Unreachable()
    assert FALSE;</ins><del>PL0};</del></p></div><div class="ps" psname="shared.functions.system.UsingAArch32"><a id="shared.functions.system.UsingAArch32" name="shared.functions.system.UsingAArch32"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>UsingAArch32</ins><del>ProcState</del></h3><p class="pseudocode"><ins>// UsingAArch32()
// ==============
// Return TRUE if the current Exception level is using AArch32, FALSE if using AArch64.

boolean</ins><del>type</del> <a id="impl-shared.UsingAArch32.0" name="impl-shared.UsingAArch32.0"></a><ins>UsingAArch32()
    boolean aarch32 = (PSTATE.nRW == '1');
    if !</ins><del>ProcState is (
    bits (1) N,        // Negative condition flag
    bits (1) Z,        // Zero condition flag
    bits (1) C,        // Carry condition flag
    bits (1) V,        // oVerflow condition flag
    bits (1) D,        // Debug mask bit                     [AArch64 only]
    bits (1) A,        // SError interrupt mask bit
    bits (1) I,        // IRQ mask bit
    bits (1) F,        // FIQ mask bit
    bits (1) PAN,      // Privileged Access Never Bit        [v8.1]
    bits (1) UAO,      // User Access Override               [v8.2]
    bits (1) DIT,      // Data Independent Timing            [v8.4]
    bits (1) TCO,      // Tag Check Override                 [v8.5, AArch64 only]
    bits (2) BTYPE,    // Branch Type                        [v8.5]
    bits (1) SS,       // Software step bit
    bits (1) IL,       // Illegal Execution state bit
    bits (2) EL,       // Exception Level
    bits (1) nRW,      // not Register Width: 0=64, 1=32
    bits (1)</del><a href="shared_pseudocode.html#impl-shared.HaveAnyAArch32.0" title="function: boolean HaveAnyAArch32()"><ins>HaveAnyAArch32</ins></a><a href="shared_pseudocode.html#impl-aarch32.SP.write.none" title="accessor: SP = bits(32) value"><del>SP</del></a><ins>() then assert !aarch32;
    if </ins><a href="shared_pseudocode.html#impl-shared.HighestELUsingAArch32.0" title="function: boolean HighestELUsingAArch32()"><ins>HighestELUsingAArch32</ins></a><ins>() then assert aarch32;
    return aarch32;</ins><del>,       // Stack pointer select: 0=SP0, 1=SPx [AArch64 only]
    bits (1) Q,        // Cumulative saturation flag         [AArch32 only]
    bits (4) GE,       // Greater than or Equal flags        [AArch32 only]
    bits (1) SSBS,     // Speculative Store Bypass Safe
    bits (8) IT,       // If-then bits, RES0 in CPSR         [AArch32 only]
    bits (1) J,        // J bit, RES0                        [AArch32 only, RES0 in SPSR and CPSR]
    bits (1) T,        // T32 bit, RES0 in CPSR              [AArch32 only]
    bits (1) E,        // Endianness bit                     [AArch32 only]
    bits (5) M         // Mode field                         [AArch32 only]
)</del></p></div><div class="ps" psname="shared.functions.system.WaitForEvent"><a id="shared.functions.system.WaitForEvent" name="shared.functions.system.WaitForEvent"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>WaitForEvent</ins><del>RandomTag</del></h3><p class="pseudocode"><ins>// WaitForEvent()
// ==============
// PE suspends its operation and enters a low-power state
// if the Event Register is clear when the WFE is executed</ins><del>// RandomTag()
// ===========
// Generate a random Allocation Tag.

bits(4)</del>

<a id="impl-shared.WaitForEvent.0" name="impl-shared.WaitForEvent.0"></a><ins>WaitForEvent()
    if EventRegister == '0' then</ins><del>RandomTag()
    bits(4) tag;
    for i = 0 to 3
        tag&lt;i> =</del>
        <a href="shared_pseudocode.html#impl-shared.EnterLowPowerState.0" title="function: EnterLowPowerState()"><ins>EnterLowPowerState</ins></a><a href="shared_pseudocode.html#impl-shared.NextRandomTagBit.0" title="function: bit NextRandomTagBit()"><del>NextRandomTagBit</del></a>();
<ins>    return;</ins><del>    return tag;</del></p></div><div class="ps" psname="shared.functions.system.WaitForInterrupt"><a id="shared.functions.system.WaitForInterrupt" name="shared.functions.system.WaitForInterrupt"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/<ins>WaitForInterrupt</ins><del>RandomTagBit</del></h3><p class="pseudocode"><ins>// WaitForInterrupt()
// ==================
// PE suspends its operation to enter a low-power state
// until a WFI wake-up event occurs or the PE is reset</ins><del>// RandomTagBit()
// ==============
// Generate a random bit suitable for generating a random Allocation Tag.

bit</del>

<a id="impl-shared.WaitForInterrupt.0" name="impl-shared.WaitForInterrupt.0"></a><ins>WaitForInterrupt()</ins><del>NextRandomTagBit()
    bits(16) lfsr = RGSR_EL1.SEED;
    bit top = lfsr&lt;5> EOR lfsr&lt;3> EOR lfsr&lt;2> EOR lfsr&lt;0>;
    RGSR_EL1.SEED = top:lfsr&lt;15:1>;
    return top;</del>
    <a href="shared_pseudocode.html#impl-shared.EnterLowPowerState.0" title="function: EnterLowPowerState()"><ins>EnterLowPowerState</ins></a><ins>();
    return;</ins></p></div><div class="ps" psname="shared.functions.unpredictable.ConstrainUnpredictable"><a id="shared.functions.unpredictable.ConstrainUnpredictable" name="shared.functions.unpredictable.ConstrainUnpredictable"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>unpredictable</ins><del>system</del>/<ins>ConstrainUnpredictable</ins><del>RestoredITBits</del></h3><p class="pseudocode"><ins>// ConstrainUnpredictable()
// ========================
// Return the appropriate Constraint result to control the caller's behavior. The return value
// is IMPLEMENTATION DEFINED within a permitted list for each UNPREDICTABLE case.
// (The permitted list is determined by an assert or case statement at the call site.)
</ins><del>// RestoredITBits()
// ================
// Get the value of PSTATE.IT to be restored on this exception return.
</del>
<ins>// NOTE: This version of the function uses an Unpredictable argument to define the call site.
// This argument does not appear in the version used in the Armv8 Architecture Reference Manual.
// The extra argument is used here to allow this example definition. This is an example only and
// does not imply a fixed implementation of these behaviors. Indeed the intention is that it should
// be defined by each implementation, according to its implementation choices.

Constraint</ins><del>bits(8)</del> <a id="impl-shared.ConstrainUnpredictable.1" name="impl-shared.ConstrainUnpredictable.1"></a><ins>ConstrainUnpredictable(</ins><del>RestoredITBits(bits(32) spsr)
    it = spsr&lt;15:10,26:25>;

    // When PSTATE.IL is set, it is CONSTRAINED UNPREDICTABLE whether the IT bits are each set
    // to zero or copied from the SPSR.
    if PSTATE.IL == '1' then
        if</del><a href="shared_pseudocode.html#Unpredictable" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable</ins></a><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)"><del>ConstrainUnpredictableBool</del></a> <ins>which)
    case which of
        when</ins><del>(</del> <a href="shared_pseudocode.html#Unpredictable_WBOVERLAPLD" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_WBOVERLAPLD</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_WBSUPPRESS" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_WBSUPPRESS</ins></a><ins>; // return loaded value
        when </ins><a href="shared_pseudocode.html#Unpredictable_WBOVERLAPST" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_WBOVERLAPST</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_NONE</ins></a><ins>;     // store pre-writeback value
        when </ins><a href="shared_pseudocode.html#Unpredictable_LDPOVERLAP" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_LDPOVERLAP</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_UNDEF" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_UNDEF</ins></a><ins>;    // instruction is UNDEFINED
        when </ins><a href="shared_pseudocode.html#Unpredictable_BASEOVERLAP" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_BASEOVERLAP</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_NONE</ins></a><ins>;     // use original address
        when </ins><a href="shared_pseudocode.html#Unpredictable_DATAOVERLAP" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_DATAOVERLAP</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_NONE</ins></a><ins>;     // store original value
        when </ins><a href="shared_pseudocode.html#Unpredictable_DEVPAGE2" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_DEVPAGE2</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FAULT</ins></a><ins>;    // take an alignment fault
        when </ins><a href="shared_pseudocode.html#Unpredictable_INSTRDEVICE" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_INSTRDEVICE</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_NONE</ins></a><ins>;     // Do not take a fault
        when </ins><a href="shared_pseudocode.html#Unpredictable_RESCPACR" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESCPACR</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_UNKNOWN</ins></a><ins>;  // Map to UNKNOWN value
        when </ins><a href="shared_pseudocode.html#Unpredictable_RESMAIR" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESMAIR</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_UNKNOWN</ins></a><ins>;  // Map to UNKNOWN value
        when </ins><a href="shared_pseudocode.html#Unpredictable_RESTEXCB" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESTEXCB</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_UNKNOWN</ins></a><ins>;  // Map to UNKNOWN value
        when </ins><a href="shared_pseudocode.html#Unpredictable_RESDACR" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESDACR</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_UNKNOWN</ins></a><ins>;  // Map to UNKNOWN value
        when </ins><a href="shared_pseudocode.html#Unpredictable_RESPRRR" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESPRRR</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_UNKNOWN</ins></a><ins>;  // Map to UNKNOWN value
        when </ins><a href="shared_pseudocode.html#Unpredictable_RESVTCRS" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESVTCRS</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_UNKNOWN</ins></a><ins>;  // Map to UNKNOWN value
        when </ins><a href="shared_pseudocode.html#Unpredictable_RESTnSZ" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESTnSZ</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FORCE</ins></a><ins>;    // Map to the limit value
        when </ins><a href="shared_pseudocode.html#Unpredictable_OORTnSZ" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_OORTnSZ</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FORCE</ins></a><ins>;    // Map to the limit value
        when </ins><a href="shared_pseudocode.html#Unpredictable_LARGEIPA" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_LARGEIPA</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FORCE</ins></a><ins>;    // Restrict the inputsize to the PAMax value
        when </ins><a href="shared_pseudocode.html#Unpredictable_ESRCONDPASS" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_ESRCONDPASS</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FALSE</ins></a><ins>;    // Report as "AL"
        when </ins><a href="shared_pseudocode.html#Unpredictable_ILZEROIT" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}">Unpredictable_ILZEROIT</a>
            <ins>return</ins><del>) then return '00000000';
        else return it;

    // The IT bits are forced to zero when they are set to a reserved value.
    if !</del> <a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FALSE</ins></a><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><ins>;    // Do not zero PSTATE.IT
        when</ins><del>(it&lt;7:4>) &amp;&amp;</del> <a href="shared_pseudocode.html#Unpredictable_ILZEROT" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_ILZEROT</ins></a><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a>
            <ins>return</ins><del>(it&lt;3:0>) then
        return '00000000';

    // The IT bits are forced to zero when returning to A32 state, or when returning to an EL
    // with the ITD bit set to 1, and the IT bits are describing a multi-instruction block.
    itd = if PSTATE.EL ==</del> <a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FALSE</ins></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><ins>;    // Do not zero PSTATE.T
        when</ins><del>then HSCTLR.ITD else SCTLR.ITD;
    if (spsr&lt;5> == '0' &amp;&amp; !</del> <a href="shared_pseudocode.html#Unpredictable_BPVECTORCATCHPRI" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_BPVECTORCATCHPRI</ins></a><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a>
            <ins>return</ins><del>(it)) || (itd == '1' &amp;&amp; !</del> <a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_TRUE</ins></a><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><ins>;     // Debug Vector Catch: match on 2nd halfword
        when </ins><a href="shared_pseudocode.html#Unpredictable_VCMATCHHALF" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_VCMATCHHALF</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FALSE</ins></a><ins>;    // No match
        when </ins><a href="shared_pseudocode.html#Unpredictable_VCMATCHDAPA" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_VCMATCHDAPA</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FALSE</ins></a><ins>;    // No match on Data Abort or Prefetch abort
        when </ins><a href="shared_pseudocode.html#Unpredictable_WPMASKANDBAS" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_WPMASKANDBAS</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FALSE</ins></a><ins>;    // Watchpoint disabled
        when </ins><a href="shared_pseudocode.html#Unpredictable_WPBASCONTIGUOUS" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_WPBASCONTIGUOUS</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FALSE</ins></a><ins>;    // Watchpoint disabled
        when </ins><a href="shared_pseudocode.html#Unpredictable_RESWPMASK" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESWPMASK</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_DISABLED</ins></a><ins>; // Watchpoint disabled
        when </ins><a href="shared_pseudocode.html#Unpredictable_WPMASKEDBITS" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_WPMASKEDBITS</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FALSE</ins></a><ins>;    // Watchpoint disabled
        when </ins><a href="shared_pseudocode.html#Unpredictable_RESBPWPCTRL" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESBPWPCTRL</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_DISABLED</ins></a><ins>; // Breakpoint/watchpoint disabled
        when </ins><a href="shared_pseudocode.html#Unpredictable_BPNOTIMPL" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_BPNOTIMPL</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_DISABLED</ins></a><ins>; // Breakpoint disabled
        when </ins><a href="shared_pseudocode.html#Unpredictable_RESBPTYPE" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESBPTYPE</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_DISABLED</ins></a><ins>; // Breakpoint disabled
        when </ins><a href="shared_pseudocode.html#Unpredictable_BPNOTCTXCMP" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_BPNOTCTXCMP</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_DISABLED</ins></a><ins>; // Breakpoint disabled
        when </ins><a href="shared_pseudocode.html#Unpredictable_BPMATCHHALF" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_BPMATCHHALF</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FALSE</ins></a><ins>;    // No match
        when </ins><a href="shared_pseudocode.html#Unpredictable_BPMISMATCHHALF" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_BPMISMATCHHALF</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FALSE</ins></a><ins>;    // No match
        when </ins><a href="shared_pseudocode.html#Unpredictable_RESTARTALIGNPC" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESTARTALIGNPC</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FALSE</ins></a><ins>;    // Do not force alignment
        when </ins><a href="shared_pseudocode.html#Unpredictable_RESTARTZEROUPPERPC" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_RESTARTZEROUPPERPC</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_TRUE</ins></a><ins>;     // Force zero extension
        when </ins><a href="shared_pseudocode.html#Unpredictable_ZEROUPPER" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_ZEROUPPER</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_TRUE</ins></a><ins>;     // zero top halves of X registers
        when </ins><a href="shared_pseudocode.html#Unpredictable_ERETZEROUPPERPC" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_ERETZEROUPPERPC</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_TRUE</ins></a><ins>;     // zero top half of PC
        when </ins><a href="shared_pseudocode.html#Unpredictable_A32FORCEALIGNPC" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_A32FORCEALIGNPC</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FALSE</ins></a><ins>;    // Do not force alignment
        when </ins><a href="shared_pseudocode.html#Unpredictable_SMD" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_SMD</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_UNDEF" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_UNDEF</ins></a><ins>;    // disabled SMC is Unallocated
        when </ins><a href="shared_pseudocode.html#Unpredictable_NONFAULT" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_NONFAULT</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FALSE</ins></a><ins>;    // Speculation enabled
        when </ins><a href="shared_pseudocode.html#Unpredictable_SVEZEROUPPER" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_SVEZEROUPPER</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_TRUE</ins></a><ins>;     // zero top bits of Z registers
        when </ins><a href="shared_pseudocode.html#Unpredictable_SVELDNFDATA" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_SVELDNFDATA</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_TRUE</ins></a><ins>;     // Load mem data in NF loads
        when </ins><a href="shared_pseudocode.html#Unpredictable_SVELDNFZERO" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_SVELDNFZERO</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_TRUE</ins></a><ins>;     // Write zeros in NF loads
        when </ins><a href="shared_pseudocode.html#Unpredictable_AFUPDATE" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_AFUPDATE</ins></a><ins>     // AF update for alignment or permission fault
            return </ins><a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_TRUE</ins></a><ins>;
        when </ins><a href="shared_pseudocode.html#Unpredictable_IESBinDebug" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_IESBinDebug</ins></a><ins>  // Use SCTLR[].IESB in Debug state
            return </ins><a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_TRUE</ins></a><ins>;
        when </ins><a href="shared_pseudocode.html#Unpredictable_ZEROBTYPE" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_ZEROBTYPE</ins></a><ins>
            return </ins><a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_TRUE</ins></a><ins>;    // Save BTYPE in SPSR_ELx/DPSR_EL0 as '00'
        when </ins><a href="shared_pseudocode.html#Unpredictable_CLEARERRITEZERO" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable_CLEARERRITEZERO</ins></a><ins> // Clearing sticky errors when instruction in flight
            return </ins><a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FALSE</ins></a><ins>;</ins><del>(it&lt;2:0>)) then
        return '00000000';
    else
        return it;</del></p></div><div class="ps" psname="shared.functions.unpredictable.ConstrainUnpredictableBits"><a id="shared.functions.unpredictable.ConstrainUnpredictableBits" name="shared.functions.unpredictable.ConstrainUnpredictableBits"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>unpredictable</ins><del>system</del>/<ins>ConstrainUnpredictableBits</ins><del>SCRType</del></h3><p class="pseudocode"><ins>// ConstrainUnpredictableBits()
// ============================

// This is a variant of ConstrainUnpredictable for when the result can be Constraint_UNKNOWN.
// If the result is Constraint_UNKNOWN then the function also returns UNKNOWN value, but that
// value is always an allocated value; that is, one for which the behavior is not itself
// CONSTRAINED.

// NOTE: This version of the function uses an Unpredictable argument to define the call site.
// This argument does not appear in the version used in the Armv8 Architecture Reference Manual.
// See the NOTE on ConstrainUnpredictable() for more information.

// This is an example placeholder only and does not imply a fixed implementation of the bits part
// of the result, and may not be applicable in all cases.

(Constraint,bits(width))</ins><del>type</del> <a id="impl-shared.ConstrainUnpredictableBits.1" name="impl-shared.ConstrainUnpredictableBits.1"></a><ins>ConstrainUnpredictableBits(</ins><del>SCRType;</del><a href="shared_pseudocode.html#Unpredictable" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable</ins></a><ins> which)

    c = </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><ins>ConstrainUnpredictable</ins></a><ins>(which);

    if c == </ins><a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_UNKNOWN</ins></a><ins> then
        return (c, </ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(width));           // See notes; this is an example implementation only
    else
        return (c, bits(width) UNKNOWN);    // bits result not used</ins></p></div><div class="ps" psname="shared.functions.unpredictable.ConstrainUnpredictableBool"><a id="shared.functions.unpredictable.ConstrainUnpredictableBool" name="shared.functions.unpredictable.ConstrainUnpredictableBool"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>unpredictable</ins><del>system</del>/<ins>ConstrainUnpredictableBool</ins><del>SCR_GEN</del></h3><p class="pseudocode"><ins>// ConstrainUnpredictableBool()
// ============================
</ins><del>// SCR_GEN[]
// =========
</del>
<ins>// This is a simple wrapper function for cases where the constrained result is either TRUE or FALSE.

// NOTE: This version of the function uses an Unpredictable argument to define the call site.
// This argument does not appear in the version used in the Armv8 Architecture Reference Manual.
// See the NOTE on ConstrainUnpredictable() for more information.

boolean</ins><del>SCRType</del> <a id="impl-shared.ConstrainUnpredictableBool.1" name="impl-shared.ConstrainUnpredictableBool.1"></a><ins>ConstrainUnpredictableBool(</ins><del>SCR_GEN[]
    // AArch32 secure &amp; AArch64 EL3 registers are not architecturally mapped
    assert</del><a href="shared_pseudocode.html#Unpredictable" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable</ins></a><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a> <ins>which)

    c =</ins><del>(</del> <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><ins>ConstrainUnpredictable</ins></a><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><ins>(which);
    assert c IN {</ins><del>);
    bits(32) r;
    if</del><a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_TRUE</ins></a><a href="shared_pseudocode.html#impl-shared.HighestELUsingAArch32.0" title="function: boolean HighestELUsingAArch32()"><del>HighestELUsingAArch32</del></a><ins>, </ins><a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_FALSE</ins></a><ins>};
    return (c == </ins><a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_TRUE</ins></a><ins>);</ins><del>() then
        r = SCR;
    else
        r = SCR_EL3;
    return r;</del></p></div><div class="ps" psname="shared.functions.unpredictable.ConstrainUnpredictableInteger"><a id="shared.functions.unpredictable.ConstrainUnpredictableInteger" name="shared.functions.unpredictable.ConstrainUnpredictableInteger"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>unpredictable</ins><del>system</del>/<ins>ConstrainUnpredictableInteger</ins><del>SendEvent</del></h3><p class="pseudocode"><ins>// ConstrainUnpredictableInteger()
// ===============================

// This is a variant of ConstrainUnpredictable for when the result can be Constraint_UNKNOWN. If
// the result is Constraint_UNKNOWN then the function also returns an UNKNOWN value in the range
// low to high, inclusive.

// NOTE: This version of the function uses an Unpredictable argument to define the call site.
// This argument does not appear in the version used in the Armv8 Architecture Reference Manual.
// See the NOTE on ConstrainUnpredictable() for more information.

// This is an example placeholder only and does not imply a fixed implementation of the integer part
// of the result.

(Constraint,integer)</ins><del>// Signal an event to all PEs in a multiprocessor system to set their Event Registers.
// When a PE executes the SEV instruction, it causes this function to be executed</del> <a id="impl-shared.ConstrainUnpredictableInteger.3" name="impl-shared.ConstrainUnpredictableInteger.3"></a><ins>ConstrainUnpredictableInteger(integer low, integer high,</ins><del>SendEvent();</del> <a href="shared_pseudocode.html#Unpredictable" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><ins>Unpredictable</ins></a><ins> which)

    c = </ins><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><ins>ConstrainUnpredictable</ins></a><ins>(which);

    if c == </ins><a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><ins>Constraint_UNKNOWN</ins></a><ins> then
        return (c, low);                // See notes; this is an example implementation only
    else
        return (c, integer UNKNOWN);    // integer result not used</ins></p></div><div class="ps" psname="shared.functions.unpredictable.Constraint"><a id="shared.functions.unpredictable.Constraint" name="shared.functions.unpredictable.Constraint"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>unpredictable</ins><del>system</del>/<ins>Constraint</ins><del>SendEventLocal</del></h3><p class="pseudocode"><ins>enumeration</ins><del>// SendEventLocal()
// ================
// Set the local Event Register of this PE.
// When a PE executes the SEVL instruction, it causes this function to be executed</del> <a id="Constraint" name="Constraint"></a><ins>Constraint    {// General</ins><del>SendEventLocal()
    EventRegister = '1';
    return;</del>
                           <a id="Constraint_NONE" name="Constraint_NONE"></a><ins>Constraint_NONE,              // Instruction executes with
                                                         //   no change or side-effect to its described behavior
                           </ins><a id="Constraint_UNKNOWN" name="Constraint_UNKNOWN"></a><ins>Constraint_UNKNOWN,           // Destination register has UNKNOWN value
                           </ins><a id="Constraint_UNDEF" name="Constraint_UNDEF"></a><ins>Constraint_UNDEF,             // Instruction is UNDEFINED
                           </ins><a id="Constraint_UNDEFEL0" name="Constraint_UNDEFEL0"></a><ins>Constraint_UNDEFEL0,          // Instruction is UNDEFINED at EL0 only
                           </ins><a id="Constraint_NOP" name="Constraint_NOP"></a><ins>Constraint_NOP,               // Instruction executes as NOP
                           </ins><a id="Constraint_TRUE" name="Constraint_TRUE"></a><ins>Constraint_TRUE,
                           </ins><a id="Constraint_FALSE" name="Constraint_FALSE"></a><ins>Constraint_FALSE,
                           </ins><a id="Constraint_DISABLED" name="Constraint_DISABLED"></a><ins>Constraint_DISABLED,
                           </ins><a id="Constraint_UNCOND" name="Constraint_UNCOND"></a><ins>Constraint_UNCOND,            // Instruction executes unconditionally
                           </ins><a id="Constraint_COND" name="Constraint_COND"></a><ins>Constraint_COND,              // Instruction executes conditionally
                           </ins><a id="Constraint_ADDITIONAL_DECODE" name="Constraint_ADDITIONAL_DECODE"></a><ins>Constraint_ADDITIONAL_DECODE, // Instruction executes with additional decode
                           // Load-store
                           </ins><a id="Constraint_WBSUPPRESS" name="Constraint_WBSUPPRESS"></a><ins>Constraint_WBSUPPRESS, </ins><a id="Constraint_FAULT" name="Constraint_FAULT"></a><ins>Constraint_FAULT,
                           // IPA too large
                           </ins><a id="Constraint_FORCE" name="Constraint_FORCE"></a><ins>Constraint_FORCE, </ins><a id="Constraint_FORCENOSLCHECK" name="Constraint_FORCENOSLCHECK"></a><ins>Constraint_FORCENOSLCHECK};</ins></p></div><div class="ps" psname="shared.functions.unpredictable.Unpredictable"><a id="shared.functions.unpredictable.Unpredictable" name="shared.functions.unpredictable.Unpredictable"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>unpredictable</ins><del>system</del>/<ins>Unpredictable</ins><del>SetPSTATEFromPSR</del></h3><p class="pseudocode"><ins>enumeration</ins><del>// SetPSTATEFromPSR()
// ==================
// Set PSTATE based on a PSR value</del> <a id="Unpredictable" name="Unpredictable"></a><ins>Unpredictable {// Writeback/transfer register overlap (load)</ins><del>SetPSTATEFromPSR(bits(32) spsr)
    PSTATE.SS =</del>
                           <a id="Unpredictable_WBOVERLAPLD" name="Unpredictable_WBOVERLAPLD"></a><ins>Unpredictable_WBOVERLAPLD,
                           // Writeback/transfer register overlap (store)</ins><del>(spsr);
    if</del>
                           <a id="Unpredictable_WBOVERLAPST" name="Unpredictable_WBOVERLAPST"></a><ins>Unpredictable_WBOVERLAPST,
                           // Load Pair transfer register overlap</ins><del>(spsr) then
        PSTATE.IL = '1';
    else
        // State that is reinstated only on a legal exception return
        PSTATE.IL = spsr&lt;20>;
        if spsr&lt;4> == '1' then                    // AArch32 state</del>
                           <a id="Unpredictable_LDPOVERLAP" name="Unpredictable_LDPOVERLAP"></a><ins>Unpredictable_LDPOVERLAP,
                           // Store-exclusive base/status register overlap</ins><del>(spsr&lt;4:0>);         // Sets PSTATE.EL correctly
        else                                      // AArch64 state
            PSTATE.nRW = '0';
            PSTATE.EL  = spsr&lt;3:2>;
            PSTATE.SP  = spsr&lt;0>;
    // If PSTATE.IL is set and returning to AArch32 state, it is CONSTRAINED UNPREDICTABLE whether
    // the T bit is set to zero or copied from SPSR.
    if PSTATE.IL == '1' &amp;&amp; PSTATE.nRW == '1' then
        if</del>
                           <a id="Unpredictable_BASEOVERLAP" name="Unpredictable_BASEOVERLAP"></a><ins>Unpredictable_BASEOVERLAP,
                           // Store-exclusive data/status register overlap</ins><del>(</del>
                           <a id="Unpredictable_DATAOVERLAP" name="Unpredictable_DATAOVERLAP"></a><ins>Unpredictable_DATAOVERLAP,
                           // Load-store alignment checks</ins><del>) then spsr&lt;5> = '0';

    // State that is reinstated regardless of illegal exception return
    PSTATE.&lt;N,Z,C,V> = spsr&lt;31:28>;
    if</del>
                           <a id="Unpredictable_DEVPAGE2" name="Unpredictable_DEVPAGE2"></a><ins>Unpredictable_DEVPAGE2,
                           // Instruction fetch from Device memory</ins><del>() then PSTATE.DIT = spsr&lt;24>;
    if PSTATE.nRW == '1' then                     // AArch32 state
        PSTATE.Q         = spsr&lt;27>;
        PSTATE.IT        =</del>
                           <a id="Unpredictable_INSTRDEVICE" name="Unpredictable_INSTRDEVICE"></a><ins>Unpredictable_INSTRDEVICE,
                           // Reserved CPACR value</ins><del>(spsr);
        ShouldAdvanceIT  = FALSE;
        if</del>
                           <a id="Unpredictable_RESCPACR" name="Unpredictable_RESCPACR"></a><ins>Unpredictable_RESCPACR,
                           // Reserved MAIR value</ins><del>() then PSTATE.SSBS = spsr&lt;23>;
        PSTATE.GE        = spsr&lt;19:16>;
        PSTATE.E         = spsr&lt;9>;
        PSTATE.&lt;A,I,F>   = spsr&lt;8:6>;             // No PSTATE.D in AArch32 state
        PSTATE.T         = spsr&lt;5>;               // PSTATE.J is RES0
    else                                          // AArch64 state
        if</del>
                           <a id="Unpredictable_RESMAIR" name="Unpredictable_RESMAIR"></a><ins>Unpredictable_RESMAIR,
                           // Reserved TEX:C:B value</ins><del>() then PSTATE.UAO = spsr&lt;23>;
        if</del>
                           <a id="Unpredictable_RESTEXCB" name="Unpredictable_RESTEXCB"></a><ins>Unpredictable_RESTEXCB,
                           // Reserved PRRR value</ins><del>() then PSTATE.SSBS = spsr&lt;12>;
        PSTATE.&lt;D,A,I,F> = spsr&lt;9:6>;

        if</del>
                           <a id="Unpredictable_RESPRRR" name="Unpredictable_RESPRRR"></a><ins>Unpredictable_RESPRRR,
                           // Reserved DACR field</ins><del>() then PSTATE.BTYPE = spsr&lt;11:10>;

    if</del>
                           <a id="Unpredictable_RESDACR" name="Unpredictable_RESDACR"></a><ins>Unpredictable_RESDACR,
                           // Reserved VTCR.S value</ins><del>() then PSTATE.PAN = spsr&lt;22>;
    if</del>
                           <a id="Unpredictable_RESVTCRS" name="Unpredictable_RESVTCRS"></a><ins>Unpredictable_RESVTCRS,
                           // Reserved TCR.TnSZ value
                           </ins><a id="Unpredictable_RESTnSZ" name="Unpredictable_RESTnSZ"></a><ins>Unpredictable_RESTnSZ,
                           // Out-of-range TCR.TnSZ value
                           </ins><a id="Unpredictable_OORTnSZ" name="Unpredictable_OORTnSZ"></a><ins>Unpredictable_OORTnSZ,
                           // IPA size exceeds PA size
                           </ins><a id="Unpredictable_LARGEIPA" name="Unpredictable_LARGEIPA"></a><ins>Unpredictable_LARGEIPA,
                           // Syndrome for a known-passing conditional A32 instruction
                           </ins><a id="Unpredictable_ESRCONDPASS" name="Unpredictable_ESRCONDPASS"></a><ins>Unpredictable_ESRCONDPASS,
                           // Illegal State exception: zero PSTATE.IT
                           </ins><a id="Unpredictable_ILZEROIT" name="Unpredictable_ILZEROIT"></a><ins>Unpredictable_ILZEROIT,
                           // Illegal State exception: zero PSTATE.T
                           </ins><a id="Unpredictable_ILZEROT" name="Unpredictable_ILZEROT"></a><ins>Unpredictable_ILZEROT,
                           // Debug: prioritization of Vector Catch
                           </ins><a id="Unpredictable_BPVECTORCATCHPRI" name="Unpredictable_BPVECTORCATCHPRI"></a><ins>Unpredictable_BPVECTORCATCHPRI,
                           // Debug Vector Catch: match on 2nd halfword
                           </ins><a id="Unpredictable_VCMATCHHALF" name="Unpredictable_VCMATCHHALF"></a><ins>Unpredictable_VCMATCHHALF,
                           // Debug Vector Catch: match on Data Abort or Prefetch abort
                           </ins><a id="Unpredictable_VCMATCHDAPA" name="Unpredictable_VCMATCHDAPA"></a><ins>Unpredictable_VCMATCHDAPA,
                           // Debug watchpoints: non-zero MASK and non-ones BAS
                           </ins><a id="Unpredictable_WPMASKANDBAS" name="Unpredictable_WPMASKANDBAS"></a><ins>Unpredictable_WPMASKANDBAS,
                           // Debug watchpoints: non-contiguous BAS
                           </ins><a id="Unpredictable_WPBASCONTIGUOUS" name="Unpredictable_WPBASCONTIGUOUS"></a><ins>Unpredictable_WPBASCONTIGUOUS,
                           // Debug watchpoints: reserved MASK
                           </ins><a id="Unpredictable_RESWPMASK" name="Unpredictable_RESWPMASK"></a><ins>Unpredictable_RESWPMASK,
                           // Debug watchpoints: non-zero MASKed bits of address
                           </ins><a id="Unpredictable_WPMASKEDBITS" name="Unpredictable_WPMASKEDBITS"></a><ins>Unpredictable_WPMASKEDBITS,
                           // Debug breakpoints and watchpoints: reserved control bits
                           </ins><a id="Unpredictable_RESBPWPCTRL" name="Unpredictable_RESBPWPCTRL"></a><ins>Unpredictable_RESBPWPCTRL,
                           // Debug breakpoints: not implemented
                           </ins><a id="Unpredictable_BPNOTIMPL" name="Unpredictable_BPNOTIMPL"></a><ins>Unpredictable_BPNOTIMPL,
                           // Debug breakpoints: reserved type
                           </ins><a id="Unpredictable_RESBPTYPE" name="Unpredictable_RESBPTYPE"></a><ins>Unpredictable_RESBPTYPE,
                           // Debug breakpoints: not-context-aware breakpoint
                           </ins><a id="Unpredictable_BPNOTCTXCMP" name="Unpredictable_BPNOTCTXCMP"></a><ins>Unpredictable_BPNOTCTXCMP,
                           // Debug breakpoints: match on 2nd halfword of instruction
                           </ins><a id="Unpredictable_BPMATCHHALF" name="Unpredictable_BPMATCHHALF"></a><ins>Unpredictable_BPMATCHHALF,
                           // Debug breakpoints: mismatch on 2nd halfword of instruction
                           </ins><a id="Unpredictable_BPMISMATCHHALF" name="Unpredictable_BPMISMATCHHALF"></a><ins>Unpredictable_BPMISMATCHHALF,
                           // Debug: restart to a misaligned AArch32 PC value
                           </ins><a id="Unpredictable_RESTARTALIGNPC" name="Unpredictable_RESTARTALIGNPC"></a><ins>Unpredictable_RESTARTALIGNPC,
                           // Debug: restart to a not-zero-extended AArch32 PC value
                           </ins><a id="Unpredictable_RESTARTZEROUPPERPC" name="Unpredictable_RESTARTZEROUPPERPC"></a><ins>Unpredictable_RESTARTZEROUPPERPC,
                           // Zero top 32 bits of X registers in AArch32 state
                           </ins><a id="Unpredictable_ZEROUPPER" name="Unpredictable_ZEROUPPER"></a><ins>Unpredictable_ZEROUPPER,
                           // Zero top 32 bits of PC on illegal return to AArch32 state
                           </ins><a id="Unpredictable_ERETZEROUPPERPC" name="Unpredictable_ERETZEROUPPERPC"></a><ins>Unpredictable_ERETZEROUPPERPC,
                           // Force address to be aligned when interworking branch to A32 state
                           </ins><a id="Unpredictable_A32FORCEALIGNPC" name="Unpredictable_A32FORCEALIGNPC"></a><ins>Unpredictable_A32FORCEALIGNPC,
                           // SMC disabled
                           </ins><a id="Unpredictable_SMD" name="Unpredictable_SMD"></a><ins>Unpredictable_SMD,
                           // FF speculation
                           </ins><a id="Unpredictable_NONFAULT" name="Unpredictable_NONFAULT"></a><ins>Unpredictable_NONFAULT,
                           // Zero top bits of Z registers in EL change
                           </ins><a id="Unpredictable_SVEZEROUPPER" name="Unpredictable_SVEZEROUPPER"></a><ins>Unpredictable_SVEZEROUPPER,
                           // Load mem data in NF loads
                           </ins><a id="Unpredictable_SVELDNFDATA" name="Unpredictable_SVELDNFDATA"></a><ins>Unpredictable_SVELDNFDATA,
                           // Write zeros in NF loads
                           </ins><a id="Unpredictable_SVELDNFZERO" name="Unpredictable_SVELDNFZERO"></a><ins>Unpredictable_SVELDNFZERO,
                           // Access Flag Update by HW
                           </ins><a id="Unpredictable_AFUPDATE" name="Unpredictable_AFUPDATE"></a><ins>Unpredictable_AFUPDATE,
                           // Consider SCTLR[].IESB in Debug state
                           </ins><a id="Unpredictable_IESBinDebug" name="Unpredictable_IESBinDebug"></a><ins>Unpredictable_IESBinDebug,
                           // No events selected in PMSEVFR_EL1
                           </ins><a id="Unpredictable_ZEROPMSEVFR" name="Unpredictable_ZEROPMSEVFR"></a><ins>Unpredictable_ZEROPMSEVFR,
                           // No operation type selected in PMSFCR_EL1
                           </ins><a id="Unpredictable_NOOPTYPES" name="Unpredictable_NOOPTYPES"></a><ins>Unpredictable_NOOPTYPES,
                           // Zero latency in PMSLATFR_EL1
                           </ins><a id="Unpredictable_ZEROMINLATENCY" name="Unpredictable_ZEROMINLATENCY"></a><ins>Unpredictable_ZEROMINLATENCY,
                           // Zero saved BType value in SPSR_ELx/DPSR_EL0
                           </ins><a id="Unpredictable_ZEROBTYPE" name="Unpredictable_ZEROBTYPE"></a><ins>Unpredictable_ZEROBTYPE,
                           // Clearing DCC/ITR sticky flags when instruction is in flight
                           </ins><a id="Unpredictable_CLEARERRITEZERO" name="Unpredictable_CLEARERRITEZERO"></a><ins>Unpredictable_CLEARERRITEZERO};</ins><del>() then
        if PSTATE.nRW != '1' then
            PSTATE.TCO = spsr&lt;25>;
    return;</del></p></div><div class="ps" psname="shared.functions.vector.AdvSIMDExpandImm"><a id="shared.functions.vector.AdvSIMDExpandImm" name="shared.functions.vector.AdvSIMDExpandImm"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>vector</ins><del>system</del>/<ins>AdvSIMDExpandImm</ins><del>ShouldAdvanceIT</del></h3><p class="pseudocode"><ins>// AdvSIMDExpandImm()
// ==================

bits(64)</ins><del>boolean ShouldAdvanceIT;</del> <a id="impl-shared.AdvSIMDExpandImm.3" name="impl-shared.AdvSIMDExpandImm.3"></a><ins>AdvSIMDExpandImm(bit op, bits(4) cmode, bits(8) imm8)
    case cmode&lt;3:1> of
        when '000'
            imm64 = </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(24):imm8, 2);
        when '001'
            imm64 = </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(16):imm8:</ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(8), 2);
        when '010'
            imm64 = </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(8):imm8:</ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(16), 2);
        when '011'
            imm64 = </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(imm8:</ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(24), 2);
        when '100'
            imm64 = </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(8):imm8, 4);
        when '101'
            imm64 = </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(imm8:</ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(8), 4);
        when '110'
            if cmode&lt;0> == '0' then
                imm64 = </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(16):imm8:</ins><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><ins>(8), 2);
            else
                imm64 = </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(8):imm8:</ins><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><ins>(16), 2);
        when '111'
            if cmode&lt;0> == '0' &amp;&amp; op == '0' then
                imm64 = </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(imm8, 8);
            if cmode&lt;0> == '0' &amp;&amp; op == '1' then
                imm8a = </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(imm8&lt;7>, 8); imm8b = </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(imm8&lt;6>, 8);
                imm8c = </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(imm8&lt;5>, 8); imm8d = </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(imm8&lt;4>, 8);
                imm8e = </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(imm8&lt;3>, 8); imm8f = </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(imm8&lt;2>, 8);
                imm8g = </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(imm8&lt;1>, 8); imm8h = </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(imm8&lt;0>, 8);
                imm64 = imm8a:imm8b:imm8c:imm8d:imm8e:imm8f:imm8g:imm8h;
            if cmode&lt;0> == '1' &amp;&amp; op == '0' then
                imm32 = imm8&lt;7>:NOT(imm8&lt;6>):</ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(imm8&lt;6>,5):imm8&lt;5:0>:</ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(19);
                imm64 = </ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(imm32, 2);
            if cmode&lt;0> == '1' &amp;&amp; op == '1' then
                if </ins><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><ins>UsingAArch32</ins></a><ins>() then ReservedEncoding();
                imm64 = imm8&lt;7>:NOT(imm8&lt;6>):</ins><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><ins>Replicate</ins></a><ins>(imm8&lt;6>,8):imm8&lt;5:0>:</ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(48);

    return imm64;</ins></p></div><div class="ps" psname="shared.functions.vector.PolynomialMult"><a id="shared.functions.vector.PolynomialMult" name="shared.functions.vector.PolynomialMult"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>vector</ins><del>system</del>/<ins>PolynomialMult</ins><del>SpeculationBarrier</del></h3><p class="pseudocode"><ins>// PolynomialMult()
// ================

bits(M+N) </ins><a id="impl-shared.PolynomialMult.2" name="impl-shared.PolynomialMult.2"></a><ins>PolynomialMult(bits(M) op1, bits(N) op2)
    result = </ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(M+N);
    extended_op2 = </ins><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><ins>ZeroExtend</ins></a><ins>(op2, M+N);
    for i=0 to M-1
        if op1&lt;i> == '1' then
            result = result EOR </ins><a href="shared_pseudocode.html#impl-shared.LSL.2" title="function: bits(N) LSL(bits(N) x, integer shift)"><ins>LSL</ins></a><ins>(extended_op2, i);
    return result;</ins><del>SpeculationBarrier();</del></p></div><div class="ps" psname="shared.functions.vector.SatQ"><a id="shared.functions.vector.SatQ" name="shared.functions.vector.SatQ"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>vector</ins><del>system</del>/<ins>SatQ</ins><del>SynchronizeContext</del></h3><p class="pseudocode"><ins>// SatQ()
// ======

(bits(N), boolean) </ins><a id="impl-shared.SatQ.3" name="impl-shared.SatQ.3"></a><ins>SatQ(integer i, integer N, boolean unsigned)
    (result, sat) = if unsigned then </ins><a href="shared_pseudocode.html#impl-shared.UnsignedSatQ.2" title="function: (bits(N), boolean) UnsignedSatQ(integer i, integer N)"><ins>UnsignedSatQ</ins></a><ins>(i, N) else </ins><a href="shared_pseudocode.html#impl-shared.SignedSatQ.2" title="function: (bits(N), boolean) SignedSatQ(integer i, integer N)"><ins>SignedSatQ</ins></a><ins>(i, N);
    return (result, sat);</ins><del>SynchronizeContext();</del></p></div><div class="ps" psname="shared.functions.vector.SignedSatQ"><a id="shared.functions.vector.SignedSatQ" name="shared.functions.vector.SignedSatQ"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>vector</ins><del>system</del>/<ins>SignedSatQ</ins><del>SynchronizeErrors</del></h3><p class="pseudocode"><ins>// SignedSatQ()
// ============

(bits(N), boolean)</ins><del>// Implements the error synchronization event.</del> <a id="impl-shared.SignedSatQ.2" name="impl-shared.SignedSatQ.2"></a><ins>SignedSatQ(integer i, integer N)
    if i > 2^(N-1) - 1 then
        result = 2^(N-1) - 1;  saturated = TRUE;
    elsif i &lt; -(2^(N-1)) then
        result = -(2^(N-1));  saturated = TRUE;
    else
        result = i;  saturated = FALSE;
    return (result&lt;N-1:0>, saturated);</ins><del>SynchronizeErrors();</del></p></div><div class="ps" psname="shared.functions.vector.UnsignedRSqrtEstimate"><a id="shared.functions.vector.UnsignedRSqrtEstimate" name="shared.functions.vector.UnsignedRSqrtEstimate"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>vector</ins><del>system</del>/<ins>UnsignedRSqrtEstimate</ins><del>TakeUnmaskedPhysicalSErrorInterrupts</del></h3><p class="pseudocode"><ins>// UnsignedRSqrtEstimate()
// =======================

bits(N)</ins><del>// Take any pending unmasked physical SError interrupt</del> <a id="impl-shared.UnsignedRSqrtEstimate.1" name="impl-shared.UnsignedRSqrtEstimate.1"></a><ins>UnsignedRSqrtEstimate(bits(N) operand)
    assert N IN {16,32};
    if operand&lt;N-1:N-2> == '00' then  // Operands &lt;= 0x3FFFFFFF produce 0xFFFFFFFF
        result =</ins><del>TakeUnmaskedPhysicalSErrorInterrupts(boolean iesb_req);</del> <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><ins>(N);
    else
        // input is in the range 0x40000000 .. 0xffffffff representing [0.25 .. 1.0)

        // estimate is in the range 256 .. 511 representing [1.0 .. 2.0)
        case N of
            when 16 estimate = </ins><a href="shared_pseudocode.html#impl-shared.RecipSqrtEstimate.1" title="function: integer RecipSqrtEstimate(integer a)"><ins>RecipSqrtEstimate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(operand&lt;15:7>));
            when 32 estimate = </ins><a href="shared_pseudocode.html#impl-shared.RecipSqrtEstimate.1" title="function: integer RecipSqrtEstimate(integer a)"><ins>RecipSqrtEstimate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(operand&lt;31:23>));

        // result is in the range 0x80000000 .. 0xff800000 representing [1.0 .. 2.0)
        result = estimate&lt;8:0> : </ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(N-9);

    return result;</ins></p></div><div class="ps" psname="shared.functions.vector.UnsignedRecipEstimate"><a id="shared.functions.vector.UnsignedRecipEstimate" name="shared.functions.vector.UnsignedRecipEstimate"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>vector</ins><del>system</del>/<ins>UnsignedRecipEstimate</ins><del>TakeUnmaskedSErrorInterrupts</del></h3><p class="pseudocode"><ins>// UnsignedRecipEstimate()
// =======================

bits(N)</ins><del>// Take any pending unmasked physical SError interrupt or unmasked virtual SError
// interrupt.</del> <a id="impl-shared.UnsignedRecipEstimate.1" name="impl-shared.UnsignedRecipEstimate.1"></a><ins>UnsignedRecipEstimate(bits(N) operand)
    assert N IN {16,32};
    if operand&lt;N-1> == '0' then  // Operands &lt;= 0x7FFFFFFF produce 0xFFFFFFFF
        result =</ins><del>TakeUnmaskedSErrorInterrupts();</del> <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><ins>Ones</ins></a><ins>(N);
    else
        // input is in the range 0x80000000 .. 0xffffffff representing [0.5 .. 1.0)

        // estimate is in the range 256 to 511 representing [1.0 .. 2.0)
        case N of
            when 16 estimate = </ins><a href="shared_pseudocode.html#impl-shared.RecipEstimate.1" title="function: integer RecipEstimate(integer a)"><ins>RecipEstimate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(operand&lt;15:7>));
            when 32 estimate = </ins><a href="shared_pseudocode.html#impl-shared.RecipEstimate.1" title="function: integer RecipEstimate(integer a)"><ins>RecipEstimate</ins></a><ins>(</ins><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><ins>UInt</ins></a><ins>(operand&lt;31:23>));

        // result is in the range 0x80000000 .. 0xff800000 representing [1.0 .. 2.0)
        result = estimate&lt;8:0> : </ins><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><ins>Zeros</ins></a><ins>(N-9);

    return result;</ins></p></div><div class="ps" psname="shared.functions.vector.UnsignedSatQ"><a id="shared.functions.vector.UnsignedSatQ" name="shared.functions.vector.UnsignedSatQ"></a><h3 class="pseudocode">
            Library pseudocode for shared/functions/<ins>vector</ins><del>system</del>/<ins>UnsignedSatQ</ins><del>ThisInstr</del></h3><p class="pseudocode"><ins>// UnsignedSatQ()
// ==============

(bits(N), boolean)</ins><del>bits(32)</del> <a id="impl-shared.UnsignedSatQ.2" name="impl-shared.UnsignedSatQ.2"></a><ins>UnsignedSatQ(integer i, integer N)
    if i > 2^N - 1 then
        result = 2^N - 1;  saturated = TRUE;
    elsif i &lt; 0 then
        result = 0;  saturated = TRUE;
    else
        result = i;  saturated = FALSE;
    return (result&lt;N-1:0>, saturated);</ins><del>ThisInstr();</del></p></div><div class="ps" psname="shared.translation.attrs.CombineS1S2AttrHints"><a id="shared.translation.attrs.CombineS1S2AttrHints" name="shared.translation.attrs.CombineS1S2AttrHints"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>translation</ins><del>functions</del>/<ins>attrs</ins><del>system</del>/<ins>CombineS1S2AttrHints</ins><del>ThisInstrLength</del></h3><p class="pseudocode"><ins>// CombineS1S2AttrHints()
// ======================

MemAttrHints</ins><del>integer</del> <a id="impl-shared.CombineS1S2AttrHints.2" name="impl-shared.CombineS1S2AttrHints.2"></a><ins>CombineS1S2AttrHints(</ins><del>ThisInstrLength();</del><a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )"><ins>MemAttrHints</ins></a><ins> s1desc, </ins><a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )"><ins>MemAttrHints</ins></a><ins> s2desc)

    </ins><a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )"><ins>MemAttrHints</ins></a><ins> result;

    if </ins><a href="shared_pseudocode.html#impl-shared.HaveStage2MemAttrControl.0" title="function: boolean HaveStage2MemAttrControl()"><ins>HaveStage2MemAttrControl</ins></a><ins>() &amp;&amp; HCR_EL2.FWB == '1' then
        if s2desc.attrs == </ins><a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'"><ins>MemAttr_WB</ins></a><ins> then
            result.attrs = s1desc.attrs;
        elsif s2desc.attrs == </ins><a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'"><ins>MemAttr_WT</ins></a><ins> then
            result.attrs = </ins><a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'"><ins>MemAttr_WB</ins></a><ins>;
        else
            result.attrs = </ins><a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'"><ins>MemAttr_NC</ins></a><ins>;
    else
        if s2desc.attrs == '01' || s1desc.attrs == '01' then
            result.attrs = bits(2) UNKNOWN;   // Reserved
        elsif s2desc.attrs == </ins><a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'"><ins>MemAttr_NC</ins></a><ins> || s1desc.attrs == </ins><a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'"><ins>MemAttr_NC</ins></a><ins> then
            result.attrs = </ins><a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'"><ins>MemAttr_NC</ins></a><ins>;        // Non-cacheable
        elsif s2desc.attrs == </ins><a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'"><ins>MemAttr_WT</ins></a><ins> || s1desc.attrs == </ins><a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'"><ins>MemAttr_WT</ins></a><ins> then
            result.attrs = </ins><a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'"><ins>MemAttr_WT</ins></a><ins>;        // Write-through
        else
            result.attrs = </ins><a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'"><ins>MemAttr_WB</ins></a><ins>;        // Write-back

    result.hints = s1desc.hints;
    result.transient = s1desc.transient;

    return result;</ins></p></div><div class="ps" psname="shared.translation.attrs.CombineS1S2Desc"><a id="shared.translation.attrs.CombineS1S2Desc" name="shared.translation.attrs.CombineS1S2Desc"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>translation</ins><del>functions</del>/<ins>attrs</ins><del>system</del>/<ins>CombineS1S2Desc</ins><del>Unreachable</del></h3><p class="pseudocode"><ins>// CombineS1S2Desc()
// =================
// Combines the address descriptors from stage 1 and stage 2

AddressDescriptor </ins><a id="impl-shared.CombineS1S2Desc.2" name="impl-shared.CombineS1S2Desc.2"></a><ins>CombineS1S2Desc(</ins><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><ins>AddressDescriptor</ins></a><ins> s1desc, </ins><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><ins>AddressDescriptor</ins></a><ins> s2desc)

    </ins><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><ins>AddressDescriptor</ins></a><ins> result;

    result.paddress = s2desc.paddress;

    if </ins><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><ins>(s1desc) || </ins><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><ins>(s2desc) then
        result = if </ins><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><ins>IsFault</ins></a><ins>(s1desc) then s1desc else s2desc;
    elsif s2desc.memattrs.type == </ins><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Device</ins></a><ins> || s1desc.memattrs.type == </ins><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Device</ins></a><ins> then
        result.memattrs.type = </ins><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Device</ins></a><ins>;
        if s1desc.memattrs.type == </ins><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Normal</ins></a><ins> then
            result.memattrs.device = s2desc.memattrs.device;
        elsif s2desc.memattrs.type == </ins><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Normal</ins></a><ins> then
            result.memattrs.device = s1desc.memattrs.device;
        else                    // Both Device
            result.memattrs.device = </ins><a href="shared_pseudocode.html#impl-shared.CombineS1S2Device.2" title="function: DeviceType CombineS1S2Device(DeviceType s1device, DeviceType s2device)"><ins>CombineS1S2Device</ins></a><ins>(s1desc.memattrs.device,
                                                       s2desc.memattrs.device);
        result.memattrs.tagged = FALSE;
    else                        // Both Normal
        result.memattrs.type = </ins><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Normal</ins></a><ins>;
        result.memattrs.device = </ins><a href="shared_pseudocode.html#DeviceType" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType</ins></a><ins> UNKNOWN;
        result.memattrs.inner = </ins><a href="shared_pseudocode.html#impl-shared.CombineS1S2AttrHints.2" title="function: MemAttrHints CombineS1S2AttrHints(MemAttrHints s1desc, MemAttrHints s2desc)"><ins>CombineS1S2AttrHints</ins></a><ins>(s1desc.memattrs.inner, s2desc.memattrs.inner);
        result.memattrs.outer = </ins><a href="shared_pseudocode.html#impl-shared.CombineS1S2AttrHints.2" title="function: MemAttrHints CombineS1S2AttrHints(MemAttrHints s1desc, MemAttrHints s2desc)"><ins>CombineS1S2AttrHints</ins></a><ins>(s1desc.memattrs.outer, s2desc.memattrs.outer);
        result.memattrs.shareable = (s1desc.memattrs.shareable || s2desc.memattrs.shareable);
        result.memattrs.outershareable = (s1desc.memattrs.outershareable ||
                                          s2desc.memattrs.outershareable);
        result.memattrs.tagged = (s1desc.memattrs.tagged &amp;&amp;
                                  result.memattrs.inner.attrs == </ins><a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'"><ins>MemAttr_WB</ins></a><ins> &amp;&amp;
                                  result.memattrs.inner.hints == </ins><a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'"><ins>MemHint_RWA</ins></a><ins> &amp;&amp;
                                  result.memattrs.outer.attrs == </ins><a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'"><ins>MemAttr_WB</ins></a><ins> &amp;&amp;
                                  result.memattrs.outer.hints == </ins><a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'"><ins>MemHint_RWA</ins></a><ins>);

    result.memattrs = </ins><a href="shared_pseudocode.html#impl-shared.MemAttrDefaults.1" title="function: MemoryAttributes MemAttrDefaults(MemoryAttributes memattrs)"><ins>MemAttrDefaults</ins></a><ins>(result.memattrs);

    return result;</ins><del>Unreachable()
    assert FALSE;</del></p></div><div class="ps" psname="shared.translation.attrs.CombineS1S2Device"><a id="shared.translation.attrs.CombineS1S2Device" name="shared.translation.attrs.CombineS1S2Device"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>translation</ins><del>functions</del>/<ins>attrs</ins><del>system</del>/<ins>CombineS1S2Device</ins><del>UsingAArch32</del></h3><p class="pseudocode"><ins>// CombineS1S2Device()
// ===================
// Combines device types from stage 1 and stage 2
</ins><del>// UsingAArch32()
// ==============
// Return TRUE if the current Exception level is using AArch32, FALSE if using AArch64.
</del>
<ins>DeviceType</ins><del>boolean</del> <a id="impl-shared.CombineS1S2Device.2" name="impl-shared.CombineS1S2Device.2"></a><ins>CombineS1S2Device(</ins><del>UsingAArch32()
    boolean aarch32 = (PSTATE.nRW == '1');
    if !</del><a href="shared_pseudocode.html#DeviceType" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType</ins></a><a href="shared_pseudocode.html#impl-shared.HaveAnyAArch32.0" title="function: boolean HaveAnyAArch32()"><del>HaveAnyAArch32</del></a> <ins>s1device,</ins><del>() then assert !aarch32;
    if</del> <a href="shared_pseudocode.html#DeviceType" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType</ins></a><a href="shared_pseudocode.html#impl-shared.HighestELUsingAArch32.0" title="function: boolean HighestELUsingAArch32()"><del>HighestELUsingAArch32</del></a><ins> s2device)

    if s2device == </ins><a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType_nGnRnE</ins></a><ins> || s1device == </ins><a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType_nGnRnE</ins></a><ins> then
        result = </ins><a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType_nGnRnE</ins></a><ins>;
    elsif s2device == </ins><a href="shared_pseudocode.html#DeviceType_nGnRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType_nGnRE</ins></a><ins> || s1device == </ins><a href="shared_pseudocode.html#DeviceType_nGnRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType_nGnRE</ins></a><ins> then
        result = </ins><a href="shared_pseudocode.html#DeviceType_nGnRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType_nGnRE</ins></a><ins>;
    elsif s2device == </ins><a href="shared_pseudocode.html#DeviceType_nGRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType_nGRE</ins></a><ins> || s1device == </ins><a href="shared_pseudocode.html#DeviceType_nGRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType_nGRE</ins></a><ins> then
        result = </ins><a href="shared_pseudocode.html#DeviceType_nGRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType_nGRE</ins></a><ins>;
    else
        result = </ins><a href="shared_pseudocode.html#DeviceType_GRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType_GRE</ins></a><ins>;

    return result;</ins><del>() then assert aarch32;
    return aarch32;</del></p></div><div class="ps" psname="shared.translation.attrs.LongConvertAttrsHints"><a id="shared.translation.attrs.LongConvertAttrsHints" name="shared.translation.attrs.LongConvertAttrsHints"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>translation</ins><del>functions</del>/<ins>attrs</ins><del>system</del>/<ins>LongConvertAttrsHints</ins><del>WaitForEvent</del></h3><p class="pseudocode"><ins>// LongConvertAttrsHints()
// =======================
// Convert the long attribute fields for Normal memory as used in the MAIR fields
// to orthogonal attributes and hints

MemAttrHints</ins><del>// WaitForEvent()
// ==============
// PE suspends its operation and enters a low-power state
// if the Event Register is clear when the WFE is executed</del> <a id="impl-shared.LongConvertAttrsHints.2" name="impl-shared.LongConvertAttrsHints.2"></a><ins>LongConvertAttrsHints(bits(4) attrfield,</ins><del>WaitForEvent()
    if EventRegister == '0' then</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><a href="shared_pseudocode.html#impl-shared.EnterLowPowerState.0" title="function: EnterLowPowerState()"><del>EnterLowPowerState</del></a><ins> acctype)
    assert !</ins><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><ins>(attrfield);
    </ins><a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )"><ins>MemAttrHints</ins></a><ins> result;
    if </ins><a href="shared_pseudocode.html#impl-shared.S1CacheDisabled.1" title="function: boolean S1CacheDisabled(AccType acctype)"><ins>S1CacheDisabled</ins></a><ins>(acctype) then             // Force Non-cacheable
        result.attrs = </ins><a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'"><ins>MemAttr_NC</ins></a><ins>;
        result.hints = </ins><a href="shared_pseudocode.html#MemHint_No" title="constant bits(2) MemHint_No = '00'"><ins>MemHint_No</ins></a><ins>;
    else
        if attrfield&lt;3:2> == '00' then          // Write-through transient
            result.attrs = </ins><a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'"><ins>MemAttr_WT</ins></a><ins>;
            result.hints = attrfield&lt;1:0>;
            result.transient = TRUE;
        elsif attrfield&lt;3:0> == '0100' then     // Non-cacheable (no allocate)
            result.attrs = </ins><a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'"><ins>MemAttr_NC</ins></a><ins>;
            result.hints = </ins><a href="shared_pseudocode.html#MemHint_No" title="constant bits(2) MemHint_No = '00'"><ins>MemHint_No</ins></a><ins>;
            result.transient = FALSE;
        elsif attrfield&lt;3:2> == '01' then       // Write-back transient
            result.attrs = </ins><a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'"><ins>MemAttr_WB</ins></a><ins>;
            result.hints = attrfield&lt;1:0>;
            result.transient = TRUE;
        else                                    // Write-through/Write-back non-transient
            result.attrs = attrfield&lt;3:2>;
            result.hints = attrfield&lt;1:0>;
            result.transient = FALSE;

    return result;</ins><del>();
    return;</del></p></div><div class="ps" psname="shared.translation.attrs.MemAttrDefaults"><a id="shared.translation.attrs.MemAttrDefaults" name="shared.translation.attrs.MemAttrDefaults"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>translation</ins><del>functions</del>/<ins>attrs</ins><del>system</del>/<ins>MemAttrDefaults</ins><del>WaitForInterrupt</del></h3><p class="pseudocode"><ins>// MemAttrDefaults()
// =================
// Supply default values for memory attributes, including overriding the shareability attributes
// for Device and Non-cacheable memory types.

MemoryAttributes</ins><del>// WaitForInterrupt()
// ==================
// PE suspends its operation to enter a low-power state
// until a WFI wake-up event occurs or the PE is reset</del> <a id="impl-shared.MemAttrDefaults.1" name="impl-shared.MemAttrDefaults.1"></a><ins>MemAttrDefaults(</ins><del>WaitForInterrupt()</del><a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType type, DeviceType device, MemAttrHints inner, MemAttrHints outer, boolean tagged, boolean shareable, boolean outershareable )"><ins>MemoryAttributes</ins></a><a href="shared_pseudocode.html#impl-shared.EnterLowPowerState.0" title="function: EnterLowPowerState()"><del>EnterLowPowerState</del></a><ins> memattrs)

    if memattrs.type == </ins><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Device</ins></a><ins> then
        memattrs.inner = </ins><a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )"><ins>MemAttrHints</ins></a><ins> UNKNOWN;
        memattrs.outer = </ins><a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )"><ins>MemAttrHints</ins></a><ins> UNKNOWN;
        memattrs.shareable = TRUE;
        memattrs.outershareable = TRUE;
    else
        memattrs.device = </ins><a href="shared_pseudocode.html#DeviceType" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType</ins></a><ins> UNKNOWN;
        if memattrs.inner.attrs == </ins><a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'"><ins>MemAttr_NC</ins></a><ins> &amp;&amp; memattrs.outer.attrs == </ins><a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'"><ins>MemAttr_NC</ins></a> <ins>then
            memattrs.shareable = TRUE;
            memattrs.outershareable = TRUE;

    return memattrs;</ins><del>();
    return;</del></p></div><div class="ps" psname="shared.translation.attrs.S1CacheDisabled"><a id="shared.translation.attrs.S1CacheDisabled" name="shared.translation.attrs.S1CacheDisabled"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>translation</ins><del>functions</del>/<ins>attrs</ins><del>unpredictable</del>/<ins>S1CacheDisabled</ins><del>ConstrainUnpredictable</del></h3><p class="pseudocode"><ins>// S1CacheDisabled()
// =================
</ins><del>// ConstrainUnpredictable()
// ========================
// Return the appropriate Constraint result to control the caller's behavior. The return value
// is IMPLEMENTATION DEFINED within a permitted list for each UNPREDICTABLE case.
// (The permitted list is determined by an assert or case statement at the call site.)
</del>
<ins>boolean</ins><del>// NOTE: This version of the function uses an Unpredictable argument to define the call site.
// This argument does not appear in the version used in the ARMv8 Architecture Reference Manual.
// The extra argument is used here to allow this example definition. This is an example only and
// does not imply a fixed implementation of these behaviors. Indeed the intention is that it should
// be defined by each implementation, according to its implementation choices.

Constraint</del> <a id="impl-shared.S1CacheDisabled.1" name="impl-shared.S1CacheDisabled.1"></a><ins>S1CacheDisabled(</ins><del>ConstrainUnpredictable(</del><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><a href="shared_pseudocode.html#Unpredictable" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable</del></a> <ins>acctype)
    if</ins><del>which)
    case which of
        when</del> <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><a href="shared_pseudocode.html#Unpredictable_WBOVERLAPLD" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_WBOVERLAPLD</del></a><ins>(</ins><del>return</del><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><ins>S1TranslationRegime</ins></a><a href="shared_pseudocode.html#Constraint_WBSUPPRESS" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_WBSUPPRESS</del></a><ins>()) then
        if PSTATE.EL ==</ins><del>; // return loaded value
        when</del> <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#Unpredictable_WBOVERLAPST" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_WBOVERLAPST</del></a> <ins>then
            enable = if acctype ==</ins><del>return</del> <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_NONE</del></a> <ins>then HSCTLR.I else HSCTLR.C;
        else
            enable = if acctype ==</ins><del>;     // store pre-writeback value
        when</del> <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><a href="shared_pseudocode.html#Unpredictable_LDPOVERLAP" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_LDPOVERLAP</del></a> <ins>then SCTLR.I else SCTLR.C;
    else
        enable = if acctype ==</ins><del>return</del> <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><a href="shared_pseudocode.html#Constraint_UNDEF" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_UNDEF</del></a> <ins>then</ins><del>;    // instruction is UNDEFINED
        when</del> <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><ins>SCTLR</ins></a><a href="shared_pseudocode.html#Unpredictable_BASEOVERLAP" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_BASEOVERLAP</del></a><ins>[].I else</ins><del>return</del> <del>;     // use original address
        when </del><a href="shared_pseudocode.html#Unpredictable_DATAOVERLAP" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_DATAOVERLAP</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_NONE</del></a><del>;     // store original value
        when </del><a href="shared_pseudocode.html#Unpredictable_DEVPAGE2" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_DEVPAGE2</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FAULT</del></a><del>;    // take an alignment fault
        when </del><a href="shared_pseudocode.html#Unpredictable_INSTRDEVICE" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_INSTRDEVICE</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_NONE</del></a><del>;     // Do not take a fault
        when </del><a href="shared_pseudocode.html#Unpredictable_RESCPACR" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESCPACR</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_UNKNOWN</del></a><del>;  // Map to UNKNOWN value
        when </del><a href="shared_pseudocode.html#Unpredictable_RESMAIR" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESMAIR</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_UNKNOWN</del></a><del>;  // Map to UNKNOWN value
        when </del><a href="shared_pseudocode.html#Unpredictable_RESTEXCB" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESTEXCB</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_UNKNOWN</del></a><del>;  // Map to UNKNOWN value
        when </del><a href="shared_pseudocode.html#Unpredictable_RESDACR" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESDACR</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_UNKNOWN</del></a><del>;  // Map to UNKNOWN value
        when </del><a href="shared_pseudocode.html#Unpredictable_RESPRRR" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESPRRR</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_UNKNOWN</del></a><del>;  // Map to UNKNOWN value
        when </del><a href="shared_pseudocode.html#Unpredictable_RESVTCRS" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESVTCRS</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_UNKNOWN</del></a><del>;  // Map to UNKNOWN value
        when </del><a href="shared_pseudocode.html#Unpredictable_RESTnSZ" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESTnSZ</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FORCE</del></a><del>;    // Map to the limit value
        when </del><a href="shared_pseudocode.html#Unpredictable_OORTnSZ" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_OORTnSZ</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FORCE</del></a><del>;    // Map to the limit value
        when </del><a href="shared_pseudocode.html#Unpredictable_LARGEIPA" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_LARGEIPA</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FORCE</del></a><del>;    // Restrict the inputsize to the PAMax value
        when </del><a href="shared_pseudocode.html#Unpredictable_ESRCONDPASS" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_ESRCONDPASS</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FALSE</del></a><del>;    // Report as "AL"
        when </del><a href="shared_pseudocode.html#Unpredictable_ILZEROIT" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_ILZEROIT</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FALSE</del></a><del>;    // Do not zero PSTATE.IT
        when </del><a href="shared_pseudocode.html#Unpredictable_ILZEROT" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_ILZEROT</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FALSE</del></a><del>;    // Do not zero PSTATE.T
        when </del><a href="shared_pseudocode.html#Unpredictable_BPVECTORCATCHPRI" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_BPVECTORCATCHPRI</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_TRUE</del></a><del>;     // Debug Vector Catch: match on 2nd halfword
        when </del><a href="shared_pseudocode.html#Unpredictable_VCMATCHHALF" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_VCMATCHHALF</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FALSE</del></a><del>;    // No match
        when </del><a href="shared_pseudocode.html#Unpredictable_VCMATCHDAPA" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_VCMATCHDAPA</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FALSE</del></a><del>;    // No match on Data Abort or Prefetch abort
        when </del><a href="shared_pseudocode.html#Unpredictable_WPMASKANDBAS" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_WPMASKANDBAS</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FALSE</del></a><del>;    // Watchpoint disabled
        when </del><a href="shared_pseudocode.html#Unpredictable_WPBASCONTIGUOUS" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_WPBASCONTIGUOUS</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FALSE</del></a><del>;    // Watchpoint disabled
        when </del><a href="shared_pseudocode.html#Unpredictable_RESWPMASK" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESWPMASK</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_DISABLED</del></a><del>; // Watchpoint disabled
        when </del><a href="shared_pseudocode.html#Unpredictable_WPMASKEDBITS" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_WPMASKEDBITS</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FALSE</del></a><del>;    // Watchpoint disabled
        when </del><a href="shared_pseudocode.html#Unpredictable_RESBPWPCTRL" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESBPWPCTRL</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_DISABLED</del></a><del>; // Breakpoint/watchpoint disabled
        when </del><a href="shared_pseudocode.html#Unpredictable_BPNOTIMPL" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_BPNOTIMPL</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_DISABLED</del></a><del>; // Breakpoint disabled
        when </del><a href="shared_pseudocode.html#Unpredictable_RESBPTYPE" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESBPTYPE</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_DISABLED</del></a><del>; // Breakpoint disabled
        when </del><a href="shared_pseudocode.html#Unpredictable_BPNOTCTXCMP" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_BPNOTCTXCMP</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_DISABLED</del></a><del>; // Breakpoint disabled
        when </del><a href="shared_pseudocode.html#Unpredictable_BPMATCHHALF" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_BPMATCHHALF</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FALSE</del></a><del>;    // No match
        when </del><a href="shared_pseudocode.html#Unpredictable_BPMISMATCHHALF" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_BPMISMATCHHALF</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FALSE</del></a><del>;    // No match
        when </del><a href="shared_pseudocode.html#Unpredictable_RESTARTALIGNPC" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESTARTALIGNPC</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FALSE</del></a><del>;    // Do not force alignment
        when </del><a href="shared_pseudocode.html#Unpredictable_RESTARTZEROUPPERPC" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_RESTARTZEROUPPERPC</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_TRUE</del></a><del>;     // Force zero extension
        when </del><a href="shared_pseudocode.html#Unpredictable_ZEROUPPER" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_ZEROUPPER</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_TRUE</del></a><del>;     // zero top halves of X registers
        when </del><a href="shared_pseudocode.html#Unpredictable_ERETZEROUPPERPC" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_ERETZEROUPPERPC</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_TRUE</del></a><del>;     // zero top half of PC
        when </del><a href="shared_pseudocode.html#Unpredictable_A32FORCEALIGNPC" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_A32FORCEALIGNPC</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FALSE</del></a><del>;    // Do not force alignment
        when </del><a href="shared_pseudocode.html#Unpredictable_SMD" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_SMD</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_UNDEF" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_UNDEF</del></a><del>;    // disabled SMC is Unallocated
        when </del><a href="shared_pseudocode.html#Unpredictable_NONFAULT" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_NONFAULT</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FALSE</del></a><del>;    // Speculation enabled
        when </del><a href="shared_pseudocode.html#Unpredictable_SVEZEROUPPER" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_SVEZEROUPPER</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_TRUE</del></a><del>;     // zero top bits of Z registers
        when </del><a href="shared_pseudocode.html#Unpredictable_SVELDNFDATA" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_SVELDNFDATA</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_TRUE</del></a><del>;     // Load mem data in NF loads
        when </del><a href="shared_pseudocode.html#Unpredictable_SVELDNFZERO" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_SVELDNFZERO</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_TRUE</del></a><del>;     // Write zeros in NF loads
        when </del><a href="shared_pseudocode.html#Unpredictable_AFUPDATE" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_AFUPDATE</del></a><del>     // AF update for alignment or permission fault
            return </del><a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_TRUE</del></a><del>;
        when </del><a href="shared_pseudocode.html#Unpredictable_IESBinDebug" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_IESBinDebug</del></a><del>  // Use SCTLR[].IESB in Debug state
            return </del><a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_TRUE</del></a><del>;
        when </del><a href="shared_pseudocode.html#Unpredictable_ZEROBTYPE" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_ZEROBTYPE</del></a><del>
            return </del><a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_TRUE</del></a><del>;    // Save BTYPE in SPSR_ELx/DPSR_EL0 as '00'
        when </del><a href="shared_pseudocode.html#Unpredictable_CLEARERRITEZERO" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable_CLEARERRITEZERO</del></a><del> // Clearing sticky errors when instruction in flight
            return </del><a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FALSE</del></a><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><ins>SCTLR</ins></a><a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_NONE</del></a><ins>[].C;
    return enable == '0';</ins><del>;</del></p></div><div class="ps" psname="shared.translation.attrs.S2AttrDecode"><a id="shared.translation.attrs.S2AttrDecode" name="shared.translation.attrs.S2AttrDecode"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>translation</ins><del>functions</del>/<ins>attrs</ins><del>unpredictable</del>/<ins>S2AttrDecode</ins><del>ConstrainUnpredictableBits</del></h3><p class="pseudocode"><ins>// S2AttrDecode()
// ==============
// Converts the Stage 2 attribute fields into orthogonal attributes and hints
</ins><del>// ConstrainUnpredictableBits()
// ============================
</del>
<ins>MemoryAttributes</ins><del>// This is a variant of ConstrainUnpredictable for when the result can be Constraint_UNKNOWN.
// If the result is Constraint_UNKNOWN then the function also returns UNKNOWN value, but that
// value is always an allocated value; that is, one for which the behavior is not itself
// CONSTRAINED.

// NOTE: This version of the function uses an Unpredictable argument to define the call site.
// This argument does not appear in the version used in the ARMv8 Architecture Reference Manual.
// See the NOTE on ConstrainUnpredictable() for more information.

// This is an example placeholder only and does not imply a fixed implementation of the bits part
// of the result, and may not be applicable in all cases.

(Constraint,bits(width))</del> <a id="impl-shared.S2AttrDecode.3" name="impl-shared.S2AttrDecode.3"></a><ins>S2AttrDecode(bits(2) SH, bits(4) attr,</ins><del>ConstrainUnpredictableBits(</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><a href="shared_pseudocode.html#Unpredictable" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable</del></a> <ins>acctype)</ins><del>which)

    c =</del>

    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType type, DeviceType device, MemAttrHints inner, MemAttrHints outer, boolean tagged, boolean shareable, boolean outershareable )"><ins>MemoryAttributes</ins></a><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><del>ConstrainUnpredictable</del></a> <ins>memattrs;
</ins><del>(which);
</del>
<ins>    apply_force_writeback =</ins><del>    if c ==</del> <a href="shared_pseudocode.html#impl-shared.HaveStage2MemAttrControl.0" title="function: boolean HaveStage2MemAttrControl()"><ins>HaveStage2MemAttrControl</ins></a><a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_UNKNOWN</del></a><ins>() &amp;&amp; HCR_EL2.FWB == '1';

    // Device memory
    if (apply_force_writeback &amp;&amp; attr&lt;2> == '0') || attr&lt;3:2> == '00' then
        memattrs.type =</ins><del>then
        return (c,</del> <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Device</ins></a><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><ins>;
        case attr&lt;1:0> of
            when '00'  memattrs.device = </ins><a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType_nGnRnE</ins></a><ins>;
            when '01'  memattrs.device = </ins><a href="shared_pseudocode.html#DeviceType_nGnRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType_nGnRE</ins></a><ins>;
            when '10'  memattrs.device = </ins><a href="shared_pseudocode.html#DeviceType_nGRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType_nGRE</ins></a><ins>;
            when '11'  memattrs.device = </ins><a href="shared_pseudocode.html#DeviceType_GRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><ins>DeviceType_GRE</ins></a><ins>;

    // Normal memory
    elsif attr&lt;1:0> != '00' then
        memattrs.type = </ins><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Normal</ins></a><ins>;
        if apply_force_writeback then
            memattrs.outer = </ins><a href="shared_pseudocode.html#impl-shared.S2ConvertAttrsHints.2" title="function: MemAttrHints S2ConvertAttrsHints(bits(2) attr, AccType acctype)"><ins>S2ConvertAttrsHints</ins></a><ins>(attr&lt;1:0>, acctype);
        else
            memattrs.outer = </ins><a href="shared_pseudocode.html#impl-shared.S2ConvertAttrsHints.2" title="function: MemAttrHints S2ConvertAttrsHints(bits(2) attr, AccType acctype)"><ins>S2ConvertAttrsHints</ins></a><ins>(attr&lt;3:2>, acctype);
        memattrs.inner = </ins><a href="shared_pseudocode.html#impl-shared.S2ConvertAttrsHints.2" title="function: MemAttrHints S2ConvertAttrsHints(bits(2) attr, AccType acctype)"><ins>S2ConvertAttrsHints</ins></a><ins>(attr&lt;1:0>, acctype);
        memattrs.shareable = SH&lt;1> == '1';
        memattrs.outershareable = SH == '10';

    else
        memattrs = </ins><a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType type, DeviceType device, MemAttrHints inner, MemAttrHints outer, boolean tagged, boolean shareable, boolean outershareable )"><ins>MemoryAttributes</ins></a><ins> UNKNOWN;    // Reserved

    return </ins><a href="shared_pseudocode.html#impl-shared.MemAttrDefaults.1" title="function: MemoryAttributes MemAttrDefaults(MemoryAttributes memattrs)"><ins>MemAttrDefaults</ins></a><ins>(memattrs);</ins><del>(width));           // See notes; this is an example implementation only
    else
        return (c, bits(width) UNKNOWN);    // bits result not used</del></p></div><div class="ps" psname="shared.translation.attrs.S2CacheDisabled"><a id="shared.translation.attrs.S2CacheDisabled" name="shared.translation.attrs.S2CacheDisabled"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>translation</ins><del>functions</del>/<ins>attrs</ins><del>unpredictable</del>/<ins>S2CacheDisabled</ins><del>ConstrainUnpredictableBool</del></h3><p class="pseudocode"><ins>// S2CacheDisabled()
// =================
</ins><del>// ConstrainUnpredictableBool()
// ============================

// This is a simple wrapper function for cases where the constrained result is either TRUE or FALSE.

// NOTE: This version of the function uses an Unpredictable argument to define the call site.
// This argument does not appear in the version used in the ARMv8 Architecture Reference Manual.
// See the NOTE on ConstrainUnpredictable() for more information.
</del>
boolean <a id="impl-shared.S2CacheDisabled.1" name="impl-shared.S2CacheDisabled.1"></a><ins>S2CacheDisabled(</ins><del>ConstrainUnpredictableBool(</del><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><a href="shared_pseudocode.html#Unpredictable" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable</del></a> <ins>acctype)
    if</ins><del>which)

    c =</del> <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><del>ConstrainUnpredictable</del></a><ins>(</ins><del>(which);
    assert c IN {</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_TRUE</del></a><ins>) then
        disable = if acctype ==</ins><del>,</del> <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_FALSE</del></a> <ins>then HCR2.ID else HCR2.CD;
    else
        disable = if acctype ==</ins><del>};
    return (c ==</del> <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_IFETCH</ins></a><a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_TRUE</del></a> <ins>then HCR_EL2.ID else HCR_EL2.CD;
    return disable == '1';</ins><del>);</del></p></div><div class="ps" psname="shared.translation.attrs.S2ConvertAttrsHints"><a id="shared.translation.attrs.S2ConvertAttrsHints" name="shared.translation.attrs.S2ConvertAttrsHints"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>translation</ins><del>functions</del>/<ins>attrs</ins><del>unpredictable</del>/<ins>S2ConvertAttrsHints</ins><del>ConstrainUnpredictableInteger</del></h3><p class="pseudocode"><ins>// S2ConvertAttrsHints()
// =====================
// Converts the attribute fields for Normal memory as used in stage 2
// descriptors to orthogonal attributes and hints
</ins><del>// ConstrainUnpredictableInteger()
// ===============================
</del>
<ins>MemAttrHints</ins><del>// This is a variant of ConstrainUnpredictable for when the result can be Constraint_UNKNOWN. If
// the result is Constraint_UNKNOWN then the function also returns an UNKNOWN value in the range
// low to high, inclusive.

// NOTE: This version of the function uses an Unpredictable argument to define the call site.
// This argument does not appear in the version used in the ARMv8 Architecture Reference Manual.
// See the NOTE on ConstrainUnpredictable() for more information.

// This is an example placeholder only and does not imply a fixed implementation of the integer part
// of the result.

(Constraint,integer)</del> <a id="impl-shared.S2ConvertAttrsHints.2" name="impl-shared.S2ConvertAttrsHints.2"></a><ins>S2ConvertAttrsHints(bits(2) attr,</ins><del>ConstrainUnpredictableInteger(integer low, integer high,</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a><a href="shared_pseudocode.html#Unpredictable" title="enumeration Unpredictable { Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,  Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,  Unpredictable_ERETZEROUPPERPC,  Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_AFUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_ZEROPMSEVFR,  Unpredictable_NOOPTYPES,  Unpredictable_ZEROMINLATENCY,  Unpredictable_ZEROBTYPE,  Unpredictable_CLEARERRITEZERO}"><del>Unpredictable</del></a> <ins>acctype)
    assert !</ins><del>which)

    c =</del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><ins>IsZero</ins></a><a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)"><del>ConstrainUnpredictable</del></a><ins>(attr);</ins><del>(which);

    if c ==</del>

    <a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )"><ins>MemAttrHints</ins></a><a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE, Constraint_FALSE, Constraint_DISABLED, Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS, Constraint_FAULT,  Constraint_FORCE, Constraint_FORCENOSLCHECK}"><del>Constraint_UNKNOWN</del></a><ins> result;

    if </ins><a href="shared_pseudocode.html#impl-shared.S2CacheDisabled.1" title="function: boolean S2CacheDisabled(AccType acctype)"><ins>S2CacheDisabled</ins></a><ins>(acctype) then                // Force Non-cacheable
        result.attrs = </ins><a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'"><ins>MemAttr_NC</ins></a><ins>;
        result.hints = </ins><a href="shared_pseudocode.html#MemHint_No" title="constant bits(2) MemHint_No = '00'"><ins>MemHint_No</ins></a><ins>;
    else
        case attr of
            when '01'                               // Non-cacheable (no allocate)
                result.attrs = </ins><a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'"><ins>MemAttr_NC</ins></a><ins>;
                result.hints = </ins><a href="shared_pseudocode.html#MemHint_No" title="constant bits(2) MemHint_No = '00'"><ins>MemHint_No</ins></a><ins>;
            when '10'                               // Write-through
                result.attrs = </ins><a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'"><ins>MemAttr_WT</ins></a><ins>;
                result.hints = </ins><a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'"><ins>MemHint_RWA</ins></a><ins>;
            when '11'                               // Write-back
                result.attrs = </ins><a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'"><ins>MemAttr_WB</ins></a><ins>;
                result.hints = </ins><a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'"><ins>MemHint_RWA</ins></a><ins>;

    result.transient = FALSE;

    return result;</ins><del>then
        return (c, low);                // See notes; this is an example implementation only
    else
        return (c, integer UNKNOWN);    // integer result not used</del></p></div><div class="ps" psname="shared.translation.attrs.ShortConvertAttrsHints"><a id="shared.translation.attrs.ShortConvertAttrsHints" name="shared.translation.attrs.ShortConvertAttrsHints"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>translation</ins><del>functions</del>/<ins>attrs</ins><del>unpredictable</del>/<ins>ShortConvertAttrsHints</ins><del>Constraint</del></h3><p class="pseudocode"><ins>// ShortConvertAttrsHints()
// ========================
// Converts the short attribute fields for Normal memory as used in the TTBR and
// TEX fields to orthogonal attributes and hints

MemAttrHints</ins><del>enumeration</del> <a id="impl-shared.ShortConvertAttrsHints.3" name="impl-shared.ShortConvertAttrsHints.3"></a><ins>ShortConvertAttrsHints(bits(2) RGN,</ins><del>Constraint    {// General</del> <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a> <ins>acctype, boolean secondstage)</ins><del>Constraint_NONE,              // Instruction executes with
                                                         //   no change or side-effect to its described behavior</del>

    <a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )"><ins>MemAttrHints</ins></a> <ins>result;

    if (!secondstage &amp;&amp;</ins><del>Constraint_UNKNOWN,           // Destination register has UNKNOWN value</del> <a href="shared_pseudocode.html#impl-shared.S1CacheDisabled.1" title="function: boolean S1CacheDisabled(AccType acctype)"><ins>S1CacheDisabled</ins></a><ins>(acctype)) || (secondstage &amp;&amp;</ins><del>Constraint_UNDEF,             // Instruction is UNDEFINED</del> <a href="shared_pseudocode.html#impl-shared.S2CacheDisabled.1" title="function: boolean S2CacheDisabled(AccType acctype)"><ins>S2CacheDisabled</ins></a><ins>(acctype)) then
       // Force Non-cacheable
        result.attrs =</ins><del>Constraint_UNDEFEL0,          // Instruction is UNDEFINED at EL0 only</del> <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'"><ins>MemAttr_NC</ins></a><ins>;
        result.hints =</ins><del>Constraint_NOP,               // Instruction executes as NOP</del> <a href="shared_pseudocode.html#MemHint_No" title="constant bits(2) MemHint_No = '00'"><ins>MemHint_No</ins></a><ins>;
    else
        case RGN of
            when '00'                   // Non-cacheable (no allocate)
                result.attrs =</ins><del>Constraint_TRUE,</del> <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'"><ins>MemAttr_NC</ins></a><ins>;
                result.hints =</ins><del>Constraint_FALSE,</del> <a href="shared_pseudocode.html#MemHint_No" title="constant bits(2) MemHint_No = '00'"><ins>MemHint_No</ins></a><ins>;
            when '01'                   // Write-back, Read and Write allocate
                result.attrs =</ins><del>Constraint_DISABLED,</del> <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'"><ins>MemAttr_WB</ins></a><ins>;
                result.hints =</ins><del>Constraint_UNCOND,            // Instruction executes unconditionally</del> <a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'"><ins>MemHint_RWA</ins></a><ins>;
            when '10'                   // Write-through, Read allocate
                result.attrs =</ins><del>Constraint_COND,              // Instruction executes conditionally</del> <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'"><ins>MemAttr_WT</ins></a><ins>;
                result.hints =</ins><del>Constraint_ADDITIONAL_DECODE, // Instruction executes with additional decode
                           // Load-store</del> <a href="shared_pseudocode.html#MemHint_RA" title="constant bits(2) MemHint_RA = '10'"><ins>MemHint_RA</ins></a><ins>;
            when '11'                   // Write-back, Read allocate
                result.attrs =</ins><del>Constraint_WBSUPPRESS,</del> <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'"><ins>MemAttr_WB</ins></a><ins>;
                result.hints =</ins><del>Constraint_FAULT,
                           // IPA too large</del> <del>Constraint_FORCE, </del><a id="Constraint_FORCENOSLCHECK" name="Constraint_FORCENOSLCHECK"></a><a href="shared_pseudocode.html#MemHint_RA" title="constant bits(2) MemHint_RA = '10'"><ins>MemHint_RA</ins></a><ins>;

    result.transient = FALSE;

    return result;</ins><del>Constraint_FORCENOSLCHECK};</del></p></div><div class="ps" psname="shared.translation.attrs.WalkAttrDecode"><a id="shared.translation.attrs.WalkAttrDecode" name="shared.translation.attrs.WalkAttrDecode"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>translation</ins><del>functions</del>/<ins>attrs</ins><del>unpredictable</del>/<ins>WalkAttrDecode</ins><del>Unpredictable</del></h3><p class="pseudocode"><ins>// WalkAttrDecode()
// ================

MemoryAttributes</ins><del>enumeration</del> <a id="impl-shared.WalkAttrDecode.4" name="impl-shared.WalkAttrDecode.4"></a><ins>WalkAttrDecode(bits(2) SH, bits(2) ORGN, bits(2) IRGN, boolean secondstage)</ins><del>Unpredictable {// Writeback/transfer register overlap (load)</del>

    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType type, DeviceType device, MemAttrHints inner, MemAttrHints outer, boolean tagged, boolean shareable, boolean outershareable )"><ins>MemoryAttributes</ins></a> <ins>memattrs;</ins><del>Unpredictable_WBOVERLAPLD,
                           // Writeback/transfer register overlap (store)</del>

    <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType</ins></a> <ins>acctype =</ins><del>Unpredictable_WBOVERLAPST,
                           // Load Pair transfer register overlap</del> <a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><ins>AccType_NORMAL</ins></a><ins>;

    memattrs.type =</ins><del>Unpredictable_LDPOVERLAP,
                           // Store-exclusive base/status register overlap</del> <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><ins>MemType_Normal</ins></a><ins>;
    memattrs.inner =</ins><del>Unpredictable_BASEOVERLAP,
                           // Store-exclusive data/status register overlap</del> <a href="shared_pseudocode.html#impl-shared.ShortConvertAttrsHints.3" title="function: MemAttrHints ShortConvertAttrsHints(bits(2) RGN, AccType acctype, boolean secondstage)"><ins>ShortConvertAttrsHints</ins></a><ins>(IRGN, acctype, secondstage);
    memattrs.outer =</ins><del>Unpredictable_DATAOVERLAP,
                           // Load-store alignment checks</del> <a href="shared_pseudocode.html#impl-shared.ShortConvertAttrsHints.3" title="function: MemAttrHints ShortConvertAttrsHints(bits(2) RGN, AccType acctype, boolean secondstage)"><ins>ShortConvertAttrsHints</ins></a><ins>(ORGN, acctype, secondstage);
    memattrs.shareable = SH&lt;1> == '1';
    memattrs.outershareable = SH == '10';
    memattrs.tagged = FALSE;

    return</ins><del>Unpredictable_DEVPAGE2,
                           // Instruction fetch from Device memory</del> <del>Unpredictable_INSTRDEVICE,
                           // Reserved CPACR value
                           </del><a id="Unpredictable_RESCPACR" name="Unpredictable_RESCPACR"></a><del>Unpredictable_RESCPACR,
                           // Reserved MAIR value
                           </del><a id="Unpredictable_RESMAIR" name="Unpredictable_RESMAIR"></a><del>Unpredictable_RESMAIR,
                           // Reserved TEX:C:B value
                           </del><a id="Unpredictable_RESTEXCB" name="Unpredictable_RESTEXCB"></a><del>Unpredictable_RESTEXCB,
                           // Reserved PRRR value
                           </del><a id="Unpredictable_RESPRRR" name="Unpredictable_RESPRRR"></a><del>Unpredictable_RESPRRR,
                           // Reserved DACR field
                           </del><a id="Unpredictable_RESDACR" name="Unpredictable_RESDACR"></a><del>Unpredictable_RESDACR,
                           // Reserved VTCR.S value
                           </del><a id="Unpredictable_RESVTCRS" name="Unpredictable_RESVTCRS"></a><del>Unpredictable_RESVTCRS,
                           // Reserved TCR.TnSZ value
                           </del><a id="Unpredictable_RESTnSZ" name="Unpredictable_RESTnSZ"></a><del>Unpredictable_RESTnSZ,
                           // Out-of-range TCR.TnSZ value
                           </del><a id="Unpredictable_OORTnSZ" name="Unpredictable_OORTnSZ"></a><del>Unpredictable_OORTnSZ,
                           // IPA size exceeds PA size
                           </del><a id="Unpredictable_LARGEIPA" name="Unpredictable_LARGEIPA"></a><del>Unpredictable_LARGEIPA,
                           // Syndrome for a known-passing conditional A32 instruction
                           </del><a id="Unpredictable_ESRCONDPASS" name="Unpredictable_ESRCONDPASS"></a><del>Unpredictable_ESRCONDPASS,
                           // Illegal State exception: zero PSTATE.IT
                           </del><a id="Unpredictable_ILZEROIT" name="Unpredictable_ILZEROIT"></a><del>Unpredictable_ILZEROIT,
                           // Illegal State exception: zero PSTATE.T
                           </del><a id="Unpredictable_ILZEROT" name="Unpredictable_ILZEROT"></a><del>Unpredictable_ILZEROT,
                           // Debug: prioritization of Vector Catch
                           </del><a id="Unpredictable_BPVECTORCATCHPRI" name="Unpredictable_BPVECTORCATCHPRI"></a><del>Unpredictable_BPVECTORCATCHPRI,
                           // Debug Vector Catch: match on 2nd halfword
                           </del><a id="Unpredictable_VCMATCHHALF" name="Unpredictable_VCMATCHHALF"></a><del>Unpredictable_VCMATCHHALF,
                           // Debug Vector Catch: match on Data Abort or Prefetch abort
                           </del><a id="Unpredictable_VCMATCHDAPA" name="Unpredictable_VCMATCHDAPA"></a><del>Unpredictable_VCMATCHDAPA,
                           // Debug watchpoints: non-zero MASK and non-ones BAS
                           </del><a id="Unpredictable_WPMASKANDBAS" name="Unpredictable_WPMASKANDBAS"></a><del>Unpredictable_WPMASKANDBAS,
                           // Debug watchpoints: non-contiguous BAS
                           </del><a id="Unpredictable_WPBASCONTIGUOUS" name="Unpredictable_WPBASCONTIGUOUS"></a><del>Unpredictable_WPBASCONTIGUOUS,
                           // Debug watchpoints: reserved MASK
                           </del><a id="Unpredictable_RESWPMASK" name="Unpredictable_RESWPMASK"></a><del>Unpredictable_RESWPMASK,
                           // Debug watchpoints: non-zero MASKed bits of address
                           </del><a id="Unpredictable_WPMASKEDBITS" name="Unpredictable_WPMASKEDBITS"></a><del>Unpredictable_WPMASKEDBITS,
                           // Debug breakpoints and watchpoints: reserved control bits
                           </del><a id="Unpredictable_RESBPWPCTRL" name="Unpredictable_RESBPWPCTRL"></a><del>Unpredictable_RESBPWPCTRL,
                           // Debug breakpoints: not implemented
                           </del><a id="Unpredictable_BPNOTIMPL" name="Unpredictable_BPNOTIMPL"></a><del>Unpredictable_BPNOTIMPL,
                           // Debug breakpoints: reserved type
                           </del><a id="Unpredictable_RESBPTYPE" name="Unpredictable_RESBPTYPE"></a><del>Unpredictable_RESBPTYPE,
                           // Debug breakpoints: not-context-aware breakpoint
                           </del><a id="Unpredictable_BPNOTCTXCMP" name="Unpredictable_BPNOTCTXCMP"></a><del>Unpredictable_BPNOTCTXCMP,
                           // Debug breakpoints: match on 2nd halfword of instruction
                           </del><a id="Unpredictable_BPMATCHHALF" name="Unpredictable_BPMATCHHALF"></a><del>Unpredictable_BPMATCHHALF,
                           // Debug breakpoints: mismatch on 2nd halfword of instruction
                           </del><a id="Unpredictable_BPMISMATCHHALF" name="Unpredictable_BPMISMATCHHALF"></a><del>Unpredictable_BPMISMATCHHALF,
                           // Debug: restart to a misaligned AArch32 PC value
                           </del><a id="Unpredictable_RESTARTALIGNPC" name="Unpredictable_RESTARTALIGNPC"></a><del>Unpredictable_RESTARTALIGNPC,
                           // Debug: restart to a not-zero-extended AArch32 PC value
                           </del><a id="Unpredictable_RESTARTZEROUPPERPC" name="Unpredictable_RESTARTZEROUPPERPC"></a><del>Unpredictable_RESTARTZEROUPPERPC,
                           // Zero top 32 bits of X registers in AArch32 state
                           </del><a id="Unpredictable_ZEROUPPER" name="Unpredictable_ZEROUPPER"></a><del>Unpredictable_ZEROUPPER,
                           // Zero top 32 bits of PC on illegal return to AArch32 state
                           </del><a id="Unpredictable_ERETZEROUPPERPC" name="Unpredictable_ERETZEROUPPERPC"></a><del>Unpredictable_ERETZEROUPPERPC,
                           // Force address to be aligned when interworking branch to A32 state
                           </del><a id="Unpredictable_A32FORCEALIGNPC" name="Unpredictable_A32FORCEALIGNPC"></a><del>Unpredictable_A32FORCEALIGNPC,
                           // SMC disabled
                           </del><a id="Unpredictable_SMD" name="Unpredictable_SMD"></a><del>Unpredictable_SMD,
                           // FF speculation
                           </del><a id="Unpredictable_NONFAULT" name="Unpredictable_NONFAULT"></a><del>Unpredictable_NONFAULT,
                           // Zero top bits of Z registers in EL change
                           </del><a id="Unpredictable_SVEZEROUPPER" name="Unpredictable_SVEZEROUPPER"></a><del>Unpredictable_SVEZEROUPPER,
                           // Load mem data in NF loads
                           </del><a id="Unpredictable_SVELDNFDATA" name="Unpredictable_SVELDNFDATA"></a><del>Unpredictable_SVELDNFDATA,
                           // Write zeros in NF loads
                           </del><a id="Unpredictable_SVELDNFZERO" name="Unpredictable_SVELDNFZERO"></a><del>Unpredictable_SVELDNFZERO,
                           // Access Flag Update by HW
                           </del><a id="Unpredictable_AFUPDATE" name="Unpredictable_AFUPDATE"></a><del>Unpredictable_AFUPDATE,
                           // Consider SCTLR[].IESB in Debug state
                           </del><a id="Unpredictable_IESBinDebug" name="Unpredictable_IESBinDebug"></a><del>Unpredictable_IESBinDebug,
                           // No events selected in PMSEVFR_EL1
                           </del><a id="Unpredictable_ZEROPMSEVFR" name="Unpredictable_ZEROPMSEVFR"></a><del>Unpredictable_ZEROPMSEVFR,
                           // No operation type selected in PMSFCR_EL1
                           </del><a id="Unpredictable_NOOPTYPES" name="Unpredictable_NOOPTYPES"></a><del>Unpredictable_NOOPTYPES,
                           // Zero latency in PMSLATFR_EL1
                           </del><a id="Unpredictable_ZEROMINLATENCY" name="Unpredictable_ZEROMINLATENCY"></a><del>Unpredictable_ZEROMINLATENCY,
                           // Zero saved BType value in SPSR_ELx/DPSR_EL0
                           </del><a id="Unpredictable_ZEROBTYPE" name="Unpredictable_ZEROBTYPE"></a><del>Unpredictable_ZEROBTYPE,
                           // Clearing DCC/ITR sticky flags when instruction is in flight
                           </del><a id="Unpredictable_CLEARERRITEZERO" name="Unpredictable_CLEARERRITEZERO"></a><a href="shared_pseudocode.html#impl-shared.MemAttrDefaults.1" title="function: MemoryAttributes MemAttrDefaults(MemoryAttributes memattrs)"><ins>MemAttrDefaults</ins></a><ins>(memattrs);</ins><del>Unpredictable_CLEARERRITEZERO};</del></p></div><div class="ps" psname="shared.translation.translation.HasS2Translation"><a id="shared.translation.translation.HasS2Translation" name="shared.translation.translation.HasS2Translation"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>translation</ins><del>functions</del>/<ins>translation</ins><del>vector</del>/<ins>HasS2Translation</ins><del>AdvSIMDExpandImm</del></h3><p class="pseudocode"><ins>// HasS2Translation()
</ins><del>// AdvSIMDExpandImm()
</del>// ==================
<ins>// Returns TRUE if stage 2 translation is present for the current translation regime
</ins>
<ins>boolean</ins><del>bits(64)</del> <a id="impl-shared.HasS2Translation.0" name="impl-shared.HasS2Translation.0"></a><ins>HasS2Translation()
    return (</ins><del>AdvSIMDExpandImm(bit op, bits(4) cmode, bits(8) imm8)
    case cmode&lt;3:1> of
        when '000'
            imm64 =</del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><ins>EL2Enabled</ins></a><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><ins>() &amp;&amp; !</ins><del>(</del><a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><ins>IsInHost</ins></a><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><ins>() &amp;&amp; PSTATE.EL IN {</ins><del>(24):imm8, 2);
        when '001'
            imm64 =</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><ins>,</ins><del>(</del><del>(16):imm8:</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(8), 2);
        when '010'
            imm64 = </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(8):imm8:</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(16), 2);
        when '011'
            imm64 = </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(imm8:</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(24), 2);
        when '100'
            imm64 = </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(8):imm8, 4);
        when '101'
            imm64 = </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(imm8:</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(8), 4);
        when '110'
            if cmode&lt;0> == '0' then
                imm64 = </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(16):imm8:</del><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a><del>(8), 2);
            else
                imm64 = </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(8):imm8:</del><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a><del>(16), 2);
        when '111'
            if cmode&lt;0> == '0' &amp;&amp; op == '0' then
                imm64 = </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(imm8, 8);
            if cmode&lt;0> == '0' &amp;&amp; op == '1' then
                imm8a = </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(imm8&lt;7>, 8); imm8b = </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(imm8&lt;6>, 8);
                imm8c = </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(imm8&lt;5>, 8); imm8d = </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(imm8&lt;4>, 8);
                imm8e = </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(imm8&lt;3>, 8); imm8f = </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(imm8&lt;2>, 8);
                imm8g = </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(imm8&lt;1>, 8); imm8h = </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(imm8&lt;0>, 8);
                imm64 = imm8a:imm8b:imm8c:imm8d:imm8e:imm8f:imm8g:imm8h;
            if cmode&lt;0> == '1' &amp;&amp; op == '0' then
                imm32 = imm8&lt;7>:NOT(imm8&lt;6>):</del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(imm8&lt;6>,5):imm8&lt;5:0>:</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(19);
                imm64 = </del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(imm32, 2);
            if cmode&lt;0> == '1' &amp;&amp; op == '1' then
                if </del><a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()"><del>UsingAArch32</del></a><del>() then ReservedEncoding();
                imm64 = imm8&lt;7>:NOT(imm8&lt;6>):</del><a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)"><del>Replicate</del></a><del>(imm8&lt;6>,8):imm8&lt;5:0>:</del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><ins>});</ins><del>(48);

    return imm64;</del></p></div><div class="ps" psname="shared.translation.translation.Have16bitVMID"><a id="shared.translation.translation.Have16bitVMID" name="shared.translation.translation.Have16bitVMID"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>translation</ins><del>functions</del>/<ins>translation</ins><del>vector</del>/<ins>Have16bitVMID</ins><del>PolynomialMult</del></h3><p class="pseudocode"><ins>// Have16bitVMID()
// ===============
// Returns TRUE if EL2 and support for a 16-bit VMID are implemented.
</ins><del>// PolynomialMult()
// ================
</del>
<ins>boolean</ins><del>bits(M+N)</del> <a id="impl-shared.Have16bitVMID.0" name="impl-shared.Have16bitVMID.0"></a><ins>Have16bitVMID()
    return</ins><del>PolynomialMult(bits(M) op1, bits(N) op2)
    result =</del> <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><ins>(</ins><del>(M+N);
    extended_op2 =</del><del>(op2, M+N);
    for i=0 to M-1
        if op1&lt;i> == '1' then
            result = result EOR </del><a href="shared_pseudocode.html#impl-shared.LSL.2" title="function: bits(N) LSL(bits(N) x, integer shift)"><del>LSL</del></a><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)"><del>ZeroExtend</del></a><ins>) &amp;&amp; boolean IMPLEMENTATION_DEFINED;</ins><del>(extended_op2, i);
    return result;</del></p></div><div class="ps" psname="shared.translation.translation.PAMax"><a id="shared.translation.translation.PAMax" name="shared.translation.translation.PAMax"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>translation</ins><del>functions</del>/<ins>translation</ins><del>vector</del>/<ins>PAMax</ins><del>SatQ</del></h3><p class="pseudocode"><ins>// PAMax()
// =======
// Returns the IMPLEMENTATION DEFINED upper limit on the physical address
// size for this processor, as log2().
</ins><del>// SatQ()
// ======
</del>
<ins>integer</ins><del>(bits(N), boolean)</del> <a id="impl-shared.PAMax.0" name="impl-shared.PAMax.0"></a><ins>PAMax()
    return integer IMPLEMENTATION_DEFINED "Maximum Physical Address Size";</ins><del>SatQ(integer i, integer N, boolean unsigned)
    (result, sat) = if unsigned then</del><a href="shared_pseudocode.html#impl-shared.UnsignedSatQ.2" title="function: (bits(N), boolean) UnsignedSatQ(integer i, integer N)"><del>UnsignedSatQ</del></a><del>(i, N) else </del><a href="shared_pseudocode.html#impl-shared.SignedSatQ.2" title="function: (bits(N), boolean) SignedSatQ(integer i, integer N)"><del>SignedSatQ</del></a><del>(i, N);
    return (result, sat);</del></p></div><div class="ps" psname="shared.translation.translation.S1TranslationRegime"><a id="shared.translation.translation.S1TranslationRegime" name="shared.translation.translation.S1TranslationRegime"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>translation</ins><del>functions</del>/<ins>translation</ins><del>vector</del>/<ins>S1TranslationRegime</ins><del>SignedSatQ</del></h3><p class="pseudocode"><ins>// S1TranslationRegime()
// =====================
// Stage 1 translation regime for the given Exception level
</ins><del>// SignedSatQ()
// ============
</del>
<ins>bits(2)</ins><del>(bits(N), boolean)</del> <a id="impl-shared.S1TranslationRegime.1" name="impl-shared.S1TranslationRegime.1"></a><ins>S1TranslationRegime(bits(2) el)
    if el !=</ins><del>SignedSatQ(integer i, integer N)
    if i > 2^(N-1) - 1 then
        result = 2^(N-1) - 1;  saturated = TRUE;
    elsif i &lt; -(2^(N-1)) then
        result = -(2^(N-1));  saturated = TRUE;
    else
        result = i;  saturated = FALSE;
    return (result&lt;N-1:0>, saturated);</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><ins>EL0</ins></a><ins> then
        return el;
    elsif </ins><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><ins>HaveEL</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><ins>ELUsingAArch32</ins></a><ins>(</ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>) &amp;&amp; SCR.NS == '0' then
        return </ins><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><ins>EL3</ins></a><ins>;
    elsif </ins><a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><ins>HaveVirtHostExt</ins></a><ins>() &amp;&amp; </ins><a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)"><ins>ELIsInHost</ins></a><ins>(el) then
        return </ins><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><ins>EL2</ins></a><ins>;
    else
        return </ins><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><ins>EL1</ins></a><ins>;

// S1TranslationRegime()
// =====================
// Returns the Exception level controlling the current Stage 1 translation regime. For the most
// part this is unused in code because the system register accessors (SCTLR[], etc.) implicitly
// return the correct value.

bits(2) </ins><a id="impl-shared.S1TranslationRegime.0" name="impl-shared.S1TranslationRegime.0"></a><ins>S1TranslationRegime()
    return </ins><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.1" title="function: bits(2) S1TranslationRegime(bits(2) el)"><ins>S1TranslationRegime</ins></a><ins>(PSTATE.EL);</ins></p></div><div class="ps" psname="shared.translation.translation.VAMax"><a id="shared.translation.translation.VAMax" name="shared.translation.translation.VAMax"></a><h3 class="pseudocode">
            Library pseudocode for shared/<ins>translation</ins><del>functions</del>/<ins>translation</ins><del>vector</del>/<ins>VAMax</ins><del>UnsignedRSqrtEstimate</del></h3><p class="pseudocode"><ins>// VAMax()
// =======
// Returns the IMPLEMENTATION DEFINED upper limit on the virtual address
// size for this processor, as log2().
</ins><del>// UnsignedRSqrtEstimate()
// =======================
</del>
<ins>integer</ins><del>bits(N)</del> <a id="impl-shared.VAMax.0" name="impl-shared.VAMax.0"></a><ins>VAMax()
    return integer IMPLEMENTATION_DEFINED "Maximum Virtual Address Size";</ins><del>UnsignedRSqrtEstimate(bits(N) operand)
    assert N IN {16,32};
    if operand&lt;N-1:N-2> == '00' then  // Operands &lt;= 0x3FFFFFFF produce 0xFFFFFFFF
        result =</del><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a><del>(N);
    else
        // input is in the range 0x40000000 .. 0xffffffff representing [0.25 .. 1.0)

        // estimate is in the range 256 .. 511 representing [1.0 .. 2.0)
        case N of
            when 16 estimate = </del><a href="shared_pseudocode.html#impl-shared.RecipSqrtEstimate.1" title="function: integer RecipSqrtEstimate(integer a)"><del>RecipSqrtEstimate</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(operand&lt;15:7>));
            when 32 estimate = </del><a href="shared_pseudocode.html#impl-shared.RecipSqrtEstimate.1" title="function: integer RecipSqrtEstimate(integer a)"><del>RecipSqrtEstimate</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(operand&lt;31:23>));

        // result is in the range 0x80000000 .. 0xff800000 representing [1.0 .. 2.0)
        result = estimate&lt;8:0> : </del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(N-9);

    return result;</del></p></div><div class="ps" psname="shared.functions.vector.UnsignedRecipEstimate"><a id="shared.functions.vector.UnsignedRecipEstimate" name="shared.functions.vector.UnsignedRecipEstimate"></a><h3 class="pseudocode"><del>
            Library pseudocode for shared/functions/vector/UnsignedRecipEstimate</del></h3><p class="pseudocode"><del>// UnsignedRecipEstimate()
// =======================

bits(N) </del><a id="impl-shared.UnsignedRecipEstimate.1" name="impl-shared.UnsignedRecipEstimate.1"></a><del>UnsignedRecipEstimate(bits(N) operand)
    assert N IN {16,32};
    if operand&lt;N-1> == '0' then  // Operands &lt;= 0x7FFFFFFF produce 0xFFFFFFFF
        result = </del><a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)"><del>Ones</del></a><del>(N);
    else
        // input is in the range 0x80000000 .. 0xffffffff representing [0.5 .. 1.0)

        // estimate is in the range 256 to 511 representing [1.0 .. 2.0)
        case N of
            when 16 estimate = </del><a href="shared_pseudocode.html#impl-shared.RecipEstimate.1" title="function: integer RecipEstimate(integer a)"><del>RecipEstimate</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(operand&lt;15:7>));
            when 32 estimate = </del><a href="shared_pseudocode.html#impl-shared.RecipEstimate.1" title="function: integer RecipEstimate(integer a)"><del>RecipEstimate</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)"><del>UInt</del></a><del>(operand&lt;31:23>));

        // result is in the range 0x80000000 .. 0xff800000 representing [1.0 .. 2.0)
        result = estimate&lt;8:0> : </del><a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)"><del>Zeros</del></a><del>(N-9);

    return result;</del></p></div><div class="ps" psname="shared.functions.vector.UnsignedSatQ"><a id="shared.functions.vector.UnsignedSatQ" name="shared.functions.vector.UnsignedSatQ"></a><h3 class="pseudocode"><del>
            Library pseudocode for shared/functions/vector/UnsignedSatQ</del></h3><p class="pseudocode"><del>// UnsignedSatQ()
// ==============

(bits(N), boolean) </del><a id="impl-shared.UnsignedSatQ.2" name="impl-shared.UnsignedSatQ.2"></a><del>UnsignedSatQ(integer i, integer N)
    if i > 2^N - 1 then
        result = 2^N - 1;  saturated = TRUE;
    elsif i &lt; 0 then
        result = 0;  saturated = TRUE;
    else
        result = i;  saturated = FALSE;
    return (result&lt;N-1:0>, saturated);</del></p></div><div class="ps" psname="shared.translation.attrs.CombineS1S2AttrHints"><a id="shared.translation.attrs.CombineS1S2AttrHints" name="shared.translation.attrs.CombineS1S2AttrHints"></a><h3 class="pseudocode"><del>
            Library pseudocode for shared/translation/attrs/CombineS1S2AttrHints</del></h3><p class="pseudocode"><del>// CombineS1S2AttrHints()
// ======================

MemAttrHints </del><a id="impl-shared.CombineS1S2AttrHints.2" name="impl-shared.CombineS1S2AttrHints.2"></a><del>CombineS1S2AttrHints(</del><a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )"><del>MemAttrHints</del></a><del> s1desc, </del><a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )"><del>MemAttrHints</del></a><del> s2desc)

    </del><a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )"><del>MemAttrHints</del></a><del> result;

    if </del><a href="shared_pseudocode.html#impl-shared.HaveStage2MemAttrControl.0" title="function: boolean HaveStage2MemAttrControl()"><del>HaveStage2MemAttrControl</del></a><del>() &amp;&amp; HCR_EL2.FWB == '1' then
        if s2desc.attrs == </del><a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'"><del>MemAttr_WB</del></a><del> then
            result.attrs = s1desc.attrs;
        elsif s2desc.attrs == </del><a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'"><del>MemAttr_WT</del></a><del> then
            result.attrs = </del><a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'"><del>MemAttr_WB</del></a><del>;
        else
            result.attrs = </del><a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'"><del>MemAttr_NC</del></a><del>;
    else
        if s2desc.attrs == '01' || s1desc.attrs == '01' then
            result.attrs = bits(2) UNKNOWN;   // Reserved
        elsif s2desc.attrs == </del><a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'"><del>MemAttr_NC</del></a><del> || s1desc.attrs == </del><a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'"><del>MemAttr_NC</del></a><del> then
            result.attrs = </del><a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'"><del>MemAttr_NC</del></a><del>;        // Non-cacheable
        elsif s2desc.attrs == </del><a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'"><del>MemAttr_WT</del></a><del> || s1desc.attrs == </del><a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'"><del>MemAttr_WT</del></a><del> then
            result.attrs = </del><a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'"><del>MemAttr_WT</del></a><del>;        // Write-through
        else
            result.attrs = </del><a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'"><del>MemAttr_WB</del></a><del>;        // Write-back

    result.hints = s1desc.hints;
    result.transient = s1desc.transient;

    return result;</del></p></div><div class="ps" psname="shared.translation.attrs.CombineS1S2Desc"><a id="shared.translation.attrs.CombineS1S2Desc" name="shared.translation.attrs.CombineS1S2Desc"></a><h3 class="pseudocode"><del>
            Library pseudocode for shared/translation/attrs/CombineS1S2Desc</del></h3><p class="pseudocode"><del>// CombineS1S2Desc()
// =================
// Combines the address descriptors from stage 1 and stage 2

AddressDescriptor </del><a id="impl-shared.CombineS1S2Desc.2" name="impl-shared.CombineS1S2Desc.2"></a><del>CombineS1S2Desc(</del><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><del>AddressDescriptor</del></a><del> s1desc, </del><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><del>AddressDescriptor</del></a><del> s2desc)

    </del><a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )"><del>AddressDescriptor</del></a><del> result;

    result.paddress = s2desc.paddress;

    if </del><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><del>(s1desc) || </del><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><del>(s2desc) then
        result = if </del><a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)"><del>IsFault</del></a><del>(s1desc) then s1desc else s2desc;
    elsif s2desc.memattrs.type == </del><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Device</del></a><del> || s1desc.memattrs.type == </del><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Device</del></a><del> then
        result.memattrs.type = </del><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Device</del></a><del>;
        if s1desc.memattrs.type == </del><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Normal</del></a><del> then
            result.memattrs.device = s2desc.memattrs.device;
        elsif s2desc.memattrs.type == </del><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Normal</del></a><del> then
            result.memattrs.device = s1desc.memattrs.device;
        else                    // Both Device
            result.memattrs.device = </del><a href="shared_pseudocode.html#impl-shared.CombineS1S2Device.2" title="function: DeviceType CombineS1S2Device(DeviceType s1device, DeviceType s2device)"><del>CombineS1S2Device</del></a><del>(s1desc.memattrs.device,
                                                       s2desc.memattrs.device);
        result.memattrs.tagged = FALSE;
    else                        // Both Normal
        result.memattrs.type = </del><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Normal</del></a><del>;
        result.memattrs.device = </del><a href="shared_pseudocode.html#DeviceType" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType</del></a><del> UNKNOWN;
        result.memattrs.inner = </del><a href="shared_pseudocode.html#impl-shared.CombineS1S2AttrHints.2" title="function: MemAttrHints CombineS1S2AttrHints(MemAttrHints s1desc, MemAttrHints s2desc)"><del>CombineS1S2AttrHints</del></a><del>(s1desc.memattrs.inner, s2desc.memattrs.inner);
        result.memattrs.outer = </del><a href="shared_pseudocode.html#impl-shared.CombineS1S2AttrHints.2" title="function: MemAttrHints CombineS1S2AttrHints(MemAttrHints s1desc, MemAttrHints s2desc)"><del>CombineS1S2AttrHints</del></a><del>(s1desc.memattrs.outer, s2desc.memattrs.outer);
        result.memattrs.shareable = (s1desc.memattrs.shareable || s2desc.memattrs.shareable);
        result.memattrs.outershareable = (s1desc.memattrs.outershareable ||
                                          s2desc.memattrs.outershareable);
        result.memattrs.tagged = (s1desc.memattrs.tagged &amp;&amp;
                                  result.memattrs.inner.attrs == </del><a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'"><del>MemAttr_WB</del></a><del> &amp;&amp;
                                  result.memattrs.inner.hints == </del><a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'"><del>MemHint_RWA</del></a><del> &amp;&amp;
                                  result.memattrs.outer.attrs == </del><a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'"><del>MemAttr_WB</del></a><del> &amp;&amp;
                                  result.memattrs.outer.hints == </del><a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'"><del>MemHint_RWA</del></a><del>);

    result.memattrs = </del><a href="shared_pseudocode.html#impl-shared.MemAttrDefaults.1" title="function: MemoryAttributes MemAttrDefaults(MemoryAttributes memattrs)"><del>MemAttrDefaults</del></a><del>(result.memattrs);

    return result;</del></p></div><div class="ps" psname="shared.translation.attrs.CombineS1S2Device"><a id="shared.translation.attrs.CombineS1S2Device" name="shared.translation.attrs.CombineS1S2Device"></a><h3 class="pseudocode"><del>
            Library pseudocode for shared/translation/attrs/CombineS1S2Device</del></h3><p class="pseudocode"><del>// CombineS1S2Device()
// ===================
// Combines device types from stage 1 and stage 2

DeviceType </del><a id="impl-shared.CombineS1S2Device.2" name="impl-shared.CombineS1S2Device.2"></a><del>CombineS1S2Device(</del><a href="shared_pseudocode.html#DeviceType" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType</del></a><del> s1device, </del><a href="shared_pseudocode.html#DeviceType" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType</del></a><del> s2device)

    if s2device == </del><a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType_nGnRnE</del></a><del> || s1device == </del><a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType_nGnRnE</del></a><del> then
        result = </del><a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType_nGnRnE</del></a><del>;
    elsif s2device == </del><a href="shared_pseudocode.html#DeviceType_nGnRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType_nGnRE</del></a><del> || s1device == </del><a href="shared_pseudocode.html#DeviceType_nGnRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType_nGnRE</del></a><del> then
        result = </del><a href="shared_pseudocode.html#DeviceType_nGnRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType_nGnRE</del></a><del>;
    elsif s2device == </del><a href="shared_pseudocode.html#DeviceType_nGRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType_nGRE</del></a><del> || s1device == </del><a href="shared_pseudocode.html#DeviceType_nGRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType_nGRE</del></a><del> then
        result = </del><a href="shared_pseudocode.html#DeviceType_nGRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType_nGRE</del></a><del>;
    else
        result = </del><a href="shared_pseudocode.html#DeviceType_GRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType_GRE</del></a><del>;

    return result;</del></p></div><div class="ps" psname="shared.translation.attrs.LongConvertAttrsHints"><a id="shared.translation.attrs.LongConvertAttrsHints" name="shared.translation.attrs.LongConvertAttrsHints"></a><h3 class="pseudocode"><del>
            Library pseudocode for shared/translation/attrs/LongConvertAttrsHints</del></h3><p class="pseudocode"><del>// LongConvertAttrsHints()
// =======================
// Convert the long attribute fields for Normal memory as used in the MAIR fields
// to orthogonal attributes and hints

MemAttrHints </del><a id="impl-shared.LongConvertAttrsHints.2" name="impl-shared.LongConvertAttrsHints.2"></a><del>LongConvertAttrsHints(bits(4) attrfield, </del><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><del> acctype)
    assert !</del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(attrfield);
    </del><a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )"><del>MemAttrHints</del></a><del> result;
    if </del><a href="shared_pseudocode.html#impl-shared.S1CacheDisabled.1" title="function: boolean S1CacheDisabled(AccType acctype)"><del>S1CacheDisabled</del></a><del>(acctype) then             // Force Non-cacheable
        result.attrs = </del><a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'"><del>MemAttr_NC</del></a><del>;
        result.hints = </del><a href="shared_pseudocode.html#MemHint_No" title="constant bits(2) MemHint_No = '00'"><del>MemHint_No</del></a><del>;
    else
        if attrfield&lt;3:2> == '00' then          // Write-through transient
            result.attrs = </del><a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'"><del>MemAttr_WT</del></a><del>;
            result.hints = attrfield&lt;1:0>;
            result.transient = TRUE;
        elsif attrfield&lt;3:0> == '0100' then     // Non-cacheable (no allocate)
            result.attrs = </del><a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'"><del>MemAttr_NC</del></a><del>;
            result.hints = </del><a href="shared_pseudocode.html#MemHint_No" title="constant bits(2) MemHint_No = '00'"><del>MemHint_No</del></a><del>;
            result.transient = FALSE;
        elsif attrfield&lt;3:2> == '01' then       // Write-back transient
            result.attrs = </del><a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'"><del>MemAttr_WB</del></a><del>;
            result.hints = attrfield&lt;1:0>;
            result.transient = TRUE;
        else                                    // Write-through/Write-back non-transient
            result.attrs = attrfield&lt;3:2>;
            result.hints = attrfield&lt;1:0>;
            result.transient = FALSE;

    return result;</del></p></div><div class="ps" psname="shared.translation.attrs.MemAttrDefaults"><a id="shared.translation.attrs.MemAttrDefaults" name="shared.translation.attrs.MemAttrDefaults"></a><h3 class="pseudocode"><del>
            Library pseudocode for shared/translation/attrs/MemAttrDefaults</del></h3><p class="pseudocode"><del>// MemAttrDefaults()
// =================
// Supply default values for memory attributes, including overriding the shareability attributes
// for Device and Non-cacheable memory types.

MemoryAttributes </del><a id="impl-shared.MemAttrDefaults.1" name="impl-shared.MemAttrDefaults.1"></a><del>MemAttrDefaults(</del><a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType type, DeviceType device, MemAttrHints inner, MemAttrHints outer, boolean tagged, boolean shareable, boolean outershareable )"><del>MemoryAttributes</del></a><del> memattrs)

    if memattrs.type == </del><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Device</del></a><del> then
        memattrs.inner = </del><a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )"><del>MemAttrHints</del></a><del> UNKNOWN;
        memattrs.outer = </del><a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )"><del>MemAttrHints</del></a><del> UNKNOWN;
        memattrs.shareable = TRUE;
        memattrs.outershareable = TRUE;
    else
        memattrs.device = </del><a href="shared_pseudocode.html#DeviceType" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType</del></a><del> UNKNOWN;
        if memattrs.inner.attrs == </del><a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'"><del>MemAttr_NC</del></a><del> &amp;&amp; memattrs.outer.attrs == </del><a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'"><del>MemAttr_NC</del></a><del> then
            memattrs.shareable = TRUE;
            memattrs.outershareable = TRUE;

    return memattrs;</del></p></div><div class="ps" psname="shared.translation.attrs.S1CacheDisabled"><a id="shared.translation.attrs.S1CacheDisabled" name="shared.translation.attrs.S1CacheDisabled"></a><h3 class="pseudocode"><del>
            Library pseudocode for shared/translation/attrs/S1CacheDisabled</del></h3><p class="pseudocode"><del>// S1CacheDisabled()
// =================

boolean </del><a id="impl-shared.S1CacheDisabled.1" name="impl-shared.S1CacheDisabled.1"></a><del>S1CacheDisabled(</del><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><del> acctype)
    if </del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()"><del>S1TranslationRegime</del></a><del>()) then
        if PSTATE.EL == </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del> then
            enable = if acctype == </del><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IFETCH</del></a><del> then HSCTLR.I else HSCTLR.C;
        else
            enable = if acctype == </del><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IFETCH</del></a><del> then SCTLR.I else SCTLR.C;
    else
        enable = if acctype == </del><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IFETCH</del></a><del> then </del><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><del>SCTLR</del></a><del>[].I else </del><a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]"><del>SCTLR</del></a><del>[].C;
    return enable == '0';</del></p></div><div class="ps" psname="shared.translation.attrs.S2AttrDecode"><a id="shared.translation.attrs.S2AttrDecode" name="shared.translation.attrs.S2AttrDecode"></a><h3 class="pseudocode"><del>
            Library pseudocode for shared/translation/attrs/S2AttrDecode</del></h3><p class="pseudocode"><del>// S2AttrDecode()
// ==============
// Converts the Stage 2 attribute fields into orthogonal attributes and hints

MemoryAttributes </del><a id="impl-shared.S2AttrDecode.3" name="impl-shared.S2AttrDecode.3"></a><del>S2AttrDecode(bits(2) SH, bits(4) attr, </del><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><del> acctype)

    </del><a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType type, DeviceType device, MemAttrHints inner, MemAttrHints outer, boolean tagged, boolean shareable, boolean outershareable )"><del>MemoryAttributes</del></a><del> memattrs;

    apply_force_writeback = </del><a href="shared_pseudocode.html#impl-shared.HaveStage2MemAttrControl.0" title="function: boolean HaveStage2MemAttrControl()"><del>HaveStage2MemAttrControl</del></a><del>() &amp;&amp; HCR_EL2.FWB == '1';

    // Device memory
    if (apply_force_writeback &amp;&amp; attr&lt;2> == '0') || attr&lt;3:2> == '00' then
        memattrs.type = </del><a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Device</del></a><del>;
        case attr&lt;1:0> of
            when '00'  memattrs.device = </del><a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType_nGnRnE</del></a><del>;
            when '01'  memattrs.device = </del><a href="shared_pseudocode.html#DeviceType_nGnRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType_nGnRE</del></a><del>;
            when '10'  memattrs.device = </del><a href="shared_pseudocode.html#DeviceType_nGRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType_nGRE</del></a><del>;
            when '11'  memattrs.device = </del><a href="shared_pseudocode.html#DeviceType_GRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}"><del>DeviceType_GRE</del></a><del>;

    // Normal memory
    elsif attr&lt;1:0> != '00' then
        memattrs.type = </del><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Normal</del></a><del>;
        if apply_force_writeback then
            memattrs.outer = </del><a href="shared_pseudocode.html#impl-shared.S2ConvertAttrsHints.2" title="function: MemAttrHints S2ConvertAttrsHints(bits(2) attr, AccType acctype)"><del>S2ConvertAttrsHints</del></a><del>(attr&lt;1:0>, acctype);
        else
            memattrs.outer = </del><a href="shared_pseudocode.html#impl-shared.S2ConvertAttrsHints.2" title="function: MemAttrHints S2ConvertAttrsHints(bits(2) attr, AccType acctype)"><del>S2ConvertAttrsHints</del></a><del>(attr&lt;3:2>, acctype);
        memattrs.inner = </del><a href="shared_pseudocode.html#impl-shared.S2ConvertAttrsHints.2" title="function: MemAttrHints S2ConvertAttrsHints(bits(2) attr, AccType acctype)"><del>S2ConvertAttrsHints</del></a><del>(attr&lt;1:0>, acctype);
        memattrs.shareable = SH&lt;1> == '1';
        memattrs.outershareable = SH == '10';

    else
        memattrs = </del><a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType type, DeviceType device, MemAttrHints inner, MemAttrHints outer, boolean tagged, boolean shareable, boolean outershareable )"><del>MemoryAttributes</del></a><del> UNKNOWN;    // Reserved

    return </del><a href="shared_pseudocode.html#impl-shared.MemAttrDefaults.1" title="function: MemoryAttributes MemAttrDefaults(MemoryAttributes memattrs)"><del>MemAttrDefaults</del></a><del>(memattrs);</del></p></div><div class="ps" psname="shared.translation.attrs.S2CacheDisabled"><a id="shared.translation.attrs.S2CacheDisabled" name="shared.translation.attrs.S2CacheDisabled"></a><h3 class="pseudocode"><del>
            Library pseudocode for shared/translation/attrs/S2CacheDisabled</del></h3><p class="pseudocode"><del>// S2CacheDisabled()
// =================

boolean </del><a id="impl-shared.S2CacheDisabled.1" name="impl-shared.S2CacheDisabled.1"></a><del>S2CacheDisabled(</del><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><del> acctype)
    if </del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) then
        disable = if acctype == </del><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IFETCH</del></a><del> then HCR2.ID else HCR2.CD;
    else
        disable = if acctype == </del><a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_IFETCH</del></a><del> then HCR_EL2.ID else HCR_EL2.CD;

    return disable == '1';</del></p></div><div class="ps" psname="shared.translation.attrs.S2ConvertAttrsHints"><a id="shared.translation.attrs.S2ConvertAttrsHints" name="shared.translation.attrs.S2ConvertAttrsHints"></a><h3 class="pseudocode"><del>
            Library pseudocode for shared/translation/attrs/S2ConvertAttrsHints</del></h3><p class="pseudocode"><del>// S2ConvertAttrsHints()
// =====================
// Converts the attribute fields for Normal memory as used in stage 2
// descriptors to orthogonal attributes and hints

MemAttrHints </del><a id="impl-shared.S2ConvertAttrsHints.2" name="impl-shared.S2ConvertAttrsHints.2"></a><del>S2ConvertAttrsHints(bits(2) attr, </del><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><del> acctype)
    assert !</del><a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)"><del>IsZero</del></a><del>(attr);

    </del><a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )"><del>MemAttrHints</del></a><del> result;

    if </del><a href="shared_pseudocode.html#impl-shared.S2CacheDisabled.1" title="function: boolean S2CacheDisabled(AccType acctype)"><del>S2CacheDisabled</del></a><del>(acctype) then                // Force Non-cacheable
        result.attrs = </del><a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'"><del>MemAttr_NC</del></a><del>;
        result.hints = </del><a href="shared_pseudocode.html#MemHint_No" title="constant bits(2) MemHint_No = '00'"><del>MemHint_No</del></a><del>;
    else
        case attr of
            when '01'                               // Non-cacheable (no allocate)
                result.attrs = </del><a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'"><del>MemAttr_NC</del></a><del>;
                result.hints = </del><a href="shared_pseudocode.html#MemHint_No" title="constant bits(2) MemHint_No = '00'"><del>MemHint_No</del></a><del>;
            when '10'                               // Write-through
                result.attrs = </del><a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'"><del>MemAttr_WT</del></a><del>;
                result.hints = </del><a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'"><del>MemHint_RWA</del></a><del>;
            when '11'                               // Write-back
                result.attrs = </del><a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'"><del>MemAttr_WB</del></a><del>;
                result.hints = </del><a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'"><del>MemHint_RWA</del></a><del>;

    result.transient = FALSE;

    return result;</del></p></div><div class="ps" psname="shared.translation.attrs.ShortConvertAttrsHints"><a id="shared.translation.attrs.ShortConvertAttrsHints" name="shared.translation.attrs.ShortConvertAttrsHints"></a><h3 class="pseudocode"><del>
            Library pseudocode for shared/translation/attrs/ShortConvertAttrsHints</del></h3><p class="pseudocode"><del>// ShortConvertAttrsHints()
// ========================
// Converts the short attribute fields for Normal memory as used in the TTBR and
// TEX fields to orthogonal attributes and hints

MemAttrHints </del><a id="impl-shared.ShortConvertAttrsHints.3" name="impl-shared.ShortConvertAttrsHints.3"></a><del>ShortConvertAttrsHints(bits(2) RGN, </del><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><del> acctype, boolean secondstage)

    </del><a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )"><del>MemAttrHints</del></a><del> result;

    if (!secondstage &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.S1CacheDisabled.1" title="function: boolean S1CacheDisabled(AccType acctype)"><del>S1CacheDisabled</del></a><del>(acctype)) || (secondstage &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.S2CacheDisabled.1" title="function: boolean S2CacheDisabled(AccType acctype)"><del>S2CacheDisabled</del></a><del>(acctype)) then
       // Force Non-cacheable
        result.attrs = </del><a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'"><del>MemAttr_NC</del></a><del>;
        result.hints = </del><a href="shared_pseudocode.html#MemHint_No" title="constant bits(2) MemHint_No = '00'"><del>MemHint_No</del></a><del>;
    else
        case RGN of
            when '00'                   // Non-cacheable (no allocate)
                result.attrs = </del><a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'"><del>MemAttr_NC</del></a><del>;
                result.hints = </del><a href="shared_pseudocode.html#MemHint_No" title="constant bits(2) MemHint_No = '00'"><del>MemHint_No</del></a><del>;
            when '01'                   // Write-back, Read and Write allocate
                result.attrs = </del><a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'"><del>MemAttr_WB</del></a><del>;
                result.hints = </del><a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'"><del>MemHint_RWA</del></a><del>;
            when '10'                   // Write-through, Read allocate
                result.attrs = </del><a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'"><del>MemAttr_WT</del></a><del>;
                result.hints = </del><a href="shared_pseudocode.html#MemHint_RA" title="constant bits(2) MemHint_RA = '10'"><del>MemHint_RA</del></a><del>;
            when '11'                   // Write-back, Read allocate
                result.attrs = </del><a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'"><del>MemAttr_WB</del></a><del>;
                result.hints = </del><a href="shared_pseudocode.html#MemHint_RA" title="constant bits(2) MemHint_RA = '10'"><del>MemHint_RA</del></a><del>;

    result.transient = FALSE;

    return result;</del></p></div><div class="ps" psname="shared.translation.attrs.WalkAttrDecode"><a id="shared.translation.attrs.WalkAttrDecode" name="shared.translation.attrs.WalkAttrDecode"></a><h3 class="pseudocode"><del>
            Library pseudocode for shared/translation/attrs/WalkAttrDecode</del></h3><p class="pseudocode"><del>// WalkAttrDecode()
// ================

MemoryAttributes </del><a id="impl-shared.WalkAttrDecode.4" name="impl-shared.WalkAttrDecode.4"></a><del>WalkAttrDecode(bits(2) SH, bits(2) ORGN, bits(2) IRGN, boolean secondstage)

    </del><a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType type, DeviceType device, MemAttrHints inner, MemAttrHints outer, boolean tagged, boolean shareable, boolean outershareable )"><del>MemoryAttributes</del></a><del> memattrs;

    </del><a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType</del></a><del> acctype = </del><a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}"><del>AccType_NORMAL</del></a><del>;

    memattrs.type = </del><a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}"><del>MemType_Normal</del></a><del>;
    memattrs.inner = </del><a href="shared_pseudocode.html#impl-shared.ShortConvertAttrsHints.3" title="function: MemAttrHints ShortConvertAttrsHints(bits(2) RGN, AccType acctype, boolean secondstage)"><del>ShortConvertAttrsHints</del></a><del>(IRGN, acctype, secondstage);
    memattrs.outer = </del><a href="shared_pseudocode.html#impl-shared.ShortConvertAttrsHints.3" title="function: MemAttrHints ShortConvertAttrsHints(bits(2) RGN, AccType acctype, boolean secondstage)"><del>ShortConvertAttrsHints</del></a><del>(ORGN, acctype, secondstage);
    memattrs.shareable = SH&lt;1> == '1';
    memattrs.outershareable = SH == '10';
    memattrs.tagged = FALSE;

    return </del><a href="shared_pseudocode.html#impl-shared.MemAttrDefaults.1" title="function: MemoryAttributes MemAttrDefaults(MemoryAttributes memattrs)"><del>MemAttrDefaults</del></a><del>(memattrs);</del></p></div><div class="ps" psname="shared.translation.translation.HasS2Translation"><a id="shared.translation.translation.HasS2Translation" name="shared.translation.translation.HasS2Translation"></a><h3 class="pseudocode"><del>
            Library pseudocode for shared/translation/translation/HasS2Translation</del></h3><p class="pseudocode"><del>// HasS2Translation()
// ==================
// Returns TRUE if stage 2 translation is present for the current translation regime

boolean </del><a id="impl-shared.HasS2Translation.0" name="impl-shared.HasS2Translation.0"></a><del>HasS2Translation()
    return (</del><a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()"><del>EL2Enabled</del></a><del>() &amp;&amp; !</del><a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()"><del>IsInHost</del></a><del>() &amp;&amp; PSTATE.EL IN {</del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del>,</del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>});</del></p></div><div class="ps" psname="shared.translation.translation.Have16bitVMID"><a id="shared.translation.translation.Have16bitVMID" name="shared.translation.translation.Have16bitVMID"></a><h3 class="pseudocode"><del>
            Library pseudocode for shared/translation/translation/Have16bitVMID</del></h3><p class="pseudocode"><del>// Have16bitVMID()
// ===============
// Returns TRUE if EL2 and support for a 16-bit VMID are implemented.

boolean </del><a id="impl-shared.Have16bitVMID.0" name="impl-shared.Have16bitVMID.0"></a><del>Have16bitVMID()
    return </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>) &amp;&amp; boolean IMPLEMENTATION_DEFINED;</del></p></div><div class="ps" psname="shared.translation.translation.PAMax"><a id="shared.translation.translation.PAMax" name="shared.translation.translation.PAMax"></a><h3 class="pseudocode"><del>
            Library pseudocode for shared/translation/translation/PAMax</del></h3><p class="pseudocode"><del>// PAMax()
// =======
// Returns the IMPLEMENTATION DEFINED upper limit on the physical address
// size for this processor, as log2().

integer </del><a id="impl-shared.PAMax.0" name="impl-shared.PAMax.0"></a><del>PAMax()
    return integer IMPLEMENTATION_DEFINED "Maximum Physical Address Size";</del></p></div><div class="ps" psname="shared.translation.translation.S1TranslationRegime"><a id="shared.translation.translation.S1TranslationRegime" name="shared.translation.translation.S1TranslationRegime"></a><h3 class="pseudocode"><del>
            Library pseudocode for shared/translation/translation/S1TranslationRegime</del></h3><p class="pseudocode"><del>// S1TranslationRegime()
// =====================
// Stage 1 translation regime for the given Exception level

bits(2) </del><a id="impl-shared.S1TranslationRegime.1" name="impl-shared.S1TranslationRegime.1"></a><del>S1TranslationRegime(bits(2) el)
    if el != </del><a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'"><del>EL0</del></a><del> then
        return el;
    elsif </del><a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)"><del>HaveEL</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)"><del>ELUsingAArch32</del></a><del>(</del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>) &amp;&amp; SCR.NS == '0' then
        return </del><a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'"><del>EL3</del></a><del>;
    elsif </del><a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()"><del>HaveVirtHostExt</del></a><del>() &amp;&amp; </del><a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)"><del>ELIsInHost</del></a><del>(el) then
        return </del><a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'"><del>EL2</del></a><del>;
    else
        return </del><a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'"><del>EL1</del></a><del>;

// S1TranslationRegime()
// =====================
// Returns the Exception level controlling the current Stage 1 translation regime. For the most
// part this is unused in code because the system register accessors (SCTLR[], etc.) implicitly
// return the correct value.

bits(2) </del><a id="impl-shared.S1TranslationRegime.0" name="impl-shared.S1TranslationRegime.0"></a><del>S1TranslationRegime()
    return </del><a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.1" title="function: bits(2) S1TranslationRegime(bits(2) el)"><del>S1TranslationRegime</del></a><del>(PSTATE.EL);</del></p></div><div class="ps" psname="shared.translation.translation.VAMax"><a id="shared.translation.translation.VAMax" name="shared.translation.translation.VAMax"></a><h3 class="pseudocode"><del>
            Library pseudocode for shared/translation/translation/VAMax</del></h3><p class="pseudocode"><del>// VAMax()
// =======
// Returns the IMPLEMENTATION DEFINED upper limit on the virtual address
// size for this processor, as log2().

integer </del><a id="impl-shared.VAMax.0" name="impl-shared.VAMax.0"></a><del>VAMax()
    return integer IMPLEMENTATION_DEFINED "Maximum Virtual Address Size";</del></p></div><hr/><table align="center"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="a32_encindex.html">A32 Instructions by Encoding</a></div></td><td><div class="topbar"><a href="t32_encindex.html">T32 Instructions by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">
      Internal version only: isa <ins>v00_88</ins><del>v00_87</del>, pseudocode <ins>v85-xml-00bet9_rc1_1</ins><del>v85-xml-00bet8_rc3</del>
      ; Build timestamp: <ins>2018-12-12T12</ins><del>2018-09-13T14</del>:<ins>33</ins><del>00</del>
    </p><p class="copyconf">
      Copyright © 2010-2018 <ins>Arm</ins><del>ARM</del> Limited or its affiliates. All rights reserved.
      This document is Non-Confidential.
    </p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>
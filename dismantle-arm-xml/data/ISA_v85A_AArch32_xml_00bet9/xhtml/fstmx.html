<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><link rel="stylesheet" type="text/css" href="insn.css" /><meta name="generator" content="iform.xsl" /><title>FSTMDBX, FSTMIAX -- AArch32</title></head><body><table align="center"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="a32_encindex.html">A32 Instructions by Encoding</a></div></td><td><div class="topbar"><a href="t32_encindex.html">T32 Instructions by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr /><h2 class="instruction-section">FSTMDBX, FSTMIAX</h2><p id="desc">
      <p class="aml">FSTMX stores multiple SIMD&amp;FP registers from the Advanced SIMD and floating-point register file to consecutive locations in using an address from a general-purpose register.</p>
      <p class="aml">Arm deprecates use of FLDMDBX and FLDMIAX, except for disassembly purposes, and reassembly of disassembled code.</p>
      <p class="aml">Depending on settings in the <a class="armarm-xref" title="Reference to Armv8 ARM section">CPACR</a>, <a class="armarm-xref" title="Reference to Armv8 ARM section">NSACR</a>, <a class="armarm-xref" title="Reference to Armv8 ARM section">HCPTR</a>, and <a class="armarm-xref" title="Reference to Armv8 ARM section">FPEXC</a> registers, and the Security state and PE mode in which the instruction is executed, an attempt to execute the instruction might be <span class="arm-defined-word">undefined</span>, or trapped to Hyp mode. For more information see <a class="armarm-xref" title="Reference to Armv8 ARM section">Enabling Advanced SIMD and floating-point support</a>.</p>
    </p>
    <p class="desc">
      It has encodings from the following instruction sets:
       A32 (
      <a href="#a1">A1</a>
      )
       and 
       T32 (
      <a href="#t1">T1</a>
      )
      .
    </p>
    <h3 class="classheading"><a name="a1" id="a1"></a>A1</h3><p class="desc"></p><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td colspan="4" class="lr">!= 1111</td><td class="l">1</td><td>1</td><td class="r">0</td><td class="lr">P</td><td class="lr">U</td><td class="lr">D</td><td class="lr">W</td><td class="lr">0</td><td colspan="4" class="lr">Rn</td><td colspan="4" class="lr">Vd</td><td class="l">1</td><td class="r">0</td><td class="l">1</td><td class="r">1</td><td colspan="7" class="lr">imm8&lt;7:1&gt;</td><td class="lr">1</td></tr><tr class="secondrow"><td colspan="4" class="droppedname">cond</td><td colspan="3"></td><td></td><td></td><td></td><td></td><td></td><td colspan="4"></td><td colspan="4"></td><td colspan="2"></td><td colspan="2"></td><td colspan="7"></td><td class="droppedname">imm8&lt;0&gt;</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">Decrement Before<span class="bitdiff"> (P == 1 &amp;&amp; U == 0 &amp;&amp; W == 1)</span></h4><p class="asm-code"><a name="FSTMDBX_A1" id="FSTMDBX_A1"></a>FSTMDBX{<a href="#c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>} <a href="#rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>!, <a href="#dreglist" title="List of consecutively numbered 64-bit SIMD&amp;FP registers to be transferred (field &quot;D:Vd&quot;)">&lt;dreglist&gt;</a></p></div><div class="encoding"><h4 class="encoding">Increment After<span class="bitdiff"> (P == 0 &amp;&amp; U == 1)</span></h4><p class="asm-code"><a name="FSTMIAX_A1" id="FSTMIAX_A1"></a>FSTMIAX{<a href="#c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>} <a href="#rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a><a href="#0d33" title="Specifies base register writeback (field &quot;W&quot;)">{!}</a>, <a href="#dreglist" title="List of consecutively numbered 64-bit SIMD&amp;FP registers to be transferred (field &quot;D:Vd&quot;)">&lt;dreglist&gt;</a></p></div><p class="pseudocode">if P == '0' &amp;&amp; U == '0' &amp;&amp; W == '0' then SEE "Related encodings";
if P == '1' &amp;&amp; W == '0' then SEE "VSTR";
if P == U &amp;&amp; W == '1' then UNDEFINED;
// Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
single_regs = FALSE;  add = (U == '1');  wback = (W == '1');
d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(D:Vd);  n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);  imm32 = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(imm8:'00', 32);
regs = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(imm8) DIV 2;  // If UInt(imm8) is odd, see "FSTMX".
if n == 15 &amp;&amp; (wback || <a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>() != <a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a>) then UNPREDICTABLE;
if regs == 0 || regs &gt; 16 || (d+regs) &gt; 32 then UNPREDICTABLE;
if imm8&lt;0&gt; == '1' &amp;&amp; (d+regs) &gt; 16 then UNPREDICTABLE;</p><h3>CONSTRAINED UNPREDICTABLE behavior</h3><p>If <span class="pseudocode">regs == 0</span>, then one of the following behaviors must occur:</p><ul><li>The instruction is <span class="arm-defined-word">undefined</span>.</li><li>The instruction executes as <span class="asm-code">NOP</span>.</li><li>The instruction operates as a <span class="asm-code">VSTM</span> with the same addressing mode but stores no registers.</li></ul><p>If <span class="pseudocode">regs &gt; 16 || (d+regs) &gt; 16</span>, then one of the following behaviors must occur:</p><ul><li>The instruction is <span class="arm-defined-word">undefined</span>.</li><li>The instruction executes as <span class="asm-code">NOP</span>.</li><li>The memory locations specified by the instruction and the number of registers specified by the instruction if the register list had not gone out of range, become <span class="arm-defined-word">unknown</span>. If the instruction specifies writeback, then that register becomes <span class="arm-defined-word">unknown</span>. This behavior does not affect any other memory locations.</li></ul>
    <h3 class="classheading"><a name="t1" id="t1"></a>T1</h3><p class="desc"></p><div class="regdiagram-16x2"><table class="regdiagram"><thead><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td class="r">0</td><td class="lr">P</td><td class="lr">U</td><td class="lr">D</td><td class="lr">W</td><td class="lr">0</td><td colspan="4" class="lr">Rn</td><td colspan="4" class="lr">Vd</td><td class="l">1</td><td class="r">0</td><td class="l">1</td><td class="r">1</td><td colspan="7" class="lr">imm8&lt;7:1&gt;</td><td class="lr">1</td></tr><tr class="secondrow"><td colspan="7"></td><td></td><td></td><td></td><td></td><td></td><td colspan="4"></td><td colspan="4"></td><td colspan="2"></td><td colspan="2"></td><td colspan="7"></td><td class="droppedname">imm8&lt;0&gt;</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">Decrement Before<span class="bitdiff"> (P == 1 &amp;&amp; U == 0 &amp;&amp; W == 1)</span></h4><p class="asm-code"><a name="FSTMDBX_T1" id="FSTMDBX_T1"></a>FSTMDBX{<a href="#c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>} <a href="#rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a>!, <a href="#dreglist" title="List of consecutively numbered 64-bit SIMD&amp;FP registers to be transferred (field &quot;D:Vd&quot;)">&lt;dreglist&gt;</a></p></div><div class="encoding"><h4 class="encoding">Increment After<span class="bitdiff"> (P == 0 &amp;&amp; U == 1)</span></h4><p class="asm-code"><a name="FSTMIAX_T1" id="FSTMIAX_T1"></a>FSTMIAX{<a href="#c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c&gt;</a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q&gt;</a>} <a href="#rn" title="General-purpose base register (field &quot;Rn&quot;)">&lt;Rn&gt;</a><a href="#0d33" title="Specifies base register writeback (field &quot;W&quot;)">{!}</a>, <a href="#dreglist" title="List of consecutively numbered 64-bit SIMD&amp;FP registers to be transferred (field &quot;D:Vd&quot;)">&lt;dreglist&gt;</a></p></div><p class="pseudocode">if P == '0' &amp;&amp; U == '0' &amp;&amp; W == '0' then SEE "Related encodings";
if P == '1' &amp;&amp; W == '0' then SEE "VSTR";
if P == U &amp;&amp; W == '1' then UNDEFINED;
// Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
single_regs = FALSE;  add = (U == '1');  wback = (W == '1');
d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(D:Vd);  n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);  imm32 = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(imm8:'00', 32);
regs = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(imm8) DIV 2;  // If UInt(imm8) is odd, see "FSTMX".
if n == 15 &amp;&amp; (wback || <a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>() != <a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a>) then UNPREDICTABLE;
if regs == 0 || regs &gt; 16 || (d+regs) &gt; 32 then UNPREDICTABLE;
if imm8&lt;0&gt; == '1' &amp;&amp; (d+regs) &gt; 16 then UNPREDICTABLE;</p><h3>CONSTRAINED UNPREDICTABLE behavior</h3><p>If <span class="pseudocode">regs == 0</span>, then one of the following behaviors must occur:</p><ul><li>The instruction is <span class="arm-defined-word">undefined</span>.</li><li>The instruction executes as <span class="asm-code">NOP</span>.</li><li>The instruction operates as a <span class="asm-code">VSTM</span> with the same addressing mode but stores no registers.</li></ul><p>If <span class="pseudocode">regs &gt; 16 || (d+regs) &gt; 16</span>, then one of the following behaviors must occur:</p><ul><li>The instruction is <span class="arm-defined-word">undefined</span>.</li><li>The instruction executes as <span class="asm-code">NOP</span>.</li><li>The memory locations specified by the instruction and the number of registers specified by the instruction if the register list had not gone out of range, become <span class="arm-defined-word">unknown</span>. If the instruction specifies writeback, then that register becomes <span class="arm-defined-word">unknown</span>. This behavior does not affect any other memory locations.</li></ul>
  <p class="encoding-notes">
      <p class="aml">For more information about the <span class="arm-defined-word">constrained unpredictable</span> behavior of this instruction, see <a class="armarm-xref" title="Reference to Armv8 ARM section">Architectural Constraints on UNPREDICTABLE behaviors</a>.</p>
      <p class="aml">Related encodings: See <a class="armarm-xref" title="Reference to Armv8 ARM section">Advanced SIMD and floating-point 64-bit move</a> for the T32 instruction set, or <a class="armarm-xref" title="Reference to Armv8 ARM section">Advanced SIMD and floating-point 64-bit move</a> for the A32 instruction set.</p>
    </p><h3 class="explanations">Assembler Symbols</h3><div class="explanations"><table><col class="asyn-l" /><col class="asyn-r" /><tr><td>&lt;c&gt;</td><td><a name="c" id="c"></a>
        
          <p class="aml">See <a class="armarm-xref" title="Reference to Armv8 ARM section">Standard assembler syntax fields</a>.</p>
        
      </td></tr></table><table><col class="asyn-l" /><col class="asyn-r" /><tr><td>&lt;q&gt;</td><td><a name="q" id="q"></a>
        
          <p class="aml">See <a class="armarm-xref" title="Reference to Armv8 ARM section">Standard assembler syntax fields</a>.</p>
        
      </td></tr></table><table><col class="asyn-l" /><col class="asyn-r" /><tr><td>&lt;Rn&gt;</td><td><a name="rn" id="rn"></a>
        
          <p class="aml">Is the general-purpose base register, encoded in the "Rn" field. If writeback is not specified, the PC can be used. However, Arm deprecates use of the PC.</p>
        
      </td></tr></table><table><col class="asyn-l" /><col class="asyn-r" /><tr><td>!</td><td><a name="0d33" id="0d33"></a>
        
          <p class="aml">Specifies base register writeback. Encoded in the "W" field as 1 if present, otherwise 0.</p>
        
      </td></tr></table><table><col class="asyn-l" /><col class="asyn-r" /><tr><td>&lt;dreglist&gt;</td><td><a name="dreglist" id="dreglist"></a>
        
          <p class="aml">Is the list of consecutively numbered 64-bit SIMD&amp;FP registers to be transferred. The first register in the list is encoded in "D:Vd", and "imm8" is set to twice the number of registers in the list plus one. The list must contain at least one register, all registers must be in the range D0-D15, and must not contain more than 16 registers.</p>
        
      </td></tr></table></div><p class="syntax-notes"></p>
    <div class="ps" psname="commonps"><a name="commonps" id="commonps"></a><h3 class="pseudocode">Operation</h3>
      <p class="pseudocode">if <a href="shared_pseudocode.html#impl-aarch32.ConditionPassed.0" title="function: boolean ConditionPassed()">ConditionPassed</a>() then
    EncodingSpecificOperations();  <a href="shared_pseudocode.html#impl-aarch32.CheckVFPEnabled.1" title="function: CheckVFPEnabled(boolean include_fpexc_check)">CheckVFPEnabled</a>(TRUE);
    address = if add then <a href="shared_pseudocode.html#impl-aarch32.R.read.1" title="accessor: bits(32) R[integer n]">R</a>[n] else <a href="shared_pseudocode.html#impl-aarch32.R.read.1" title="accessor: bits(32) R[integer n]">R</a>[n]-imm32;
    for r = 0 to regs-1
        if single_regs then
            <a href="shared_pseudocode.html#impl-aarch32.MemA.write.2" title="accessor: MemA[bits(32) address, integer size] = bits(8*size) value">MemA</a>[address,4] = <a href="shared_pseudocode.html#impl-aarch32.S.read.1" title="accessor: bits(32) S[integer n]">S</a>[d+r];  address = address+4;
        else
            // Store as two word-aligned words in the correct order for current endianness.
            <a href="shared_pseudocode.html#impl-aarch32.MemA.write.2" title="accessor: MemA[bits(32) address, integer size] = bits(8*size) value">MemA</a>[address,4] = if <a href="shared_pseudocode.html#impl-shared.BigEndian.0" title="function: boolean BigEndian()">BigEndian</a>() then <a href="shared_pseudocode.html#impl-aarch32.D.read.1" title="accessor: bits(64) D[integer n]">D</a>[d+r]&lt;63:32&gt; else <a href="shared_pseudocode.html#impl-aarch32.D.read.1" title="accessor: bits(64) D[integer n]">D</a>[d+r]&lt;31:0&gt;;
            <a href="shared_pseudocode.html#impl-aarch32.MemA.write.2" title="accessor: MemA[bits(32) address, integer size] = bits(8*size) value">MemA</a>[address+4,4] = if <a href="shared_pseudocode.html#impl-shared.BigEndian.0" title="function: boolean BigEndian()">BigEndian</a>() then <a href="shared_pseudocode.html#impl-aarch32.D.read.1" title="accessor: bits(64) D[integer n]">D</a>[d+r]&lt;31:0&gt; else <a href="shared_pseudocode.html#impl-aarch32.D.read.1" title="accessor: bits(64) D[integer n]">D</a>[d+r]&lt;63:32&gt;;
            address = address+8;
    if wback then <a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value">R</a>[n] = if add then <a href="shared_pseudocode.html#impl-aarch32.R.read.1" title="accessor: bits(32) R[integer n]">R</a>[n]+imm32 else <a href="shared_pseudocode.html#impl-aarch32.R.read.1" title="accessor: bits(32) R[integer n]">R</a>[n]-imm32;</p>
    </div>
  <hr /><table align="center"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="a32_encindex.html">A32 Instructions by Encoding</a></div></td><td><div class="topbar"><a href="t32_encindex.html">T32 Instructions by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">
      Internal version only: isa v00_88, pseudocode v85-xml-00bet9_rc1_1
      ; Build timestamp: 2018-12-12T12:33
    </p><p class="copyconf">
      Copyright © 2010-2018 Arm Limited or its affiliates. All rights reserved.
      This document is Non-Confidential.
    </p></body></html>

<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><link href="insn.css" rel="stylesheet" type="text/css"/><meta content="iform.xsl" name="generator"/><title>ADD, ADDS (SP plus register) -- AArch32</title></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table align="center"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="a32_encindex.html">A32 Instructions by Encoding</a></div></td><td><div class="topbar"><a href="t32_encindex.html">T32 Instructions by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h2 class="instruction-section">ADD, ADDS (SP plus register)</h2><p id="desc"><p class="aml">Add to SP (register) adds an optionally-shifted register value to the SP value, and writes the result to the destination register.</p><p class="aml">If the destination register is not the PC, the ADDS variant of the instruction updates the condition flags based on the result.</p><p class="aml">The field descriptions for &lt;Rd> identify the encodings where the PC is permitted as the destination register. ARM deprecates any use of these encodings. However, when the destination register is the PC:</p><ul><li>The ADD variant of the instruction is an interworking branch, see <a class="armarm-xref" title="Reference to Armv8 ARM section">Pseudocode description of operations on the AArch32 general-purpose registers and the PC</a>.</li><li>The ADDS variant of the instruction performs an exception return without the use of the stack. In this case:<ul><li>The PE branches to the address written to the PC, and restores <a class="armarm-xref" title="Reference to Armv8 ARM section">PSTATE</a> from SPSR_&lt;current_mode>.</li><li>The PE checks SPSR_&lt;current_mode> for an illegal return event. See <a class="armarm-xref" title="Reference to Armv8 ARM section">Illegal return events from AArch32 state</a>.</li><li>The instruction is <span class="arm-defined-word">undefined</span> in Hyp mode.</li><li>The instruction is <span class="arm-defined-word">constrained unpredictable</span> in User mode and System mode.</li></ul></li></ul></p><p class="desc">
      It has encodings from the following instruction sets:
       A32 (
      <a href="#a1">A1</a>
      )
       and 
       T32 (
      <a href="#t1">T1</a>
      , 
      <a href="#t2">T2</a>
       and 
      <a href="#t3">T3</a>
      )
      .
    </p><h3 class="classheading"><a id="a1" name="a1"></a>A1</h3><p class="desc"></p><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="4">!= 1111</td><td class="l">0</td><td>0</td><td>0</td><td class="r">0</td><td class="l">1</td><td>0</td><td class="r">0</td><td class="lr">S</td><td class="l">1</td><td>1</td><td>0</td><td class="r">1</td><td class="lr" colspan="4">Rd</td><td class="lr" colspan="5">imm5</td><td class="lr" colspan="2">type</td><td class="lr">0</td><td class="lr" colspan="4">Rm</td></tr><tr class="secondrow"><td class="droppedname" colspan="4">cond</td><td colspan="4"></td><td colspan="3"></td><td></td><td colspan="4"></td><td colspan="4"></td><td colspan="5"></td><td colspan="2"></td><td></td><td colspan="4"></td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">ADD, rotate right with extend<span class="bitdiff"> (S == 0 &amp;&amp; imm5 == 00000 &amp;&amp; type == 11)</span></h4><p class="asm-code"><a id="ADD_SP_r_A1_RRX" name="ADD_SP_r_A1_RRX"></a>ADD{<a href="#c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>} {<a href="#rd_1" title="General-purpose destination register (field &quot;Rd&quot;)">&lt;Rd></a>,} SP, <a href="#rm" title="Second general-purpose source register (field &quot;Rm&quot;)">&lt;Rm></a> , RRX</p></div><div class="encoding"><h4 class="encoding">ADD, shift or rotate by value<span class="bitdiff"> (S == 0 &amp;&amp; !(imm5 == 00000 &amp;&amp; type == 11))</span></h4><p class="asm-code"><a id="ADD_SP_r_A1" name="ADD_SP_r_A1"></a>ADD{<a href="#c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>} {<a href="#rd_1" title="General-purpose destination register (field &quot;Rd&quot;)">&lt;Rd></a>,} SP, <a href="#rm" title="Second general-purpose source register (field &quot;Rm&quot;)">&lt;Rm></a> {, <a href="#shift" title="Type of shift applied to second source register (field &quot;type&quot;) [ASR,LSL,LSR,ROR]">&lt;shift></a> #<a href="#amount_1" title="Shift amount [1-31 (when &lt;shift> = LSL or ROR) or 1 to 32 (when &lt;shift> = LSR or ASR) (field &quot;imm5&quot;)">&lt;amount></a>}</p></div><div class="encoding"><h4 class="encoding">ADDS, rotate right with extend<span class="bitdiff"> (S == 1 &amp;&amp; imm5 == 00000 &amp;&amp; type == 11)</span></h4><p class="asm-code"><a id="ADDS_SP_r_A1_RRX" name="ADDS_SP_r_A1_RRX"></a>ADDS{<a href="#c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>} {<a href="#rd_1" title="General-purpose destination register (field &quot;Rd&quot;)">&lt;Rd></a>,} SP, <a href="#rm" title="Second general-purpose source register (field &quot;Rm&quot;)">&lt;Rm></a> , RRX</p></div><div class="encoding"><h4 class="encoding">ADDS, shift or rotate by value<span class="bitdiff"> (S == 1 &amp;&amp; !(imm5 == 00000 &amp;&amp; type == 11))</span></h4><p class="asm-code"><a id="ADDS_SP_r_A1" name="ADDS_SP_r_A1"></a>ADDS{<a href="#c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>} {<a href="#rd_1" title="General-purpose destination register (field &quot;Rd&quot;)">&lt;Rd></a>,} SP, <a href="#rm" title="Second general-purpose source register (field &quot;Rm&quot;)">&lt;Rm></a> {, <a href="#shift" title="Type of shift applied to second source register (field &quot;type&quot;) [ASR,LSL,LSR,ROR]">&lt;shift></a> #<a href="#amount_1" title="Shift amount [1-31 (when &lt;shift> = LSL or ROR) or 1 to 32 (when &lt;shift> = LSR or ASR) (field &quot;imm5&quot;)">&lt;amount></a>}</p></div><p class="pseudocode">d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rd);  m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rm);  setflags = (S == '1');
(shift_t, shift_n) = <a href="shared_pseudocode.html#impl-aarch32.DecodeImmShift.2" title="function: (SRType, integer) DecodeImmShift(bits(2) type, bits(5) imm5)">DecodeImmShift</a>(type, imm5);</p><h3 class="classheading"><a id="t1" name="t1"></a>T1</h3><div class="regdiagram-16"><table class="regdiagram"><thead><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">0</td><td>1</td><td>0</td><td>0</td><td>0</td><td class="r">1</td><td class="l">0</td><td class="r">0</td><td class="lr">DM</td><td class="l">1</td><td>1</td><td>0</td><td class="r">1</td><td class="lr" colspan="3">Rdm</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">T1</h4><p class="asm-code"><a id="ADD_SP_r_T1" name="ADD_SP_r_T1"></a>ADD{<a href="#c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>} {<a href="#rdm" title="General-purpose destination and second source register (field &quot;Rdm&quot;)">&lt;Rdm></a>,} SP, <a href="#rdm" title="General-purpose destination and second source register (field &quot;Rdm&quot;)">&lt;Rdm></a></p></div><p class="pseudocode">d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(DM:Rdm);  m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(DM:Rdm);  setflags = FALSE;
(shift_t, shift_n) = (<a href="shared_pseudocode.html#SRType_LSL" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_LSL</a>, 0);
if d == 15 &amp;&amp; <a href="shared_pseudocode.html#impl-aarch32.InITBlock.0" title="function: boolean InITBlock()">InITBlock</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-aarch32.LastInITBlock.0" title="function: boolean LastInITBlock()">LastInITBlock</a>() then UNPREDICTABLE;</p><h3 class="classheading"><a id="t2" name="t2"></a>T2</h3><div class="regdiagram-16"><table class="regdiagram"><thead><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">0</td><td>1</td><td>0</td><td>0</td><td>0</td><td class="r">1</td><td class="l">0</td><td class="r">0</td><td class="lr">1</td><td class="lr" colspan="4">!= 1101</td><td class="l">1</td><td>0</td><td class="r">1</td></tr><tr class="secondrow"><td colspan="6"></td><td colspan="2"></td><td></td><td class="droppedname" colspan="4">Rm</td><td colspan="3"></td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">T2</h4><p class="asm-code"><a id="ADD_SP_r_T2" name="ADD_SP_r_T2"></a>ADD{<a href="#c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>} <a href="#sp" title="Stack pointer">{SP,}</a> SP, <a href="#rm" title="Second general-purpose source register (field &quot;Rm&quot;)">&lt;Rm></a></p></div><p class="pseudocode">if Rm == '1101' then SEE "encoding T1";
d = 13;  m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rm);  setflags = FALSE;
(shift_t, shift_n) = (<a href="shared_pseudocode.html#SRType_LSL" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_LSL</a>, 0);</p><h3 class="classheading"><a id="t3" name="t3"></a>T3</h3><p class="desc"></p><div class="regdiagram-16x2"><table class="regdiagram"><thead><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td class="r">1</td><td class="l">1</td><td>0</td><td>0</td><td class="r">0</td><td class="lr">S</td><td class="l">1</td><td>1</td><td>0</td><td class="r">1</td><td class="lr">(0)</td><td class="lr" colspan="3">imm3</td><td class="lr" colspan="4">Rd</td><td class="lr" colspan="2">imm2</td><td class="lr" colspan="2">type</td><td class="lr" colspan="4">Rm</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">ADD, rotate right with extend<span class="bitdiff"> (S == 0 &amp;&amp; imm3 == 000 &amp;&amp; imm2 == 00 &amp;&amp; type == 11)</span></h4><p class="asm-code"><a id="ADD_SP_r_T3_RRX" name="ADD_SP_r_T3_RRX"></a>ADD{<a href="#c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>} {<a href="#rd" title="General-purpose destination register (field &quot;Rd&quot;)">&lt;Rd></a>,} SP, <a href="#rm_1" title="Second general-purpose source register (field &quot;Rm&quot;)">&lt;Rm></a>, RRX</p></div><div class="encoding"><h4 class="encoding">ADD, shift or rotate by value<span class="bitdiff"> (S == 0 &amp;&amp; !(imm3 == 000 &amp;&amp; imm2 == 00 &amp;&amp; type == 11))</span></h4><p class="asm-code"><a id="ADD_SP_r_T3" name="ADD_SP_r_T3"></a>ADD{<a href="#c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}.W {<a href="#rd" title="General-purpose destination register (field &quot;Rd&quot;)">&lt;Rd></a>,} SP, <a href="#rm_1" title="Second general-purpose source register (field &quot;Rm&quot;)">&lt;Rm></a>
        //
      
        (&lt;Rd>, &lt;Rm> can be represented in T1 or T2)
      </p><p class="asm-code"><a id="ADD_SP_r_T3" name="ADD_SP_r_T3"></a>ADD{<a href="#c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>} {<a href="#rd" title="General-purpose destination register (field &quot;Rd&quot;)">&lt;Rd></a>,} SP, <a href="#rm_1" title="Second general-purpose source register (field &quot;Rm&quot;)">&lt;Rm></a> {, <a href="#shift" title="Type of shift applied to second source register (field &quot;type&quot;) [ASR,LSL,LSR,ROR]">&lt;shift></a> #<a href="#amount" title="Shift amount [1-31 (when &lt;shift> = LSL or ROR) or 1 to 32 (when &lt;shift> = LSR or ASR)] (field &quot;imm3:imm2&quot;)">&lt;amount></a>}</p></div><div class="encoding"><h4 class="encoding">ADDS, rotate right with extend<span class="bitdiff"> (S == 1 &amp;&amp; imm3 == 000 &amp;&amp; Rd != 1111 &amp;&amp; imm2 == 00 &amp;&amp; type == 11)</span></h4><p class="asm-code"><a id="ADDS_SP_r_T3_RRX" name="ADDS_SP_r_T3_RRX"></a>ADDS{<a href="#c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>} {<a href="#rd" title="General-purpose destination register (field &quot;Rd&quot;)">&lt;Rd></a>,} SP, <a href="#rm_1" title="Second general-purpose source register (field &quot;Rm&quot;)">&lt;Rm></a>, RRX</p></div><div class="encoding"><h4 class="encoding">ADDS, shift or rotate by value<span class="bitdiff"> (S == 1 &amp;&amp; !(imm3 == 000 &amp;&amp; imm2 == 00 &amp;&amp; type == 11) &amp;&amp; Rd != 1111)</span></h4><p class="asm-code"><a id="ADDS_SP_r_T3" name="ADDS_SP_r_T3"></a>ADDS{<a href="#c" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;c></a>}{<a href="#q" title="See {xref{ARMARM_Babbefhf}{Standard assembler syntax fields}}">&lt;q></a>} {<a href="#rd" title="General-purpose destination register (field &quot;Rd&quot;)">&lt;Rd></a>,} SP, <a href="#rm_1" title="Second general-purpose source register (field &quot;Rm&quot;)">&lt;Rm></a> {, <a href="#shift" title="Type of shift applied to second source register (field &quot;type&quot;) [ASR,LSL,LSR,ROR]">&lt;shift></a> #<a href="#amount" title="Shift amount [1-31 (when &lt;shift> = LSL or ROR) or 1 to 32 (when &lt;shift> = LSR or ASR)] (field &quot;imm3:imm2&quot;)">&lt;amount></a>}</p></div><p class="pseudocode">if Rd == '1111' &amp;&amp; S == '1' then SEE "CMN (register)";
d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rd);  m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rm);  setflags = (S == '1');
(shift_t, shift_n) = <a href="shared_pseudocode.html#impl-aarch32.DecodeImmShift.2" title="function: (SRType, integer) DecodeImmShift(bits(2) type, bits(5) imm5)">DecodeImmShift</a>(type, imm3:imm2);
<ins>if (d == 15 &amp;&amp; !setflags) || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13</ins><del>if (d == 15 &amp;&amp; !setflags) || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13</del></p><p class="encoding-notes"><p class="aml">For more information about the <span class="arm-defined-word">constrained unpredictable</span> behavior, see <a class="armarm-xref" title="Reference to Armv8 ARM section">Architectural Constraints on UNPREDICTABLE behaviors</a>.</p></p><h3 class="explanations">Assembler Symbols</h3><div class="explanations"><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;c></td><td><a id="c" name="c"></a><p class="aml">See <a class="armarm-xref" title="Reference to Armv8 ARM section">Standard assembler syntax fields</a>.</p></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;q></td><td><a id="q" name="q"></a><p class="aml">See <a class="armarm-xref" title="Reference to Armv8 ARM section">Standard assembler syntax fields</a>.</p></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td><ins>SP,</ins><del>&lt;Rdm></del></td><td><a id="sp" name="sp"></a><p class="aml">Is the <ins>stack</ins><del>general-purpose</del> <ins>pointer.</ins><del>destination and second source register, encoded in the "Rdm" field. If omitted, this register is the SP. ARM deprecates using the PC as the destination register, but if the PC is used, the instruction is a branch to the address calculated by the operation. This is a simple branch, see</del><a class="armarm-xref" title="Reference to ARM ARM section"><del>Pseudocode description of operations on the AArch32 general-purpose registers and the PC</del></a><del>.</del></p></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;<ins>Rdm</ins><del>Rd</del>></td><td><a id="rdm" name="rdm"></a><ul><li><del>For the ADD variant, the instruction is a branch to the address calculated by the operation. This is an interworking branch, see </del><a class="armarm-xref" title="Reference to ARM ARM section"><del>Pseudocode description of operations on the AArch32 general-purpose registers and the PC</del></a><del>.</del></li><li><del>For the ADDS variant, the instruction performs an exception return, that restores </del><a class="armarm-xref" title="Reference to ARM ARM section"><del>PSTATE</del></a><del> from SPSR_&lt;current_mode>.</del></li></ul><p class="aml"><ins>Is</ins><del>For</del> <del>encoding A1: is </del>the general-purpose destination <ins>and second source </ins>register, encoded in the "<ins>Rdm</ins><del>Rd</del>" field. If omitted, this register is the SP. <ins>Arm</ins><del>ARM</del> deprecates using the PC as the destination register, but if the PC is used<ins>, the instruction is a branch to the address calculated by the operation. This is a simple branch, see</ins><del>:</del> <a class="armarm-xref" title="Reference to Armv8 ARM section"><ins>Pseudocode description of operations on the AArch32 general-purpose registers and the PC</ins></a><ins>.</ins></p></td></tr><tr><td></td><td><a id="rd" name="rd"></a><p class="aml"><del>For encoding T3: is the general-purpose destination register, encoded in the "Rd" field. If omitted, this register is the SP.</del></p></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;<ins>Rd</ins><del>Rm</del>></td><td><a id="rd_1" name="rd_1"></a><p class="aml">For encoding A1<del> and T2</del>: is the <del>second </del>general-purpose <ins>destination</ins><del>source</del> register, encoded in the "<ins>Rd</ins><del>Rm</del>" field. <ins>If</ins><del>The</del> <ins>omitted, this register is the SP. Arm deprecates using the </ins>PC <ins>as</ins><del>can</del> <ins>the</ins><del>be</del> <ins>destination register</ins><del>used</del>, but <ins>if</ins><del>this</del> <ins>the PC </ins>is <ins>used:</ins><del>deprecated.</del></p><ul><li><ins>For the ADD variant, the instruction is a branch to the address calculated by the operation. This is an interworking branch, see </ins><a class="armarm-xref" title="Reference to Armv8 ARM section"><ins>Pseudocode description of operations on the AArch32 general-purpose registers and the PC</ins></a><ins>.</ins></li><li><ins>For the ADDS variant, the instruction performs an exception return, that restores </ins><a class="armarm-xref" title="Reference to Armv8 ARM section"><ins>PSTATE</ins></a><ins> from SPSR_&lt;current_mode>.</ins></li></ul></td></tr><tr><td></td><td><a id="rd" name="rd"></a><p class="aml">For encoding T3: is the <del>second </del>general-purpose <ins>destination</ins><del>source</del> register, encoded in the "<ins>Rd</ins><del>Rm</del>" field.<ins> If omitted, this register is the SP.</ins></p></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td><ins>&lt;Rm></ins></td><td><a id="rm" name="rm"></a><p class="aml"><ins>For encoding A1 and T2: is the second general-purpose source register, encoded in the "Rm" field. The PC can be used, but this is deprecated.</ins></p></td></tr><tr><td><del>&lt;shift></del></td><td><a id="shift" name="shift"></a><del>
        Is the type of shift to be applied to the second source register, 
    encoded in 
    </del><q><del>type</del></q><del>:
      
        </del><table class="valuetable"><thead><tr><th class="bitfield"><del>type</del></th><th class="symbol"><del>&lt;shift></del></th></tr></thead><tbody><tr><td class="bitfield"><del>00</del></td><td class="symbol"><del>LSL</del></td></tr><tr><td class="bitfield"><del>01</del></td><td class="symbol"><del>LSR</del></td></tr><tr><td class="bitfield"><del>10</del></td><td class="symbol"><del>ASR</del></td></tr><tr><td class="bitfield"><del>11</del></td><td class="symbol"><del>ROR</del></td></tr></tbody></table></td></tr><tr><td></td><td><a id="rm_1" name="rm_1"></a><p class="aml"><ins>For encoding T3: is the second general-purpose source register, encoded in the "Rm" field.</ins></p></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td><ins>&lt;shift></ins></td><td><a id="shift" name="shift"></a><ins>
        Is the type of shift to be applied to the second source register, 
    encoded in 
    </ins><q><ins>type</ins></q><ins>:
      
        </ins><table class="valuetable"><thead><tr><th class="bitfield"><ins>type</ins></th><th class="symbol"><ins>&lt;shift></ins></th></tr></thead><tbody><tr><td class="bitfield"><ins>00</ins></td><td class="symbol"><ins>LSL</ins></td></tr><tr><td class="bitfield"><ins>01</ins></td><td class="symbol"><ins>LSR</ins></td></tr><tr><td class="bitfield"><ins>10</ins></td><td class="symbol"><ins>ASR</ins></td></tr><tr><td class="bitfield"><ins>11</ins></td><td class="symbol"><ins>ROR</ins></td></tr></tbody></table></td></tr><tr><td></td><td><a id="amount" name="amount"></a><p class="aml"><del>For encoding T3: is the shift amount, in the range 1 to 31 (when &lt;shift> = LSL or ROR) or 1 to 32 (when &lt;shift> = LSR or ASR), encoded in the "imm3:imm2" field as &lt;amount> modulo 32.</del></p></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td><ins>&lt;amount></ins></td><td><a id="amount_1" name="amount_1"></a><p class="aml"><ins>For encoding A1: is the shift amount, in the range 1 to 31 (when &lt;shift> = LSL or ROR) or 1 to 32 (when &lt;shift> = LSR or ASR) encoded in the "imm5" field as &lt;amount> modulo 32.</ins></p></td></tr><tr><td></td><td><a id="amount" name="amount"></a><p class="aml"><ins>For encoding T3: is the shift amount, in the range 1 to 31 (when &lt;shift> = LSL or ROR) or 1 to 32 (when &lt;shift> = LSR or ASR), encoded in the "imm3:imm2" field as &lt;amount> modulo 32.</ins></p></td></tr></table></div><p class="syntax-notes"></p><div class="ps" psname="commonps"><a id="commonps" name="commonps"></a><h3 class="pseudocode">Operation</h3><p class="pseudocode">if <a href="shared_pseudocode.html#impl-aarch32.ConditionPassed.0" title="function: boolean ConditionPassed()">ConditionPassed</a>() then
    EncodingSpecificOperations();
    shifted = <a href="shared_pseudocode.html#impl-aarch32.Shift.4" title="function: bits(N) Shift(bits(N) value, SRType type, integer amount, bit carry_in)">Shift</a>(<a href="shared_pseudocode.html#impl-aarch32.R.read.1" title="accessor: bits(32) R[integer n]">R</a>[m], shift_t, shift_n, PSTATE.C);
    (result, nzcv) = <a href="shared_pseudocode.html#impl-shared.AddWithCarry.3" title="function: (bits(N), bits(4)) AddWithCarry(bits(N) x, bits(N) y, bit carry_in)">AddWithCarry</a>(SP, shifted, '0');
    if d == 15 then
        if setflags then
            <a href="shared_pseudocode.html#impl-aarch32.ALUExceptionReturn.1" title="function: ALUExceptionReturn(bits(32) address)">ALUExceptionReturn</a>(result);
        else
            <a href="shared_pseudocode.html#impl-aarch32.ALUWritePC.1" title="function: ALUWritePC(bits(32) address)">ALUWritePC</a>(result);
    else
        <a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value">R</a>[d] = result;
        if setflags then
            PSTATE.&lt;N,Z,C,V> = nzcv;</p></div><hr/><table align="center"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="a32_encindex.html">A32 Instructions by Encoding</a></div></td><td><div class="topbar"><a href="t32_encindex.html">T32 Instructions by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">
      Internal version only: isa <ins>v00_88</ins><del>v00_87</del>, pseudocode <ins>v85-xml-00bet9_rc1_1</ins><del>v85-xml-00bet8_rc3</del>
      ; Build timestamp: <ins>2018-12-12T12</ins><del>2018-09-13T14</del>:<ins>33</ins><del>00</del>
    </p><p class="copyconf">
      Copyright © 2010-2018 <ins>Arm</ins><del>ARM</del> Limited or its affiliates. All rights reserved.
      This document is Non-Confidential.
    </p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>
This document describes the format of the data produced by the ``llvm-tblgen``
tool.  Note that the output of this tool is mostly meant to be informative and
not used directly, which means that the use of the data in this library is
sub-optimal.  It might be possible to link against the LLVM TableGen library
directly to do something better, but it isn't obvious how that would look.

The TableGen format itself is a format for defining records.  There are two high
level constructs: classes and definitions.  Classes sketch out the outline of a
definition, while a definition instantiates a class and contains concrete
values.  In this project, we are primarily concerned with the definitions (which
are definitions of instructions), but knowing that they are instantiated from
classes can be useful while tracking the provenance of values.

Many classes define general instruction formats (e.g., in PowerPC, there is a
class called ``AForm_1``, which defines the shape of all A-form instructions in
PowerPC).  Individual instructions then derive from this class to instantiate
themselves with concrete details.

The official documentation for TableGen_ is available on the LLVM website.  It
mostly describes the template language.

Definitions
===========

Each instruction definition is a record with a number of fields.  Most are not
very important for our uses, but inform various stages of the LLVM pipeline.
This section describes the fields that seem important for us.

``Inst``
  The ``Inst`` field describes the bit pattern that makes up the instruction.
  The type is ``bits<N>``, where ``N`` is the number of bits in the instruction.
  Bits can be one of:
  * 0 - a bit that must be zero to match
  * 1 - a bit that must be one to match
  * an operand bit

  Operand bits are lexically of the form ``OperandName{bitNum}``: a name of an
  operand followed by the position of that bit in its respective operand.
  
``Namespace`` and ``DecoderNamespace``
  Describes the instruction set being decoded.  There can be more than one ISA mixed
  together in a single file, and these can be used to filter out only the intended sub-ISA.

  As an example, in the ARM data, all instructions are in the ``ARM`` namespace,
  while ``DecoderNamespace`` is used to distinguish between ``ARM`` and
  ``Thumb`` (and ``Thumb2``).

``OutOperandList``
  Describes the operands that are *modified* (or written to) by the instruction.

``InOperandList``
  Describes the operands that are inputs to the instruction.

``AsmString``
  This is a string template that shows how the instruction should be pretty printed.

``isAsmParserOnly``
  If this is set to 1, the instruction is a pseudo-instruction that is only valid as
  an input to the assembler.  There is no corresponding machine code instruction -
  the assembler translates it to something else.  We aren't very interested in these,
  and can filter them out entirely.

``isPseudo``
  If this is set to 1, the instruction is a pseudo-instruction (and we probably don't
  want to support it).  These are often generated by LLVM to carry metadata to a backend,
  and don't have any real effect.

``Size``
  This is the number of bytes of the instruction.  For most ISAs, this is a constant.
  This would be more important for x86, though it is redundant with the ``Inst`` field.

Operands
========

The most important data in this dataset is operand data, which is mostly encoded
in the ``Inst`` field of each definition.  The operand bit patterns described in
``Inst`` tell us which bits to decode as operands.  Unfortunately, that isn't
quite enough: we need to know how to interpret the bits.  That information is
encoded in ``InOperandList`` and ``OutOperandList``, which include *types* of
operands.  For example, in the PPC dataset, ``g8rc`` in the operand lists
corresponds to an 8 byte general purpose register.  Other types indicate
immediates of various sizes and interpretations.

As a cross check, each def also includes a list of the operands as fields
(usually at the end of the record) that notes how many bits each operand is.  So
far, this seems to match the number of bits encoded in the ``Inst`` fields, but
that might not always be true.

The real problem is in mapping between the operands defined in ``Inst`` and in
the operand lists.

Mapping Operands
----------------

Operands in ``Inst`` and the operand lists do not always have the same names.
In fact, they often do not.  This is a product of how the template instantiation
works: the instruction classes define the names used in the ``Inst`` template,
while the definitions instantiating the classes provide the names for the
operand lists.  Some architectures (e.g., RISCV) make them match.  Most of the
others don't.

This is an open problem.

Providing the mapping by hand is probably possible, but obnoxious and
inconsistent.  It is probably safer and easier to map the names based on the
instruction forms encoded in the metadata.

Pseudo-Instructions
===================

There are many instructions marked as "pseudo" in various ways.  These
instructions are not real machine instructions and are used to communicate
metadata between various stages of the LLVM pipeline.  We aren't concerned with
them, as there is nothing to decode (or encode).  We do our best to filter these
out early.

Metadata
========

There is metadata associated with each instruction definition as a comment on
its first line (after the opening curly brace).  Each architecture has its own
set of metadata, but some instructions are marked as pseudo-instructions via
metadata and not other flags.  Additionally, most architectures seem to list
*instruction forms* as metadata, which can help inform decoding.


Expression Language
===================

Some fields are defined in terms of an expression language.  This is usually
true for string fields that are constructed via a set of intrinsic string
operations.

.. _TableGen: http://llvm.org/docs/TableGen/index.html
